
<html>

<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<title>Введение в Perl</title>
<link rev="made" title="Andrew A.Alikberov" href="mailto:info@citmgu.msk.su">
</head>

<body bgcolor="#DDE1C2">


<!--#include virtual="/header.raw"-->
<h3>Версия для печати</h3>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/141.shtml">Perl</a>"
</b>
 <small>(<a href="./">Многостраничная версия</a>)</small>
<hr noshade size=1>

<a name="index_html"></a>
Введение в Perl</h1>
<h2>Маслов Владимир Викторович.</h2>
Верстка html: <a href="mailto:info@citmgu.msk.su">Andrew A.Alikberov</a>

<p>В книге приводятся начальные
сведения по новому языку
программирования Perl. Данный язык
получил широкое распространение в
связи с развитием компьютерной
сети Интернет. Все примеры в книге
проверены для Perl версии 5.003
операционной системы Unix FreeBSD 2.1.0. </p>

<p>Для программистов, системных
администраторов и пользователей
компьютеров.<br>
╘ Маслов Владимир Викторович.</p>

<p><b>Содержание</b></p>

<ul>
    <li><a href="#begin_html">От простого к
        сложному</a> </li>
    <li><a href="#run_html">Запуск Perl - программы</a>
    </li>
    <li><a href="#syntax_html">Синтаксис</a> <ul>
            <li><a href="#syntax_html_1">Декларации
                (объявления)</a> </li>
            <li><a href="#syntax_html_2">Простое
                предложение</a> </li>
            <li><a href="#syntax_html_3">Сложные
                предложения</a> </li>
            <li>Циклы <ul>
                    <li><a href="#syntax_html_4">while</a> </li>
                    <li><a href="#syntax_html_5">Операторы
                        управления циклом</a> <ul>
                            <li><a href="#syntax_html_6">next</a> </li>
                            <li><a href="#syntax_html_7">last</a> </li>
                            <li><a href="#syntax_html_8">redo</a> </li>
                        </ul>
                    </li>
                    <li><a href="#syntax_html_9">for</a> </li>
                    <li><a href="#syntax_html_10">foreach</a> </li>
                </ul>
            </li>
            <li><a href="#syntax_html_11">Блоки и
                оператор switch</a> </li>
            <li><a href="#syntax_html_12">Оператор goto</a>
            </li>
            <li><a href="#syntax_html_13">POD операторы.
                Документирование программ</a>
            </li>
        </ul>
    </li>
    <li><a href="#dat_html">Переменные</a> <ul>
            <li><a href="#dat_html_1">Контекст</a> </li>
            <li><a href="#dat_html_2">Скалярные
                значения</a> </li>
            <li><a href="#dat_html_3">Конструкторы
                скаляров</a> </li>
            <li><a href="#dat_html_4">Конструкторы
                списков</a> </li>
            <li><a href="#dat_html_5">Тип typeglobs</a> </li>
        </ul>
    </li>
    <li><a href="#sysvar_html">Встроенные
        переменные</a> </li>
    <li><a href="#re_html">Регулярные выражения
        (шаблоны)</a> </li>
    <li><a href="#op_html">Операторы и
        приоритеты</a> <ul>
            <li><a href="#op_html_1">Термы и
                левосторонние списковые
                операторы</a> </li>
            <li><a href="#op_html_2">Унарные
                операторы</a> </li>
            <li><a href="#op_html_3">Операторы
                &quot;привязки&quot; =~ и !=</a> </li>
            <li><a href="#op_html_4">Мультипликативные
                операторы</a> </li>
            <li><a href="#op_html_5">Аддитивные
                операторы</a> </li>
            <li><a href="#op_html_6">Операторы
                сдвига</a> </li>
            <li><a href="#op_html_7">Именованные
                унарные операторы</a> </li>
            <li><a href="#op_html_8">Операторы
                отношений</a> </li>
            <li><a href="#op_html_9">Операторы
                равенства</a> </li>
            <li><a href="#op_html_10">Операторы
                работы с битами</a> </li>
            <li><a href="#op_html_11">Логические
                операторы &amp;&amp; (AND) и || (OR)</a>
            </li>
            <li><a href="#op_html_12">Оператор
                диапазона '..'</a> </li>
            <li><a href="#op_html_13">Условный
                оператор '?:'</a> </li>
            <li><a href="#op_html_14">Операторы
                присваивания</a> </li>
            <li><a href="#op_html_15">Оператор ','
                (запятая)</a> </li>
            <li><a href="#op_html_16">Логические not,
                and, or, xor</a> </li>
            <li><a href="#op_html_17">Операторы
                ограничители строк</a> </li>
            <li><a href="#op_html_18">Операторы
                ввода-вывода</a> </li>
            <li><a href="#op_html_19">Слияние
                констант</a> </li>
            <li><a href="#op_html_20">Целочисленная
                арифметика</a> </li>
        </ul>
    </li>
    <li><a href="#func_html">Встроенные функции</a>
    </li>
    <li><a href="#sub_html">Подпрограммы</a> <ul>
            <li><a href="#sub_html_1">Private переменные</a>
            </li>
            <li><a href="#sub_html_2">Переменные типа
                local</a> </li>
            <li><a href="#sub_html_3">Прототипы
                (prototypes)</a> </li>
            <li><a href="#sub_html_4">Ссылка как
                параметр</a> </li>
            <li><a href="#sub_html_5">Переопределение
                встроенных функций</a> </li>
            <li><a href="#sub_html_6">Автозагрузка</a> </li>
        </ul>
    </li>
    <li><a href="#mod_html">Модули</a> <ul>
            <li><a href="#mod_html_1">Таблицы имен</a> </li>
            <li><a href="#mod_html_2">Конструкторы и
                деструкторы</a> </li>
            <li><a href="#mod_html_3">Классы</a> </li>
            <li><a href="#mod_html_4">Создание
                библиотеки</a> </li>
            <li><a href="#mod_html_5">Pragma библиотеки</a>
            </li>
            <li><a href="#mod_html_6">Стандартные
                библиотеки</a> </li>
            <li><a href="#mod_html_7">CPAN</a> </li>
        </ul>
    </li>
    <li><a href="#form_html">Форматы отчетов</a> </li>
    <li><a href="#debug_html">Отладка</a> </li>
    <li><a href="#internet_html">Интернет - ссылки и
        литература</a> </li>
</ul>


<hr>

<a name="run_html"></a>
<font color="#8000FF">Запуск
интерпретатора Perl </font></h3>

<hr width="90%">

<p>Синтаксис: </p>

<pre>
	perl [ключи] файл аргументы
</pre>

<p>Перед стартом Perl ищет скрипт
(программу) в следующем порядке: </p>

<ol>
    <li>В командной строке если указан
        ключ '-e' </li>
    <li>Содержимое файла указанного в
        командной строке. В первой
        строке можно указывать
        #!/usr/bin/perl для
        &quot;автоматического&quot; запуска
        скрипта. </li>
    <li>Стандартный ввод/вывод, если не
        указан файл или аргументы,
        содержащие имя файла. Для
        передачи аргументов скрипту из
        стандартного потока, имя файла
        в командной строке
        обозначается символом '-'. </li>
</ol>

<p>В методах 1 и 2 Perl сканирует строки,
начиная с первой, если не указан
ключ '-x', в противном случае началом
программы считается строка с
символами '#!' в начале и содержащая
слово 'perl'. Концом программы
считается строка '__END__'. В строке с
'#!' можно указывать и ключи.
Например '#!/bin/perl -d' для отладки
программ. </p>

<p>После &quot;обнаружения&quot; скрипта
Perl компилирует его целиком во
внутреннее представление. Если
обнаруживаются ошибки, то
выполнение прекращается. Если
ошибок нет, он выполняется. Если
скрипт заканчивается без команд
exit() или die(), то по умолчанию
выполняется команда exit(0),
обозначающая нормальное
завершение программы. </p>

<p>Ключи: </p>

<ul>
    <li><b>-O цифры</b><br>
        Код символа-разделителя
        записей. По умолчанию \0. </li>
    <li><b>-a</b><br>
        Включает режим
        автоматического разделения
        (split) переменной $_ в массив $F.
        Применяется с ключами -n и -p. </li>
    <li><b>-c</b><br>
        Выполняется синтаксическая
        проверка скрипта и выход без
        запуска. </li>
    <li><b>-d</b><br>
        Запуск в режиме интерактивной
        отладки. </li>
    <li><b>-D число или D список</b><br>
        Установить флаги отладки Perl.
        Например -d14 проследить как Perl
        исполняет вашу программу. <div align="center"><center><table border="1">
            <tr>
                <td valign="top">1</td>
                <td valign="top">p</td>
                <td valign="top">Синтаксический
                разбор</td>
            </tr>
            <tr>
                <td valign="top">2</td>
                <td valign="top">s</td>
                <td valign="top">Состояние стека</td>
            </tr>
            <tr>
                <td valign="top">4</td>
                <td valign="top">l</td>
                <td valign="top">Состояние стека
                имен</td>
            </tr>
            <tr>
                <td valign="top">8</td>
                <td valign="top">t</td>
                <td valign="top">Трассировка
                исполнения</td>
            </tr>
            <tr>
                <td valign="top">16</td>
                <td valign="top">o</td>
                <td valign="top">Создание
                оператора узла</td>
            </tr>
            <tr>
                <td valign="top">32</td>
                <td valign="top">c</td>
                <td valign="top">Строковое/числовое
                преобразование</td>
            </tr>
            <tr>
                <td valign="top">64</td>
                <td valign="top">p</td>
                <td valign="top">Вывод команды
                препроцессора для -P</td>
            </tr>
            <tr>
                <td valign="top">128</td>
                <td valign="top">m</td>
                <td valign="top">Распределение
                памяти</td>
            </tr>
            <tr>
                <td valign="top">256</td>
                <td valign="top">f</td>
                <td valign="top">Обработка
                формата</td>
            </tr>
            <tr>
                <td valign="top">512</td>
                <td valign="top">r</td>
                <td valign="top">Синтаксический
                разбор регулярных
                выражений</td>
            </tr>
            <tr>
                <td valign="top">1024</td>
                <td valign="top">x</td>
                <td valign="top">Дамп
                синтаксического дерева</td>
            </tr>
            <tr>
                <td valign="top">2048</td>
                <td valign="top">u</td>
                <td valign="top">Проверка защиты</td>
            </tr>
            <tr>
                <td valign="top">4096</td>
                <td valign="top">L</td>
                <td valign="top">&quot;Утечка&quot;
                памяти</td>
            </tr>
            <tr>
                <td valign="top">8192</td>
                <td valign="top">H</td>
                <td valign="top">Дамп хеша</td>
            </tr>
            <tr>
                <td valign="top">16384</td>
                <td valign="top">X</td>
                <td valign="top">Распределение
                scratchpad</td>
            </tr>
            <tr>
                <td valign="top">32768</td>
                <td valign="top">D</td>
                <td valign="top">Очистка</td>
            </tr>
        </table>
        </center></div></li>
    <li><b>-e команда</b><br>
        Выполнение скрипта из одной
        строки указанного в командной
        строке. </li>
    <li><b>-F шаблон</b><br>
        Указывает шаблон разделения в
        режиме работы с ключом -a </li>
    <li><b>-i расширение</b><br>
        Применяется для резервной
        копии файла обрабатываемого
        оператором '&lt;&gt;'. Оригинал
        хранится в файле с тем же
        именем, что и исходный, но с
        указанным расширением.<br>
        <i>Пример:</i> <pre>
	perl -p -i.old -e &quot;s/рядовой/ефрейтор/&quot; file
</pre>
        <ul>
            <li>Поменять все слова
                &quot;рядовой&quot; на
                &quot;ефрейтор&quot; в файле file,
                а оригинал записать в
                файле file.old </li>
        </ul>
    </li>
    <li><b>-I директория</b><br>
        Директория includ- файлов для С
        препроцессора. Применяется с
        ключом -P по умолчанию это
        /usr/include и /usr/lib/perl. </li>
    <li><b>-l число</b><br>
        Автоматическая обработка
        символа конца строки. Работает
        в двух случаях. <ol>
            <li>Отбрасывает последний
                символ читаемых строк для
                режимов -n и -p </li>
            <li>Присваивает указанное
                значение переменной $\.
                Таким образом к концу
                каждой строки выводимой
                оператором print добавляется
                этот символ. </li>
        </ol>
    </li>
    <li><b>-n</b><br>
        Зацикливает скрипт и
        последовательно обрабатывает
        файлы указанные в командной
        строке. Позволяет создавать
        команды подобные sed или awk.
        Операторы BEGIN и END дают
        возможность делать начальные и
        конечные установки. Содержимое
        файлов не выводится. </li>
    <li><b>-p</b><br>
        То же что и -n, но печатает
        обрабатываемые строки файлов. </li>
    <li><b>-P</b><br>
        Предварительная обработка
        препроцессором языка С. Будьте
        внимательны и не применяйте в
        комментариях слова 'if', 'else' или
        'define', т.к. это команды С -
        препроцессора. </li>
    <li><b>-s</b><br>
        Включение режима обработки
        ключей командной строки
        запуска скрипта. Все аргументы
        с символом '-' в начале,
        считаются ключом, и переменным
        с таким же именем
        присваивается значение true. </li>
    <li><b>-S</b><br>
        Использование системной
        переменной PATH для поиска
        скрипта. Данный ключ
        применяется в системах,
        невоспринимающих
        последовательность &quot;#!&quot; в
        начале скрипта для указания
        интерпретатора. </li>
    <li><b>-T</b><br>
        Режим проверки &quot;дыр&quot; в
        защите. Обычно это нужно для
        программ, работающих в режиме
        повышенной привилегии (setuid,
        setguid). Желательно для CGI
        скриптов. </li>
    <li><b>-u</b><br>
        Принудительный дамп памяти
        после компиляции скрипта. Этот
        дамп можно потом использовать
        для создания исполняемого
        файла с помощью программы undump. </li>
    <li><b>-U</b><br>
        Разрешение выполнять опасные
        операции. Например, стереть
        директорию или выполнять явно
        не закрытую программу. </li>
    <li><b>-v</b><br>
        Вывод номера версии Perl. </li>
    <li><b>-w</b><br>
        Вывод имен переменных,
        используемых только один раз,
        имен скаляров, используемых до
        их определения, имен
        переопределяемых подпрограмм,
        ссылок на неопределенные
        указатели файлов, попыток
        записи в файлы, открытых только
        на &quot;чтение&quot;, употребление
        некорректных записей чисел,
        использование массивов как
        скаляров, рекурсия более 100
        уровней. </li>
    <li><b>-x директория</b><br>
        Режим запуска скрипта,
        вставленного в файл,
        содержащий обычный текст.
        Началом скрипта считается
        строка с символами '#!' в начале
        и содержащая слово perl. Концом -
        строка с '__END__' Указанная
        директория становится текущей
        в момент исполнения. Если
        необходимо читать последующие
        строки, то это лучше делать
        через указатель файла DATA. </li>
</ul>


<hr>

<a name="syntax_html"></a>
<font color="#8000FF">Синтаксис.</font></h3>

<hr width="90%">

<ul>
    <li><a href="#syntax_html_1">Декларации (объявления)</a>
    </li>
    <li><a href="#syntax_html_2">Простое предложение</a> </li>
    <li><a href="#syntax_html_3">Сложные предложения</a> </li>
    <li>Циклы <ul>
            <li><a href="#syntax_html_4">while</a> </li>
            <li><a href="#syntax_html_5">Операторы
                управления циклом</a> <ul>
                    <li><a href="#syntax_html_6">next</a> </li>
                    <li><a href="#syntax_html_7">last</a> </li>
                    <li><a href="#syntax_html_8">redo</a> </li>
                </ul>
            </li>
            <li><a href="#syntax_html_9">for</a> </li>
            <li><a href="#syntax_html_10">foreach</a> </li>
        </ul>
    </li>
    <li><a href="#syntax_html_11">Блоки и оператор switch</a> </li>
    <li><a href="#syntax_html_12">Оператор goto</a> </li>
    <li><a href="#syntax_html_13">POD операторы.
        Документирование программ</a> </li>
</ul>

<p>Perl программа (скрипт) состоит из
последовательности деклараций и
предложений. Единственно что
должно быть обязательно
декларировано, это форматы отчетов
и подпрограммы (функции). Все
необъявленные переменные, массивы
имеют значение 0 или null.</p>

<p><a name="syntax_html_1"></a><b>Декларации
(объявления).</b> </p>

<p>Perl имеет свободный формат.
Комментарии начинаются с символа '#'
и продолжаются до конца строки.
Декларации могут использоваться в
любом месте программы так же как и
предложения (statements), но действуют
они только в фазе компиляции
программы. Обычно их помещают или в
начале или в конце программы.
Декларация подпрограмм позволяет
использовать имя подпрограммы как
списковый оператор, начиная с
момента декларирования.<br>
<i>Пример:</i> </p>

<pre>
	sub test;	# Декларация подпрограммы test

	$var1 = test $0; # Использование как оператора списка.
</pre>

<p>Декларации подпрограмм могут
быть загружены из отдельного файла
предложением require или загружены и
импортированы в текущую область
имен предложением use. Подробно см.
главу <a href="#mod_html">Модули</a>.</p>

<p><a name="syntax_html_2"></a><b>Простое предложение.</b> </p>

<p>Простое предложение обязательно
заканчивается символом ';' если
только это не последнее
предложение в блоке где ';' можно
опустить. Заметьте, что существуют
операторы такие как eval{} и do{},
которые выглядят как сложные
предложения, но на самом деле это
термы и требуют обязательного
указания конца предложения. </p>

<p>Любое простое предложение может
содержать single модификатор перед ';'.
Существуют следующие single
модификаторы: </p>

<pre>
	if EXPR
	unless EXPR
	while EXPR
	until EXPR
</pre>

<p>где EXPR - выражение, возвращающее
логическое значение true или false.
Модификаторы while и until вычисляются в
начале предложения кроме блока do,
который выполняется первым. </p>

<p><b>if EXPR</b>- Модификатор &quot;если&quot;.
Предложение выполняется, если EXPR
возвращает true. </p>

<p><i>Пример:</i> </p>

<pre>
	$var = 1;
	$var2 = 3 if $var &gt; 0; # Результат: $var2 = 3
</pre>

<p><b>while EXPR</b> - Модификатор
&quot;пока&quot;. Предложение
выполняется пока EXPR = true </p>

<p><i>Пример:</i> </p>

<pre>
	$var = 1;
	print $var++ while $var &lt; 5; # Печать $var с инкрементом
</pre>

<p>Результат: 1234 </p>

<p><b>until EXPR</b>- Модификатор &quot;до &quot;.
Предложение выполняется до тех пор
пока EXPR = false </p>

<p><i>Пример:</i> </p>

<pre>
	$var = 1;
	print $var++ until $var &gt; 5; # Печать $var с инкрементом
</pre>

<p>Результат: 12345 </p>

<p><b>unless EXPR</b> - Модификатор &quot;если
не&quot; . Обратный к if. Выражение
выполняется если EXPR = false. </p>

<p><i>Пример:</i> </p>

<pre>
	$var = 1;
	print $var++ unless $var &gt; 5; # Печать $var с инкрементом
</pre>

<p>Результат: 1 </p>

<p><a name="syntax_html_3"></a><b>Сложные предложения.</b> </p>

<p>Последовательность простых
предложений, ограниченная
функциональными ограничителями,
называется блоком. В Perl это может
быть целый файл,
последовательность предложений в
операторе eval{} или чаще всего это
множество простых предложений,
ограниченных круглыми скобками '{}'. </p>

<p>Существуют следующие виды
сложных предложений: </p>

<ul>
    <li><a href="#syntax_html_a1">if (EXPR) BLOCK</a><br>
        <a href="#syntax_html_a2">if (EXPR) BLOCK else BLOCK</a><br>
        <a href="#syntax_html_a3">if (EXPR) BLOCK elsif (EXPR) BLOCK ... else
        BLOCK</a> <p>LABEL while (EXPR) BLOCK<br>
        LABEL while (EXPR) BLOCK continue BLOCK<br>
        LABEL for (EXPR; EXPR; EXPR) BLOCK<br>
        LABEL foreach VAR (LIST) BLOCK<br>
        LABEL BLOCK continue BLOCK </p>
    </li>
</ul>

<p>Обратите внимание, что сложные
предложения описаны в термах
блоков, а не предложений, как в
языках C или Pascal. Поэтому необходимо
всегда использовать круглые скобки
для обозначения блока. </p>

<p><a name="syntax_html_a1"></a><b>if (EXPR) BLOCK</b> -
Вычисляется логическое выражение
EXPR и если true блок выполняется. <br>
<i>Пример: </i></p>

<pre>
	$var =1;
	if ($var == 1)
	   { print $var,&quot;\n&quot;;
	   }
</pre>

<p>Результат: 1 </p>

<p><a name="syntax_html_a2"></a><b>if (EXPR) BLOCK else BLOCK2</b> - Если
EXPR=true выполняется BLOCK иначе BLOCK2. <br>
<i>Пример: </i></p>

<pre>
	$var =2;
	if ($var == 1)
	   { print &quot;\$var = 1\n&quot;;
	   }
	else
	   { print &quot;\$var не равно 1\n&quot;;
	   }
</pre>

<p>Результат: $var не равно 1 </p>

<p><a name="syntax_html_a3"></a><b>if (EXPR1) BLOCK1 elsif (EXPR2) BLOCK2 ...
else BLOCK</b> - Если EXPR1=true выполняется
BLOCK1 иначе если EXPR2=true выполняется
BLOCK2 иначе ... иначе BLOCK. <br>
<i>Пример:</i></p>

<pre>
	$var = 1;
	if ($var == 0)
	   { print &quot;\$var = 0\n&quot;;
	   }
	elsif ($var == 1)
	   { print &quot;\$var = 1\n&quot;;
	   }
	else
	   { print &quot;Не известное \$var\n&quot;;
	   }
</pre>

<p>Результат: $var = 1 </p>

<p><a name="syntax_html_4"></a><b>Цикл While</b></p>

<p>Цикл while выполняет BLOCK до тех пор
пока EXPR = true. Метка LABEL не
обязательна и состоит из
идентификатора, завершающегося
символом ':'. Метка необходима при
использовании внутри блока цикла
управляющих операторов next, last и redo.
Если метка все же отсутствует, то
эти операторы ссылаются к началу
ближайшего цикла. Блок после continue
выполняется всегда перед тем как
вычисляется логическое выражение
EXPR. Это подобно EXPR3 в предложении for,
поэтому в этом блоке удобно
изменять счетчики и флаги цикла
даже если применяется оператор next. </p>

<p><a name="syntax_html_5"></a><b> Операторы управления
циклом.</b></p>

<p><a name="syntax_html_6"></a><b>next</b> - подобен continue в С.
Переходит к началу текущего цикла
т.е. повторяет итерацию. </p>

<p><i>Пример: </i></p>

<pre>
	M1:
	while ($i &lt; 6)
	    {
	    ++$i;	# Увеличиваем счетчик на 1
	    next M1 if $i &lt; 3; # Переходим в начало если $i &lt; 3
	    ++$i;	# иначе увеличиваем счетчик еще раз на 1
	    }
	continue
	    {
	    print &quot;$i &quot;; # Печатаем $i
	    }
</pre>

<p>Результат: 1 2 4 6 </p>

<p><a name="syntax_html_7"></a><b>last</b> - подобен
оператору break в языке С. Немедленно
прерывает цикл. Блок continue
пропускается. </p>

<p><i>Пример: </i></p>

<pre>
        M1:
        while ($i &lt; 6)
            {
            ++$i;       # Увеличиваем счетчик на 1
            last M1 if $i &gt; 3; # Выход из цикла если $i &gt; 3
            ++$i;       # иначе увеличиваем счетчик еще раз на 1
            }
continue {
            print &quot;$i &quot;; # Печатаем $i
}
</pre>

<p>Результат: 2 4 </p>

<p><a name="syntax_html_8"></a><b>redo</b> - начать новый цикл
не вычисляя EXPR и не выполняя continue
блок. </p>

<p><i>Пример:</i></p>

<pre>
        M1:
        while ($i &lt; 6)
            {
            ++$i;       # Увеличиваем счетчик на 1
            redo M1 if $i == 3; # Далее пропустить для $i = 3
            ++$i;       # иначе увеличиваем счетчик еще раз на 1
            }
continue {
            print &quot;$i &quot;; # Печатаем $i
}
</pre>

<p>Результат: 2 5 7 </p>

<p><a name="syntax_html_9"></a><b>Цикл for.</b> </p>

<p>LABEL for (EXPR1; EXPR2; EXPR3) BLOCK<br>
Оператор for полностью аналогичен
оператору for в С. В перед началом
цикла выполняется EXPR1, если EXPR2 = true
выполняется блок, затем
выполняется EXPR3. </p>

<p><i>Пример:</i></p>

<pre>
	for ($i = 2; $i &lt; 5; ++$i)
           {
           print $i, &quot; &quot;;
           }
        print &quot;\nПосле цикла i = $i\n&quot;;
</pre>

<p>Результат:</p>

<ul>
    <li>2 3 4<br>
        После цикла i = 5</li>
</ul>

<p><a name="syntax_html_10"></a><b> Цикл foreach.</b> </p>

<p>LABEL foreach VAR (LIST) BLOCK<br>
Переменной VAR присваивается
поочередно каждый элемент списка
LIST и выполняется блок. Если VAR
опущено, то элементы присваиваются
встроенной переменной $_. Если в
теле блока изменять значение VAR то
это вызовет изменение и элементов
списка т.к. VAR фактически указывает
на текущий элемент списка. Вместо
слова foreach можно писать просто for -
это слова синонимы. </p>

<p><i>Пример:</i></p>

<pre>
        @месяц = (&quot;январь&quot;,&quot;февраль&quot;,&quot;март&quot;);  # Создали массив
        foreach $i (@месяц)
            {
            print $i,&quot; &quot;;       # Печать $i
            }
</pre>

<p>Результат: январь февраль март </p>

<p><i>Пример:</i></p>

<pre>
        @месяц = (&quot;январь&quot;,&quot;февраль&quot;,&quot;март&quot;);  # Создали массив
        foreach $i (@месяц)
            {
            $i = uc($i); # Перевели в верхний регистр
            }
        print @месяц;
</pre>

<p>Результат: ЯНВАРЬФЕВРАЛЬМАРТ </p>

<p><i>Пример:</i></p>

<pre>
	for $i (3,5,7)
	    {
	    print &quot;$i &quot;;
	    }
</pre>

<p>Результат: 3 5 7 </p>

<p><a name="syntax_html_11"></a><b> Блоки и оператор switch.</b>
</p>

<p>Блок не зависимо от того имеет он
метку или нет семантически
представляет собой цикл который
выполняется один раз. Поэтому
действие операторов цикла next, last, redo
- аналогично описанному выше. Блоки
удобны для построения switch
(переключатель) структур. В Perl нет
специального оператора switch
подобного языку С поэтому вы сами
можете создавать удобные для вас
конструкции. Опыт автора
показывает что для простоты
написания лучше всего подходит
конструкция вида if ... elsif ... else ...
хотя можно сочинить и нечто
подобное: </p>

<pre>
	SWITCH:
	{
	if ($i ==1 ) { .....; last SWITCH; }
	if ($i ==2 ) { .....; last SWITCH; }
	if ($i ==3 ) { .....; last SWITCH; }
	$default = 13;
	}
</pre>

<p>Выбирайте сами по своему вкусу. </p>

<p><a name="syntax_html_12"></a><b> Оператор goto.</b> </p>

<p>В Perl существует оператор goto хотя
где , как и когда его применять как
говорил Ходжа Насреддин &quot;Тонкий
философский вопрос&quot;. Для
начинающих программистов которым
от так &quot;нужен&quot; я бы вообще
посоветовал &quot;забыть&quot; о его
существовании. Однако при создании
больших производственных задач на
последнем этапе особенно при
отработке &quot;отвальных&quot;
ошибочных ситуаций конечно goto
нужен. </p>

<p>В Perl реализовано три формы goto. goto -
метка, goto - выражение и goto -
подпрограмма. </p>

<table border="0">
    <tr>
        <th valign="top">goto</th>
        <td valign="top">метка выполняет
        непосредственный переход на
        указанную метку. </td>
    </tr>
    <tr>
        <th valign="top">goto - выражение</th>
        <td valign="top">Вычисляет имя метки и
        делает соответствующий
        переход. Например если мы хотим
        сделать переход на одну из трех
        меток &quot;M1:&quot;, &quot;M2:&quot; или
        &quot;M3:&quot; в зависимости от
        значений переменной $i равной 0,
        1 или 2 то это лучше сделать
        следующим образом: <pre>
	goto (&quot;M1&quot;, &quot;M2&quot;, &quot;M3&quot;)[$i];
</pre>
        <p>здесь $i используется как
        индекс массива указанного
        непосредственно в выражении. </p>
        </td>
    </tr>
    <tr>
        <th valign="top">goto подпрограмма</th>
        <td valign="top">довольно редкий
        случай т.к. всегда проще и
        надежней вызвать подпрограмму
        &quot;естественным&quot; образом.</td>
    </tr>
</table>

<p><a name="syntax_html_13"></a><b> POD операторы.
Документирование программ.</b> </p>

<p>В Perl реализован очень удобный
механизм для написания
документации в момент создания
программы. Для этого применяются
специальные POD операторы. Если в
теле программы интерпретатор
встречает оператор начинающийся с
символа '=' например: </p>

<pre>
	= head Набор стандартных процедур
</pre>

<p>то пропускается все до слова '=cut'.
Это удобно для включения длинных на
несколько строк или страниц
комментариев. Затем с помощью
специальной программы pod можно
отделить текст документации от
текста программы. </p>


<hr>

<a name="mod_html"></a>
<font color="#8000FF">Модули (packages).</font></h3>

<hr width="90%">

<ul>
    <li><a href="#mod_html_1">Таблицы имен</a> </li>
    <li><a href="#mod_html_2">Конструкторы и
        деструкторы</a> </li>
    <li><a href="#mod_html_3">Классы</a> </li>
    <li><a href="#mod_html_4">Создание библиотеки</a> </li>
    <li><a href="#mod_html_5">Pragma библиотеки</a> </li>
    <li><a href="#mod_html_6">Стандартные библиотеки</a>
    </li>
    <li><a href="#mod_html_7">CPAN</a> </li>
</ul>

<p>В Perl реализован механизм модулей.
Модуль это группа подпрограмм и
переменных обычно включенных в
один файл. Внутри одного модуля
можно определить другой модуль.
Начало модуля определяется
директивой: </p>

<ul>
    <li>packages имя_модуля; </li>
</ul>

<p>Конец модуля это конец блока или
файла. Головной модуль имеет по
умолчанию имя main. На имя внутри
модуля можно ссылаться, добавляя '::'
после имени модуля.</p>

<p><i>Например:</i> </p>

<pre>
	$main::var1	- переменная в головном модуле.

	::var1		- то же самое. Имя main можно опускать.

	$модуль1::var1	- переменная в модуле 'модуль1'

	$модуль1::модуль2::var1 - Модуль2 содержится в модуле 1.
</pre>

<p>Только идентификаторы,
начинающиеся с буквы или символа '_',
хранятся в пространстве имен
текущего модуля. Остальные
хранятся в пространстве головного
модуля main. Кроме этого имена STDIN,
STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC и SIG так же
хранятся в головном модуле. </p>

<p><a name="mod_html_1"></a><b> Таблицы имен.</b> </p>

<p>Все имена модуля хранятся в
ассоциативном массиве (хеше) с
именем модуля, к которому добавлены
символы &quot;::&quot;. Таким образом
имена головного модуля хранятся в
%main:: , модуля 'mod1' в %mod1:: и т.д.
Выражение вида *имя указывает
значение элемента хеша 'имя', это
удобно для определения констант. </p>

<p><i>Например:</i> </p>

<pre>
	*pi = \3.14159;
</pre>

<p>Здесь переменная $pi - это
константа пи, которую уже нельзя
изменить. </p>

<p><a name="mod_html_2"></a><b> Конструкторы и
деструкторы.</b> </p>

<p>Конструктор - это подпрограмма,
которая выполняется в момент
создания объекта, а деструктор -
удаления объекта. Для модуля это
подпрограммы с именами BEGIN и END. При
определении этих подпрограмм слово
sub можно опускать. </p>

<p>Конструктор BEGIN выполняется сразу
как только возможно, т.е. как только
он определен, даже не завершая
дальнейший разбор программы. Можно
указать несколько блоков BEGIN. Они
будут выполняться один за другим в
порядке определения. </p>

<p>Деструктор END выполняется
последним как только возможно, т.е.
при завершении работы
интерпретатора. Можно указать
несколько блоков END, при этом они
будут выполняться в обратном
определению порядке. </p>

<p><a name="mod_html_3"></a><b> Классы.</b> </p>

<p>В Perl нет специального синтаксиса
для классов. Но функционально
полноценными классами могут быть
модули. При этом подпрограммы
модуля становятся методами, а с
помощью массива @ISA можно
реализовать механизм наследования
в классах. Более подробно классы
описаны отдельно. </p>

<p><a name="mod_html_4"></a><b> Создание библиотеки.</b>
</p>

<p>Если вы хотите создать модуль
отдельным файлом и использовать
как библиотеку подпрограмм, при
этом вызывать подпрограммы
библиотеки, не указывая имени
модуля, вам необходимо оформить
модуль следующим образом: </p>

<pre>
	package имя_модуля;	# Такое же как и имя этого файла без расширения '.pm'
	require Exporter;	# Обязательная строка для экспорта имен
	@ISA = qw(Exporter);	# -//-
	@EXPORT = qw(func1 func2) # Перечисляем имена функций. Внимание ! нет запятой!
	@EXPORT_OK = qw( $переменная @массив ); # Указать публичные переменные, массивы и т.д. если необходимо
	{  # Начало блока модуля
	..... 
	sub func1
	........
	sub func2
	........
	1;
	}
</pre>

<p>Данный файл с расширением
&quot;.pm&quot; должен храниться в одной
из библиотечных директорий Perl. Они
перечислены в массиве @INC, одна из
них обычно &quot;/usr/local/lib/perl/&quot;. </p>

<p>В головной программе вы
указываете: </p>

<ul>
    <li>use имя_модуля; </li>
</ul>

<p>и вам становятся доступны имена
подпрограмм данного модуля. </p>

<p><b>Perl библиотеки.</b> </p>

<p>Стандартный набор библиотек
обычно поставляется с
дистрибутивом Perl, они разделяются
на pragma библиотеки (работают как
директивы компилятору) и
стандартные библиотеки. </p>

<p><a name="mod_html_5"></a><b> Pragma библиотеки.</b> </p>

<p>Данные библиотеки используют как:
</p>

<ul>
    <li>use имя; </li>
</ul>

<p>когда хотят включить действие и </p>

<ul>
    <li>no имя; </li>
</ul>

<p>когда выключить. </p>

<p>В стандартный набор входят
следующие pragma: </p>

<p><i>diagnostics</i><br>
Включить режим расширенной
диагностики. </p>

<p><i>integer</i><br>
Использовать целочисленную
арифметику. </p>

<p><i>less</i><br>
Режим минимальной загрузки
компилятора. </p>

<p><i>overload</i><br>
Режим переопределения операторов. </p>

<p><i>sigtrap</i><br>
Режим слежения за прерываниями. </p>

<p><i>strict</i><br>
Режим ограниченного использования
&quot;опасных&quot; операторов. </p>

<p><i>subs</i><br>
Режим обязательного
декларирования подпрограмм. </p>

<p><a name="mod_html_6"><b></b></a><b> Стандартные
библиотеки.</b> </p>

<p><i>AnyDBM_File </i><br>
Возможность работы с разными
типами баз данных. </p>

<p><i>AutoLoader </i><br>
Загрузка в память функций только во
время вызова. </p>

<p><i>AutoSplit </i><br>
Разделить модуль для автозагрузки. </p>

<p><i>Benchmark </i><br>
Анализ скорости исполнения
программы. </p>

<p><i>Carp </i><br>
Предупреждения об ошибках. </p>

<p><i>Config </i><br>
Доступ к конфигурации Perl. </p>

<p><i>Cwd </i><br>
Получить имя текущей рабочей
директории. </p>

<p><i>DB_File </i><br>
Работа с базой данных формата Berkley
DB. </p>

<p><i>Devel::SelfStubber </i><br>
Режим отладки автозагрузки. </p>

<p><i>DynaLoader </i><br>
Динамическая загрузка библиотек C. </p>

<p><i>English </i><br>
Использовать длинные имена
встроенных переменных. </p>

<p><i>Env </i><br>
Импортировать имена переменных
окружения </p>

<p><i>Exporter </i><br>
Обеспечивает экспорт/импорт для
модулей. </p>

<p><i>ExtUtils::LibList </i><br>
Определяет используемые
библиотеки. </p>

<p><i>ExtUtils::MakeMaker </i><br>
Создает файл проекта Makefile </p>

<p><i>ExtUtils::Manifest </i><br>
Программы для создания и проверки
файла MANIFEST </p>

<p><i>ExtUtils::Mkbootstrap </i><br>
Применение файла начальной
загрузки для DynaLoader. </p>

<p><i>Fcntl </i><br>
Определения как и в С Fcntl.h </p>

<p><i>File::Basename </i><br>
Синтаксический разбор
спецификации файла. </p>

<p><i>File::CheckTree </i><br>
Быстрый проход по директориям
диска. </p>

<p><i>File::Find </i><br>
Быстрый поиск файлов по
директориям. </p>

<p><i>FileHandle </i><br>
Обеспечивает объектный метод
доступа к указателям файлов. </p>

<p><i>File::Path </i><br>
Создание/удаление директорий. </p>

<p><i>Getopt::Long </i><br>
Расширенная обработка опций. </p>

<p><i>Getopt::Std </i><br>
Стандартная обработка опций. </p>

<p><i>I18N::Collate </i><br>
Сравнение символов локальной
кодировки. </p>

<p><i>IPC::Open2 </i><br>
Межпроцессорный обмен по чтению и
записи. </p>

<p><i>IPC::Open3 </i><br>
Межпроцессорный обмен по чтению,
записи, и обработки ошибок. </p>

<p><i>Net::Ping </i><br>
Тест доступа к хосту. </p>

<p><i>POSIX </i><br>
Стандартный интерфейс по IEEE Std 1003.1 </p>

<p><i>SelfLoader </i><br>
Загрузка функций только по вызову. </p>

<p><i>Socket </i><br>
Определение структур и констант
как и в С socket.h </p>

<p><i>Test::Harness </i><br>
Стандартный тест с статистикой. </p>

<p><i>Text::Abbrev </i><br>
Создание таблицы сокращений по
списку. </p>

<p>Подробное описание каждой
библиотеки записано в самом файле. </p>

<p><a name="mod_html_7"></a><b> CPAN</b> </p>

<p>Программисты всего мира,
работающие с Perl, создали <a href="http://www.perl.com/CPAN/">общедоступную
библиотеку модулей CPAN</a>. Она
доступна через Интернет и содержит
огромное количество различных по
назначению модулей. К ним относятся
документаторы, системные
интерфейсы, интерфейсы работы с
базами данных, работа в сети, с
файлами, Интернет-броузеры, системы
поиска, огромное количество CGI
скриптов для Web серверов и
многое-многое другое. Список
некоторых CPAN серверов вы можете
найти в приложении. </p>


<hr>

<a name="sub_html"></a>
<font color="#8000FF"><strong>Подпрограммы.</strong></font></h3>

<hr width="90%">

<ul>
    <li><a href="#sub_html_1">Private переменные</a> </li>
    <li><a href="#sub_html_2">Переменные типа local</a> </li>
    <li><a href="#sub_html_3">Прототипы (prototypes)</a> </li>
    <li><a href="#sub_html_4">Ссылка как параметр</a> </li>
    <li><a href="#sub_html_5">Переопределение
        встроенных функций</a> </li>
    <li><a href="#sub_html_6">Автозагрузка</a> </li>
</ul>

<p>Для применения подпрограммы ее
необходимо определить либо в
текущем модуле (файле), либо во
внешнем модуле (файле).
Подпрограммы определяются и
декларируются следующим образом: </p>

<ul>
    <li><b>sub имя;</b> - Только декларация.
        Определение ниже. </li>
    <li><b>sub имя (прототипы);</b> - То же но
        с декларацией параметров. </li>
    <li><b>sub имя блок;</b> - Декларация и
        определение. </li>
    <li><b>sub имя (прототипы) блок;</b> - То
        же, но с параметрами. </li>
</ul>

<p>Для определения динамической
анонимной подпрограммы можно
указать: </p>

<ul>
    <li>$переменная = sub блок; </li>
</ul>

<p>Для импортирования подпрограмм
из других модулей используйте: </p>

<ul>
    <li>use модуль qw(подпрограмма1
        подпрограмма2 ); </li>
</ul>

<p>Вызов подпрограммы: </p>

<pre>
     имя(список параметров); # символ '&amp;' можно не указывать.
     имя список;             # Если подпрограмма уже декларирована.
     &amp;имя;                   # Параметры в @_
</pre>

<p>Все параметры передаются
подпрограмме как массив @_.
Соответственно $_[0] - первый
параметр, $_[1] - второй и т.д. Массив @_
- локальный, но он содержит адреса
параметров, поэтому можно изменять
значение параметров. Возвращаемое
значение подпрограммы - результат
последнего оператора. Это может
быть как скаляр так и массив. Можно
принудительно возвращать
результат используя функцию return(). </p>

<p>Подпрограмму можно вызвать,
используя префикс '&amp;' перед именем
подпрограммы. Если подпрограмма
предварительно продекларирована,
то префикс и скобки можно опустить. </p>

<p><a name="sub_html_1"></a><b> Private переменные.</b> </p>

<p>Для применения переменных
доступных только внутри блока или
подпрограммы необходимо
определить их с помощью функции
my(список).<br>
Если переменная одна, то скобки
можно опустить. </p>

<p>my() декларирует private переменные в
пределах текущей подпрограммы,
блока, функции eval() или do/require/use
файлов. Private переменные аналогичны
auto переменным в С. </p>

<p><i>Пример:</i> </p>

<pre>
	# Программа вычисления факториала.

	print fact(3);  # вычислить факториал 3*2*1

	sub fact	# Определяем подпрограмму.
	{ my $m;                # private переменная но не local !
	$m = $_[0];
	return 1 if $m &lt;= 1; return($m * fact($m 1)); }

</pre>

<p>Можно указывать начальные
значения private переменных как: </p>

<ul>
    <li>my(список) = выражение; </li>
</ul>

<pre>Так для вышеприведенного примера лучше было написать:
</pre>

<ul>
    <li>my($m) = $_[0]; </li>
</ul>

<p><a name="sub_html_2"></a><b> Переменные типа local.</b> </p>

<p>В общем лучше использовать private
переменные, т. к. это надежней и
быстрее. private переменные
обеспечивают лексическую область
применения (видимости), а local -
динамическую. Обычно это
переменные форматов, значение
которых должно быть видимо из
вызываемых подпрограмм. Применение
функции local() нецелесообразно в
циклах, так как она вызывается
каждый раз и таким образом заметно
увеличивает время выполнения
цикла. </p>

<p><a name="sub_html_3"></a><b> Прототипы (prototypes).</b> </p>

<p>Для краткого описания типа
передаваемых подпрограмме
параметров можно применять
прототипы. В Perl существуют
следующие прототипы: </p>

<table border="1">
    <tr>
        <th>Декларация</th>
        <th>Пример вызова</th>
    </tr>
    <tr>
        <td valign="top"><b>sub mylink($$)</b></td>
        <td valign="top">mylink $old, $new</td>
    </tr>
    <tr>
        <td valign="top"><b>sub myvec($$$)</b></td>
        <td valign="top">myvec $var, $offset, 1</td>
    </tr>
    <tr>
        <td valign="top"><b>sub myindex($$;$)</b></td>
        <td valign="top">myindex &amp;getstring,
        &quot;substr&quot;</td>
    </tr>
    <tr>
        <td valign="top"><b>sub myreverse(@)</b></td>
        <td valign="top">myreverse $a, $b, $c</td>
    </tr>
    <tr>
        <td valign="top"><b>sub myjoin($@)</b></td>
        <td valign="top">myjoin &quot;:&quot;,$a,$b,$c</td>
    </tr>
    <tr>
        <td valign="top"><b>sub mypop(\@)</b></td>
        <td valign="top">mypop @array</td>
    </tr>
    <tr>
        <td valign="top"><b>sub mysplice(\@$$@)</b></td>
        <td valign="top">mysplice @array, @array, 0, @pushme</td>
    </tr>
    <tr>
        <td valign="top"><b>sub mykeys(\%)</b></td>
        <td valign="top">mykeys %{$hashref}</td>
    </tr>
    <tr>
        <td valign="top"><b>sub myopen(*;$)</b></td>
        <td valign="top">myopen HANDLE, $name</td>
    </tr>
    <tr>
        <td valign="top"><b>sub mypipe(**)</b></td>
        <td valign="top">mypipe READHANDLE, WRITEHANDLE</td>
    </tr>
    <tr>
        <td valign="top"><b>sub mygrep(&amp;@)</b></td>
        <td valign="top">mygrep { /foo/ } $a, $b, $c</td>
    </tr>
    <tr>
        <td valign="top"><b>sub myrand($)</b></td>
        <td valign="top">myrand 42</td>
    </tr>
    <tr>
        <td valign="top"><b>sub mytime()</b></td>
        <td valign="top">mytime</td>
    </tr>
</table>

<pre>Здесь:
</pre>

<ul>
    <li><b>\'символ'</b> - параметр с типом
        'символ' </li>
    <li><b>'@' или '%'</b> - все оставшиеся
        параметры как список </li>
    <li><b>'$'</b> - скаляр </li>
    <li><b>'&amp;'</b> - безымянная
        подпрограмма </li>
    <li><b>'*'</b> - ссылка на таблицу имен </li>
    <li><b>';'</b> - разграничитель
        обязательных и не обязательных
        параметров. </li>
</ul>

<p><a name="sub_html_4"></a><b> Ссылка как параметр.</b> </p>

<p>Иногда нужно в качестве параметра
передать подпрограмме не значение
элемента массива, а ссылку на него,
чтобы подпрограмма могла изменить
значение элемента. Для этого в Perl к
имени переменной добавляется
символ '*' Подобное выражение
называют 'type glob' так же как в Unix
символом '*' обозначают &quot;все
возможные значения&quot;. Поэтому '*'
для массива означает &quot;все
элементы массива&quot;. Для скаляров
употреблять '*' не имеет смысла, т.к.
они и так передаются ссылкой и вы
можете изменять значение
параметра, изменяя, например,
переменную $_[0]. </p>

<p><a name="sub_html_5"></a><b> Переопределение
встроенных функций.</b> </p>

<p>Большинство встроенных функций
Perl можно переопределить своими
собственными. Обычно это делают для
удобства совместимости Perl для
разных платформ систем.<br>
Для этого нужно перечислить имена
этих функций в виде: </p>

<ul>
    <li>use subs 'функция1', 'функция2' ....; </li>
</ul>

<pre>и далее в модуле определить сами функции.
</pre>

<p><a name="sub_html_6"></a><b> Автозагрузка.</b> </p>

<p>Если вы попытаетесь вызвать
несуществующую функцию, то Perl
немедленно выдаст сообщение об
ошибке. Но если вы определите
подпрограмму с именем 'AUTOLOAD', то она
будет вызвана с теми же
параметрами, а переменная $AUTOLOAD
будет содержать имя несуществующей
подпрограммы. Данный механизм
очень удобен для средств отладки. </p>


<hr>

<a name="form_html"></a>
<font color="#8000FF">Форматы.</font></h3>

<hr width="90%">

<p>В Perl реализован удобный метод
создания форматированных отчетов.
С помощью оператора format вы
описываете заголовки, размеры
полей, указываете положение данных
на листе в удобной текстовой форме.
Затем выполняете команду write(файл),
которая выводит отформатированные
данные в указанный файл. </p>

<p>Оператор format имеет следующий
синтаксис: </p>

<pre>
	format имя =
	FORMLIST
	.
</pre>

<p>Обратите внимание на то, что
описание формата идет после строки
format и заканчивается символом '.' в
начале строки. </p>

<p>Здесь 'имя' - это имя формата, такое
же как и имя указателя выходного
файла. Если 'имя' отсутствует то
значение по умолчанию - STDOUT. </p>

<p>FORMLIST - это строки формата. Они
бывают трех типов: </p>

<ol>
    <li>Комментарий. Строка начинается
        символом '#'. </li>
    <li>Описатель полей данных (picture). </li>
    <li>Строка аргументов
        используемых описателем. </li>
</ol>

<p>Описатель - это строка, которая
выводится в виде &quot;как есть&quot; за
исключением специально
обозначенных форматов полей
данных. Каждое поле начинается либо
символом '@', либо '^'. В описательной
строке указывается только
положение и вид выводимых данных,
но не имена полей и переменных. Для
этого предназначена следующая
строка аргументов которая следует
всегда после описателя и содержит
имена переменных или целые
выражения в порядке указанном
описателем. </p>

<p>Размер и вид поля в описателе
обозначается следующими символами:
</p>

<table border="0">
    <tr>
        <td>&quot;&lt;&lt;&lt;&lt;&quot; </td>
        <td>- выравнить значение по
        правому краю.</td>
    </tr>
    <tr>
        <td>&quot;&gt;&gt;&gt;&gt;&quot; </td>
        <td>- -//- по левому. </td>
    </tr>
    <tr>
        <td>&quot;||||&quot;</td>
        <td>- -//- по центру. </td>
    </tr>
    <tr>
        <td>&quot;####.###&quot;</td>
        <td>- формат числа с точкой. </td>
    </tr>
    <tr>
        <td>&quot;@*&quot;</td>
        <td>- многострочная строка.
        Данные выводятся в колонку. </td>
    </tr>
</table>

<p>Размер поля равен количеству
указанных символов.<br>
Символ '^' в начале поля имеет
специальное значение. <br>
Так: </p>

<ul>
    <li>&quot;^####&quot; - пусто если
        переменная не определена. </li>
</ul>

<p>для строчного скаляра: </p>

<ul>
    <li>&quot;^&lt;&lt;&lt;&lt;&lt;&quot; Выводится
        сколько возможно символов, а
        значение переменной меняется
        на остаток, вывод которого
        можно продолжить на следующих
        строках, которые могут иметь
        свои поля.<p><i>Пример:</i> </p>
        <pre>
#!/usr/local/bin/perl
#
#	Программа печати пригласительного билета
#
$кому = &quot;Чапаеву Василию Ивановичу&quot;;
$от_кого = &quot;Компания МММ&quot;;
$адрес = &quot;Москва, ул. Петровка, д 38&quot;;
$текст = &quot;Уважаемый Василий Иванович! Компания МММ имеет честь пригласить
Вас и Ваших близких на презентацию наших новых хромовых сапог, сделанных
на уровне мировых стандартов качества и дизайна.&quot;;
format STDOUT =

	П Р И Г Л А С И Т Е Л Ь Н Ы Й      Б И Л Е Т
----------------------------------------------------------------------
Кому: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; | ^|||||||||||||||||||||||||||||||
 	$кому,				 $текст
 				  | ^|||||||||||||||||||||||||||||||
					 $текст
От кого: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; | ^|||||||||||||||||||||||||||||||
	$от_кого,			 $текст
				  | ^|||||||||||||||||||||||||||||||
					 $текст
Адрес:@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; | ^|||||||||||||||||||||||||||||||
	$адрес,				 $текст
				  | ^|||||||||||||||||||||||||||||||
					 $текст
				  | ^|||||||||||||||||||||||||||||||
					 $текст
				  | ^|||||||||||||||||||||||||||||||
					 $текст
----------------------------------------------------------------------
 Отпечатано в типографии ИТУ 38
 .</pre>
        <pre> write(); # Вывод данных.
 exit 0; # Конец программы 
</pre>
        <p><i>Результат:</i> </p>
        <pre>

	П Р И Г Л А С И Т Е Л Ь Н Ы Й      Б И Л Е Т
----------------------------------------------------------------------
Кому: Чапаеву Василию Ивановичу    |   Уважаемый Василий Иванович!
                                   |     Компания МММ имеет честь
От кого: Компания МММ              |  пригласить Вас и Ваших близких
                                   |    на презентацию наших новых
Адрес:Москва, ул. Петровка, д 38   |   хромовых сапог, сделанных на
                                   |    уровне мировых стандартов
                                   |       качества и дизайна.
                                   |
----------------------------------------------------------------------
Отпечатано в типографии ИТУ 38
</pre>
        <p>Специальные переменные: </p>
        <ul>
            <li><b>$~</b> - построчный формат
                содержимого. </li>
            <li><b>$^</b> - формат заголовка
                листа. </li>
            <li><b>$%</b> - номер листа. </li>
            <li><b>$=</b> - строк в листе. </li>
        </ul>
        <p>Если вы хотите использовать
        одни и те же форматы для разных
        файлов, то самый простой путь: </p>
        <pre>
	use FileHandle;                   # Указать в начале программы
	format_name файл имя_формата;     # Формат содержимого листа.
	format_top_name файл имя_формата; # Формат заголовка листа.
	write(файл);                      # вывод данных.
</pre>
        <p>Здесь 'файл' имеется ввиду
        указатель файла полученный
        командой open(); </p>
        <p>Если вам нужно в теле листа
        выводить разного рода форматы
        (например заголовки групп или
        отбивку листа), то применяйте
        format_name. </p>

<hr>

<a name="dat_html"></a>
<font color="#8000FF">Переменные.</font></h3>

<hr width="90%">

<ul>
    <li><a href="#dat_html_1">Контекст</a> </li>
    <li><a href="#dat_html_2">Скалярные значения</a> </li>
    <li><a href="#dat_html_3">Конструкторы скаляров</a>
    </li>
    <li><a href="#dat_html_4">Конструкторы списков</a> </li>
    <li><a href="#dat_html_5">Тип typeglobs</a> </li>
</ul>

<p>В Perl существует три типа структур
данных: скаляры, массивы скаляров и
хеши (hashes) - ассоциативные массивы
скаляров. Обычно элементы массивов
индексируются целыми числами,
первый элемент - нулевой.
Отрицательное значение индекса
обозначает номер позиции элемента
с конца. Хеши индексируются
строками символов. </p>

<p>Имена скалярных переменных
всегда начинаются с символа '$' даже
когда обозначают элемент массива. </p>

<p><i>Пример:</i></p>

<pre>

	$var1		# Простой скаляр 'var1'

	$var1[0]	# Первый элемент массива 'var1'

	$var1{'first'}	# Элемент с индексом 'first'
</pre>

<p>В случае использования имени
массива &quot;целиком&quot; или его
&quot;среза&quot; перед именем массива
ставится символ '@'. </p>

<p><i>Пример:</i></p>

<pre>

	@var1		# Все элементы массива var1 ( $var1[0], $var1[1], ... $var1[n])

	@var1[1,3,10]	# Элементы $var1[1], $var1[3], $var1[10]

	@var1{'first','last'} # то же что и ( $var1{'first'}, $var1{'last'} )
</pre>

<p>Хеш &quot;целиком&quot; начинается с
символа '%'. </p>

<p><i>Пример:</i></p>

<pre>

	%var, %key, %years
</pre>

<p>Имена подпрограмм начинаются
символом '&amp;', если из контекста не
видно, что это подпрограмма. </p>

<p><i>Пример:</i> </p>

<pre>
	&amp;sub1, &amp;test_prog, test(12)
</pre>

<p>Имена таблиц символов всегда
начинаются символом '*'. </p>

<p>Каждый тип переменных имеет свою
область памяти поэтому $var1 и $var1[0]
совершенно разные переменные, хотя
$var1[0] часть массива @var1. Так же @var1 и
%var1 - разные массивы переменных. </p>

<p>Имена переменных могут содержать
любые буквенно-цифровые символы за
исключением пробела и табуляции.
Эти символы используются в
качестве разделителей. Большие и
малые буквы различаются поэтому $var1
и $Var1 - разные переменные. В Perl по
умолчанию имена меток и указателей
файлов пишут большими буквами. </p>

<p><a name="dat_html_1"></a><b> Контекст.</b> </p>

<p>Большое значение для правильного
употребления встроенных функций
имеет контекст использования
результата этих функций, т.к. в
противном случае они возвращают
совершенно &quot;непонятный&quot;
результат. В Perl имеется два главных
контекста: скалярный и список (list).
Проще говоря, если в левой части
выражения имеется ввиду одно
единственное значение, то это
скалярный контекст. Если множество
значений - список. </p>

<p><i>Пример:</i> </p>

<pre>
	$var1 = &lt;&gt;;	# Прочитать одну строку файла

	@var1 = &lt;&gt;;	# Прочитать все строки файла в массив @var1

	$var1 = (1,2,3); # $var = 3 - количество элементов

	@var1 = (1,2,3); # Создание массива @var1 с элементами 1,2,3
</pre>

<p><a name="dat_html_2"></a><b>Скалярные значения.</b> </p>

<p>Все данные в Perl это скаляры,
массивы скаляров и хеши скаляров.
Скалярные переменные могут
содержать числа, строки и ссылки.
Преобразование числа - строки
происходит автоматически по
умолчанию. Скаляр может иметь
только одно единственное значение,
хотя это может быть ссылка на
массив скаляров. Так как Perl сам
преобразовывает числа в строки и
наоборот, то программисту нет
необходимости думать о том, что
возвращает функция. </p>

<p>В Perl не существует типов
&quot;строка&quot; или &quot;число&quot; или
&quot;файл&quot; или что-то еще. Это
контекстно зависимый полиморфный
язык для работы с текстами. </p>

<p>Скаляр имеет логическое значение
&quot;TRUE&quot; (истина), если это не
нулевая строка или число не равное
0. </p>

<p>В Perl существует два типа нулевых
(null) скаляров - определенные (defined) и
неопределенные (undefined).
Неопределенное значение
возвращается, когда что-то не
существует. Например, неизвестная
переменная, конец файла или ошибка.
С помощью функции defined() вы можете
заранее обнаружить подобное
состояние. </p>

<p>Количество элементов массива так
же является скаляром и начинается
символами $# подобно интерпретатору
csh. Фактически $#var1 - это индекс
последнего элемента массива. Нужно
помнить, что первый элемент имеет
индекс 0, поэтому количество
элементов определяется как $#var1+1 .
Присвоение значения $#var1 изменит
длину массива и разрушит
&quot;оставленные&quot; значения.
Присвоение значения элементу
массива с индексом больше чем $#var1
увеличит размер массива, а
присвоение ему нулевого списка
-обнулит. </p>

<p>В скалярном контексте имя массива
возвращает его длину (для списка
возвращается последний элемент). </p>

<p><i>Пример:</i> </p>

<pre>
	@var1 = (4, 3, 2, 1);	# Присвоение значения элементам массива
	$i = @var1;		# Использование скалярного контекста
	print $i;		# Печать результата 4 - кол-во элементов
	print @var1;		# Списковый контекст, печать всех элементов.
</pre>

<p>Для принудительного получения
скалярного значения удобно
применять функцию scalar(). </p>

<p><i>Пример:</i> </p>

<pre>
	print scalar(@var1);	# Вывод длины массива а не его значений
</pre>

<p>Хеш в скалярном контексте
возвращает &quot;true&quot;, если
существует хотя бы одна пара
&quot;ключ-значение&quot;. Фактически
возвращается строка типа 2/8 где 8 -
количество выделенных &quot;ячеек&quot;
памяти, а 2 - количество
использованных. </p>

<p><a name="dat_html_3"></a><b> Конструкторы скаляров.</b>
</p>

<p>Числа пишутся стандартно: </p>

<pre>
	123
	123.123
	0.12
	.12E-10
	0xABCD		# Шестнадцатиричная запись
	0377		# Если 0 в начале - восьмеричная
	123_456_123	# Так тоже можно для удобства чтения.
</pre>

<p>Строки ограничиваются одинарными
(') или двойными (&quot;) кавычками: </p>

<pre>
	'Равняйсь, смирно!'
	&quot;Построимся и спасемся.&quot;
</pre>

<p>Способов обозначения строк очень
много. Смотрите описание оператора
qq. </p>

<p>В хеше можно опускать кавычки,
если индекс не содержит пробелов. </p>

<p><i>Пример:</i> </p>

<pre>
	$var1{first} то же что и $var1{'first'}
</pre>

<p>Обратите внимание на то, что перед
первой одинарной кавычкой должен
стоять пробел, иначе строка
воспримется как имя переменной, т.
к. в именах разрешено использование
одинарных кавычек. Запрещается в
кавычках применять
зарезервированные литералы __LINE__
(номер текущей строки программы),
__FILE__ (текущий файл). Для обозначения
конца программы можно применять
литерал __END__ Весь последующий текст
игнорируется, но его можно
прочитать используя указатель
файла DATA. </p>

<p>Слова в программе, не поддающиеся
никакой интерпретации,
воспринимаются как строки в
кавычках, поэтому рекомендуется
имена меток и указателей файлов
писать большими буквами во
избежание возможного
&quot;конфликта&quot; с
зарезервированными словами. </p>

<p>В Perl есть возможность вставлять
текст документа прямо в программу.
Так называемый &quot;here-doc&quot; (здесь
текст) метод. Обозначается
символами &lt;&lt; за которыми идет
слово-ограничитель. </p>

<p><i>Пример:</i> </p>

<pre>
	print &lt;&lt;EOF;	# Все строки до EOF - текст для печати.

	Эй вы трое, идите двое сюда!
	Что стоишь! Я тебе говорю!!

		Полковник Савонькин.
	EOF
</pre>

<p><a name="dat_html_4"></a><b>Конструкторы списков.</b>
</p>

<p>Список - множество значений,
перечисленных через запятую и
заключенных в круглые скобки. В
списковом контексте список
возвращает последний элемент
списка. </p>

<p><i>Пример:</i> </p>

<pre>
	@var1 = (1, 2, 'привет', 1.2); # Присвоить значение элементам.
</pre>

<p>где </p>

<pre>
		$var1[0] = 1,

		$var1[1] = 2,

		$var1[2] = 'привет'

		$var1[3] = 1.2


	$var1 = (1, 2, 'привет', 1.2);
</pre>

<p>а здесь $var1 = 1.2 т.е. последнее
значение списка. </p>

<p>Допускается применять в списке
другие списки, но в полученном
списке уже невозможно различить
начало и конец включенных списков. </p>

<p><i>Пример:</i> </p>

<pre>
	@s1 = (1, 2, 3); # 	Первый список

	@s2 = (6, 7, 8);	# Второй

	@s = (0, @s1, 4, 5, @s2, 9, 10); # Включаем списки @s1 и @s2

	print @s;	# Результат: 012345678910  - значения без пробелов.
</pre>

<p>Список без элементов
обозначается как () и называется
нуль-списком. Списковое выражение
можно употреблять как имя массива,
но при этом его нужно брать в
круглые скобки. </p>

<p><i>Пример:</i> </p>

<pre>
	print ('январь','февраль','март')[1];
</pre>

<p>Результат: февраль </p>

<p>Список может быть присвоен списку
только если каждый элемент в списке
в левой части выражения допустим по
типу списку в правой части. </p>

<p><i>Пример:</i> </p>

<pre>
	($a, $b, $c) = (1, 2, 3); # $a = 1, $b = 2, $c = 3
</pre>

<p>Присваивание списков в скалярном
контексте возвращает количество
присвоенных элементов. </p>

<p><i>Пример:</i> </p>

<pre>
	$x = (($a, $b, $c) = (1,2));  # Результат $x=2
</pre>

<p>В случае присваивания списка
хешу, список рассматривается как
пары: ключ-значение. </p>

<p><i>Пример:</i> </p>

<pre>
	%дни_месяца = ('январь', 31, 'февраль', 30);
</pre>

<p>Результат: $дни_месяца{январь} = 31,
$дни_месяца{февраль} = 30 </p>

<p>Для удобства записи можно
использовать выражение с =&gt; . </p>

<p><i>Пример:</i> </p>

<pre>
	%дни_месяца = (
			январь =&gt; 31,
			февраль =&gt; 30,
	);
</pre>

<p><a name="dat_html_5"></a><b>Тип typeglobs</b> </p>

<p>В Perl используется специальный
внутренний тип typeglog для записи
массива всех переменных. Такие
массивы начинаются с символа '*'. Их
удобно применять для передачи
ссылок на массивы и хеши, но в
данной версии Perl уже есть
возможность применять ссылки,
поэтому это делается очень редко.
Единственно где это необходимо, так
это для работы со ссылками на файлы.
Например, если вам нужно создать
локальную ссылку на файл в
процедуре, то это лучше сделать так:
</p>

<pre>
sub new_sub
{ local *IN; # Ссылка на файл
open (IN, &quot;test&quot;) || return undef;  # Открыть файл. Возврат при ошибке.
......... 
return;
}
</pre>

<p>Более подробно это описано в
главе <a href="#internet_html">Ссылки</a>. </p>


<hr>

<a name="sysvar_html"></a>
<font color="#8000FF">Встроенные
переменные Perl.</font></h3>

<hr width="90%">

<p>Описанные в данной главе
переменные имеют в Perl специальные
значения. Они обозначаются
несколько непривычно для
&quot;глаза&quot; программистов, т.к.
состоят обычно только из двух
символов, причем первый это '$'
символ, с которого начинаются имена
всех переменных, и произвольный
часто не буквенно-цифровой символ.
Если вы хотите пользоваться их
&quot;нормальными&quot; буквенными
синонимами, то вам нужно указать в
начале программы: </p>

<pre>
	use English;
</pre>

<p>Точно так же если вы захотите
пользоваться переменными и
методами текущего указателя файлов
вы можете написать: </p>

<pre>
	use FileHandle;
</pre>

<p>после этого можно просто писать: </p>

<pre>
	метод указатель выражение
</pre>

<p>или </p>

<pre>
	указатель -&gt; метод(выражение)
</pre>

<p>Ниже приводятся имена как в
короткой, так и в длинной
(словесной) форме. Некоторые из
встроенных переменных имеют доступ
только на чтение, поэтому изменить
их значение просто невозможно. </p>

<p><b>$_<br>
$ARG</b> </p>

<p>Переменная - по умолчанию для
операторов ввода и поиска. То есть
если в качестве аргумента не
указана никакая переменная, то
используется именно эта. </p>

<p><b>$цифра</b> </p>

<p>Содержит найденную подстроку в
последнем поиске, когда шаблон
содержит метасимволы в круглых
скобках. Цифра в данном случае, это
номер скобок. Первая подстрока
имеет номер 1. </p>

<p><b>$&amp;<br>
$MATCH</b> </p>

<p>Найденная подстрока в последнем
поиске по шаблону. </p>

<p><b>$`</b> </p>

<p>Подстрока, предшествующая
найденной подстроке. </p>

<p><b>$'<br>
$POSTMATCH</b> </p>

<p>Подстрока, последующая за
найденной подстрокой. </p>

<p><b>$+<br>
$LAST_PAREN_MATCH</b> </p>

<p>Подстрока, найденная в поиске с
выбором по &quot;или&quot;. </p>

<p><b>$*<br>
$MULTILINE_MATCHING</b> </p>

<p>Если значение этой переменной
установить равным 1, то переменная,
в которой осуществляется поиск,
будет считаться многострочной, т.е.
содержащей символы '\n' - перевод
строки. Если значение равно 0, то
переменная считается однострочной.
В Perl версии 5 и выше не
рекомендуется использовать эту
переменную. </p>

<p><b>$.<br>
$INPUT_LINE_NUMBER<br>
$NR</b> </p>

<p>Номер прочитанной строки
последнего оператора ввода.
Закрытие файла вызывает очистку
значения этой переменной. </p>

<p><b>$/<br>
$RS<br>
$INPUT_RECORD_SEPARATOR</b> </p>

<p>Символ - признак конца входной
строки. По умолчанию это '\n' </p>

<p><b>$|<br>
$OUTPUT_AUTOFLUSH</b> </p>

<p>Если присвоить этой переменной
ненулевое значение, то будет сброс
буфера вывода после каждой
операции вывода. Значение по
умолчанию - 0 </p>

<p><b>$,<br>
$OFS<br>
$OUTPUT_FIELD_SEPARATOR</b> </p>

<p>Символ, добавляемый оператором
print после каждого элемента из
списка параметров. </p>

<p><b>$\<br>
$ORS<br>
$OUTPUT_RECORD_SEPARATOR</b> </p>

<p>Символ, добавляемый print после
вывода всех параметров. </p>

<p><b>$&quot;<br>
$LIST_SEPARATOR</b> </p>

<p>Аналогичен &quot;$,&quot;, но
добавляется после каждого элемента
массива, указанного в &quot;....&quot;. </p>

<p><b>$;<br>
$SUBSEP<br>
$SUBSCRIPT_SEPARATOR</b> </p>

<p>Символ - разделитель для эмуляции
многомерных массивов в хеш
массивах. По умолчанию '\034'. </p>

<p><b>$#<br>
$OFMT</b> </p>

<p>Формат по умолчанию для вывода
чисел. </p>

<p><b>$%<br>
$FORMAT_PAGE_NUMBER</b> </p>

<p>Формат по умолчанию для вывода
номеров страниц. </p>

<p><b>$=<br>
$FORMAT_LINES_PER_PAGE</b> </p>

<p>Длина одной страницы. По
умолчанию 60 строк. </p>

<p><b>$-<br>
$FORMAT_LINES_LEFT</b> </p>

<p>Количество оставшихся строк на
странице. </p>

<p><b>$~<br>
$FORMAT_NAME</b> </p>

<p>Имя формата текущего вывода. По
умолчанию имя указателя. </p>

<p><b>$^<br>
$FORMAT_TOP_NAME</b> </p>

<p>Имя текущего формата для
заголовка страницы. </p>

<p><b>$:<br>
$FORMAT_LINE_BREAK_CHARACTERS</b> </p>

<p>Символы переноса строки для
многострочных полей. В строке
формата такие поля начинаются
символом '^'. По умолчанию '\n-'. </p>

<p><b>$^L<br>
$FORMAT_FORMFEED</b> </p>

<p>Символ перевода формата ( смены
листа). По умолчанию '\f'. </p>

<p><b>$^A<br>
$ACCUMULATOR</b> </p>

<p>Текущее значение аккумулятора
функции write() для format(). Значение этой
переменной можно увидеть только
при использовании функции formline(),
т.к. write() очищает ее после каждого
вывода. </p>

<p><b>$?<br>
$CHILD_ERROR</b> </p>

<p>Данная переменная содержит
статус завершения таких процессов
как: закрытие pipe, завершение
функций system(), wait() и `...`. </p>

<p><b>$!<br>
$ERRNO $OS_ERROR</b> </p>

<p>В числовом контексте возвращает
код ошибки errno. В строковом - строку
сообщения об ошибке. Можно
принудительно присвоить этой
переменной код ошибки, что бы
получить системное сообщение для
данного кода или установить код
завершения для функции die(). </p>

<p><b>$@<br>
$EVAL_ERROR</b> </p>

<p>Сообщение об ошибке последней
команды eval(). </p>

<p><b>$$<br>
$PID<br>
$PROCESS_ID</b> </p>

<p>Номер текущего процесса. </p>

<p><b>$&lt; <br>
$UID<br>
$REAL_USER_ID</b> </p>

<p>Реальный UID текущего процесса. </p>

<p><b>$&gt; <br>
$EUID<br>
$EFFECTIVE_USER_ID</b> </p>

<p>Эффективный UID текущего процесса. </p>

<p><b>$( $GID<br>
$REAL_GROUP_ID</b> </p>

<p>Реальный GID текущего процесса. </p>

<p><b>$)<br>
$EGID<br>
$EFFECTIVE_GROUP_ID</b> </p>

<p>Эффективный GID текущего процесса. </p>

<p><b>$O<br>
$PROGRAM_NAME</b> </p>

<p>Имя файла программы. Если этой
переменной присвоить какое-нибудь
значение, то его можно видеть в
команде ps, что удобно для контроля
за состоянием программы. </p>

<p><b>$[</b> </p>

<p>Номер первого элемента массива
или символа строки. Значение по
умолчанию - 0. </p>

<p><b>$]<br>
$PERL_VERSION</b> </p>

<p>Строка - сообщение версии Perl.
Печатается по команде perl -v
Применяется в программе для
определения рабочей версии Perl. В
числовом контексте это номер
версии плюс номер модификации / 1000. </p>

<p><b>$^D<br>
$DEBUGGING</b> </p>

<p>Текущее значение ключа отладки
'-D'. </p>

<p><b>$^F<br>
$SYSTEM_FD_MAX</b> </p>

<p>Номер максимального системного
описателя файлов (system file descriptor).
Обычно это 2. </p>

<p><b>$^I<br>
$INPLACE_EDIT</b> </p>

<p>Текущее значение inplace-edit
возможности. Для отключения
используйте undef. </p>

<p><b>$^P<br>
$PERLDB</b> </p>

<p>Внутренний флаг отладки.
Применяется для того, чтобы
отладчик не отслеживал самого себя.
</p>

<p><b>$^T<br>
$BASETIME</b> </p>

<p>Время в секундах с начала 1970 года
старта текущей программы. </p>

<p><b>$^W<br>
$WARNING</b> </p>

<p>Значение флага '-w'. true -если
включено и false - выключено. </p>

<p><b>$^X<br>
$EXECUTABLE_NAME</b> </p>

<p>Команда запуска Perl. Аналогично
argv[0] в С. </p>

<p><b>$ARGV</b> </p>

<p>Имя текущего файла, читаемого
оператором '&lt;&gt;'. </p>

<p><b>@ARGV</b> </p>

<p>Массив параметров строки запуска
программы. Внимание! @#ARGV - меньше
количества параметров на 1, т.к. $ARGV[0]
это первый параметр (не имя
программы). </p>

<p><b>@INC</b> </p>

<p>Список директорий диска, которые
просматривает Perl для выполнения
команд do, require или use. </p>

<p><b>%INC</b> </p>

<p>Этот хеш содержит имена
директорий для имен использованных
файлов командами do или require. Ключ -
имя файла, а значение - директория. </p>

<p><b>$ENV{выражение}</b> </p>

<p>Хеш %ENV содержит значения
переменных окружения. Изменение
этих значений вызывает изменение
окружения для процессов потомков. </p>

<p><b>$SIG{выражение}</b> </p>

<p>Хеш %SIG содержит имена подпрограмм
для таких системных сигналов как INT,
QUIT, PIPE, ... Значение 'DEFAULT' - для
системной обработки. 'IGNORE' -
игнорировать данный сигнал. </p>


<hr>

<a name="re_html"></a>
<font color="#8000FF">Регулярные
выражения (шаблоны).</font></h3>

<hr width="90%">

<p>В данной главе описывается
синтаксис регулярных выражений.
Чаще всего в Perl они используются в
операторах поиска и замены таких
как <b>s//</b>, <b>m/</b>, операторах связки <b>=~</b>
или <b>!=</b> и т.д. Как правило все эти
операторы имеют схожие опции такие
как: </p>

<table border="1">
    <tr>
        <td valign="top"><b>i</b></td>
        <td valign="top"><b>- не различать
        строчные и заглавные буквы.</b></td>
    </tr>
    <tr>
        <td valign="top"><b>m</b></td>
        <td valign="top"><b>- считать строку
        многострочной.</b></td>
    </tr>
    <tr>
        <td valign="top"><b>s</b></td>
        <td valign="top"><b>- однострочная
        строка.</b></td>
    </tr>
    <tr>
        <td valign="top"><b>x</b></td>
        <td valign="top"><b>- расширенный
        синтаксис ( использование
        пробелов и комментариев)</b></td>
    </tr>
</table>

<p>Обычно все эти опции обозначают
как '/x'. Их можно использовать даже
внутри шаблонов, используя новую
конструкцию (?...) </p>

<p>Регулярные выражения или шаблоны
(pattern) то же самое, что и regexp
процедуры в Unix. Выражения и
синтаксис заимствованы из свободно
распространяемых процедур V8 Генри
Спенсера (Henry Spencer), там же они
подробно и описаны. </p>

<p>В шаблонах используются
следующие метасимволы (символы
обозначающие группы других
символов) часто называемые egrep -
стандартом: </p>

<table border="1">
    <tr>
        <td valign="top"><b>\</b></td>
        <td valign="top"><b>- считать следующий
        метасимвол как обычный символ.</b></td>
    </tr>
    <tr>
        <td valign="top"><b>^</b></td>
        <td valign="top"><b>- начало строки</b></td>
    </tr>
    <tr>
        <td valign="top"><b>.</b></td>
        <td valign="top"><b>- один произвольный
        символ. Кроме '\n' - конец строки.</b></td>
    </tr>
    <tr>
        <td valign="top"><b>$</b></td>
        <td valign="top"><b>- конец строки</b></td>
    </tr>
    <tr>
        <td valign="top"><b>|</b></td>
        <td valign="top"><b>- альтернатива (или)</b></td>
    </tr>
    <tr>
        <td valign="top"><b>()</b></td>
        <td valign="top"><b>- группировка</b></td>
    </tr>
    <tr>
        <td valign="top"><b>[]</b></td>
        <td valign="top"><b>- класс символов</b></td>
    </tr>
</table>

<p><b>Метасимволы имеют модификаторы
(пишутся после метасимвола): </b></p>

<table border="1">
    <tr>
        <td valign="top"><b>*</b></td>
        <td valign="top"><b>- повторяется 0 или
        большее число раз</b></td>
    </tr>
    <tr>
        <td valign="top"><b>+</b></td>
        <td valign="top"><b>- -//- 1 или большее
        число раз</b></td>
    </tr>
    <tr>
        <td valign="top"><b>?</b></td>
        <td valign="top"><b>- 1 или 0 раз</b></td>
    </tr>
    <tr>
        <td valign="top"><b>{n}</b></td>
        <td valign="top"><b>- точно n раз</b></td>
    </tr>
    <tr>
        <td valign="top"><b>{n,}</b></td>
        <td valign="top"><b>- по меньшей мере раз</b></td>
    </tr>
    <tr>
        <td valign="top"><b>{n,m}</b></td>
        <td valign="top"><b>- не меньше n, но и не
        больше m</b></td>
    </tr>
</table>

<p>Во все других случаях фигурные
скобки считаются обычными
(регулярными) символами. Таким
образом '*' эквивалентна {0,} , '+' - {1,} и
'?' - {0,1}. n и m не могут быть больше 65536. </p>

<p>По умолчанию действие
метасимволов &quot;жадно&quot; (greedy).
Совпадение распространяется
столько раз, сколько возможно, не
учитывая результат действия
следующих метасимволов. Если вы
хотите &quot;уменьшить их аппетит&quot;,
то используйте символ '?'. Это не
изменяет значение метасимволов,
просто уменьшает распространение.
Таким образом: </p>

<table border="1">
    <tr>
        <td valign="top"><b>*?</b></td>
        <td valign="top"><b>- станет 0 и более</b></td>
    </tr>
    <tr>
        <td valign="top"><b>+?</b></td>
        <td valign="top"><b>- 1 и более</b></td>
    </tr>
    <tr>
        <td valign="top"><b>??</b></td>
        <td valign="top"><b>- 0 или 1 раз</b></td>
    </tr>
    <tr>
        <td valign="top"><b>{n}?</b></td>
        <td valign="top"><b>- точно n раз</b></td>
    </tr>
    <tr>
        <td valign="top"><b>{n,}?</b></td>
        <td valign="top"><b>- не меньше n раз</b></td>
    </tr>
    <tr>
        <td valign="top"><b>{n,m}?</b></td>
        <td valign="top"><b>- больше или равно n и
        меньше m раз</b></td>
    </tr>
</table>

<p>Шаблоны работают так же, как и
двойные кавычки, поэтому в них
можно использовать `\` - символы
(бэкслэш-символы): </p>

<table border="1">
    <tr>
        <td valign="top"><b>\t</b></td>
        <td valign="top"><b>- символ табуляции</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\n</b></td>
        <td valign="top"><b>- новая строка</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\r</b></td>
        <td valign="top"><b>- перевод каретки</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\а</b></td>
        <td valign="top"><b>- перевод формата</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\v</b></td>
        <td valign="top"><b>- вертикальная
        табуляция</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\a</b></td>
        <td valign="top"><b>- звонок</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\e</b></td>
        <td valign="top"><b>- escape</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\033</b></td>
        <td valign="top"><b>- восьмеричная
        запись символа</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\x1A</b></td>
        <td valign="top"><b>- шестнадцатеричная</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\c[</b></td>
        <td valign="top"><b>- control символ</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\l</b></td>
        <td valign="top"><b>- нижний регистр
        следующего символа</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\u</b></td>
        <td valign="top"><b>- верхний регистр -//-</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\L</b></td>
        <td valign="top"><b>- все символы в
        нижнем регистре до \E</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\U</b></td>
        <td valign="top"><b>- в верхнем -//-</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\E</b></td>
        <td valign="top"><b>- ограничитель смены
        регистра</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\Q</b></td>
        <td valign="top"><b>- отмена действия
        как метасимвола</b></td>
    </tr>
</table>

<p><b>Дополнительно в Perl добавлены
следующие метасимволы: </b></p>

<table border="1">
    <tr>
        <td valign="top"><b>\w</b></td>
        <td valign="top"><b>- алфавитно-цифровой
        или '_' символ</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\W</b></td>
        <td valign="top"><b>- не -//- </b></td>
    </tr>
    <tr>
        <td valign="top"><b>\s</b></td>
        <td valign="top"><b>- один пробел</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\S</b></td>
        <td valign="top"><b>- один не пробел</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\d</b></td>
        <td valign="top"><b>- одна цифра</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\D</b></td>
        <td valign="top"><b>- одна не цифра</b></td>
    </tr>
</table>

<p><b>Обратите внимание, что все это
&quot;один&quot; символ. Для обозначения
последовательности применяйте
модификаторы. Так: </b></p>

<table border="1">
    <tr>
        <td valign="top"><b>\w+</b></td>
        <td valign="top"><b>- слово</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\d+</b></td>
        <td valign="top"><b>- целое число</b></td>
    </tr>
    <tr>
        <td valign="top"><b>[+-]?\d+</b></td>
        <td valign="top"><b>- целое со знаком</b></td>
    </tr>
    <tr>
        <td valign="top"><b>[+-]?\d+\.?\d*</b></td>
        <td valign="top"><b>- число с точкой</b></td>
    </tr>
</table>

<p><b>Кроме того существуют мнимые
метасимволы. Обозначающие не
существующие символы в месте смены
значения. Такие как: </b></p>

<table border="1">
    <tr>
        <td valign="top"><b>\b</b></td>
        <td valign="top"><b>- граница слова</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\B</b></td>
        <td valign="top"><b>- не граница слова</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\A</b></td>
        <td valign="top"><b>- начало строки</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\Z</b></td>
        <td valign="top"><b>- конец строки</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\G</b></td>
        <td valign="top"><b>- конец действия m//g</b></td>
    </tr>
</table>

<p>Граница слова (<strong>\b</strong>) - это
мнимая точка между символами <strong>\w</strong>
и <strong>\W</strong>. Внутри класса
символов '<strong>\b</strong>' обозначает
символ backspace (стирания). Метасимволы<strong>
\A</strong> и <strong>\Z</strong> - аналогичны '^' и
'$', но если начало строки '^' и конец
строки '$' действуют для каждой
строки в многострочной строке, то <b>\A</b>
и <b>\Z</b> обозначают начало и конец
всей многострочной строки. </p>

<p>Если внутри шаблона применяется
группировка (круглые скобки), то
номер подстроки группы
обозначается как '\цифра'. Заметьте,
что за шаблоном в пределах
выражения или блока эти группы
обозначаются как '$цифра'. Кроме
этого существуют дополнительные
переменные: </p>

<table border="1">
    <tr>
        <td valign="top"><b>$+</b></td>
        <td valign="top"><b>- обозначает
        последнее совпадение</b></td>
    </tr>
    <tr>
        <td valign="top"><b>$&amp;</b></td>
        <td valign="top"><b>- все совпадение</b></td>
    </tr>
    <tr>
        <td valign="top"><b>$`</b></td>
        <td valign="top"><b>- все до совпадения</b></td>
    </tr>
    <tr>
        <td valign="top"><b>$'</b></td>
        <td valign="top"><b>- все после
        совпадения</b></td>
    </tr>
</table>

<p><i>Пример:</i> </p>

<pre>
$s = &quot;Один 1 два 2 и три 3&quot;;
if ($s =~ /(\d+)\D+(\d+)/)
    {
        print &quot;$1\n&quot;;# Результат '1'
        print &quot;$2\n&quot;;# '2'
        print &quot;$+\n&quot;;# '2'
        print &quot;$&amp;\n&quot;;# '1 два 2'
        print &quot;$`\n&quot;;# 'Один '
        print &quot;$'\n&quot;;# ' и три 3'
   }
</pre>

<p><b>Perl версии 5 содержит
дополнительные конструкции
шаблонов: </b></p>

<table border="1">
    <tr>
        <td valign="top"><b>(?#комментарий)</b></td>
        <td valign="top"><b>- комментарий в теле
        шаблона. </b></td>
    </tr>
    <tr>
        <td valign="top"><b>(?:шаблон)</b></td>
        <td valign="top"><b>- группировка как и '(
        )', но без обратной ссылки </b></td>
    </tr>
    <tr>
        <td valign="top"><b>(?=шаблон)</b></td>
        <td valign="top"><b>-
        &quot;заглядывание&quot; вперед.
        Например /\w+(?=\t)/ соответствует
        слову, за которым идет
        табуляция, но символ '\t' не
        включается в результат. </b></td>
    </tr>
</table>

<p><i>Пример:</i> </p>

<pre>
$s = &quot;1+2-3*4&quot;;
if ($s =~ /(\d)(?=-)/)  # Найти цифру за которой стоит '-'
    {
        print &quot;$1\n&quot;;   # Результат '2'
   }
else { print &quot;ошибка поиска\n&quot;;}


        (?!шаблон)         - &quot;заглядывание&quot; вперед по отрицанию.
</pre>

<p><i>Пример:</i> </p>

<pre>
$s = &quot;1+2-3*4&quot;;
if ($s =~ /(\d)(?!\+)/) # Найти цифру за которой не стоит '+'
    {
        print &quot;$1\n&quot;;   # Результат '2'
   }
else { print &quot;ошибка поиска\n&quot;;}
</pre>

<p>(?ismx)- &quot;внутренние&quot;
модификаторы. Удобно применять в
шаблонах, где например нужно внутри
шаблона указать модификатор. </p>

<p><b>Правила регулярного выражения.
(regex)</b> </p>

<ol>
    <li>Любой символ обозначает себя
        самого, если это не метасимвол.
        Если вам нужно отменить
        действие метасимвола, то
        поставьте перед ним '\'. </li>
    <li>Строка символов обозначает
        строку этих символов. </li>
    <li>Множество возможных символов
        (класс) заключается в
        квадратные скобки '[]', это
        значит, что в данном месте
        может стоять один из указанных
        в скобках символов. Если первый
        символ в скобках это '^' - значит
        ни один из указанных символов
        не может стоять в данном месте
        выражения. Внутри класса можно
        употреблять символ '-',
        обозначающий диапазон
        символов. Например, a-z - один из
        малых букв латинского
        алфавита, 0-9 - цифра и т.д. </li>
    <li>Все символы, включая
        специальные, можно обозначать
        с помощью '\' как в языке С. </li>
    <li>Альтернативные
        последовательности
        разделяются символом '|'
        Заметьте что внутри квадратных
        скобок это обычный символ. </li>
    <li>Внутри регулярного выражения
        можно указывать
        &quot;подшаблоны&quot; заключая их в
        круглые скобки и ссылаться на
        них как '\номер' Первая скобка
        обозначается как '\1'. </li>
</ol>


<hr>

<a name="op_html"></a>
<font color="#8000FF">Операторы и
приоритеты.</font></h3>

<hr width="90%">

<ul>
    <li><a href="#op_html_1">Термы и левосторонние
        списковые операторы</a> </li>
    <li><a href="#op_html_2">Унарные операторы</a> </li>
    <li><a href="#op_html_3">Операторы
        &quot;привязки&quot; =~ и !=</a> </li>
    <li><a href="#op_html_4">Мультипликативные
        операторы</a> </li>
    <li><a href="#op_html_5">Аддитивные операторы</a> </li>
    <li><a href="#op_html_6">Операторы сдвига</a> </li>
    <li><a href="#op_html_7">Именованные унарные
        операторы</a> </li>
    <li><a href="#op_html_8">Операторы отношений</a> </li>
    <li><a href="#op_html_9">Операторы равенства</a> </li>
    <li><a href="#op_html_10">Операторы работы с
        битами</a> </li>
    <li><a href="#op_html_11">Логические операторы
        &amp;&amp; (AND) и || (OR)</a> </li>
    <li><a href="#op_html_12">Оператор диапазона '..'</a>
    </li>
    <li><a href="#op_html_13">Условный оператор '?:'</a> </li>
    <li><a href="#op_html_14">Операторы присваивания</a>
    </li>
    <li><a href="#op_html_15">Оператор ',' (запятая)</a> </li>
    <li><a href="#op_html_16">Логические not, and, or, xor</a> </li>
    <li><a href="#op_html_17">Операторы ограничители
        строк</a> </li>
    <li><a href="#op_html_18">Операторы ввода-вывода</a>
    </li>
    <li><a href="#op_html_19">Слияние констант</a> </li>
    <li><a href="#op_html_20">Целочисленная
        арифметика</a> </li>
</ul>

<p>В Perl ассоциативность и
приоритетность операторов
аналогична языку С. Ниже
перечислены все операторы в
порядке уменьшения приоритета, в
начале строки указана
ассоциативность. </p>

<table border="1">
    <tr>
        <th valign="top" bgcolor="#C0C0C0">ассоц.</th>
        <th valign="top" bgcolor="#C0C0C0">операторы</th>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>термы и
        левосторонние списковые
        операторы</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>-&gt;</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>-</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>++ --</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>правая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>**</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>правая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>! ~ \
        унарные + и -</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>=~ !~</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>* / % x</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>+ - .</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>&lt;&lt; &gt;&gt;</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>-</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>именованные
        унарные операторы</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>-</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>&lt; &gt; &lt;=
        &gt;= lt gt le ge</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>-</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>== != &lt;=&gt; eq
        ne cmp</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>&amp;</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>| ^</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>&amp;&amp;</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>||</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>-</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>..</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>правая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>?:</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>правая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>= += -= *= и
        т.д.</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>, =&gt;</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>-</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>правосторонние
        списковые операторы</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>not</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>and</b></td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#C0C0C0"><b>левая</b></td>
        <td valign="top" bgcolor="#C0C0C0"><b>or xor</b></td>
    </tr>
</table>

<p><a name="op_html_1"><b></b></a><b> Термы и
левосторонние списковые операторы.</b>
</p>

<p>Любой терм имеет самый высокий
приоритет. К терму относятся
переменные, кавычки и их операторы,
арифметические и логические
выражения в скобках, любые функции
с параметрами в скобках. Фактически
таких функций нет, так как это
просто унарные и списковые
операторы. Просто они ведут себя
подобно функциям с параметрами в
скобках. Подробно смотри главу <a href="#func_html">Функции</a>. </p>

<p>Если после любого спискового
оператора ( print(), и т.д.) или унарного
оператора (chdir(), и т.д.) следует левая
круглая скобка, то операторы внутри
скобок имеют наивысший приоритет.
Так же как и обычные функции. </p>

<p>Если скобки отсутствуют, то
приоритет списковых операторов или
наивысший или наименьший в
отношении операторов справа или
слева от него. </p>

<p><i>Например:</i> </p>

<pre>
        @i = ('a ','b ', print 'c ', 'd ');
        print &quot;\n&quot;,@i,&quot;\n&quot;;
</pre>

<p>Результат: </p>

<pre>
     c d
     a b 1
</pre>

<p>Здесь мы имеем списковый оператор
print. Для запятых слева от него он
имеет наименьший приоритет, но
повышает приоритет правой запятой.
Поэтому правая запятая
воспринимается как параметр для print
и печатается 'c d', а левая просто
записывает код завершения операции
в массив @i и последний print
показывает это. </p>

<p>Оператор '-&gt;' </p>

<p>Так же как в С или С++ это инфиксный
оператор переадресации. Если
справа от него стоит [...] или {...}
выражение, то правая часть может
быть непосредственной или
символической ссылкой на массив
или хеш. В противном случае правая
сторона это метод или простой
скаляр, содержащий имя метода, а
правая - или объект или имя класса.
Подробно смотри главу <a href="#mod_html_3">Классы</a>.
</p>

<p>Операторы ++ (инкремент) и --
(декремент). </p>

<p>Эти операторы работают так же как
и в С. Если оператор стоит перед
переменной, то значение переменной
изменяется на 1 и полученное
значение используется. Если после
переменной - то ее величина
изменяется после применения. </p>

<p>Употребление инкремента к
строковым переменным в Perl имеет
одну особенность. Каждый символ
остается в своем классе (большие,
малые, цифры) и учитывается перенос
предыдущего символа. Таким образом
строковые переменные с цифрами
работают как числовые переменные. </p>

<p><i>Пример:</i> </p>

<pre>
     print ++($i = &quot;09&quot;);     # Результат &quot;10&quot;

     print ++($i = &quot;a9&quot;);     # &quot;b0&quot;

     print ++($i = &quot;az&quot;);     # &quot;ba&quot;
     print ++($i = &quot;aZ&quot;);     # &quot;bA&quot;
</pre>

<p>Оператор ** (возведение в степень) </p>

<p><i>Пример:</i></p>

<pre>
     print 4**2     # Результат 16

     print -4**2     # Результат -16 т.е. -(4**2)
</pre>

<p><a name="op_html_2"></a><b>Унарные операторы.</b></p>

<table border="1">
    <tr>
        <td valign="top"><b>'!'</b></td>
        <td valign="top"><b>- логическое
        отрицание </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'-'</b></td>
        <td valign="top"><b>- арифметический
        минус </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'~'</b></td>
        <td valign="top"><b>- побитная инверсия
        (дополнение до 1) </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'+'</b></td>
        <td valign="top"><b>- арифметический
        плюс </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'\'</b></td>
        <td valign="top"><b>- получение ссылки
        на переменную (как &amp; в С) </b></td>
    </tr>
</table>

<p><a name="op_html_3"><b></b></a><b>Операторы
&quot;привязки&quot; =~ и != .</b> </p>

<p>Эти &quot;необычные&quot;, я бы даже
сказал, оригинальные операторы
имеют очень широкое применение в
Perl. Можно даже назвать их
&quot;оригинальным&quot; решением.
Оператор =~ логически связывает
левую часть выражения с патерном
(pattern - образец, шаблон, модель) в
правой. По умолчанию поиск или
изменение по патерну выполняется в
переменной $_ Операторы привязки
позволяют делать это с любой
переменной, указанной в левой
части. Логическим результатом
будет успех операции. Если в правой
части вместо патерна присутствует
выражение, то результат этого
выражения воспринимается как
патерн. Однако это не очень
эффективно, т.к. патерн будет
компилироваться во время
исполнения программы, что заметно
снизит быстродействие. Оператор !=
аналогичен =~, только результат
совпадения инвертируется
(логическое &quot;нет&quot;). Подробное
применение этих операторов
приводится в главе <a href="#op_html_pattern">Патерны</a>.
</p>

<p><a name="op_html_4"></a><b> Мультипликативные
операторы.</b></p>

<table border="1">
    <tr>
        <td valign="top"><b>'*'</b></td>
        <td valign="top"><b>- арифметическое
        умножение </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'/'</b></td>
        <td valign="top"><b>- арифметическое
        деление </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'%'</b></td>
        <td valign="top"><b>- арифметический
        модуль </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'x'</b></td>
        <td valign="top"><b>- оператор
        повторения</b></td>
    </tr>
</table>

<p>В скалярном контексте возвращает
строку левой части, повторенную
величиной, указанной в правой
части. В списковом контексте, если в
левой части список, то в круглых
скобках - повторенный список. </p>

<p><b><i>Пример:</i></b></p>

<pre><b>
     print '*' x 5;     # Результат '*****'

     print (1,2) x 3; # Результат 121212
</b></pre>

<p><a name="op_html_5"><b></b></a><b> Аддитивные
операторы.</b></p>

<table border="1">
    <tr>
        <td valign="top"><b>'+'</b></td>
        <td valign="top"><b>- арифметический
        плюс </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'-'</b></td>
        <td valign="top"><b>- арифметический
        минус </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'.'</b></td>
        <td valign="top"><b>- конкатенация
        (объединение) строк</b></td>
    </tr>
</table>

<p><a name="op_html_6"><b></b></a><b> Операторы сдвига.</b></p>

<table border="1">
    <tr>
        <td valign="top"><b>'&lt;&lt;'</b></td>
        <td valign="top"><b>- Сдвигает побитно
        влево значение выражения в
        левой части</b></td>
    </tr>
    <tr>
        <td valign="top"><b></b>&nbsp;</td>
        <td valign="top"><b>на количество бит
        указанное в правой. </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'&gt;&gt;'</b></td>
        <td valign="top"><b>- Сдвигает побитно
        вправо значение выражения в
        левой части</b></td>
    </tr>
    <tr>
        <td valign="top"><b></b>&nbsp;</td>
        <td valign="top"><b>на количество бит
        указанное в правой.</b></td>
    </tr>
</table>

<p><a name="op_html_7"><b></b></a><b>Именованные
унарные операторы.</b> </p>

<p>Фактически это функции с одним
аргументом. Круглые скобки можно
опускать. </p>

<p><a name="op_html_8"></a><b> Операторы отношений.</b></p>

<table border="1">
    <tr>
        <td valign="top"><b>'&lt;'</b></td>
        <td valign="top"><b>- арифметическое
        меньше </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'&gt;'</b></td>
        <td valign="top"><b>- арифметическое
        больше </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'&lt;='</b></td>
        <td valign="top"><b>- арифметическое
        меньше или равно </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'&gt;='</b></td>
        <td valign="top"><b>- арифметическое
        больше или равно </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'lt'</b></td>
        <td valign="top"><b>- строковое меньше </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'gt'</b></td>
        <td valign="top"><b>- строковое больше </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'le'</b></td>
        <td valign="top"><b>- строковое меньше
        или равно </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'ge'</b></td>
        <td valign="top"><b>- строковое больше
        или равно</b></td>
    </tr>
</table>

<p><a name="op_html_9"><b></b></a><b>Операторы
равенства.</b></p>

<table border="1">
    <tr>
        <td valign="top"><b>'=='</b></td>
        <td valign="top"><b>результат true если
        левая часть равна правой
        (равно) </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'!='</b></td>
        <td valign="top"><b>- не равно </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'&lt;=&gt;'</b></td>
        <td valign="top"><b>- -1 если левая часть
        меньше правой, 0 если равна,</b></td>
    </tr>
    <tr>
        <td valign="top"><b></b>&nbsp;</td>
        <td valign="top"><b>1 если больше. </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'eq'</b></td>
        <td valign="top"><b>- строковое равно </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'ne'</b></td>
        <td valign="top"><b>- строковое не равно </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'cmp'</b></td>
        <td valign="top"><b>- как и '&lt;=&gt;'
        применительно к строкам</b></td>
    </tr>
</table>

<p><a name="op_html_10"><b></b></a><b> Операторы работы с
битами.</b></p>

<table border="1">
    <tr>
        <td valign="top"><b>'&amp;'</b></td>
        <td valign="top"><b>- побитное AND </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'|'</b></td>
        <td valign="top"><b>- побитное OR </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'^'</b></td>
        <td valign="top"><b>- побитное XOR</b></td>
    </tr>
</table>

<p><a name="op_html_11"><b></b></a><b> Логические
операторы &amp;&amp; (AND) и || (OR).</b></p>

<table border="1">
    <tr>
        <td valign="top"><b>'&amp;&amp;'</b></td>
        <td valign="top"><b>- если левое
        выражение возвращает false,
        правое не выполняется. </b></td>
    </tr>
    <tr>
        <td valign="top"><b>'||'</b></td>
        <td valign="top"><b>- если левое
        выражение возвращает true,
        правое не выполняется.</b></td>
    </tr>
</table>

<p>Отличие от подобных операторов в
С заключается в том, что в С
возвращаемое значение либо 0, либо 1,
тогда как в Perl возвращается
результат выражения. </p>

<p><a name="op_html_12"><b></b></a><b> Оператор
диапазона '..'</b> </p>

<p>Результат работы данного
оператора зависит от контекста. В
списковом контексте результат есть
список с элементами, первый элемент
которого это левое выражение и
последнее - правое. Значение
каждого элемента внутри списка
увеличивается на 1. Данный оператор
удобен для небольших циклов, т.к.
память отводится для всего списка
целиком. Поэтому будьте
внимательны и не задавайте слишком
большой диапазон. </p>

<p><i>Пример:</i> </p>

<pre>
     for $i (1..4)
        { print &quot;$i &quot;;
        }
</pre>

<p>Результат: 1 2 3 4 </p>

<p>В скалярном контексте результат -
логическое значение. Каждая '..'
операция устанавливает свое
собственное состояние. Это false до
тех пор пока левый операнд false. Как
только левый операнд стал true
результат - true до тех пока правый true,
после чего результат опять - false.
Если вы не хотите проверять правый
операнд, то используйте оператор
'...'. </p>

<p>Правый операнд не вычисляется
пока результат false и левый операнд
не вычисляется пока результат true.
Приоритетность оператора '..'
немного ниже чем '&amp;&amp;' и '||'.
Возвращаемое значение если flase -
нулевая строка, если true - порядковый
номер начиная с 1. Порядковый номер
обнуляется для каждого нового
диапазона. Последний порядковый
номер добавляется строкой &quot;E0&quot;
которая не изменяет его значение,
но позволяет фиксировать последнее
значение. </p>

<p><i>Пример:</i></p>

<pre>
     @алфавит = ('a'..'z'); # Массив малых букв латинского алфавита

     @цифры = (0..9);     # Массив цифр
</pre>

<p><a name="op_html_13"></a><b>Условный оператор '?:'</b>
</p>

<p>Этот оператор работает так же как
и в С. Если выражение перед '?'
истинно, то выполняется аргумент
перед ':' - иначе после ':'. </p>

<p><i>Пример:</i></p>

<pre>
     $i = 1;
     $i &gt; 1 ? print &quot;больше&quot; : print &quot;меньше&quot;;
</pre>

<p>Результат: меньше </p>

<p><a name="op_html_14"></a><b> Операторы
присваивания.</b></p>

<table border="0">
    <tr>
        <td valign="top"><b>'='</b></td>
        <td valign="top"><b>- обычный оператор
        &quot;присвоить&quot; правое
        значение переменной слева</b></td>
    </tr>
</table>

<p><b>Вся эта группа операторов
подобна операторам С, т.е. </b></p>

<pre><b>
     $i += 2;
</b></pre>

<p><b>эквивалентно </b></p>

<pre><b>
     $i = $i + 2;
</b></pre>

<p><b>Остальные операторы этой группы
работают аналогично. Допустимы
следующие операторы: </b></p>

<table border="0">
    <tr>
        <td valign="top"><b>**=</b></td>
    </tr>
    <tr>
        <td valign="top"><b>+=, -=, .=</b></td>
    </tr>
    <tr>
        <td valign="top"><b>*=, /=, %=, x=</b></td>
    </tr>
    <tr>
        <td valign="top"><b>&amp;=, |=, ^=</b></td>
    </tr>
    <tr>
        <td valign="top"><b>&lt;&lt;=, &gt;&gt;=</b></td>
    </tr>
    <tr>
        <td valign="top"><b>&amp;&amp;=, ||=</b></td>
    </tr>
</table>

<p><b>Приоритет всей этой группы
операторов равен приоритету '='. </b></p>

<p><a name="op_html_15"><b></b></a><b> Оператор ','
(запятая)</b> </p>

<p>В скалярном контексте
выполняется левый аргумент,
результат игнорируется, затем
правый и его результат есть
результат действия оператора. В
списковом контексте это
разделитель элементов списка,
который включает указанные
элементы в список. </p>

<p><a name="op_html_16"></a><b>Операторы not, and, or, xor</b> </p>

<p><i>Оператор логическое not
(отрицание).</i><br>
Унарный not возвращает
противоположное значение,
полученное выражением справа. Он
эквивалентен '!', но имеет очень
низкий приоритет. </p>

<p><i>Оператор логическое and (И). </i><br>
Выполняет логическую конъюнкцию
двух выражений. Эквивалентен
'&amp;&amp;', но имеет очень низкий
приоритет и &quot;краткость&quot;
действия, т. е. если левое выражение
равно false - левое не выполняется. </p>

<p><i>Логическое or (ИЛИ). </i><br>
Выполняет логическую дизъюнкцию
двух выражений. Эквивалентен '||', но
имеет очень низкий приоритет и
&quot;краткость&quot; действия, т. е. если
левое выражение равно true - левое не
выполняется. </p>

<p><i>Логическое xor (исключающее ИЛИ). </i><br>
Выполняет логическое исключающие
или. Всегда выполняются оба правое
и левое выражение. </p>

<p>В Perl отсутствуют операторы языка
С такие как: </p>

<table border="1">
    <tr>
        <td valign="top"><b>унарное &amp;</b></td>
        <td valign="top"><b>- получить адрес. Для
        этого применяется '\'. </b></td>
    </tr>
    <tr>
        <td valign="top"><b>унарный *</b></td>
        <td valign="top"><b>- переадресация. </b></td>
    </tr>
    <tr>
        <td valign="top"><b>(TYPE) </b></td>
        <td valign="top"><b>- совмещение типов.</b></td>
    </tr>
</table>

<p><a name="op_html_17"><b></b></a><b> Операторы
ограничители строк.</b> </p>

<p>Обычно ограничителями строк мы
считаем литералы, но в Perl это
операторы выполняющие разного рода
интерполяцию и поиск по шаблону. Вы
можете сами задавать удобные для
вас ограничители. В следующей
таблице приведен полный перечень
вариантов. Фигурные скобки '{}'
обозначают любой символ,
используемый для ограничителя. В
случае использования скобок
(круглых '()', квадратных '[]', фигурных
'{}', угловых '&lt;&gt;') в начале ставится
открывающаяся скобка, а в конце
закрывающая. </p>

<table border="1">
    <tr>
        <th valign="top">По умолчанию</th>
        <th valign="top">Полное</th>
        <th valign="top">Функция</th>
        <th valign="top">Интерполяция</th>
    </tr>
    <tr>
        <td valign="top"><b>''</b></td>
        <td valign="top"><b>q{}</b></td>
        <td valign="top"><b>Literal</b></td>
        <td valign="top"><b>нет</b></td>
    </tr>
    <tr>
        <td valign="top"><b>&quot;&quot;</b></td>
        <td valign="top"><b>qq{}</b></td>
        <td valign="top"><b>Литерал</b></td>
        <td valign="top"><b>да</b></td>
    </tr>
    <tr>
        <td valign="top"><b>``</b></td>
        <td valign="top"><b>qx{}</b></td>
        <td valign="top"><b>Команда</b></td>
        <td valign="top"><b>да</b></td>
    </tr>
    <tr>
        <td valign="top"><b></b>&nbsp;</td>
        <td valign="top"><b>qw{}</b></td>
        <td valign="top"><b>Список слов</b></td>
        <td valign="top"><b>нет</b></td>
    </tr>
    <tr>
        <td valign="top"><b>//</b></td>
        <td valign="top"><b>m{}</b></td>
        <td valign="top"><b>Шаблон</b></td>
        <td valign="top"><b>да</b></td>
    </tr>
    <tr>
        <td valign="top"><b></b>&nbsp;</td>
        <td valign="top"><b>s{}{}</b></td>
        <td valign="top"><b>Подстановка</b></td>
        <td valign="top"><b>да</b></td>
    </tr>
    <tr>
        <td valign="top"><b></b>&nbsp;</td>
        <td valign="top"><b>tr{}{}</b></td>
        <td valign="top"><b>Трансляция</b></td>
        <td valign="top"><b>нет </b></td>
    </tr>
</table>

<p>В строках допускающих
интерполяцию имена переменных,
начинающиеся с символов '$' или '@' -
интерполируются, т.е. в строку
вставляется значение строки или
массива. Данные последовательности
символов имеют специальное
значение: </p>

<table border="1">
    <tr>
        <td valign="top"><b>\t</b></td>
        <td valign="top"><b>символ табуляции</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\n</b></td>
        <td valign="top"><b>символ новой строки</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\r</b></td>
        <td valign="top"><b>возврат</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\f</b></td>
        <td valign="top"><b>перевод формата</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\v</b></td>
        <td valign="top"><b>вертикальная
        табуляция</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\b</b></td>
        <td valign="top"><b>backspace (забой)</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\a</b></td>
        <td valign="top"><b>звонок</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\e</b></td>
        <td valign="top"><b>escape</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\034</b></td>
        <td valign="top"><b>восьмеричный символ</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\x1a</b></td>
        <td valign="top"><b>шестнадцатеричный
        символ</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\c[</b></td>
        <td valign="top"><b>символ управления</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\l</b></td>
        <td valign="top"><b>нижний регистр
        следующего символа</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\u</b></td>
        <td valign="top"><b>верхний регистр
        следующего символа</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\L</b></td>
        <td valign="top"><b>нижний регистр для
        всех символов до \E</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\U</b></td>
        <td valign="top"><b>верхний регистр для
        всех символов до \E</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\E</b></td>
        <td valign="top"><b>ограничитель смены
        регистра</b></td>
    </tr>
    <tr>
        <td valign="top"><b>\Q</b></td>
        <td valign="top"><b>отмена действия
        метасимволов до \E</b></td>
    </tr>
</table>

<p align="left">Шаблоны интерполируются
как регулярные выражения. Это
выполняется вторым проходом после
интерполяции переменных, поэтому в
шаблоны можно вставлять
переменные. Для отмены
интерполяции используйте '\Q'. Если
вы применяете вложенные
ограничители, то внутренние
ограничители работать не будут. </p>

<p><a name="op_html_pattern"><b></b></a><b> ?PATERN?</b> </p>

<p>Действие этого оператора
аналогично /шаблон/, но выполняется
до первого совпадения. Это удобно
для поиска наличия какой-нибудь
строки в одном или множестве
файлов. Это не очень удачный
оператор, поэтому в следующих
версиях Perl его возможно не будет. </p>

<p><b>m/PATERN/gimosx<br>
/PATERN/gimosx</b> </p>

<p>Поиск в строке по патерну
(шаблону). В скалярном контексте
возвращает логическое значение true
(1) или false (''). Если строка не указана
с помощью операторов '=~' или '!~',
поиск ведется в строке $_ Опции: </p>

<table border="1">
    <tr>
        <td valign="top"><b>g</b></td>
        <td valign="top"><b>- Глобальный поиск.
        Поиск всех вхождений.</b></td>
    </tr>
    <tr>
        <td valign="top"><b>i</b></td>
        <td valign="top"><b>- Сравнение не
        зависит от регистра (верхний
        или нижний)</b></td>
    </tr>
    <tr>
        <td valign="top"><b>m</b></td>
        <td valign="top"><b>- Строка
        многострочная.</b></td>
    </tr>
    <tr>
        <td valign="top"><b>o</b></td>
        <td valign="top"><b>- однопроходная
        компиляция</b></td>
    </tr>
    <tr>
        <td valign="top"><b>s</b></td>
        <td valign="top"><b>- однострочная
        строка</b></td>
    </tr>
    <tr>
        <td valign="top"><b>x</b></td>
        <td valign="top"><b>- используются
        расширенные регулярные
        выражения.</b></td>
    </tr>
</table>

<p>Если '/' - ограничитель, то
начальное 'm' можно опустить. С
помощью него в качестве
ограничителя может быть любой
символ кроме пробела. </p>

<p>PATTERN может содержать переменные,
которые будут интерполироваться
(перекомпилироваться) каждый раз в
момент вычисления. Переменные $) и $|
не интерполируются. Если вы хотите,
что бы такой шаблон
интерполировался один раз -
добавьте /o. Это необходимо делать в
циклах поиска для увеличения
быстродействия, однако, если вы
измените значение переменной, Perl
этого даже не заметит. </p>

<p>Если PATERN - нулевая строка, то
используется последнее регулярное
выражение. </p>

<p>В скалярном контексте
возвращается список элементы
которого - результаты выполнения
выражений в скобках патерна ($1, $2,
$3...). Обратите внимание что первый
элемент $1. </p>

<p><i>Пример:</i></p>

<pre>
     $a = &quot;/usr/local/perl/perl.bin&quot;; # Анализируемая строка
</pre>

<p><i>Цель:</i> Создать массив @dirs с
именами директорий. <br>
<i>Решение:</i> Самый простой способ
воспользоваться split('\/') но в
качестве примера используем
скобки. </p>

<pre>
     @dirs =~ m[/(\w*)/(\w*)/(\w*)/(\w*)]
</pre>

<p>Здесь 'm[' - использовать
квадратные скобки как
ограничители. (\w*)- шаблон
алфавитно-цифровой
последовательности. <br>
В результате @dirs равен ('usr', 'local', 'perl')
</p>

<p><b>q/строка/<br>
'строка'</b> </p>

<p>Строка литералов. Не
интерполируется. Внутри строки
разрешается использовать \' или \\
для обозначения символов ' и \ . </p>

<p><i>Пример:</i></p>

<pre>
     print q#Привет.#;     # Результат Привет.

     print 'O\'K';          # O'K
</pre>

<p><b>qq/строка/<br>
&quot;строка&quot;</b> </p>

<p>Интерполируемая строка. </p>

<p><i>Пример:</i></p>

<pre>
     $var = 13;
     print &quot;\$var = $var&quot;;
</pre>

<p>Результат: $var = 13 </p>

<p><b>qx/строка/<br>
`строка`</b> </p>

<p>Сначала строка интерполируется, а
потом выполняется как системная
команда. </p>

<p><i>Пример:</i></p>

<pre>
     print `date`;
</pre>

<p>Результат: Thu Nov 14 13:36:49 MSK 1996 </p>

<p><b>qw/строка/</b> </p>

<p>Возвращает список, элементы
которого - слова строки,
разделенные пробелами. </p>

<p><i>Пример:</i></p>

<pre>
     print qw/Построимся и спасемся!/; # ('Построимся','и','спасемся!')
</pre>

<p>Результат:</p>

<pre>
     Построимсяиспасемся!
</pre>

<p>Часто применяется как: </p>

<pre>
     use POSIX qw( setlocale localeconv )
     @EXPORT = qw( proc1 var );
</pre>

<p><b>s/шаблон/подстрока/egimosx</b> </p>

<p>Поиск по шаблону и в случае успеха
замена подстрокой. Возвращает
количество произведенных
подстановок, иначе false (0). Если
строка в которой ведется поиск не
указана (операторы =~ или != ), то
используется переменная $_ . Если в
качестве разделителя '/'
использовать одинарную кавычку ('),
то интерполяции не будет, иначе
можно применять переменные в
шаблоне или подстроке. </p>

<p>Опции: </p>

<table border="1">
    <tr>
        <td valign="top"><b>e</b></td>
        <td valign="top"><b>- Рассматривать
        правую часть как выражение.</b></td>
    </tr>
    <tr>
        <td valign="top"><b>g</b></td>
        <td valign="top"><b>- Глобальный поиск.</b></td>
    </tr>
    <tr>
        <td valign="top"><b>i</b></td>
        <td valign="top"><b>- Без различия
        регистра букв</b></td>
    </tr>
    <tr>
        <td valign="top"><b>m</b></td>
        <td valign="top"><b>- многострочная
        переменная</b></td>
    </tr>
    <tr>
        <td valign="top"><b>o</b></td>
        <td valign="top"><b>- компилировать
        шаблон один раз</b></td>
    </tr>
    <tr>
        <td valign="top"><b>s</b></td>
        <td valign="top"><b>- однострочная
        переменная</b></td>
    </tr>
    <tr>
        <td valign="top"><b>x</b></td>
        <td valign="top"><b>- расширенное
        регулярное выражение</b></td>
    </tr>
</table>

<p>Разделитель '/' можно заменить на
любой алфавитно-цифровой символ
кроме пробела. </p>

<p><i>Пример:</i></p>

<pre>
     $var = &quot;12345&quot;; # исходная строка
     $var =~ s/1/0/; # Заменить '1' на '0'. Результат 02345
     $var =~ s(5)(.); # Заменить '5' на '.' Результат 0234.
</pre>

<p>Здесь в качестве разделителя
применены скобки, поэтому
подстрока взята в две скобки. </p>

<pre>
     $var =~ s/\d*/каламбур/; Заменить все цифры. Результат 'каламбур.'

     $var =~ s/а/о/g; # Заменить все 'а' на 'о'. Результат 'коломбур.'

     $var = &quot;12 34&quot;; # Новое значение

     $var =~ s/(\d\d) (\d\d)/$2 $1/; # Поменять местами числа. Результат '34 12'.
</pre>

<p><b>tr/таблица1/таблица2/cds<br>
y/таблица1/таблица2/cds</b> </p>

<p>Замена всех символов из
&quot;таблица1&quot; на соответствующий
символ из &quot;таблица2&quot;. Результат
- количество замен или стираний. Без
оператора =~ или != операция
выполняется со строкой $_. Для
совместимости с программой sed
вместо tr можно писать 'y'. </p>

<p>Опции:</p>

<table border="1">
    <tr>
        <td valign="top"><b>c</b></td>
        <td valign="top"><b>- дополнение
        &quot;таблица1&quot;</b></td>
    </tr>
    <tr>
        <td valign="top"><b>d</b></td>
        <td valign="top"><b>- стереть найденные,
        но не замененные символы.</b></td>
    </tr>
    <tr>
        <td valign="top"><b>s</b></td>
        <td valign="top"><b>- &quot;сжать&quot;
        повторяющиеся замененные
        символы.</b></td>
    </tr>
</table>

<p>Если указана опция /d таблица2
всегда интерпретируется как
положено. Другими словами, если
таблица2 короче, чем таблица1, то
символ из таблицы1
интерпретируется всегда. Если
таблица2 - null, то все символы строки
остаются неизменными. Это удобно
для подсчета количества символов в
строке определенного класса или
для сжатия повторяющихся символов,
например, пробелов. </p>

<p><i>Пример:</i></p>

<pre>
     $s = &quot;hello&quot;;     # Исходная строка

     $s =~ tr/a-z/A-Z/;     # Заменить малые буквы на большие. Результат
                    # 'HELLO'

     $s = 'Hel....lo';
     $s =~ tr/a-zA-z/_/c;     # Заменить все не буквы на '_'
                    # Результат 'Hel____lo'
     $s =~ tr/_/ /s;          # Заменить '_' на ' ' и сжать. 
                    # Результат 'Hel lo'
     $s =~ tr/a-zA-Z /a-zA-Z/d; # Удалить все не буквы. Результат 'Hello'
</pre>

<p>Если один и тот же символ
несколько раз указан в таблице1, то
применяется только первая замена. </p>

<p><a name="op_html_18"><b></b></a><b> Операторы
ввода-вывода.</b> </p>

<p>В Perl существует несколько
операторов ввода-вывода. Первый это
скобки из символа '`' - акцента.
Строка в этих скобках
воспринимается как системная
команда и результат ее действия
возвращается как &quot;псевдо&quot;
литерал. В скалярном контексте это
строка содержащая весь результат, а
в списковом - список, элементы
которого - строки результата.
Статус выполненной команды
хранится в переменной $? . </p>

<p>Следующая команда ввода вывода
выглядит как '&lt;файл&gt;'. Вычисление
&lt;файл&gt; приводит к чтению строки
из файла. Обратите внимание, что
'файл' здесь не имя файла, а
указатель файла, который создается
функцией open(). В скалярном контексте
читается одна строка вместе с
символом '\n' - перевода строки, а в
списковом весь файл читается в
список, элементы которого суть
строки файла. В случае обнаружения
конца файла результат оператора не
определен и воспринимается как false.
Если не указана переменная
результата, то по умолчанию это $_.
Указатель файла по умолчанию STDIN -
стандартный ввод. </p>

<p><i>Пример:</i></p>

<pre>
     while(&lt;&gt;) { print; }; # Прочитать и вывести весь файл STDIN
</pre>

<p>У оператора '&lt;&gt;' есть одна
отличительная особенность. Если в
командной строке нет никаких
аргументов, то читается
стандартный ввод, если есть
аргументы, то они считаются именами
файлов, которые последовательно
читаются. </p>

<p>Если в угловых скобках записана
переменная, то содержимое этой
переменной считается именем
указателя файла или ссылкой на
указатель файла. Если такого
указателя не существует, то
содержимое переменной
воспринимается как шаблон имен
файлов и результат - имена файлов на
диске, подходящих по шаблону. </p>

<p><i>Пример:</i></p>

<pre>
     while(&lt;*.pl&gt;) { print;}; # То же что и ls *.pl

     @files = &lt;*&gt;;     # Массив @files содержит имена файлов в директории
</pre>

<p>но лучше сделать: @files = glob(&quot;*&quot;);
т.к. внутри скобок можно
использовать переменные. </p>

<p><a name="op_html_19"><b></b></a><b> Слияние констант.</b>
</p>

<p>Как и С Perl выполняет возможные
вычисления в период компиляции. Так
подстановка символов после '\' ,
операция конкатенации строк,
арифметические выражения,
содержащие только одни константы,
все это делается в момент
компиляции, что существенно
увеличивает скорость выполнения
программы. </p>

<p><a name="op_html_20"></a><b> Целочисленная
арифметика.</b> </p>

<p>По умолчанию Perl выполняет
арифметику с плавающей запятой, но
если вы укажете: </p>

<pre>
     use integer;
</pre>

<p>то компилятор будет использовать
целочисленную арифметику до конца
текущего блока, хотя вложенный блок
может это и отменить в своих
пределах с помощью: </p>

<pre>
     no integer;
</pre>


<hr>

<a name="func_html"></a>
<font color="#8000FF">Встроенные
функции.</font></h3>

<hr width="90%">

<p>Встроенные функции используются
как термы выражений и
подразделяются на две категории:
списковые операторы и унарные
операторы. Это влияет на их
приоритет по отношению к оператору
',' - запятая. Списковые операторы
могут иметь множество (список)
аргументов, а унарные только один.
Таким образом, запятая завершает
аргументы унарного оператора и
разделяет аргументы спискового.
Аргумент унарного оператора
воспринимается обычно в скалярном
контексте, а спискового как в
скалярном, так и списковом, причем
скалярные аргументы идут первыми. В
дальнейшем списковые аргументы мы
будем обозначать словом 'LIST', это
значит, что функция имеет список
аргументов, разделенных запятой.
Аргументы функций можно заключать
в круглые скобки и таким образом
обозначать, что &quot;это функция&quot; и
приоритет не имеет значения, иначе
это списковый или унарный оператор
с определенным фиксированным
приоритетом. Пробел после имени
функции и скобкой значения не
имеет. Поэтому будьте внимательны! </p>

<p><i>Пример:</i> </p>

<pre>
     print 1 + 2 + 3; # результат 6

     print(1+2)+3;    # результат 3

     print (1+2)+3;   # опять 3

     print (1+2+3);   # 6
</pre>

<p>Если функция возвращает
результат как в скалярном так и в
списковом контексте, то код выхода
по ошибке - скаляр c неопределенным
значением или пустой список. </p>

<p><i>Запомните правило:</i></p>

<p><font color="#FF0080">Не существует общего
правила преобразования списка в
скаляр! </font></p>

<p>Каждый оператор и функция имеют
свой вид значения в скалярном
контексте. Для одних это количество
элементов из скалярного контекста.
Для других - первый элемент списка
или последний или количество
успешных операций. Каждый - свое,
если вы специально не указываете.</p>

<p><a href="#func_html_1">Оператор '-X'</a>, <a href="#func_html_2">abs</a>, <a href="#func_html_3">accept</a>, <a href="#func_html_4">alarm</a>, <a href="#func_html_5">atan2
Y, X</a>, <a href="#func_html_6">bind</a>, <a href="#func_html_7">binmode</a>, <a href="#func_html_8">bless</a>, <a href="#func_html_9">caller</a>, <a href="#func_html_10">chdir</a>,
<a href="#func_html_11">chmod</a>, <a href="#func_html_11_">chomp</a>, <a href="#func_html_12">chop</a>,
<a href="#func_html_13">chown</a>, <a href="#func_html_14">chr</a>, <a href="#func_html_15">chroot</a>,
<a href="#func_html_16">close</a>, <a href="#func_html_17">closedir</a>, <a href="#func_html_18">connect</a>, <a href="#func_html_19">cos</a>, <a href="#func_html_20">crypt</a>,
<a href="#func_html_21">dbmclose</a>, <a href="#func_html_22">dbmopen</a>, <a href="#func_html_23">define</a>, <a href="#func_html_24">delete</a>, <a href="#func_html_25">die</a>,
<a href="#func_html_26">do BLOCK</a>, <a href="#func_html_27">do
подпрограмма</a>, <a href="#func_html_28">do выражение</a>,
<a href="#func_html_29">dump</a>, <a href="#func_html_30">each</a>, <a href="#func_html_31">eof</a>,
<a href="#func_html_32">eval</a>, <a href="#func_html_33">exec</a>, <a href="#func_html_34">exists</a>,
<a href="#func_html_35">exit</a>, <a href="#func_html_36">exp</a>, <a href="#func_html_37">fcntl</a>,
<a href="#func_html_38">fileno</a>, <a href="#func_html_39">flock</a>, <a href="#func_html_40">fock</a>,
<a href="#func_html_41">format</a>, <a href="#func_html_42">formline</a>, <a href="#func_html_43">getc</a>, <a href="#func_html_44">getlogin</a>, <a href="#func_html_45">getpeername</a>,
<a href="#func_html_46">getpgrp PID</a>, <a href="#func_html_47">getppid</a>, <a href="#func_html_48">getpriority</a>, <a href="#func_html_49">Группа
системных вызовов</a>, <a href="#func_html_50">getsockname</a>,
<a href="#func_html_51">getsockopt</a>, <a href="#func_html_52">glob</a>, <a href="#func_html_53">gmtime</a>, <a href="#func_html_54">goto</a>, <a href="#func_html_55">grep</a>,
<a href="#func_html_56">hex</a>, <a href="#func_html_57">import</a>, <a href="#func_html_58">index</a>,
<a href="#func_html_59">int</a>, <a href="#func_html_60">ioctl</a>, <a href="#func_html_61">join</a>,
<a href="#func_html_62">keys</a>, <a href="#func_html_63">kill</a>, <a href="#func_html_64">last</a>,
<a href="#func_html_65">lc</a>, <a href="#func_html_66">lcfirst</a>, <a href="#func_html_67">length</a>,
<a href="#func_html_68">link</a>, <a href="#func_html_69">listen</a>, <a href="#func_html_70">local</a>,
<a href="#func_html_71">localtime</a>, <a href="#func_html_72">log</a>, <a href="#func_html_73">lstat</a>,
<a href="#func_html_74">m//</a>, <a href="#func_html_75">map</a>, <a href="#func_html_76">mkdir</a>,
<a href="#func_html_77">msgctl</a>, <a href="#func_html_78">msgget</a>, <a href="#func_html_79">msgsnd</a>,
<a href="#func_html_80">msgrcv</a>, <a href="#func_html_81">my</a>, <a href="#func_html_82">next</a>,
<a href="#func_html_83">no Module</a>, <a href="#func_html_84">oct</a>, <a href="#func_html_85">open</a>,
<a href="#func_html_86">opendir</a>, <a href="#func_html_87">ord</a>, <a href="#func_html_88">pack</a>,
<a href="#func_html_89">pipe</a>, <a href="#func_html_90">pop</a>, <a href="#func_html_91">pos</a>,
<a href="#func_html_92">print</a>, <a href="#func_html_93">printf</a>, <a href="#func_html_94">push</a>,
<a href="#func_html_95">q/строка/, qq/строка/,
qx/строка/, qw/строка/</a>, <a href="#func_html_96">quotemeta</a>,
<a href="#func_html_97">rand</a>, <a href="#func_html_98">read</a>, <a href="#func_html_99">readdir</a>,
<a href="#func_html_100">readlink</a>, <a href="#func_html_101">recv</a>, <a href="#func_html_102">redo</a>, <a href="#func_html_103">ref</a>, <a href="#func_html_104">rename</a>,
<a href="#func_html_105">require</a>, <a href="#func_html_106">reset</a>, <a href="#func_html_107">return</a>, <a href="#func_html_108">reverse</a>, <a href="#func_html_109">rewindir</a>, <a href="#func_html_110">rindex</a>, <a href="#func_html_111">rmdir</a>, <a href="#func_html_112">s///</a>, <a href="#func_html_113">scalar</a>,
<a href="#func_html_114">seek</a>, <a href="#func_html_114">seekdir</a>, <a href="#func_html_116">select</a>, <a href="#func_html_117">select RBITS, WBITS,
EBITS, TIMEOUT</a>, <a href="#func_html_118">semctl</a>, <a href="#func_html_119">semget</a>,
<a href="#func_html_120">semop</a>, <a href="#func_html_121">send</a>, <a href="#func_html_122">setpgrp</a>,
<a href="#func_html_123">setpriority</a>, <a href="#func_html_124">setsockopt</a>, <a href="#func_html_125">shift</a>, <a href="#func_html_126">shmget</a>, <a href="#func_html_127">shmget</a>,
<a href="#func_html_128">shmread</a>, <a href="#func_html_129">shutdown</a>, <a href="#func_html_130">sin</a>, <a href="#func_html_131">sleep</a>, <a href="#func_html_132">soket</a>,
<a href="#func_html_133">soketpair</a>, <a href="#func_html_134">sort</a>, <a href="#func_html_135">splice</a>, <a href="#func_html_136">split</a>, <a href="#func_html_137">sprintf</a>,
<a href="#func_html_138">sqrt</a>, <a href="#func_html_139">srand</a>, <a href="#func_html_140">stat</a>,
<a href="#func_html_141">study</a>, <a href="#func_html_142">substr</a>, <a href="#func_html_143">symlink</a>, <a href="#func_html_144">syscall</a>, <a href="#func_html_145">sysread</a>, <a href="#func_html_146">system</a>, <a href="#func_html_147">syswrite</a>, <a href="#func_html_148">tell</a>, <a href="#func_html_149">telldir</a>,
<a href="#func_html_150">tie</a>, <a href="#func_html_151">time</a>, <a href="#func_html_152">times</a>,
<a href="#func_html_153">tr///</a>, <a href="#func_html_154">truncate</a>, <a href="#func_html_155">uc</a>, <a href="#func_html_156">ucfirst</a>, <a href="#func_html_157">umask</a>,
<a href="#func_html_158">undef</a>, <a href="#func_html_159">unlink</a>, <a href="#func_html_160">unpack</a>, <a href="#func_html_161">untie</a>, <a href="#func_html_162">unshift</a>,
<a href="#func_html_163">use</a>, <a href="#func_html_164">utime</a>, <a href="#func_html_165">values</a>,
<a href="#func_html_166">vec</a>, <a href="#func_html_167">wait</a>, <a href="#func_html_168">waitpid</a>,
<a href="#func_html_169">wantarray</a>, <a href="#func_html_170">warn</a>, <a href="#func_html_171">write</a>, <a href="#func_html_172">y///</a> </p>

<hr width="90%">

<p><a name="func_html_1"><b></b></a><b> Оператор '-X'.</b> </p>

<pre>
    -X указатель файла
    -X выражение
    -X
</pre>

<p>Проверка файла, где 'X' - одно из
ниже описанных значений. Это
унарный оператор с одним
аргументом - либо именем файла, либо
указателем файла. Проверяет одно из
условий. Если аргумент не указан, то
берется значение переменной $_. Для
ключа -t - STDIN. Результат 1, если true, '',
если false или неопределенное
значение, если файл не найден.
Несмотря на странный вид это
унарный оператор с соответствующим
приоритетом. Аргумент можно
заключать в круглые скобки. 'X' имеет
следующие значения: </p>

<table border="1">
    <tr>
        <td valign="top"><b>-r</b></td>
        <td valign="top">Файл разрешен на
        чтение эффективным uid/gid</td>
    </tr>
    <tr>
        <td valign="top"><b>-w</b></td>
        <td valign="top">на запись -//-</td>
    </tr>
    <tr>
        <td valign="top"><b>-x</b></td>
        <td valign="top">исполнение -//-</td>
    </tr>
    <tr>
        <td valign="top"><b>-o</b></td>
        <td valign="top">принадлежит
        эффективному uid (идентификатор
        пользователя) </td>
    </tr>
    <tr>
        <td valign="top"><b>-R</b></td>
        <td valign="top">Файл разрешен на
        чтение реальным uid/gid</td>
    </tr>
    <tr>
        <td valign="top"><b>-W</b></td>
        <td valign="top">на запись -//-</td>
    </tr>
    <tr>
        <td valign="top"><b>-X</b></td>
        <td valign="top">исполнение -//-</td>
    </tr>
    <tr>
        <td valign="top"><b>-O</b></td>
        <td valign="top">принадлежит
        реальному uid</td>
    </tr>
    <tr>
        <td valign="top"><b>-e</b></td>
        <td valign="top">файл существует</td>
    </tr>
    <tr>
        <td valign="top"><b>-z</b></td>
        <td valign="top">пустой</td>
    </tr>
    <tr>
        <td valign="top"><b>-s</b></td>
        <td valign="top">не пустой</td>
    </tr>
    <tr>
        <td valign="top"><b>-f</b></td>
        <td valign="top">обычный текст</td>
    </tr>
    <tr>
        <td valign="top"><b>-d</b></td>
        <td valign="top">директория</td>
    </tr>
    <tr>
        <td valign="top"><b>-l</b></td>
        <td valign="top">символическая ссылка</td>
    </tr>
    <tr>
        <td valign="top"><b>-p</b></td>
        <td valign="top">pipes (конвейер) </td>
    </tr>
    <tr>
        <td valign="top"><b>-S</b></td>
        <td valign="top">socket (гнездо) </td>
    </tr>
    <tr>
        <td valign="top"><b>-b</b></td>
        <td valign="top">специальное блочное
        устройство</td>
    </tr>
    <tr>
        <td valign="top"><b>-c</b></td>
        <td valign="top">-//- символьное -//-</td>
    </tr>
    <tr>
        <td valign="top"><b>-t</b></td>
        <td valign="top">указатель на уст-во tty</td>
    </tr>
    <tr>
        <td valign="top"><b>-u</b></td>
        <td valign="top">установлен бит setuid</td>
    </tr>
    <tr>
        <td valign="top"><b>-g</b></td>
        <td valign="top">-//- setgid</td>
    </tr>
    <tr>
        <td valign="top"><b>-k</b></td>
        <td valign="top">-//- sticky</td>
    </tr>
    <tr>
        <td valign="top"><b>-T</b></td>
        <td valign="top">текстовой файл</td>
    </tr>
    <tr>
        <td valign="top"><b>-B</b></td>
        <td valign="top">двоичный</td>
    </tr>
    <tr>
        <td valign="top"><b>-M</b></td>
        <td valign="top">&quot;возраст&quot; файла в
        днях на момент старта скрипта</td>
    </tr>
    <tr>
        <td valign="top"><b>-A</b></td>
        <td valign="top">дней с последнего
        чтения</td>
    </tr>
    <tr>
        <td valign="top"><b>-C</b></td>
        <td valign="top">дней с последней
        модификации inode</td>
    </tr>
</table>

<p><a name="func_html_2"><b></b></a><b>abs выражение</b> </p>

<p>Абсолютное значение выражения </p>

<p><a name="func_html_3"><b></b></a><b>accept NEWSOCKET, GENERICSOCKET</b> </p>

<p>Открыть новый сокет по внешнему
запросу. Аналогично системному
вызову accept(). Возвращает адрес или
false в случае неудачи. </p>

<p><a name="func_html_4"><b></b></a><b>alarm секунды</b> </p>

<p>Послать сигнал SIGALARM текущему
процессу по истечении указанного
промежутка времени. Не допустимо
делать несколько вызовов
одновременно в одном промежутке
времени. Возвращает остаток
времени предыдущего счетчика. </p>

<p><a name="func_html_5"><b></b></a><b>atan2 Y, X</b> </p>

<p>Арктангенс отношения Y к X в
пределах от -pi до +pi. </p>

<p><a name="func_html_6"><b></b></a><b>bind сокет, имя</b> </p>

<p>Назначить сетевой адрес сокету.
Подобно системному вызову bind.
Возвращает true в случае успеха и false
иначе. Имя - пакетный адрес сокета. </p>

<p><a name="func_html_7"><b></b></a><b>binmode файл</b> </p>

<p>Открыть файл для двоичного (binary)
режима доступа. В обычном режиме
при вводе символы CR LF транслируются
в LF, а при выводе LF транслируется в CR
LF. </p>

<p><a name="func_html_8"><b></b></a><b>bless ссылка, класс<br>
bless ссылка</b> </p>

<p>Данная функция определяет что
объект указанный ссылкой
принадлежит классу. Если класс не
указан то он относится к текущему
классу. Обычно это последний
оператор в конструкторе объекта.
Необходимо обязательно указывать
имя класса если определяемый
объект может наследоваться
классом-потомком. </p>

<p><a name="func_html_9"><b></b></a><b>caller выражение<br>
caller</b> </p>

<p>Возвращает контекст вызова
текущей подпрограммы. В скалярном
контексте true если это подпрограмма
или процедура вызванная
операторами <a href="#func_html_32">eval()</a> или <a href="#func_html_105">require()</a> и false - иначе. В
списковом это список ($package, $filename,
$line), где </p>

<ul>
    <li>$package - имя пакета </li>
    <li>$filename - имя файла пакета </li>
    <li>$line - номер строки откуда был
        сделан вызов. </li>
</ul>

<p>Если указано выражение то
возвращается список: </p>

<pre>
     ($package, $filename, $line, $subroutine, $hasargs, $wantargs)
</pre>

<p>Выражение определяет
&quot;глубину&quot; вложенности
просмотра стека вызовов. </p>

<ul>
    <li>$subroutine - имя подпрограммы </li>
    <li>$hasargs - имеющиеся аргументы </li>
    <li>$wantargs - необходимые аргументы </li>
</ul>

<p>Применение данной функции в DB
пакете возвращает более детальную
информацию. К списку аргументов
добавляется список @DB::args. </p>

<p><a name="func_html_10"><b></b></a><b>chdir выражение</b> </p>

<p>Перейти в директорию указанную
выражением. Если выражение
отсутствует то перейти в
&quot;домашнюю&quot; директорию.
Возвращает true в случае успеха и false -
неудачи. </p>

<p><a name="func_html_11"><b></b></a><b>chmod список</b> </p>

<p>Изменить права доступа к файлам
указанным в списке. Первый элемент
в списке - числовое ,обычно
восьмеричное значение прав.
Возвращает количество файлов
которым были изменены права. </p>

<p><i>Пример:</i> </p>

<pre>
     chmod 0666 'f1', 'f2', 'f3';
</pre>

<p><a name="func_html_11_"><b></b></a><b>chomp переменная<br>
chomp список<br>
chomp</b> </p>

<p>Удаляет в конце строки символ
указанный переменной $/. Обычно это
'LF'. Возвращает количество
удаленных символов. Если
переменная не указана то
используется переменная $_. Если
указан список то обрабатывается
каждая строка списка и
возвращается общее количество
удаленных символов. </p>

<p><a name="func_html_12"><b></b></a><b>chop переменная<br>
chop список<br>
chop</b> </p>

<p>Полностью аналогично функции chomp
но всегда удаляет последний символ
строки. </p>

<p><a name="func_html_13"><b></b></a><b>chown список</b> </p>

<p>Изменить &quot;владельца&quot; и
&quot;группу&quot; файлов списка. Первый
элемент - номер нового владельца,
второй номер новой группы а далее
список файлов. В большинстве
Unix-систем вы не сможете сменить
владельца если вы не
суперпользователь, но можете
изменить группу если это одна из
ваших &quot;вторичных&quot; групп. </p>

<p><a name="func_html_14"><b></b></a><b>chr число</b> </p>

<p>Возвращает символ с указанным
кодом кодировки. </p>

<p><a name="func_html_15"><b></b></a><b>chroot директория</b> </p>

<p>Сделать &quot;корневой&quot; указанную
директорию. &quot;Корневая&quot; - значит
внутри программы на нее можно
ссылаться как '/'. </p>

<p><a name="func_html_16"><b></b></a><b>close файл</b> </p>

<p>Закрыть открытый файл или поток.
Можно не использовать, если один и
тот же файл открывается повторно,
т.к. он будет автоматически
закрываться новым вызовом <a href="#func_html_85">open()</a>.
</p>

<p><a name="func_html_17"><b></b></a><b>closedir директория</b> </p>

<p>Закрыть директорию, открытую
функцией <a href="#func_html_86">opendir()</a>. </p>

<p><a name="func_html_18"><b></b></a><b>connect сокет, имя</b> </p>

<p>Связаться с удаленным сокетом.
Данная функция подобна системному
вызову connect(). Возвращает true в случае
успеха и false при ошибке. </p>

<p><a name="func_html_19"><b></b></a><b>cos выражение</b> </p>

<p>Косинус выражения в радианах. </p>

<p><a name="func_html_20"><b></b></a><b>crypt текст, salt</b> </p>

<p>Шифрация текста. Аналогично
системному crypt(). </p>

<p><a name="func_html_21"><b></b></a><b>dbmclose хеш</b> </p>

<p>Закрывает связь между хеш и базой
данных. </p>

<p><a name="func_html_22"><b></b></a><b>dbmopen хеш, база,
режим</b> </p>

<p>Ассоциировать указанный хеш и
базу в определенном режиме. Дело в
том, что в Perl реализован очень
удобный механизм работы с базами
данных типа dbm, ndbm, sbdm, gdbm и Berkeley DB.
Для этого нужно связать (открыть)
базу под именем хеша. Вся работа с
записями базы выполняется так,
будто это обычный хеш
(ассоциативный массив). Более
подробно смотрите описание функции
AnyDBM(). </p>

<p><a name="func_html_23"><b></b></a><b>define выражение</b> </p>

<p>Возвращает true, если значение
определено (существует) и false, если
нет. Многие операции завершаются
неопределенным значением, например
чтение после конца файла,
использование неопределенных
переменных, системные ошибки и т.д.
Данная функция позволяет различать
нулевое и неопределенные значения,
определенность или
неопределенность функций или
ссылок. При использовании
определенности ключа в хеше она
возвращает определен данный ключ
или нет, но не существует он или нет.
</p>

<p><a name="func_html_24"><b></b></a><b>delete выражение</b> </p>

<p>Удалить значение из хеша.
Возвращает удаляемое значение или
неопределенность, если ничего не
удаляется. Удаление из массива
окружения $ENV{} - изменяет окружение.
Удаление из хеша связанного с базой
данных - удаляет запись в базе
данных. </p>

<p><a name="func_html_25"><b></b></a><b>die список</b> </p>

<p>Если программа не была запущена
из <a href="#func_html_32">eval()</a>, данная функция
выводит список в поток STDERR и
завершает работу программы с кодом
из переменной $!. Если $! содержит 0,
то с кодом ($? &gt;&gt; 8). Если и это 0, то с
кодом 255. При вызове из <a href="#func_html_32">eval()</a>
сообщение об ошибке заносится в
переменную $@, и <a href="#func_html_32">eval()</a>
завершается с неопределенным
значением. Это позволяет
отрабатывать ошибочные ситуации,
не завершая головной модуль. Если
строка из списка не завершается
символом '\n', то дополнительно
печатается номер строки скрипта,
откуда вызвана функция и номер
входной строки, если таковой
имеется. </p>

<p><a name="func_html_26"><b></b></a><b>do BLOCK</b> </p>

<p>Это не совсем функция. Здесь
возвращается значение последнего
оператора блока. Когда
используется циклический
модификатор BLOCK исполняется перед
проверкой условия цикла в отличии
от обычных циклов. </p>

<p><a name="func_html_27"><b></b></a><b>do подпрограмма</b> </p>

<p>Устаревший метод вызова
подпрограмм. </p>

<p><a name="func_html_28"><b></b></a><b>do выражение</b> </p>

<p>Значение выражения
воспринимается как имя файла Perl
скрипта. Изначально это
применялось для включения
подпрограмм библиотеки. Сейчас
правильней использовать вызовы <a href="#func_html_163">use()</a> и <a href="#func_html_105">require()</a>,
которые обеспечивают контроль
ошибок и завершения. </p>

<p><a name="func_html_29"><b></b></a><b>dump метка</b> </p>

<p>Выполнение &quot;дампа&quot; текущей
памяти. Применялось для
возможности использовать
программу undump, чтобы включить
текущий исполняемый код в
программу после инициализации всех
переменных. Выполнение этой новой
программы будет начинаться
оператором goto метка. Если метка
опущена, то запуск сначала. </p>

<p><font color="#FF0080">Внимание! Файлы,
открытые до момента дампа, не будут
открытыми в момент исполнения
новой программой. </font></p>

<p><a name="func_html_30"><b></b></a><b>each хеш</b> </p>

<p>Возвращает 2-элементный массив.
Первый элемент - ключ второй -
значение следующего элемента хеша.
Позволяет &quot;просматривать&quot; все
значения хеша в определенном
порядке. Сброс переменной цикла
происходит только после
прохождения всего массива. </p>

<p><a name="func_html_31"><b></b></a><b>eof файл<br>
eof()<br>
eof</b> </p>

<p>Возвращает 1, если выполняется
чтение после конца или чтение из не
открытого файла. Аргументом должно
быть выражение, возвращающее
существующий указатель файла.
Данную функцию нельзя использовать
для чтения файлов, открытых как
терминалы. Если аргумент не указан,
то используется последний читаемый
файл. Использование в форме eof()
целесообразно применять в циклах
while(&lt;&gt;) для определения конца
только последнего файла из списка.
Применяйте eof(ARGV) или eof для
определения конца каждого файла из
списка. </p>

<p><a name="func_html_32"><b></b></a><b>eval выражение<br>
eval блок</b> </p>

<p>Выражение сканируется и
выполняется как обычная Perl
программа. Это делается в контексте
текущей программы, поэтому можно
использовать уже определенные
переменные и подпрограммы.
Возвращается результат последнего
оператора в блоке или значение
оператора return. Если обнаружится
синтаксическая ошибка или
выполнится оператор die, то
возвращается неопределенное
значение, а переменная $@ содержит
сообщение об ошибке. Если ошибки не
было, то $@ содержит нулевую строку.
При отсутствии аргумента берется
значение переменной $_. </p>

<p><a name="func_html_33"><b></b></a><b>exec список</b> </p>

<p>Выполняется системная команда из
списка, и выполнение программы
завершается. Если вам необходимо
вернуться, то лучше применяйте
функцию <a href="#func_html_146">system()</a>. Если в
списке количество аргументов
больше 1 или список - это массив с
количеством элементов больше 1, то
выполняется системный вызов execvp() с
аргументами из списка. Если один
скалярный аргумент, то он
сканируется на обработку
метасимволов, и если они
присутствуют, то полученные
аргументы передаются
интерпретатору /bin/sh -c для
дальнейшей обработки. Если
метасимволов нет, то аргумент
расщепляется на слова и передается
системному вызову execvp(), что более
эффективно. </p>

<p><font color="#FF0080">Внимание! exec() и system(0)
не сбрасывают буфер ввода/вывода,
поэтому необходимо установить
переменную $| для предотвращения
потери выходной информации. </font></p>

<p><a name="func_html_34"><b></b></a><b>exists выражение</b> </p>

<p>Возвращает true, если существует
указанный ключ хеша, даже если не
определено его значение. </p>

<p><a name="func_html_35"><b></b></a><b>exit выражение</b> </p>

<p>Выполнение программы завершается
с кодом выражения. </p>

<p><a name="func_html_36"><b></b></a><b>exp выражение</b> </p>

<p>Возвращает e (основание
натурального логарифма) в степени
выражения. </p>

<p><a name="func_html_37"><b></b></a><b>fcntl файл, функция,
скаляр</b> </p>

<p>Выполняет системный вызов fcntl().
Для использования обязательно
выполнить use Fcntl; </p>

<p><a name="func_html_38"><b></b></a><b>fileno файл</b> </p>

<p>Возвращает описатель файла для
данного указателя файла. </p>

<p><a name="func_html_39"><b></b></a><b>flock файл, операция</b>
</p>

<p>Системный вызов flock() </p>

<p><a name="func_html_40"><b></b></a><b>fock</b> </p>

<p>Системный вызов fock(). Возвращает pid
потомка для родителя и 0 - для
потомка в случае успеха, иначе -
неопределенное значение. </p>

<p><a name="func_html_41"><b></b></a><b>format</b> </p>

<p>Декларативная функция Perl.
Определяет формат вывода для
оператора write. Подробно смотрите
главу <a href="#form_html">Форматы</a>. </p>

<p><a name="func_html_42"><b></b></a><b>formline формат, список</b>
</p>

<p>Внутренняя функция, используемая
в format. Форматирует вывод параметров
из списка. Результат помещается в
переменную $^A Функция write просто
выводит значение этой переменной,
но ее так же можно читать, а затем
обнулять. Обычно format выполняет один
вызов formline для одной строки формы,
но formline не разделяет строки
формата. Это значит что символы '~' и
'~~' рассматривают весь формат как
одну строку, поэтому необходимо
использовать многострочные формы
для описания одной записи формата. </p>

<p><a name="func_html_43"><b></b></a><b>getc файл<br>
getc</b> </p>

<p>Читает и возвращает символ из
указанного файла. Если файл не
указан, то читается STDIN. После конца
файла возвращает пустую строку. </p>

<p><a name="func_html_44"><b></b></a><b>getlogin</b> </p>

<p>Возвращает текущий login из файла
/etc/utmp Не применяйте для
идентификации пользователя, он не
так сильно &quot;закрыт&quot; как <a href="#func_html_49">getpwuid()</a>.
</p>

<p><a name="func_html_45"><b></b></a><b>getpeername сокет</b> </p>

<p>Возвращает упакованный адрес
удаленного сокета. </p>

<p><a name="func_html_46"><b></b></a><b>getpgrp PID</b> </p>

<p>Возвращает группу процесса с
указанным PID. Если аргумент
отсутствует, возвращает группу
текущего процесса. </p>

<p><a name="func_html_47"><b></b></a><b>getppid</b> </p>

<p>Возвращает PID родительского
процесса. </p>

<p><a name="func_html_48"><b></b></a><b>getpriority WHICH, WHO</b> </p>

<p>Возвращает текущий приоритет
процесса, группы процессов или
пользователя. </p>

<p><a name="func_html_49"><b></b></a><b> Группа системных
вызовов:</b> </p>

<ul>
    <li>getpwnam NAME </li>
    <li>getgrnam NAME </li>
    <li>gethostbyname NAME </li>
    <li>getnamebyname NAME </li>
    <li>getprotobyname NAME </li>
    <li>getpwuid UID </li>
    <li>getgrid GID </li>
    <li>getservbyname NAME, PROTO </li>
    <li>gethostbyaddr ADDR, ADDRTYPE </li>
    <li>getnetbyaddr ADDR, ADDRTYPE </li>
    <li>getprotobynumber NUMBER </li>
    <li>getservbyport PORT, PROTO </li>
    <li>getpwent </li>
    <li>gethostent </li>
    <li>getnetent </li>
    <li>getprotoent </li>
    <li>getservent </li>
    <li>setpwent </li>
    <li>setgrent </li>
    <li>sethostent STAYOPEN </li>
    <li>setnetent STAYOPEN </li>
    <li>setprotoent STAYOPEN </li>
    <li>setservent STAYOPEN </li>
    <li>endpwent </li>
    <li>endgrent </li>
    <li>endhostent </li>
    <li>endnetent </li>
    <li>endprotoent </li>
    <li>endservent </li>
</ul>

<p>Все эти функции аналогичны
одноименным системным вызовам. В
списковом контексте возвращают
следующие списки: </p>

<pre>
($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell) = getpw*

($name, $passwd, $gid, $members) = getgr*

($name, $aliases, $addrtype, $length, @addrs) = gethost*

($name, $aliases, $addrtype, $net) = getnet*

($name, $aliases, $proto) = getproto*

($name, $aliases, $port, $proto) = getserv*
</pre>

<p>В скалярном контексте
возвращается имя или что-то другое,
в зависимости от типа функции.
Элемент $members в вызове getgr содержит
разделенные пробелом имена членов
группы. @addrs содержит IP адреса
компьютеров в сети Интернет в
упакованном виде. Для распаковки
применяйте:<br>
($a, $b, $c, $d) = unpack('C4',$addr[0]); </p>

<p><a name="func_html_50"><b></b></a><b>getsockname сокет</b> </p>

<p>Возвращает упакованный адрес
сокета локальной машины. </p>

<p><a name="func_html_51"><b></b></a><b>getsockopt сокет,
уровень, опция</b> </p>

<p>Возвращает опцию сокета. </p>

<p><a name="func_html_52"><b></b></a><b>glob выражение</b> </p>

<p>Возвращает список файлов,
удовлетворяющих выражению с '*', как
в команде ls. </p>

<p><a name="func_html_53"><b></b></a><b> gmtime выражение</b> </p>

<p>Переводит местное время,
полученное функцией <a href="#func_html_151">time()</a>,
во время по Гринвичу. Обычно
используется в виде: </p>

<pre>
     ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=gmtime(time);
</pre>

<p><a name="func_html_54"><b></b></a><b>goto метка<br>
goto выражение<br>
goto &amp;подпрограмма</b> </p>

<p>Безусловный переход на метку.
Нельзя делать переход на метку в
структуру, которая должна быть
инициирована, например,
подпрограмму или цикл foreach и т.д.
Вторая форма применяется для
динамического определения
перехода. </p>

<p><i>Например:</i> </p>

<pre>
     goto ('метка1', 'метка2', 'метка3')[$i];
</pre>

<p>Здесь при $i = 0 будет переход на
'метка1', $i = 1 на 'метка2' и т.д. Третья
форма (goto &amp;подпрограмма) довольно
&quot;хитрый&quot; метод подмены имени
вызываемой подпрограммы именем
текущей. Это используется в методе
автозагрузки, когда нужно
запустить другую процедуру, но под
именем текущей, как будто та была
вызвана раньше. </p>

<p><a name="func_html_55"><b></b></a><b>grep блок, список<br>
grep выражение, список</b> </p>

<p>Выполнят блок или выражение для
каждого элемента списка.
Переменная $_ содержит текущий
элемент. Возвращает список
элементов, с которыми выражение
дало результат true. В скалярном
контексте возвращает количество
результатов true. </p>

<p><a name="func_html_56"><b></b></a><b>hex выражение</b> </p>

<p>Воспринимает выражение как
строку шестнадцатеричных цифр и
возвращает десятичное значение. </p>

<p><a name="func_html_57"><b></b></a><b>import</b> </p>

<p>В Perl нет встроенной функции import,
но есть метод, с помощью которого
модули могут экспортировать
область имен другим модулям.
Подробно смотрите функцию <a href="#func_html_163">use()</a>.
</p>

<p><a name="func_html_58"><b></b></a><b>index строка,
подстрока, позиция<br>
index строка, подстрока</b> </p>

<p>Возвращает позицию первого
вхождения подстроки в строке,
начиная с указанной позиции. Если
позиция отсутствует, то сравнение
начинается с начала строки. Отсчет
позиции ведется с 0, если только не
изменено значение встроенной
переменной $[. Если подстрока не
найдена, то результат меньше первой
позиции на 1. Обычно это -1. </p>

<p><a name="func_html_59"><b></b></a><b>int выражение</b> </p>

<p>Возвращает целую часть выражения.
</p>

<p><a name="func_html_60"><b></b></a><b>ioctl FILEHANDLE, FUNCTION, SCALAR</b>
</p>

<p>Выполняет системный вызов ioctl(). В
начале программы необходимо
указать: require &quot;ioctl.ph&quot;; </p>

<p><a name="func_html_61"><b></b></a><b>join выражение,
список</b> </p>

<p>Соединяет строки списка или
массива в одну строку с кодом
разделителя, равному выражению. </p>

<p><a name="func_html_62"><b></b></a><b>keys хеш</b> </p>

<p>Возвращает массив всех ключей
хеша. В скалярном контексте -
количество ключей. Порядок
следования ключей аналогичен
порядку в each функции. </p>

<p><a name="func_html_63"><b></b></a><b>kill список</b> </p>

<p>Послать сигнал (первый элемент)
указанным в списке процессам.
Возвращает количество процессов
которые сигнал приняли. </p>

<p><a name="func_html_64"><b></b></a><b>last метка<br>
last</b> </p>

<p>Функция аналогичная break в С.
Прерывает цикл и переходит на
указанную метку. Если метки нет на
ближайший внешний цикл. Блок continue
не выполняется. </p>

<p><a name="func_html_65"><b></b></a><b>lc выражение</b> </p>

<p>Преобразовать строку в буквы
нижнего регистра. </p>

<p><a name="func_html_66"><b></b></a><b>lcfirst выражение</b> </p>

<p>Заменить первую букву строки на
малую. </p>

<p><a name="func_html_67"><b></b></a><b>length выражение</b> </p>

<p>Возвращает длину строки
выражения. </p>

<p><a name="func_html_68"><b></b></a><b>link OLDFILE, NEWFILE</b> </p>

<p>Создать файл NEWFILE связанный с
файлом OLDFILE. </p>

<p><a name="func_html_69"><b></b></a><b>listen SOCKET, QUEUESIZE</b> </p>

<p>Выполнить системный listen(). </p>

<p><a name="func_html_70"><b></b></a><b>local список</b> </p>

<p>Объявляет перечисленные
переменные как локальные в текущем
блоке или подпрограмме. Если
указано два и более имени, их
необходимо заключить в круглые
скобки. Предпочтительней
использовать функцию <a href="#func_html_81">my()</a>. </p>

<p><a name="func_html_71"><b></b></a><b>localtime выражение</b> </p>

<p>Преобразовать 9-элементный
массив, возвращаемый функцией time,
относительно местного времени.
Употребляется как: </p>

<pre>
     ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
</pre>

<p><a name="func_html_72"><b></b></a><b>log выражение</b> </p>

<p>Возвращает натуральный логарифм
выражения. </p>

<p><a name="func_html_73"><b></b></a><b>lstat файл<br>
lstat выражение</b> </p>

<p>То же что и системный вызов <a href="#func_html_140">stat()</a>, но касательно ссылки
на файл, а не самого файла. </p>

<p><a name="func_html_74"><b></b></a><b>m//</b> </p>

<p>Оператор совпадения. Смотри главу
<a href="#op_html">Операторы</a> </p>

<p><a name="func_html_75"><b></b></a><b>map блок, список<br>
map выражение, список</b> </p>

<p>Выполняет блок или выражение для
каждого элемента списка.
Возвращает список результатов. </p>

<p><a name="func_html_76"><b></b></a><b>mkdir директория,
права</b> </p>

<p>Создать директорию с указанными
правами доступа. Возвращает 1 при
успехе, и 0 при неудаче. </p>

<p><a name="func_html_77"><b></b></a><b>msgctl ID, CMD, ARG</b> </p>

<p>Системный вызов msgctl() System V </p>

<p><a name="func_html_78"><b></b></a><b>msgget KEY, FLAGS</b> </p>

<p>Системный вызов msgget() System V </p>

<p><a name="func_html_79"><b></b></a><b>msgsnd ID, MSG, FLAGS</b> </p>

<p>Системный вызов msgsnd() System V </p>

<p><a name="func_html_80"><b></b></a><b>msgrcv ID, VAR, SIZE, TYPE, FLAGS</b>
</p>

<p>Системный вызов msgrcv() System V </p>

<p><a name="func_html_81"><b></b></a><b>my список</b> </p>

<p>Объявляет локальными переменные
в списке. Если два или более имени,
их необходимо заключить в круглые
скобки. </p>

<p><a name="func_html_82"><b></b></a><b>next метка<br>
next</b> </p>

<p>Аналогичен continue в С. Переход к
следующей итерации в цикле. Если в
цикле присутствует блок continue, он
так же выполняется. Если метка
отсутствует - переход на ближайший
внутренний цикл. </p>

<p><a name="func_html_83"><b></b></a><b>no Module список.</b> </p>

<p>Исключить использование
указанных модулей. </p>

<p><a name="func_html_84"><b></b></a><b>oct выражение</b> </p>

<p>Возвращает десятичное число,
представленное восьмеричными
цифрами. </p>

<p><a name="func_html_85"><b></b></a><b>open файл, выражение<br>
open файл</b> </p>

<p>Открыть файл с указанным именем.
Аргумент &quot;файл&quot; - это
фактически указатель на блок
описания файла. Если имя (выражение)
файла отсутствует, то имя считается
таким же как и указатель файла. Если
перед именем стоит символ '&lt;' то
файл открывается только на чтение
(значение по умолчанию). Если '&gt;' -
на запись. Если '&gt;&gt;' - на
добавление записей. '+&gt;' или '+&lt;' -
файл открыт на чтение и запись
одновременно. Если имя файла
начинается с символа '|', то имя
считается системной командой, на
вход которой выводятся данные
(поток). Имя '-' - стандартный вход
(STDIN), '&gt;-' - стандартный вывод (STDOUT).
Функция возвращает true при успехе и
false - неудаче. </p>

<p>Если имя (выражение) начинается с
символов &quot;&gt;&amp;&quot;, то остаток
имени считается именем указателя
файла, который открывается
повторно. Символ '&amp;' может стоять
после '&lt;', '&gt;&gt;', '+&gt;', '+&gt;&gt;' и '+&lt;'.
Режим повторного открытия должен
соответствовать первому. Выражение
вида &quot;&lt;&amp;=N&quot; где N -число,
эквивалентно системному вызову
fdopen(). Если имя &quot;|-&quot; или &quot;-|&quot;,
то происходит &quot;расщепление&quot;
(fork) процесса на потомка и родителя.
При этом возвращается номер
процесса потомка (PID) внутри
родительского процесса и 0 - внутри
потомка. При этом запись/чтение в
файл родительским процессом
воспринимается как чтение/запись
потомком. Для потомка это
стандартный ввод/вывод.
Родительский процесс ждет
завершения потомка после закрытия
потока и получает код завершения в
переменной $?. Имя файла не должно
содержать пробелов как в начале,
так и в конце. </p>

<p><a name="func_html_86"><b></b></a><b>opendir указатель,
выражение</b> </p>

<p>Открыть директорию с именем
выражения для обработки функциями <a href="#func_html_99">readdir()</a>, <a href="#func_html_149">telldir()</a>, <a href="#func_html_114">seekdir()</a>, <a href="#func_html_109">rewinddir()</a> и <a href="#func_html_17">closedir()</a>. Возвращает true при
успехе. </p>

<p><a name="func_html_87"><b></b></a><b>ord выражение</b> </p>

<p>Возвращает ascii код первого
символа выражения. </p>

<p><a name="func_html_88"><b></b></a><b>pack шаблон, список</b>
</p>

<p>Упаковывает список в двоичную
структуру по шаблону. Шаблон - это
строка символов, описывающая
порядок и тип упакованных значений.
</p>

<ul>
    <li><b>A</b> - текстовая строка,
        добавляется пробелами. </li>
    <li><b>a</b> - текстовая строка,
        добавляется 0 символом. </li>
    <li><b>b</b> - битовая строка
        (возрастающая нумерация бит) </li>
    <li><b>B</b> - битовая строка
        (убывающая нумерация бит) </li>
    <li><b>h</b> - шестнадцатеричная
        строка ( младший байт - первый) </li>
    <li><b>H</b> - шестнадцатеричная
        строка (старший байт первый) </li>
    <li><b>c</b> - символ со знаком </li>
    <li><b>C</b> - символ без знака. </li>
    <li><b>s</b> - короткое целое (один
        байт) со знаком. </li>
    <li><b>S</b> - короткое целое без знака.
    </li>
    <li><b>i</b> - целое (два байта) со
        знаком. </li>
    <li><b>I</b> - целое без знака. </li>
    <li><b>l</b> - длинное целое (4 байта) со
        знаком. </li>
    <li><b>L</b> - длинное целое без знака. </li>
    <li><b>n</b> - короткое в &quot;сетевом&quot;
        формате. </li>
    <li><b>N</b> - длинное в &quot;сетевом&quot;
        формате. </li>
    <li><b>v</b> - короткое в &quot;VAX&quot;
        формате. </li>
    <li><b>V</b> - длинное в &quot;VAX&quot;
        формате. </li>
    <li><b>f</b> - single float. </li>
    <li><b>F</b> - double float. </li>
    <li><b>p</b> - указатель на строку
        ограниченную 0. </li>
    <li><b>P</b> - указатель на структуру с
        фиксированной длиной. </li>
    <li><b>u</b> - упаковка uuencode. </li>
    <li><b>x</b> - нуль-байт </li>
    <li><b>X</b> - резервный байт. </li>
    <li><b>@</b> - заполнить нулями
        позицию. </li>
</ul>

<p>За каждой буквой может стоять
число означающее количество
повторов. Для всех типов за
исключением 'a', 'A', 'b', 'B', 'h' и 'H',
упаковывается максимально
возможное количество значений из
списка. Символ '*' после типа
означает использовать оставшиеся
параметры. Тип 'a' и 'A' использует
только одно значение из списка и
добавляет остаток поля либо
нуль-символами, либо пробелами (при
распаковке по типу 'A' пробелы и нули
отбрасываются, а по 'a' - нет). Типы 'b'
и 'B' упаковывают строку в указанное
число бит. Так же как и 'h' и 'H' в число
ниблов (байт). 'P' - упаковывает
указатель на структуру с указанной
длиной. Числа с плавающей запятой
(floats и double) записываются в
стандартном для каждой машины
формате и могут быть разными для
разных типов машин. Заметьте, что Perl
всегда использует двойную точность
(double), поэтому упаковка и распаковка
по типу 'f' приведет к потере
точности. Шаблоны для распаковки и
упаковки совершенно одинаковы. </p>

<p><i>Примеры:</i> </p>

<pre>
     print(pack(&quot;ccc&quot;,65,66,67));      # Результат ABC

     print(pack(&quot;A4A3&quot;,&quot;ab&quot;,&quot;cdefg&quot;)); # &quot;ab  cde&quot;

     print(pack(&quot;a4a3&quot;,&quot;ab&quot;,&quot;cdefg&quot;)); # &quot;ab\0\0cde&quot;
</pre>

<p><a name="func_html_89"><b></b></a><b>pipe READHANDLE, WRITEHANDLE</b> </p>

<p>Аналогичен системному pipe(). </p>

<p><a name="func_html_90"><b></b></a><b>pop массив</b> </p>

<p>Удаляет и возвращает последний
элемент массива. Длина массива
уменьшается на 1. Результат не
определен, если массив пустой. Если
имя массива отсутствует, то
извлекает из @ARGV для головной
программы и @_ для подпрограммы. </p>

<p><a name="func_html_91"><b></b></a><b>pos скаляр</b> </p>

<p>Возвращает смещение от
последнего m//g поиска. </p>

<p><a name="func_html_92"><b></b></a><b>print файл список<br>
print список<br>
print</b> </p>

<p>Выводит строку или список строк в
файл. Возвращает true при успехе.
Аргумент файл может быть скалярной
переменной, содержащей имя
указателя файла, если он
отсутствует, то осуществляется
вывод в стандартный выходной поток
STDOUT (если не было вызова <a href="#func_html_116">select()</a>).
Если список отсутствует, то
выводится значение переменной $_.
Для вывода по умолчанию в другой
файл необходимо использовать
функцию <a href="#func_html_116">select()</a>. Так как print
работает в списковом контексте, то
все элементы списка так же
вычисляются в списковом контексте,
т.е. функции будут возвращать
списковые значения. Аргументы
можно заключать в круглые скобки.
Если указатель файла - элемент
массива, то элемент нужно заключить
в фигурные скобки для вычисления
блока. </p>

<p><a name="func_html_93"><b></b></a><b>printf файл список<br>
printf список</b> </p>

<p>Аналогичен вызову &quot;print файл
sprintf(список)&quot;. Первый элемент
списка должен быть форматом printf(),
как и в С. </p>

<p><a name="func_html_94"><b></b></a><b>push массив, список</b>
</p>

<p>Добавить элементы массива
значениями из списка. Длина массива
увеличивается на количество
элементов списка. </p>

<p><a name="func_html_95"><b></b></a><b>q/строка/<br>
qq/строка/<br>
qx/строка/<br>
qw/строка/</b> </p>

<p>Обычные операторы строк. Смотри
главу <a href="#op_html">Операторы</a>. </p>

<p><a name="func_html_96"><b></b></a><b>quotemeta выражение</b> </p>

<p>Вычисляет выражение, в котором
метасимволы рассматриваются как
обычные символы. </p>

<p><a name="func_html_97"><b></b></a><b>rand выражение<br>
rand</b> </p>

<p>Возвращает случайное число в
диапазоне между 0 и выражением. Если
выражение отсутствует - между 0 и 1.
Данная псевдослучайная
последовательность сбрасывается
функцией <a href="#func_html_139">srand()</a>. </p>

<p><a name="func_html_98"><b></b></a><b>read файл, скаляр,
длина, смещение<br>
read файл, скаляр, длина</b> </p>

<p>Прочитать указанное число байт из
файла в скалярную переменную.
Возвращает количество прочитанных
байт или неопределенность при
ошибке. Длина скаляра станет равной
количеству считанных байт.
Смещение указывают, если данные
нужно поместить не с самого начала
строки. </p>

<p><a name="func_html_99"><b></b></a><b>readdir директория</b> </p>

<p>Возвращает имя следующего файла в
директории открытой командой <a href="#func_html_86">opendir()</a>. В скалярном
контексте возвращает все
оставшиеся имена файлов. Если
файлов больше нет, то возвращает
неопределенность в скалярном
контексте и пустую строку в
списковом. </p>

<p><a name="func_html_100"><b></b></a><b>readlink выражение</b> </p>

<p>Возвращает значение
символической ссылки. При ошибке
возвращает неопределенное
значение. </p>

<p><a name="func_html_101"><b></b></a><b>recv SOCKIT, SCALAR, LEN, FLAGS</b>
</p>

<p>Получить сообщение из сокета.
Аналогичен системному recvfrom(). </p>

<p><a name="func_html_102"><b></b></a><b>redo метка<br>
redo</b> </p>

<p>Перейти к началу блока, минуя
вычисление условия и блока continue.
Если метка отсутствует, то переход
к ближайшему внешнему блоку. </p>

<p><a name="func_html_103"><b></b></a><b>ref выражение</b> </p>

<p>Возвращает true, если выражение это
ссылка, иначе - false. Возвращаемое
значение зависит от типа ссылки.
Существуют следующие типы ссылок: </p>

<pre>
     REF, SCALAR, ARRAY, HASH, CODE, GLOB
</pre>

<p>Если аргумент - ссылка на класс, то
возвращается имя класса. Функция
ref() аналогична функции typeof(). </p>

<p><a name="func_html_104"><b></b></a><b>rename старое_имя,
новое_имя_файла</b> </p>

<p>Переименовать файл. Возвращает 1 в
случае успеха, иначе - 0. </p>

<p><a name="func_html_1"><b>105</b></a><b>require выражение<br>
require</b> </p>

<p>Если выражение - число, требует
что бы текущая версия Perl была не
ниже указанной. Если строка -
считывает библиотечный файл с
указанным именем, если он еще не
прочитан. Последний оператор
библиотечного файла должен
возвращать true. Обычно это строка
вида 1; Если расширение имени файла
отсутствует, то по умолчанию
принимается &quot;.pm&quot; В данной
функции можно указывать путь
расположения файла, а если
библиотека расположена в
стандартной системной области Perl,
то вместо require предпочтительней
использовать <a href="#func_html_163">use()</a>. </p>

<p><a name="func_html_106"><b></b></a><b>reset выражение<br>
reset</b> </p>

<p>Обычно используется в блоках continue
циклов для очистки переменных и
поиска для повторного применения.
Выражение воспринимается как
список символов. Для указания
диапазона можно применять символ
минус '-'. Все переменные и массивы,
начинающиеся с этих символов,
обнуляются. Если выражение
отсутствует, то обнуляется поиск
?шаблон? для повторного поиска.
Сбрасываются только переменные
текущего модуля. </p>

<p><i>Пример:</i> </p>

<pre>
     reset 'a';     # очистить все переменные начинающиеся
                    # буквой 'a'
     reset 'a-z'    # все переменные с малых букв.
</pre>

<p>Выражение вида: 'A-Z' употреблять не
рекомендуется, т.к. обнуляются
важные массивы @ARGV и @ENV. </p>

<p><a name="func_html_107"><b></b></a><b>return список</b> </p>

<p>Выход из подпрограммы с указанным
кодом. Если данная функция
отсутствует, то выход из
подпрограммы осуществляется с
кодом последнего выполненного
оператора. </p>

<p><a name="func_html_108"><b></b></a><b>reverse список</b> </p>

<p>В списковом контексте возвращает
список с элементами в обратном
порядке указанному списку. В
скалярном контексте возвращает
строку с переставленными символами
первого элемента списка. </p>

<p><a name="func_html_109"><b></b></a><b>rewindir директория</b> </p>

<p>Устанавливает указатель файлов
открытой директории в начало для
последующего чтения функцией <a href="#func_html_99">readdir()</a>. </p>

<p><a name="func_html_110"><b></b></a><b>rindex строка,
подстрока, позиция<br>
rindex строка, подстрока</b> </p>

<p>Подобна функции index , но
возвращает позицию последнего
вхождения подстроки в строку. Если
указана позиция, то просмотр
выполняется до нее. </p>

<p><a name="func_html_111"><b></b></a><b>rmdir директория</b> </p>

<p>Удалить указанную директорию,
если в ней нет никаких файлов.
Возвращает 1 при успехе и 0 - при
неудаче. При этом переменная $!
содержит код (errno). </p>

<p><a name="func_html_112"><b></b></a><b>s///</b></p>

<p>Оператор подстановки. Смотри
главу <a href="#op_html">Операторы</a>. </p>

<p><a name="func_html_113"><b></b></a><b>scalar выражение</b> </p>

<p>Вычисляет выражение в скалярном
контексте и возвращает результат. В
Perl нет специальной функции для
принудительного вычисления в
списковом контексте, т.к. для
достаточно заключить его в круглые
скобки. </p>

<p><a name="func_html_114"><b></b></a><b>seek файл, позиция,
отсчет</b> </p>

<p>Установить указатель на
произвольную позицию в файле. Если
отсчет равен 0 - позиционировать от
начала файла, если 1 - от текущего
положения, 2 - от конца файла.
Возвращает 1 при успехе и 0 - неудаче.
</p>

<p><a name="func_html_115"><b></b></a><b>seekdir директория,
позиция</b> </p>

<p>Установить указатель файла в
открытой директории для
последующего чтения функцией <a href="#func_html_99">readdir()</a>. Текущая позиция
может быть получена функцией <a href="#func_html_149">telldir()</a>. </p>

<p><a name="func_html_116"><b></b></a><b>select файл<br>
select</b> </p>

<p>Возвращает текущий указатель
файла- по умолчанию или делает
текущим указанный. Таким образом,
если в функциях print или write не указан
файл вывода, то это осуществляется
в файл, указанный select. Переменные,
связанные с выводом, так же
действуют на вывод в этот файл. </p>

<p><a name="func_html_117"><b></b></a><b>select RBITS, WBITS, EBITS,
TIMEOUT</b> </p>

<p>Выполняет системный select() </p>

<p><a name="func_html_118"><b></b></a><b>semctl ID, SEMNUM, CMD, ARG</b> </p>

<p>Системный вызов semctl() для SYSTEM V. </p>

<p><a name="func_html_119"><b></b></a><b>semget KEY, NSEMS, FLAGS</b> </p>

<p>Системный вызов semget() для SYSTEM V. </p>

<p><a name="func_html_120"><b></b></a><b>semop KEY, OPSTRING</b> </p>

<p>Системный вызов semop() для SYSTEM V. </p>

<p><a name="func_html_121"><b></b></a><b>send SOCKET, MSG, FLAGS, TO<br>
send SOCKET, MSG, FLAGS</b> </p>

<p>Послать сообщение через сокет.
Аналогично системному send(). </p>

<p><a name="func_html_122"><b></b></a><b>setpgrp PID, PGRP</b> </p>

<p>Установить номер группы PGRP
процессу с номером PID, 0 - для
текущего процесса. </p>

<p><a name="func_html_123"><b></b></a><b>setpriority WHICH, WHO, PRIORITY</b>
</p>

<p>Установить приоритет PRIORITY
процессу пользователя WHO и группе
WHICH. </p>

<p><a name="func_html_124"><b></b></a><b>setsockopt SOCKET, LEVEL, OPTNAME,
OPTVAL</b> </p>

<p>Установить параметры сокета.
Возвращает неопределенность при
ошибке. </p>

<p><a name="func_html_125"><b></b></a><b>shift массив<br>
shift</b> </p>

<p>Удаляет первый элемент массива и
возвращает его значение. Если
массив пустой, то результат -
неопределенность. Если аргумент
опущен - обрабатывается массив @ARGV в
головной программе или @_ в
подпрограмме. </p>

<p><a name="func_html_126"><b></b></a><b>shmctl ID, CMD, ARG</b> </p>

<p>Системный вызов shmctl() System V </p>

<p><a name="func_html_127"><b></b></a><b>shmget KEY, SIZE, FLAGS</b> </p>

<p>Системный вызов shmget() System V </p>

<p><a name="func_html_128"><b></b></a><b>shmread ID, VAR, POS, SIZE<br>
shmread ID, STRING, POS, SIZE</b> </p>

<p>Пишет или читает сегмент
общедоступной памяти в System V. </p>

<p><a name="func_html_129"><b></b></a><b>shutdown SOCKET, HOW</b> </p>

<p>Прекращает работу сокета методом
HOW. </p>

<p><a name="func_html_130"><b></b></a><b>sin выражение</b> </p>

<p>Возвращает в радианах синус
выражения. </p>

<p><a name="func_html_131"><b></b></a><b>sleep выражение<br>
sleep</b> </p>

<p>Приостанавливает работу процесса
на указанное число секунд или
зацикливается, если аргумент
отсутствует. Работа продолжается,
если получен сигнал SIGALARM.
Возвращает время фактической
паузы. </p>

<p><a name="func_html_132"><b></b></a><b>socket SOCKET, DOMAIN, TYPE,
PROTOCOL</b> </p>

<p>Открывает сокет и привязывает его
к указателю SOCKET. </p>

<p><a name="func_html_133"><b></b></a><b>socketpair SOCKET1, SOCKET2,
DOMAIN, TYPE, PROTOCOL</b> </p>

<p>Создает &quot;безымянную&quot; пару
сокетов в указанном DOMAIN. Возвращает
true при успехе и false - неудаче. </p>

<p><a name="func_html_134"><b></b></a><b>sort подпрограмма
список<br>
sort блок список<br>
sort список</b> </p>

<p>Сортирует элементы списка и
возвращает полученный список.
Несуществующие элементы списка
отбрасываются. Если не указано имя
подпрограммы или блок, то сортирует
в стандартном строковом порядке.
Указанная подпрограмма возвращает
значения больше, меньше или равное
нулю в зависимости от двух соседних
элементов списка. Имя подпрограммы
может быть указано переменной. Она
не должна быть рекурсивной, и два
сравниваемых элемента списка
передаются как глобальные
переменные $main::a и $main::b. Это ссылки,
поэтому их изменение приводит к
изменению самих элементов списка. </p>

<p><a name="func_html_135"><b></b></a><b>splice массив,
смещение, длина, список<br>
splice массив, смещение, длина<br>
splice массив, смещение</b> </p>

<p>Удаляет элементы массива, начиная
со смещения и указанной длины.
Заменяет их указанным списком.
Возвращает удаленный список. Если
длина не указана, удаляет все
элементы списка, начиная со
смещения. </p>

<p><a name="func_html_136"><b></b></a><b>split /шаблон/,
выражение, предел<br>
split /шаблон/, выражение<br>
split /шаблон/<br>
split</b> </p>

<p>Разделяет строку, указанную
выражением, на массив элементов и
возвращает его. В скалярном
контексте возвращает количество
полученных элементов массива, а сам
массив помещает в @_ (в списковом
контексте поместить результат в @_
можно если применить ?шаблон?) Если
выражение отсутствует, то
обрабатывается содержимое
переменной $_. Если шаблон
отсутствует, то разделителем
является пробел. Все, что подходит
по шаблону, считается разделителем.
Если указан предел, то это
максимальное число разделений.
Отрицательное значение предела
воспринимается как неограниченно
большой предел. Если пустая строка
походит под шаблон разделителя, то
исходное значение разделяется
посимвольно. Предел удобно
использовать для частичного
разделения строки. </p>

<p><i>Пример:</i> </p>

<pre>
     ($a, $b, $остаток) = split(/ /, &quot;Один Два Три Четыре&quot;,3);
</pre>

<p>здесь $a = 'Один', $b = 'Два' и $остаток =
'Три Четыре' </p>

<p>Если шаблон содержит круглые
скобки, то символы-разделители,
указанные в них, вставляются в
результирующий список как обычные
элементы, причем вставляется
символ, который совпал с
разделителем. </p>

<p><i>Пример:</i> </p>

<pre>
        @a = split(/([,.])/, &quot;Один,Два.Три&quot;);
</pre>

<p>здесь @a = (&quot;Один&quot;, &quot;,&quot;
,&quot;Два&quot;, &quot;.&quot;, &quot;Три&quot;) </p>

<p><a name="func_html_137"><b></b></a><b>sprintf формат, список</b>
</p>

<p>Форматирует список по указанному
формату аналогично функции sprintf()
языка С. </p>

<p><a name="func_html_138"><b></b></a><b>sqrt выражение</b> </p>

<p>Возвращает корень квадратный
выражения. </p>

<p><a name="func_html_139"><b></b></a><b>srand выражение</b> </p>

<p>Задает начальное значение для
генератора случайных чисел -
оператора rand. Если аргумент
отсутствует, то используется
текущее машинное время. </p>

<p><a name="func_html_140"><b></b></a><b>stat файл<br>
stat выражение</b> </p>

<p>Возвращает 13 элементный массив
параметров указанного файла или
пустой список при ошибке.
Применяется обычно следующим
образом: </p>

<pre>
     ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($filename);
</pre>

<p>где </p>

<ul>
    <li><b>$dev</b> - имя устройства </li>
    <li><b>$ino</b> - номер i-узла </li>
    <li><b>$mode</b> - права доступа </li>
    <li><b>$nlink</b> - количество связей </li>
    <li><b>$uid</b> - идентификатор
        владельца </li>
    <li><b>$gid</b> - идентификатор группы </li>
    <li><b>$rdev</b> - тип устройства </li>
    <li><b>$size</b> - размер файла в байтах </li>
    <li><b>$atime</b> - дата последнего
        обращения </li>
    <li><b>$mtime</b> - дата последней
        модификации </li>
    <li><b>$ctime</b> - дата последнего
        изменения статуса </li>
    <li><b>$blksize</b> - размер блока на диске
    </li>
    <li><b>$blocks</b> - количество блоков в
        файле. </li>
</ul>

<p>Если указан аргумент '_', то
возвращается результат
предыдущего вызова stat(). </p>

<p><a name="func_html_141"><b></b></a><b>study скаляр<br>
study</b> </p>

<p>Включение метода частотного
сравнения. Целесообразность
применения зависит от количества
поисков и количества констант в
строке в которой ведется поиск.
Функция работает следующим
образом: Для указанного скаляра
(если аргумент отсутствует берется
значение переменной $_) строится
список указателей на каждый символ
строки. Затем, когда начинается
поиск, первыми просматриваются
символы, которые наиболее редко
встречаются в английском языке.
Выигрыш по времени очевиден, когда
выполняется многократный поиск в
одной и той же строке, и время
затраченное на индексацию
окупается. </p>

<p><a name="func_html_142"><b></b></a><b>substr выражение,
смещение, длина<br>
substr выражение, смещение</b> </p>

<p>Возвращает подстроку выражения,
начиная со смещения и заданной
длины. Если смещение отрицательное,
то отсчет ведется от конца строки.
Если длина не указана, то берется
все до конца строки. </p>

<p><a name="func_html_143"><b></b></a><b>symlink старый_файл,
новый_файл</b> </p>

<p>Создает новый файл, символически
связанный со старым, т.е. создает
ссылку на файл. Возвращает 1 при
успехе и 0 - неудаче. </p>

<p><a name="func_html_144"><b></b></a><b>syscall список</b> </p>

<p>Выполняет системную функцию.
Первый элемент списка - это имя
функции, а остальные элементы - ее
аргументы. Если функция не
выполнима, то возвращается
фатальная ошибка. Аргументы
интерпретируются следующим
образом. Если аргумент число, то оно
считается целым. Если не число, то
аргумент считается указателем на
строку. Вам необходимо обеспечить
достаточную длину аргумента для
подстановки значения указателя. В
Perl передается максимум 14
параметров. Обычно этого
достаточно. </p>

<p><a name="func_html_145"><b></b></a><b>sysread файл, скаляр,
длина, смещение<br>
sysread файл, скаляр, длина</b> </p>

<p>Прочитать из файла указанное
число байт в скаляр с помощью
системного вызова <a href="#func_html_98">read()</a>.
Смещение обозначает позицию в
скаляре, после которой будут
вставлены прочитанные байты. </p>

<p><a name="func_html_146"><b></b></a><b>system список</b> </p>

<p>Делает то же самое, что и &quot;exec
список&quot; с той лишь разницей, что
вызов fork() делается первым, и
родительский процесс ждет
завершения потомка. Возвращает
значение аналогичное функции <a href="#func_html_167">wait()</a>. Для получения
действительного кода завершения
необходимо разделить на 256. </p>

<p><a name="func_html_147"><b></b></a><b>syswrite файл, скаляр,
длина, смещение<br>
syswrite файл, скаляр, длина</b> </p>

<p>Записать в файл указанное число
байт скаляра с помощью системного
вызова <a href="#func_html_171">write()</a>. Смещение
указывает позицию в скаляре, откуда
начинается запись. </p>

<p><a name="func_html_148"><b></b></a><b>tell файл<br>
tell</b> </p>

<p>Возвращает текущую позицию
указателя в открытом файле. Если
файл не указан, то последнего
читаемого файла. </p>

<p><a name="func_html_149"><b></b></a><b> telldir директория</b> </p>

<p>Возвращает текущую позицию
указателя в открытой директории.
Обычно это параметр для
позиционирования указателя
директории функцией <a href="#func_html_114">seekdir()</a>.
</p>

<p><a name="func_html_150"><b></b></a><b> tie переменная,
класс, список</b> </p>

<p>Присваивает переменную классу.
Список - это аргументы new метода
класса (TIESCALAR, TIEARRAY или TIEHASH).
Возвращает указатель на созданный
новый объект класса, который удобен
для вызова других методов класса. </p>

<p><font color="#FF0080">Внимание! Такие
функции как </font><a href="#func_html_62"><font color="#FF0080">keys()</font></a><font color="#FF0080"> и </font><a href="#func_html_165"><font color="#FF0080">values()</font></a><font color="#FF0080"> могут вернуть в качестве
значения огромное количество
данных. </font></p>

<p>Для создания объекта
ассоциативного типа необходимо
определение следующих методов: </p>

<ul>
    <li>TIEHASH classname, LIST </li>
    <li>DESTROY this </li>
    <li>FETCH this, key </li>
    <li>STORE this, key, value </li>
    <li>DELETE this, key </li>
    <li>EXISTS this, key </li>
    <li>FIRSTKEY this </li>
    <li>NEXTKEY this, lastkey </li>
</ul>

<p>Обычного массива: </p>

<ul>
    <li>TIEHASH classname, LIST </li>
    <li>DESTROY this </li>
    <li>FETCH this, key </li>
    <li>STORE this, key, value </li>
    <li>[others TBD] </li>
</ul>

<p>Скалярного типа: </p>

<ul>
    <li>TIEHASH classname, LIST </li>
    <li>DESTROY this </li>
    <li>FETCH this, key </li>
    <li>STORE this, key, value </li>
</ul>

<p><a name="func_html_151"><b></b></a><b> time</b> </p>

<p>Возвращает количество секунд,
начиная с 1 января 1970 г 00:00:00 UTC. Годы
не разделяются на високосные. </p>

<p><a name="func_html_152"><b></b></a><b> times</b> </p>

<p>Возвращает 4-х элементный массив
значений: </p>

<pre>
     ($user, $system, $cuser, $csystem) = times;
</pre>

<p>где: </p>

<ul>
    <li><b>$user</b> - пользовательское
        время процесса в секундах. </li>
    <li><b>$system</b> - системное время
        текущего процесса. </li>
    <li><b>$cuser</b> - время
        процесса-потомка текущего
        процесса. </li>
    <li><b>$csystem</b> - его системное время. </li>
</ul>

<p><a name="func_html_153"><b></b></a><b> tr///</b> </p>

<p>Оператор транслятор. Подробно
смотри главу &quot;Операторы&quot;. </p>

<p><a name="func_html_154"><b></b></a><b>truncate файл, длина<br>
truncate выражение, длина</b> </p>

<p>Усекает длину указанного файла. </p>

<p><a name="func_html_155"><b></b></a><b>uc выражение</b> </p>

<p>Возвращает строку выражения, в
которой малые буквы заменены на
заглавные. </p>

<p><a name="func_html_156"><b></b></a><b>ucfirst выражение</b> </p>

<p>Возвращает строку выражения, в
которой первая буква заменена на
заглавную. </p>

<p><a name="func_html_157"><b></b></a><b>umask выражение<br>
umask</b> </p>

<p>Устанавливает маску umask и
возвращает старое значение. Без
аргумента возвращает текущее
значение. </p>

<p><a name="func_html_158"><b></b></a><b>undef выражение undef</b>
</p>

<p>Делает неопределенным значение
выражения. Применяется только для
скалярных переменных, целых
массивов или подпрограмм. Всегда
возвращает неопределенное
значение. </p>

<p><a name="func_html_159"><b></b></a><b>unlink список</b> </p>

<p>Удаляет файлы, указанные в списке.
Возвращает количество удаленных
файлов. Только супервизор может
удалять директории с файлами, если
Perl запущен с ключом -U. </p>

<p><a name="func_html_160"><b></b></a><b>unpack шаблон,
выражение</b> </p>

<p>Функция, обратная <a href="#func_html_88">pack()</a>.
Распаковывает строку выражения по
указанному шаблону в массив
значений. В скалярном контексте
возвращает значение только первого
элемента. Шаблоны такие же как и в <a href="#func_html_88">pack()</a>. </p>

<p>Символ '%' в шаблоне означает, что
вы хотите получить вместо значения
его контрольную сумму. По умолчанию
- 16-битную. </p>

<p><a name="func_html_161"><b></b></a><b>untie переменная</b> </p>

<p>Исключает переменную из класса
указанного <a href="#func_html_150">tie()</a>. </p>

<p><a name="func_html_162"><b></b></a><b>unshift массив, список</b>
</p>

<p>Противоположное <a href="#func_html_125">shift</a>.
Помещает элементы списка в начало
массива. </p>

<p><a name="func_html_163"><b></b></a><b>use модуль список<br>
use модуль</b> </p>

<p>Указывает библиотечный модуль, из
которого можно вызывать
подпрограммы. Список перечисляет
имена подпрограмм, которые
добавляются к текущей области имен.
Если не указан, то все имена.
Действие аналогично блоку: </p>

<pre>
     BEGIN { require модуль; import модуль список; }
</pre>

<p>Сам модуль должен располагаться в
системной области Perl файлов. </p>

<p><a name="func_html_164"><b></b></a><b>utime список</b> </p>

<p>Изменяет дату обращения и
модификации файлов из списка.
Первые два элемента списка должны
указывать новое значение даты
обращения и модификации.
Возвращает количество измененных
файлов. </p>

<p><a name="func_html_165"><b></b></a><b>values хеш</b> </p>

<p>Возвращает обычный массив со
всеми значениями хеша. В скалярном
контексте возвращает количество
значений хеша. </p>

<p><a name="func_html_166"><b></b></a><b>vec выражение,
смещение, бит</b> </p>

<p>Возвращает значение строки как
вектор беззнаковых целых. </p>

<p><a name="func_html_167"><b></b></a><b>wait</b> </p>

<p>Ожидать окончание порожденного
процесса. Возвращает PID для
родительского процесса или -1, если
нет - процесса потомка. Код
завершения записывается в
переменную $?. </p>

<p><a name="func_html_168"><b></b></a><b>waitpid PID, FLAGS</b> </p>

<p>Ожидать окончания процесса
потомка с указанным PID. Возвращает
либо PID этого процесса либо -1 если
нет такого процесса. Код завершения
записывается в переменную $?. </p>

<p><a name="func_html_169"><b></b></a><b>wantarray</b> </p>

<p>Возвращает true, если подпрограмма
вызывается в списковом контексте и
false - в скалярном. </p>

<p><a name="func_html_170"><b></b></a><b>warn список</b> </p>

<p>Выводит в стандартный поток
ошибок STDERR сообщение аналогично <a href="#func_html_25">die()</a>, но не прекращает работу
программы. </p>

<p><a name="func_html_171"><b></b></a><b>write файл<br>
write выражение<br>
write</b> </p>

<p>Выводит в файл форматированные
данные по оператору <a href="#func_html_41">format</a>.
По умолчанию имя формата совпадает
с именем указателя файла. Имя файла
по умолчанию можно изменить
функцией <a href="#func_html_116">select()</a>, а имя
формата при этом надо присвоить
переменной $~. Заголовок листа
пишется автоматически. Если на
листе не хватает места для вывода,
то выводится &quot;перевод формата&quot;
и специальная форма заголовка
листа, затем сами записи. По
умолчанию имя формата заголовка
листа состоит из имени указателя
файла и добавленной строки
&quot;_TOP&quot;. Динамически это можно
делать, присваивая формат
переменной $^. Количество
оставшихся строк листа содержится
в переменной $- и если присвоить ей 0,
то произойдет смена листа. Подробно
описание форматов смотри в главе <a href="#form_html">Форматы</a>. </p>

<p><a name="func_html_172"><b></b></a><b>y///</b> </p>

<p>Оператор транслятор. Смотри главу
<a href="#op_html">Операторы</a>. </p>


<hr>

<a name="debug_html"></a>
<font color="#8000FF">Отладка Perl
программ.</font></h3>

<hr width="90%">

<p>В Perl реализован превосходный
механизм отладки программ. Вам
достаточно запустить программу с
ключом '-d' и вы начнете работать с
интерактивным отладчиком. Вам
становятся доступны все переменные
и массивы, вы можете вводить
выражения и операторы,
трассировать, исследовать работу
программы в пошаговом режиме и
многое другое. Ниже перечислены
команды отладчика которые вы
можете вводить на его подсказку. </p>

<p><b>Команды отладчика.</b> </p>

<ul>
    <li><b>h</b> - Получить справку по
        командам. </li>
    <li><b>T</b> - Просмотреть стек
        программы </li>
    <li><b>s</b> - Выполнить одну команду и
        остановиться. </li>
    <li><b>n</b> - Выполнить подпрограмму и
        остановиться. </li>
    <li><b>r</b> - Выполнить текущую
        подпрограмму и остановиться. </li>
    <li><b>c</b> - Продолжить выполнение до
        следующей точки остановки. </li>
    <li><b>c номер</b> - Продолжить
        выполнение до строки с данным
        номером. </li>
    <li><b>&lt;CR&gt;</b> - Повторить последнюю
        команду n или s. </li>
    <li><b>l min+incr</b> - Вывести incr+1 строк
        программы начиная со строки min. </li>
    <li><b>l min-max</b> - Вывести строки
        начиная с min до max. </li>
    <li><b>l номер</b> - Вывести строку с
        указанным номером. </li>
    <li><b>l</b> - Вывести следующий экран
        строк. </li>
    <li><b>-</b> - Вывести предыдущий экран
        строк. </li>
    <li><b>w строк</b> - Вывести экран
        строк. Текущая в середине. </li>
    <li><b>l подпрограмма</b> - Вывести
        строки указанной подпрограммы.
    </li>
    <li><b>/шаблон/</b> - Найти строку в
        тексте программы. </li>
    <li><b>?шаблон?</b> - Обратный поиск
        строки в тексте программы. </li>
    <li><b>L</b> - Вывести строки с точками
        останова и активами. </li>
    <li><b>S</b> - Вывести имена всех
        подпрограмм. </li>
    <li><b>t</b> - Включить или выключить
        трассировку. </li>
    <li><b>b строка [ условие]</b> -
        Установить точку остановки. </li>
    <li><b>b подпрограмма [ условие ]</b> -
        Установить точку остановки в
        начале указанной подпрограммы
        и если указано при данном
        условии. </li>
    <li><b>d</b> - Убрать точку остановки. </li>
    <li><b>D</b> - Убрать все точки
        остановки. </li>
    <li><b>a строка команда</b> -
        Установить актив (команду
        которая выполнится вместе с
        указанной строкой.
        &quot;команда&quot; - обычная
        команда Perl. </li>
    <li><b>A</b> - Стереть все активы. </li>
    <li><b>&lt; команда - Выполнять
        команду перед каждой
        остановкой. </b></li>
    <li><b>&gt; команда</b> - Выполнить
        команду после остановки
        отладчика. </li>
    <li><b>V модуль [имена]</b> - Вывести
        значение всех или указанных
        имен в модуле. <font color="#FF0080">Внимание!
        Символ '$' не вводится. </font></li>
    <li><b>X [имена]</b> - То же что и V , но
        только для текущего модуля. </li>
    <li><b>! номер</b> - Выполнить одну
        строку программы. </li>
    <li><b>! -номер</b> - Выполнить одну
        команду с номером
        предшествующим текущей строке.
    </li>
    <li><b>H - n</b> - Вывести n последних
        выполненных команд. </li>
    <li><b>q или ^D</b> - Выход из программы. </li>
    <li><b>команда</b> - Выполнить команду
        Perl. </li>
    <li><b>p выражение</b> - Вывести
        значение выражения. </li>
</ul>

<p>Конструктор BEGIN не отслеживается
отладчиком, но можно в теле
конструктора указать: </p>

<ul>
    <li>$DB::single =1; </li>
</ul>

<p>и отладчик остановится. Данная
команда не вызовет ошибку при
работе без отладчика. </p>


<hr>

<a name="internet_html"></a>
Интернет - ссылки и
литература.</font></h3>

<hr width="90%">

<p><b>Очень полезные USENET конференции:</b>
</p>

<ul>
    <li>comp.lang.perl.announce - Различные
        объявления и сообщения. </li>
    <li>comp.lang.perl.misc - Место для вопросов
        и обсуждений. </li>
    <li>comp.lang.perl.modules - Модули Perl. </li>
    <li>comp.lang.perl.tk - Perl и Tcl/tk. </li>
</ul>

<p><b>WWW сервера:</b> </p>

<ul>
    <li><a href="http://www.perl.org">Специальный
        Perl-сервер</a> </li>
    <li><a href="http://www.ora.com">Книги по Unix
        издательства O`Reily</a> </li>
    <li><a href="ftp://ftp.perl.com">Специализированный
        FTP сервер</a> </li>
    <li><a href="http://franz.ww.tu-berlin.de/modulelist">Список
        модулей</a> </li>
</ul>

<p><b>Список литературы.</b> </p>

<p>При написании книги автор в
основном пользовался описанием Perl
&quot;Perl Programmers Reference Guide&quot;.<br>
Наиболее известная зарубежная
литература: </p>

<ul>
    <li>Programming Perl (the Camel Book) </li>
    <li>Learning Perl (Llama Book) </li>
</ul>


<hr>

<a name="begin_html"></a>
<font color="#8000FF" size="5"><strong>От
простого к сложному</strong></font></p>

<hr width="90%">

<p>Прежде чем приступить к
последовательному ознакомлению с
не знакомым для вас языком, должен
оговориться и сказать, что все
примеры да и сам язык описанию
которого посвящена эта книга это Perl
версии 5.003 для операционной системы
FreeBSD версии 2.01. Существуют
реализации этого языка для
операционных систем OS/2 , MS-DOS и Windows NT
но они немного отстают по
возможностям от оригинала,
рожденного в недрах Unix.</p>

<p><i>Пример 1.</i><br>
Введите в файл test1.pl следующие
строки: </p>

<pre>
		#!/usr/local/bin/perl
		# Содержимое файла test1.pl
		print &quot;Наше Вам с кисточкой!\n&quot;;
</pre>

<p>А теперь подробно разберем каждую
строку.<br>
</p>

<pre>
#!/usr/local/bin/perl
</pre>

<p justify>Данная строка должна быть
первой в любой Perl-программе. Она
указывает системному
интерпретатору что данный файл -
это Perl-программа. </p>

<pre>
# Содержимое файла test1.pl
</pre>

<p>Эта строка называется
комментарием. Она всегда
начинается символом '#' и
заканчивается таким объяснением
что как говорил великий Ходжа
Насреддин &quot;это тонкий
философский вопрос&quot;, а говоря
простым языком здесь можно писать
все что угодно. Даже пожелание
руководству. Уж здесь оно точно до
него не дойдет.</p>

<pre>
print &quot;Наше Вам с кисточкой!\n&quot;;
</pre>

<p justify>Самая последняя ну и конечно
главная. Она просто выводит на
экран надпись &quot;Наше Вам с
кисточкой!&quot;.</p>

<p justify>Здесь слово print - это команда
&quot;вывести&quot;. Все что в кавычках -
это символы, \n - перевод строки и ';' -
признак конца команды. Он
обязателен. В одной строке может
быть несколько команд и все они
должны завершаться символом ';'.
После него может быть символ '#' - это
значит остаток строки считается
комментарием.</p>

<p justify>Над этой строкой автору
пришлось больше всего поломать
голову так как в нее постоянно
лезли какие то странные &quot;hello&quot;,
&quot;hello all&quot;, &quot;Построимся и
спасемся&quot;, &quot;Строй наше
спасение&quot; и т. д. и т.п.</p>

<p justify>Если вы никогда не работали с
Perl, то бьюсь на спор в 10$, что данная
программа сразу у вас не
заработает! Не потому что она не
верна, а потому что &quot;Нельзя
объять необъятное&quot;. Сразу, потом
можно, да и то частями. Сначала
сделайте ваш файл test1.pl исполняемым.
Для этого введите команду: </p>

<pre>
	chmod +x test1.pl
</pre>

<p>Затем проверьте где у вас Perl. Для
этого введите: </p>

<pre>
	which perl
</pre>

<p>Система вам выдаст что то вроде:
/usr/bin/perl<br>
Если: </p>

<pre>
perl: Command not found.
</pre>

<p>То тогда закройте книжку и
ложитесь спать. У вас просто нет Perl
или он не установлен. А мне остается
послать вас к системному
администратору или к man (для
переводчиков- man сокращение от manual а
не то что вы подумали). </p>

<p justify>Теперь проверьте что бы
строка 01 содержала то что выдала
команда which. Если совпало то
введите: </p>

<pre>
	test1.pl
</pre>

<p>и бьюсь на 50$, что и теперь
программа не заработает, так как
правильней ввести: </p>

<pre>
	./test1.pl
</pre>

<p justify>Если я проиграл, то не
радуйтесь. Да же если вам удалось
запустить программу как test1.pl это
значит, что у вас будут
неприятности в будущем. </p>

<p><i>Пример 2.</i><br>
Данная программа выводит на экран
все ваши секреты. А именно файл
/etc/passwd. </p>

<pre>
	#!/usr/local/bin/perl
	open(PASS, &quot;&lt;/etc/passwd&quot;) || die &quot;Файл не найден!&quot;;
	while(&lt;PASS&gt;)
	    {
	    print;
	    }
	close(PASS);
</pre>

<p>Пояснения:<br>
</p>

<pre>
open(PASS, &quot;&lt;/etc/passwd&quot;) || die &quot;Файл не найден!&quot;;
</pre>

<p>&quot;Открыть&quot; файл, т.е. создать
указатель файла PASS, и в случае
ошибки выдать &quot;Файл не найден!&quot;
и закончить программу. </p>

<pre>
while(&lt;PASS&gt;)
</pre>

<p>Читать по одной строке файла в
переменную по умолчанию $_. </p>

<pre>
  {
</pre>

<p>Открыть блок операторов. </p>

<pre>
  print;
</pre>

<p>Вывести на экран переменную по
умолчанию $_ </p>

<pre>
   }
</pre>

<p>Конец блока. </p>

<pre>
close(PASS);
</pre>

<p>Закрыть файл. Этого можно и не
делать, т. к. файл автоматически
закроется после окончания
программы. </p>

<p justify>Результат работы этой
программы тот же что и команды cat
/etc/passwd. По экрану пробежали
непонятные строки но зато теперь
перед вами открыты горизонты Perl
программирования! Все последующие
примеры будут развитием этой
программы и она превратится из
гадкого утенка в прекрасного
лебедя (не генерала). </p>

<p><i>Пример 3.</i><br>
Разделение полей. </p>

<pre>
      #!/usr/local/bin/perl
      open(PASS, &quot;&lt;/etc/passwd&quot;) || die &quot;Файл не найден!&quot;;
      while(&amp;ltPASS&gt;)
          {
	    ($login, $pass, $uid, $gid, $name, $home_dir, $shell) = split(':');
	    print &quot;$login \t $name\n&quot;;
          }
      close(PASS);
</pre>

<p>Пояснение: </p>

<pre>
($login, $pass, $uid, $gid, $name, $home_dir, $shell) = split(':');
</pre>

<p>Присвоить указанным переменным
поля входной строки, считая
разделителем символ ':'. </p>

<pre>
print &quot;$login \t $name\n&quot;;
</pre>

<p>Вывести login - имя пользователя и
его описание. Поля разделены
символом '\t' - табуляции. </p>

<p><i>Пример 4.</i><br>
Вывести имена пользователей,
отсортированных по группам. </p>

<pre>
	#!/usr/local/bin/perl
	open(PASS, &quot;sort -n -t : +3 -4 +0 /etc/passwd|&quot;) || die &quot;Файл не найден!&quot;;
	while(&lt;PASS&gt;)
	    {
	    ($login, $pass, $uid, $gid, $name, $home_dir, $shell) = split(':');
	    print &quot;$login \t $gid \t $name\n&quot;;
	    }
	close(PASS);
</pre>

<p>Пояснения: </p>

<pre>
open(PASS, &quot;sort -n -t : +3 -4 +0 /etc/passwd|&quot;) || die &quot;Файл не найден!&quot;;
</pre>

<p justify>В данной строке весь фокус!
Входным файлом для нашей программы
стал выход команды sort которая и
отсортирует входные данные.</p>

<p><i>Форматированный вывод.</i></p>

<p justify>Ну а теперь напечатаем на
экране все наши данные в удобной
форме. </p>

<pre>
#!/usr/local/bin/perl

open(PASS, &quot;sort -n -t : +3 -4 +0 /etc/passwd|&quot;) || die &quot;Файл не найден!&quot;;
while(&lt;PASS&gt;)
    {
    ($login, $pass, $uid, $gid, $name, $home_dir, $shell) = split(':');
    write();	# Форматированный вывод данных.
    }
close(PASS);
exit 0;		# Завершение программы

############ Описание формы вывода ##################

format STDOUT =

Пользователь: ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< $name ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< $name ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< $name Login:@<<<<<<<< Uid:@<<< Gid:@<<< Home dir:@<<<<<<<<<<<<<<<<<<<<< $login, $uid, $gid, $home_dir . # Это последняя строка программы </pre>

</pre>

<p><i>Фрагмент результата:</i></p>

<pre>
Пользователь: Калужский ликероводочный завод. Лучшие водки и
              настойки. Звонить только перед праздником Кострикову
              Анатолию т. 2-23-06,,,
----------------------------------------------------------------------
Login:uucryst     Uid:1055  Gid:66    Home dir:/var/spool/uucppublic/
----------------------------------------------------------------------


Пользователь: Торговый Дом Дилен,,,


----------------------------------------------------------------------
Login:uudilen     Uid:1075  Gid:66    Home dir:/var/spool/uucppublic
----------------------------------------------------------------------
</pre>

<p justify>Если вам интересно узнать как
работает эта программа, то <a href="#run_html">переверните страницу</a> и
начините свое путешествие в мире
Perl. Желаю удачи!</p>


<hr>

<!--#include virtual="/footer.raw"-->

</body></html>