<html>
 <head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <title> Спецификация языка Perl</title>
  </head>
<body bgcolor="#DDE1C2">
<!--#include virtual="/header.raw"-->
<h3>Версия для печати</h3>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/141.shtml">Perl</a>"
</b>
 <small>(<a href="./">Многостраничная версия</a>)</small>
<hr noshade size=1>

<a name="index_html"></a>
<h1>Спецификация языка Perl </H1>
<h2>Алена Федосеева</h2> 

<h4>Содержание</h4>
             <p align=justify>П2.1<A href="#index_html_SECTION002" name=tex2html1>Основные 
               особенности Perl</A> <br>
               П2.1.1<A href="#index_html_SECTION0021" name=tex2html2>Введение</A> 
             <p align=justify>П2.2<A href="#index_html_SECTION003" name=tex2html3>Cтруктуры 
               данных</A> <br>
               П2.2.1<A href="#index_html_SECTION0031" name=tex2html4>Скалярные величины</A> 
               <br>
               П2.2.2<A href="#index_html_SECTION0032" name=tex2html5>Простые массивы</A> 
               <br>
               П2.2.3<A href="#index_html_SECTION0033" name=tex2html6>Ассоциативные массивы</A> 
             <p align=justify>П2.3<A href="#index_html_SECTION004" name=tex2html7>Синтаксис 
               языка Perl</A> <br>
               П2.3.1<A href="#index_html_SECTION0041" name=tex2html8>Основные понятия</A> 
               <br>
               П2.3.2<A href="#index_html_SECTION0042" name=tex2html9>Простые операторы</A> 
               <br>
               П2.3.3<A href="#index_html_SECTION0043" name=tex2html10>Составные операторы</A> 
               <br>
               П2.3.4<A href="#index_html_SECTION0044" name=tex2html11>Операторы языка Perl</A> 
               <br>
               П2.3.4.1<A href="#index_html_SECTION00441" name=tex2html12>Термы и операторы 
               списка</A> <br>
               П2.3.4.2<A href="#index_html_SECTION00442" name=tex2html13>Оператор ``стрелка''</A> 
               <br>
               П2.3.4.3<A href="#index_html_SECTION00443" name=tex2html14>Операторы ++ и - 
               -</A> <br>
               П2.3.4.4<A href="#index_html_SECTION00444" name=tex2html15>Экспоненциальный 
               оператор</A> <br>
               П2.3.4.5<A href="#index_html_SECTION00445" name=tex2html16>Символьные унарные 
               операторы</A> <br>
               П2.3.4.6<A href="#index_html_SECTION00446" name=tex2html17>Операторы связки</A> 
               <br>
               П2.3.4.7<A href="#index_html_SECTION00447" name=tex2html18>Бинарные операторы</A> 
               <br>
               П2.3.4.8<A href="#index_html_SECTION00448" name=tex2html19>Операторы сдвига</A> 
               <br>
               П2.3.4.9<A href="#index_html_SECTION00449" name=tex2html20>Операторы сравнения</A> 
               <br>
               П2.3.4.10<A href="#index_html_SECTION004410" name=tex2html21>Операторы эквивалентности</A> 
               <br>
               П2.3.4.11<A href="#index_html_SECTION0044110" name=tex2html22>Побитовое И, 
               побитовое ИЛИ и Исключающее ИЛИ</A> <br>
               П2.3.4.12<A href="#index_html_SECTION0044120" name=tex2html23>Логическое И 
               и логическое ИЛИ</A> <br>
               П2.3.4.13<A href="#index_html_SECTION0044130" name=tex2html24>Оператор диапазона</A> 
               <br>
               П2.3.4.14<A href="#index_html_SECTION0044140" name=tex2html25>Условный оператор</A> 
               <br>
               П2.3.4.15<A href="#index_html_SECTION0044150" name=tex2html26>Операторы присваивания</A> 
               <br>
               П2.3.4.16<A href="#index_html_SECTION0044160" name=tex2html27>Оператор ``запятая''</A> 
               <br>
               П2.3.4.17<A href="#index_html_SECTION0044170" name=tex2html28>Логическое НЕ</A> 
               <br>
               П2.3.4.18<A href="#index_html_SECTION0044180" name=tex2html29>Логическое И, 
               ИЛИ и Исключающее ИЛИ</A> <br>
               П2.3.4.19<A href="#index_html_SECTION0044190" name=tex2html30>Оператор чтения 
               из файла</A> <br>
               П2.3.4.20<A href="#index_html_SECTION004420" name=tex2html31>Оператор замены 
               строки</A> <br>
               П2.3.4.21<A href="#index_html_SECTION0044210" name=tex2html32>Оператор замены 
               множества символов</A> 
             <p align=justify>П2.4<A href="#index_html_SECTION005" name=tex2html33>Языковые 
               конструкции Perl</A> <br>
               П2.4.1<A href="#index_html_SECTION0051" name=tex2html34>Ссылки</A> <br>
               П2.4.1.1<A href="#index_html_SECTION00511" name=tex2html35>Основные понятия</A> 
               <br>
               П2.4.1.2<A href="#index_html_SECTION00512" name=tex2html36>Символьные ссылки</A> 
               <br>
               П2.4.2<A href="#index_html_SECTION0052" name=tex2html37>Регулярные выражения</A> 
               <br>
               П2.4.3<A href="#index_html_SECTION0053" name=tex2html38>Зарезервированные переменные</A> 
               <br>
               П2.4.4<A href="#index_html_SECTION0054" name=tex2html39>Встроенные функции</A> 
               <br>
               П2.4.5<A href="#index_html_SECTION0055" name=tex2html40>Подпрограммы и модули</A> 
               <br>
               П2.4.5.1<A href="#index_html_SECTION00551" name=tex2html41>Подпрограммы</A> 
               <br>
               П2.4.5.2<A href="#index_html_SECTION00552" name=tex2html42>Пакеты</A> <br>
               П2.4.5.3<A href="#index_html_SECTION00553" name=tex2html43>Таблицы символов</A> 
               <br>
               П2.4.5.4<A href="#index_html_SECTION00554" name=tex2html44>Конструкторы и деструкторы 
               пакетов</A> <br>
               П2.4.5.5<A href="#index_html_SECTION00555" name=tex2html45>Классы</A> <br>
               П2.4.5.6<A href="#index_html_SECTION00556" name=tex2html46>Модули</A> 
             <p align=justify>П2.5<A href="#index_html_SECTION006" name=tex2html47>Объектная 
               ориентация</A> <br>
               П2.5.1<A href="#index_html_SECTION0061" name=tex2html48>Объекты</A> <br>
               П2.5.2<A href="#index_html_SECTION0062" name=tex2html49>Классы</A> <br>
               П2.5.3<A href="#index_html_SECTION0063" name=tex2html50>Методы</A> <br>
               П2.5.4<A href="#index_html_SECTION0064" name=tex2html51>Вызов метода</A> <br>
               П2.5.5<A href="#index_html_SECTION0065" name=tex2html52>Деструкторы</A> <A NAME="index_html_SECTION002"></A> 
             <h3>П2.1 Основные особенности Perl</h3>
             <A NAME="index_html_SECTION0021"></A> 
             <h3><A NAME="index_html_SECTION0021"></a>П2.1.1 Введение</h3>
             <p align=justify> Perl - интерпретируемый язык, приспособленный для 
               обработки произвольных текстовых файлов, извлечения из них необходимой 
               информациии и выдачи сообщений. Perl также удобен для написания 
               различных системных программ. Этот язык прост в использовании, эффективен, 
               но про него трудно сказать, что он элегантен и компактен. Perl сочитает 
               в себе лучшие черты <TT>C</TT>, <TT>shell</TT>, <TT>sed</TT> и <TT>awk</TT>, 
               поэтому для тех, кто знаком с ними, изучение Perl-а не представляет 
               особого труда. Cинтаксис выражений Perl-а близок к синтаксису <TT>C</TT>. 
               В отличие от большинства утилит ОС <TT>UNIX</TT> Perl не ставит 
               ограничений на объем обрабатываемых данных и если хватает ресурсов, 
               то весь файл обрабатывается как одна строка. Рекурсия может быть 
               произвольной глубины. Хотя Perl приспособлен для сканирования текстовых 
               файлов, он может обрабатывать так же двоичные данные и создавать 
               .dbm файлы, подобные ассоциативным массивам. Perl позволяет использовать 
               регулярные выражения, создавать объекты, вставлять в программу на 
               <TT>С</TT> или <TT>C++</TT> куски кода на Perl-е, а также позволяет 
               осуществлять доступ к базам данных, в том числе <TT>Oracle</TT>. 
               <BR>
               Ниже приводится в качестве примера небольшая программа, которая 
               осуществляет доступ к <TT>Oracle</TT>. 
             <PRE>#! /usr/local/bin/perl -w
 # запуск с ключом печати ошибок.
 use Oraperl;
 # подключение модуля для работы с Oracle
 $system_id = 'T:bdhost.somwere.com:Base';
 # описание имени базы данных
 $lda = &amp;ora_login($system_id, 'scott','tiger');
 # подключение к базе данных пользователя
 # scott с паролем tiger
 $statement = 'create table MYTABLE
 (NAME char(10), TITLE char(20),
 ORGANIZATION varchar2(256))';
 # SQL команда создания таблицы MYTABLE
 $csr = &amp;ora_open($lda, $statement)
 || die $ora_errstr;
 # открытие курсора csr,  если это невозможно,
 # то осуществляется выход  и печать сообщения об ошибке.
 &amp;ora_close($csr);  # закрытие курсора
 open(FL, '/home/my_home_directory/my_file')
 || die &quot;Can't open file \n&quot;;
 # открытие файла, если это невозможно,
 # то выход с печатью сообщения об ошибке
 while ($string = &lt;FL&gt;) {
   # чтение входного потока из файла с дескриптором FL
   @array = split(/\//,$string);
   # считанная строка разбивается в массив
   # строк, разделителем служит слеш
   $st = 'insert into MYTABLE values(:1,:2,:3)';
   # SQL команда помещения в таблицу некоторых значений
   $csr = &amp;ora_open($lda,$st) || $ora_errstr;
   # открытие курсора или печать
   # сообщения об ошибке и выход
   &amp;ora_bind($csr,$array[0],$array[1],$array[2]);
   # привязка значений переменных к величинам, которые
   # требуется поместить в таблицу
   &amp;ora_close($csr);   # закрытие курсора
 }
 close FL; # закрытие файла
 &amp;ora_commit($lda);
 # завершение транзакции в базе данных
 &amp;ora_logoff($lda);
 # отключение от базы данных</PRE>
             <A NAME="index_html_SECTION003"></A> 
             <h3>П2.2 Cтруктуры данных</h3>
             <p align=justify> Perl поддерживает три типа данных: 
             <UL>
               <LI> скаляры 
               <LI> массивы скаляров 
               <LI> ассоциативные массивы скаляров (так называемые хэши).</LI>
             </UL>
             <p align=justify>Обычные массивы, как и в языке C, индексируются числами, 
               начиная с нуля. Ассоциативные массивы индексируются строками. Простые 
               скаляры (в дальнейшем мы будем также называть их переменными) всегда 
               начинаются со знака доллара: <code>$</code>, даже в том случае, 
               когда мы обращаемся к элементу массива. 
             <PRE><TT> &macr;
 <code>$day</code>         простая переменная <code>day</code>
 <code>$day[28]</code>     29  элемент массива <code>day</code>
 <code>$day{'Feb'}</code>  значение 'Feb' из хэша <code>%day</code>
 <code>$#day</code>        последний индекс массива <code>@day</code>
 </TT></PRE>
             Простой массив начинается со знака <code>@</code>: 
             <PRE><TT> &macr;
    <code>@day</code>         массив <code>day</code> - <code>($day[1],$day[2],...)</code>
    <code>@day[3,4,5]</code>  то же, что и <code>@day[3..5]</code>
 </TT></PRE>
             Ассоциативный массив (хэш) начинается со знака процент <code>%</code>:<BR>
             <code>%day</code> <code>(key1, val1, key2, val2, ...)</code> <BR>
             Каждый тип данных имеет свое именное пространство, поэтому вы можете 
             использовать одно и то же имя одновременно для скалярной переменной, 
             массива или хэша (а также для подпрограммы или метки) без опасения, 
             что произойдет ошибка. Perl различает большие и маленькие буквы: <code>FOO</code>, 
             <code>foo</code> и <code>Foo</code> будут рассматриваться Perl-ом 
             как разные переменные. Имена, начинающиеся с буквы или знака подчеркивания, 
             могут в дальнейшем содержать в себе цифры или знаки подчеркивания. 
             Имена, начинающиеся с цифры, могут в дальнейшем содержать только цифры. 
             Имена, начинающиеся не с буквы, цифры или подчерка должны состоять 
             только из одного символа. Большинство таких имен зарезервировано, 
             например <code>$$</code> является идентификатором текущего процесса. 
             Интерпретация команды или величины часто зависит от требований контекста. 
             Существует два основных контекста: скалярный и списковый. Некоторые 
             операции возвращают список величин если в контексте подразумевается 
             список и одну величину, если контекст скалярный. Например, операция 
             <code>&amp;ora_fetch</code> в скалярном контексте возвращает количество 
             выбранных строк:<BR>
             <code>$nfields = &amp;ora_fetch($csr);</code><BR>
             В списковом контексте она возвращает массив выбранных строк:<BR>
             <code>@array = &amp;ora_fetch($csr);</code><BR>
             Левый аргумент определяет контекст правого аргумента. <A NAME="index_html_SECTION0031"></A> 
             <h4>П2.2.1 Скалярные величины</h4>
             <p align=justify> Скалярные переменные могут содержать различные простые 
               типы данных, такие как числа, строки или ссылки. Они не могут содержать 
               сложные типы, но могут содержать ссылку на массив или хэш. В булевском 
               контексте скаляр принимает значение <code>TRUE</code>, если он содержит 
               не нулевое число или не пустую строку. В Perl существует несколько 
               способов записи чисел: 
             <PRE><TT> &macr;
   <code>12345</code>
   <code>12345.67</code>
   <code>.23E-10</code>
   <code>0xffff</code>            шестнадцатеричная запись
   <code>0377</code>             восьмеричная запись.
   <code>1_234_567_890</code>      подчерк для удобства чтения.
 </TT></PRE>
             Строки заключаются в одинарные или двойные кавычки. Использование 
             кавычек в Perl такое же как в <code>bourne shell</code>-е: строка 
             в двойных кавычках обрабатывается и вместо переменных подставляются 
             их значения, а также обрабатываются бакслэш-последовательности, строки 
             в одинарных кавычках рассматривается просто как последовательности 
             символов. Используются также: 
             <PRE><TT> &macr;
   <code>\t</code>      табуляция
   <code>\n</code>     перевод строки
   <code>\r</code>      возврат каретки
   <code>\b</code>     пробел
   <code>\e</code>     символ Escape
   <code>\033</code>    восьмеричный формат
   <code>\x1b</code>    шестнадцатеричный формат
   <code>\c[</code>     управляющая последовательность (control)
   <code>\a</code>      сигнал (alarm)
   <code>\f</code>      переход на следующую страницу
 </TT></PRE>
             <A NAME="index_html_SECTION0032"></A> 
             <h4>П2.2.2 Простые массивы</h4>
             <p align=justify> Perl позволяет произвольно удлинять массив путем 
               обращения к элементу, индекс которого больше, чем последний индекс 
               массива. Так же можно произвольно уменьшить длину массива.<BR>
               <code>@day = ('a','b');</code><BR>
               <code>$day[3] = 'c';</code><BR>
               Теперь массив day содержит три элемента: <code>('a','b','c')</code>.<BR>
               <code>@day = ();</code> или, что то же самое: <code>$#day = -1;</code><BR>
               Теперь массив day пуст.<BR>
               <code>(@day, @month, &amp;SomeSub)</code> содержит в себе элементы 
               массива <code>day</code>, за ними следуют элементы массива <code>month</code>, 
               а за ними результат выполнения подпрограммы <code>SomeSub</code>. 
               Пустой массив обозначается <code>()</code>. Массив <code>((),(),(),())</code> 
               эквивалентен пустому массиву. Последний элемент массива может быть 
               массивом или хэшэм:<BR>
               <code>($a, $b, @c)= split;</code><BR>
               <code>($a, $b, %c)= @_;</code><BR>
               Любой элемент массива может быть массивом. <A NAME="index_html_SECTION0033"></A> 
             <h4>П2.2.3 Ассоциативные массивы</h4>
             <p align=justify> Ассоциативные массивы или хэши содержат пары ``ключ'' 
               и ``значение''. Например: 
             <PRE>  \%map = ('red',0x00f,'blue',0x0f0,'green',0xf00);</PRE>
             Часто для удобства чтения между ``ключом'' и ``значением'' ставят 
             оператор =&gt;. 
             <PRE>  %map = (
           'red'   =&gt; 0x00f,
           'blue'  =&gt; 0x0f0,
           'green' =&gt; )xf00
          );</PRE>
             <A NAME="index_html_SECTION004"></A> 
             <h3>П2.3 Синтаксис языка Perl</h3>
             <A NAME="index_html_SECTION0041"></A> 
             <h4>П2.3.1 Основные понятия</h4>
             <p align=justify> Программа на Perl-е состоит из последовательности 
               команд. В отличие от типизированных языков Perl не требует объявления 
               типов своих объектов. Все объекты, определенные в программе, до 
               присваивания им какого-либо значения по умолчанию принимают значение 
               ``0''. Последовательность команд исполняется сразу, в отличие от 
               <code>sed</code> и <code>awk</code>, где исполняется последовательно 
               каждая строка. Комментарии выделяются знаком <code>#</code>, и вся 
               строка следующая за этим знаком будет рассматриваться как комментарий. 
               Если вы написали подпрограмму, то ее можно вызывать только ниже 
               по тексту программы. Блоком называется последовательность операторов, 
               логически составляющая единое целое в теле программы, как правило, 
               блоки заключаются в фигурные скобки. Каждая команда отделяется от 
               других точкой с запятой. Точка с запятой не обязательна, только 
               если оператор является последним в блоке. <A NAME="index_html_SECTION0042"></A> 
             <h4>П2.3.2 Простые операторы</h4>
             <p align=justify> Последовательность простых операторов может следовать 
               за отдельным модификатором. В Perl-е простыми модификаторами являются:<BR>
               <code>if (EXPR)</code><BR>
               <code>unless (EXPR)</code><BR>
               <code>while (EXPR)</code><BR>
               <code>until (EXPR)</code> В операторах <code>while</code> и <code>until</code> 
               проверка условия происходит перед выполнением тела блока, за исключением 
               одного случая, когда используется do-оператор:<BR>
             <PRE>  do {
       $_ = &lt;STDIN&gt;;
       ...
      } until $_ eq &quot;.\n&quot;;</PRE>
             в котором проверка условия происходит после выполнения блока. Операторы 
             цикла, которые будут описаны далее, не будут работать в этой конструкции, 
             так как отсутствует метка цикла. <A NAME="index_html_SECTION0043"></A> 
             <h4>П2.3.3 Составные операторы</h4>
             <p align=justify> if (EXPR) BLOCK<BR>
               if (EXPR) BLOCK else BLOCK<BR>
               if (EXPR) BLOCK eslif (EXPR) BLOCK else BLOCK<BR>
               LABEL: while (EXPR) BLOCK<BR>
               LABEL: while (EXPR) BLOCK continue BLOCK<BR>
               LABEL: for (EXPR; EXPR; EXPR;...) BLOCK<BR>
               LABEL: foreach VAR(LIST) BLOCK<BR>
               LABEL: BLOCK continue BLOCK 
             <p align=justify> В отличие от <code>C</code> и <code>Pascal</code> 
               все определяется в терминах блоков, а не операторов: то есть фигурные 
               скобки являются обязательными. Метка состоит из идентификатора и 
               двоеточия. Она ставится в начале цикла и служит указателем для операторов 
               цикла <code>next</code>, <code>last</code> и <code>redo</code> (их 
               описание смотри ниже). Если это <code>continue</code> блок, то он 
               выполняется перед тем, как условие будет проверено снова, как третья 
               часть <code>for</code> оператора в <code>C</code>. Правильность 
               условия может зависеть от результатов выполнения блока, например: 
             <PRE>  $i = 1;
   while ($i &lt; 10){
         ...
   } continue {
   $i++;
   }</PRE>
             или, что тоже самое: 
             <PRE>  for ($i = 1; $i &lt; 10; $i++;) {
             ...
   }</PRE>
             Foreach цикл присваивает переменной по очереди каждое значение из 
             списка и выполняет над ней все команды из блока. Переменная является 
             локальной и существует только в пределах данного цикла. Если список 
             является массивом, то его можно изменять в цикле, посредством операций 
             над переменной. Если переменная опускается, то по умолчанию в качестве 
             нее используется <code>$_</code>. 
             <PRE>foreach \$elem(@elements) \{\$elem = \$elem * 2;\}</PRE>
             -- цикл по всему содержимому массива @items. Пример: 
             <PRE>  for ((1,2,3,4,5,6,7,8,9,10,'boom')) {
     print $_,&quot;\n&quot;; sleep(1); }
   for (1..15) { print &quot;Merry Christmas\n&quot;; }
   foreach $item (split(/[\/\*\\n]/,$ENV{'TERMCAP'})) {
     print &quot;Item: $item\n&quot;; }</PRE>
             Блок семантически эквивалентен циклу, который исполняется один раз. 
             Поэтому в него можно включать операторы контроля цикла, чтобы выйти 
             из него или запустить его еще раз. <A NAME="index_html_SECTION0044"></A> 
             <h4>П2.3.4 Операторы языка Perl</h4>
             <A NAME="index_html_SECTION00441"></A> 
             <h4>П2.3.4.1 Термы и операторы списка</h4>
             <p align=justify> Операторы в Perl-е имеют различный приоритет. Операторы, 
               заимствованные из <code>C</code>, сохранили между собой ту же иерархию, 
               что и в <code>C</code>. Термы имеют самый большой приоритет, они 
               содержат переменные, кавычки, выражения в скобках, функции с их 
               параметрами. Если за списковым оператором ( например, <TT>print()</TT>) 
               или унарным оператором ( например, <TT>chdir()</TT>) следует список 
               аргументов, заключенный в скобки, то эта последовательность имеет 
               самый высокий приоритет, подобно функции с аргументами. Аналогично 
               термам обрабатываются последовательности <code>do{}</code> и <code>eval{}</code>. 
               <A NAME="index_html_SECTION00442"></A> 
             <h4>П2.3.4.2 Оператор ``стрелка''</h4>
             <p align=justify> Также, как в <code>С</code> и <code>С++</code> ``-<code>&gt;</code>'' 
               является инфиксным оператором ссылки. Если правая часть является 
               [...] или {...} подпрограммой, тогда левая часть должна быть символьной 
               ссылкой на массив или хэш. Если правая часть - это имя метода или 
               скалярная переменная содержащая имя метода, то левая часть должна 
               быть объектом или именем класса. <A NAME="index_html_SECTION00443"></A> 
             <h4>П2.3.4.3 Операторы ++ и - -</h4>
             <p align=justify> Эти операторы работают также как и в <code>С</code>. 
               То есть, если они стоят перед переменной, то они увеличивают или 
               уменьшают переменную до возвращения значения. Если они стоят после 
               переменной, то увеличение или уменьшение переменной происходит после 
               возврата значения. Если переменная содержит в себе число или употребляется 
               в скалярном контексте, то использование <code>++</code> дает обычное 
               увеличение значения. Если же переменная употреблялась только в строковом 
               контексте, не является пустой строкой и содержит символы <code>a-z,A-Z,0..9</code>, 
               то происходит строковое увеличение значения переменной: <BR>
               <TT>print ++($foo = '99');</TT> - напечатает <code>100</code><BR>
               <TT>print ++($foo = 'a0');</TT> - напечатает <code>a1</code><BR>
               <TT>print ++($foo = 'Az');</TT> - напечатает <code>Ba</code><BR>
               <TT>print ++($foo = 'zz');</TT> - напечатает <code>aaa</code><BR>
             <h4><A NAME="index_html_SECTION00444"></a>П2.3.4.4 Экспоненциальный оператор</h4>
             <p align=justify> В Perl-е двойная звездочка <code>**</code> является 
               экспоненциальным оператором. Он требует к себе даже больше внимания, 
               чем унарный минус: <code>-2**4</code> это <code>-(2**4)</code>, 
               но не <code>(-2)**4</code>. <A NAME="index_html_SECTION00445"></A> 
             <h4>П2.3.4.5 Символьные унарные операторы</h4>
             <p align=justify> Унарный <code>!</code> означает логическое отрицание. 
               Унарный минус, в случае числового значения переменной, обозначает 
               обычное арифметическое отрицание. Если операндом является идентификатор, 
               то возвращается строка, состоящая из знака минус и идентификатора. 
               Если строка начинается со знака <code>+</code> или <code>-</code>, 
               то возвращается строка, начинающаяся с противоположного знака. Унарная 
               тильда ``<code>~</code>'' обозначает побитовое отрицание.<BR>
               Унарный плюс не имеет влияния даже на строки. Он используется для 
               отделения имя функции от выражения заключенного в скобки, которое 
               иначе рассматривается как список аргументов. 
             <PRE>  rand (10) * 20;   -  (rand10) * 20;
   rand +(10) * 20;  -  rand(10 * 20);</PRE>
             Унарный бэкслэш ``'' обозначает ссылку на то, что стоит за ним. <A NAME="index_html_SECTION00446"></A> 
             <h4>П2.3.4.6 Операторы связки</h4>
             <p align=justify> Знак равенства с тильдой ``=<code>~</code>''связывает 
               выражение слева с определенным шаблоном. Некоторые операторы обрабатывают 
               и модифицируют переменную <code>$_</code>. Эти же операции иногда 
               желательно бывает выполнить над другой переменной. Правый аргумент 
               это образец поиска, подстановки или трансляции, левый аргумент - 
               это то, что должно быть подставлено вместо <code>$_</code>. Возвращаемая 
               величина показывает успех операции. Бинарное ``!<code>~</code>'' 
               это тоже самое, что и ``=<code>~</code>'', только возвращаемая величина 
               является отрицательной в логическом смысле. <A NAME="index_html_SECTION00447"></A> 
             <h4>П2.3.4.7 Бинарные операторы</h4>
             <p align=justify> Звездочка <code>*</code> - умножение двух чисел. 
               Cлэш <code>/</code> - деление числа на число. Процент <code>%</code> 
               - вычисляет модуль двух чисел, <code>x</code> - оператор повторения. 
               В скалярном контексте возвращает строку, состоящую из многократно 
               повторенного левого операнда, причем повторяется он то количество 
               раз, которое стоит справа. В списковом контексте он многократно 
               повторяет список. <TT>print 'a' x 80;</TT> напечатает букву <code>a</code> 
               80 раз.<BR>
               <TT>@ones = (1) x 80;</TT> массив из восьмидесяти единиц.<BR>
               <TT>@ones = (5) x @ones</TT> сделает все элементы равными пяти.<BR>
               Бинарный плюс - операция сложения двух чисел.<BR>
               Бинарный минус - операция вычитания двух чисел.<BR>
               Бинарная точка - конкатенация строк.<BR>
               <A NAME="index_html_SECTION00448"></A> 
             <h4>П2.3.4.8 Операторы сдвига</h4>
             <p align=justify> Двоичный сдвиг осуществляется, как и во многих других 
               языках программирования, с помощью операторов ``&lt;&lt;'' и ``&gt;&gt;''. 
               При применении этих операторов значения левых аргументов сдвигаются 
               в соответствующую сторону на количество разрядов, указанное в правых 
               аргументах. Аргументы должны быть целочисленными. <A NAME="index_html_SECTION00449"></A> 
             <h4>П2.3.4.9 Операторы сравнения</h4>
             <p align=justify> ``&lt;'' - возвращает TRUE если левый аргумент численно 
               меньше, чем правый.<BR>
               ``&gt;'' - возвращает TRUE если правый аргумент численно меньше, 
               чем левый.<BR>
               ``&lt;='' - возвращает TRUE если правый аргумент численно меньше 
               или равен левому.<BR>
               ``&gt;='' - возвращает TRUE если левый аргумент численно меньше 
               или равен правому.<BR>
               ``gt'' - возвращает TRUE если левый аргумент меньше (в строковом 
               контексте), чем правый.<BR>
               ``lt'' - возвращает TRUE если правый аргумент меньше (в строковом 
               контексте), чем левый.<BR>
               На поведение операторов <code>lt</code> и <code>gt</code> влияют 
               установки системного языка, если операционная система способна работать 
               с несколькими языками. По этой причине операторы должны корректно 
               работать со строками на языках, отличных от <code>US ASCII</code>, 
               что в системе <code>UNIX</code> задается указанием свойств <code>LC_COLLATE</code> 
               системного <code>locale</code>. <A NAME="index_html_SECTION004410"></A> 
             <h4>П2.3.4.10 Операторы эквивалентности</h4>
             <p align=justify> <code>==</code> возвращает <code>TRUE</code>, если 
               левый аргумент численно эквивалентен правому.<BR>
               <code>!=</code> возвращает <code>TRUE</code>, если левый аргумент 
               численно неэквивалентен правому.<BR>
               &lt;=&gt; возвращает -1, 0 или 1 в зависимости от того, численно 
               меньше, равен или больше левый аргумент правого.<BR>
               <code>eq</code> возвращает <code>TRUE</code>, если левый аргумент 
               эквивалентен правому (в строковом контексте).<BR>
               <code>ne</code> возвращает <code>TRUE</code>, если левый аргумент 
               неэквивалентен правому (в строковом контексте).<BR>
               <code>cmp</code> возвращает -1, 0 или 1 в зависимости от того, меньше 
               равен или больше левый аргумент правого (в строковом контексте).<BR>
               <A NAME="index_html_SECTION0044110"></A> 
             <h4>П2.3.4.11 Побитовое И, побитовое ИЛИ и Исключающее ИЛИ</h4>
             <p align=justify> Бинарное <code>&amp;</code> возвращает объединенные 
               побитово операнды. <BR>
               Бинарное | возвращает перемноженные побитово операнды. <BR>
               Бинарное <code>^</code> возвращает исключенные побитово операнды. 
               <BR>
               <A NAME="index_html_SECTION0044120"></A> 
             <h4>П2.3.4.12 Логическое И и логическое ИЛИ</h4>
             <p align=justify> Бинарное <code>&amp;&amp;</code> - логическое И. 
               Если левый аргумент <code>FALSE</code>, то правый не проверяется. 
               <BR>
               Бинарное || - логическое ИЛИ. Если левый аргумент <code>TRUE</code>, 
               то правый аргумент не проверяется. <BR>
               ||''и <code>&amp;&amp; отличаются от подобных операторов в \verb</code>C| 
               тем, что вместо 0 или 1 они возвращают последнюю обработанную величину. 
               Таким образом, наиболее удобным способом определить домашний каталог 
               пользователя из переменной окружения <code>HOME</code> будет (на 
               практике такой способ определения домашнего каталога пользователя 
               не рекомендуется): 
             <PRE>  $home = $ENV{'HOME'} || $ENV{'LOGDIR'} ||
       (getpwuid($&lt;))[7] || die &quot;You're homeless!\n&quot;;</PRE>
             В качестве более удобной для чтения альтернативы Perl поддерживает 
             операторы <code>and</code> и <code>or</code>, которые будут описаны 
             далее. Их приоритет ниже, однако их можно с удобством использовать, 
             не расставляя скобки, после операторов, аргументами которых являются 
             списки: 
             <PRE>  unlink &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;
        or gripe(), next LINE;</PRE>
             Если писать в стиле <code>C</code>, то это может быть записано так: 
             <PRE>  unlink(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;)
 	  || (gripe(), next LINE);</PRE>
             <A NAME="index_html_SECTION0044130"></A> 
             <h4>П2.3.4.13 Оператор диапазона</h4>
             <p align=justify> <code>..</code> - оператор диапазона. Реально это 
               два разных оператора, в зависимости от контекста. В списковом контексте 
               он работает как оператор диапазона от левого аргумента до правого. 
             <PRE>  for (1..10) {
     #code
     }</PRE>
             В скалярном контексте он возвращает булевское значение. Если левый 
             операнд <code>TRUE</code>, то <code>..</code> принимает значение <code>TRUE</code>, 
             если правый операнд тоже <code>TRUE</code>. 
             <PRE>   if (101..200) { print 'hi;)';}</PRE>
             - напечатает вторую сотню строк <A NAME="index_html_SECTION0044140"></A> 
             <h4>П2.3.4.14 Условный оператор</h4>
             <p align=justify> <code>?:</code> также как и в <code>C</code> является 
               условным оператором. Он работает подобно <code>if-then-else</code>. 
               Если аргумент перед <code>?</code> - <code>TRUE</code>, то возвращается 
               аргумент перед <code>:</code>, в противоположном случае возвращается 
               аргумент после <code>:</code>. Скалярный или списковый контекст 
               второго и третьего аргументов передается по наследству. 
             <PRE>  ($a_or_b ? $a : $b) = $c;</PRE>
             <A NAME="index_html_SECTION0044150"></A> 
             <h4>П2.3.4.15 Операторы присваивания</h4>
             <p align=justify> <code>=</code> - обычный оператор присваивания. 
               Вообще операторы присваивания работают также как и в <code>C</code>. 
               <code>$a += 2;</code> - то же самое, что и <code>$a = $a + 2;</code> 
               Можно использовать следующие сокращения: 
             <PRE>    **=   +=   *=   &amp;=   &lt;&lt;=   &amp;&amp;=
 	  -=   /=   |=   &gt;&gt;=   ||=
           .=   %=   ^=   x=</PRE>
             <code>($a += 2) *= 3;</code> - то же самое, что и : <code>$a = $a 
             + 2;</code> <code>$a = $a * 3;</code> <A NAME="index_html_SECTION0044160"></A> 
             <h4>П2.3.4.16 Оператор ``запятая''</h4>
             <p align=justify> <code>,</code> - оператор запятая или comma-оператор. 
               В скалярном контексте он обрабатывает левый аргумент и отбрасывает 
               его значение, потом обрабатывает правый аргумент и возвращает его 
               величину. В этом он подобен comma-оператору из <code>C</code>. В 
               списковом контексте он играет роль разделителя аргументов и вставляет 
               оба аргумента в список. =&gt; является синонимом comma-оператора. 
               <A NAME="index_html_SECTION0044170"></A> 
             <h4>П2.3.4.17 Логическое НЕ</h4>
             <p align=justify> Унарное <code>NOT</code> возвращает отрицание аргумента. 
               Оно эквивалентно <code>!</code>, за исключением более низкого приоритета. 
               <A NAME="index_html_SECTION0044180"></A> 
             <h4>П2.3.4.18 Логическое И, ИЛИ и Исключающее ИЛИ</h4>
             <p align=justify> <code>and</code> возвращает конъюнкцию двух выражений. 
               Он эквивалентен <code>&amp;&amp;</code>, за исключением более низкого 
               приоритета. <code>or</code> возвращает дизъюнкцию аргументов. Он 
               эквивалентен ||, за исключением более низкого приоритета. <code>xor</code> 
               (eXclusive OR) - исключающее ИЛИ, возвращает истину, если истинен 
               ровно один из аргументов. <A NAME="index_html_SECTION0044190"></A> 
             <h4>П2.3.4.19 Оператор чтения из файла</h4>
             <p align=justify> В Perl есть несколько операций ввода-вывода. Для 
               вывода из файла используется команда &lt;&gt;. 
             <PRE>  open(STDIN,&quot;/etc/passwd&quot;);
   while ($string = &lt;STDIN&gt;)
   {
     @a = split(/[:]/,$string);
   }</PRE>
             Внутри этих скобок стоит дескриптор файла. Считывание происходит построчно. 
             В конце файла <code>&lt;STDIN&gt;</code> принимает значение <code>FALSE</code> 
             и цикл <code>while</code> завершается. По умолчанию считывание происходит 
             в переменную <code>$_</code>. Нулевой дескриптор файла используется 
             также как в <code>sed</code> и <code>awk</code>, то есть считывается 
             поток из файлов перечисленных в командной строке. <A NAME="index_html_SECTION004420"></A> 
             <h4>П2.3.4.20 Оператор замены строки</h4>
             <p align=justify> Оператор <code>s/PATTERN/REPLACEMENT/egimosx</code> 
               производит поиск строки, соответствующей шаблону <code>PATTERN</code> 
               и если строка найдена, то подстановку на ее место текста <code>REPLACEMENT</code>. 
               Возвращает количество произведенных подстановок. Если перед этим 
               не использовался оператор <code>=~</code> или <code>!~</code> для 
               определения переменной, которая будет обрабатываться, то будет модифицироваться 
               переменная <code>$_</code>. Этот оператор используется со следующими 
               опциями: 
             <DL >
               <DT>
               <DD>e интерпретирует правую часть как выражение. 
               <DT>
               <DD>g производит подстановку на место каждой строки, соответствующей 
                 шаблону. 
               <DT>
               <DD>i производит поиск различающий большие и маленькие буквы. 
               <DT>
               <DD>m обрабатывает строку, как состоящую из нескольких строк. 
               <DT>
               <DD>o происходит подстановка только на место первой встреченной 
                 строки. 
               <DT>
               <DD>s обрабатывает строку, как состоящую только из одной строки. 
               <DT>
               <DD>x использует расширенные регулярные выражения.</DD>
             </DL>
             Например: 
             <PRE>$path =~ s|/usr/local/bin|/usr/bin|;
 ($foo = $bar) =~ s/this/that/o;
 $count = ($paragraf =~ s/Mister\b/Mr./gm);</PRE>
             <A NAME="index_html_SECTION0044210"></A> 
             <h4>П2.3.4.21 Оператор замены множества символов</h4>
             <p align=justify> <code> tr/SEARCHLIST/REPLACEMENTLIST/cds y/SEARCHLIST/REPLACEMENTLIST/cds</code> 
               Заменяет все найденные символы из множества символов <code>SEARCHLIST</code> 
               на соответствующие символы из множества символов <code>REPLACEMENTLIST</code>. 
               Возвращает число символов, которые были заменены или удалены. Если 
               посредством операторов <code>=~, !~</code> не была указана никакая 
               строка, то обрабатывается переменная <code>$_</code>. <code>y</code> 
               является синонимом <code>tr</code>. Если <code>SEARCHLIST</code> 
               заключен в скобки, то <code>REPLACEMENTLIST</code> тоже заключается 
               в скобки, которые могут отличаться от тех, в которые заключается 
               шаблон, например: 
             <PRE>tr[A-Z][a-z]
 tr(+-*/)/ABCD/</PRE>
             Этот оператор употребляется со следующими опциями: 
             <DL >
               <DT>
               <DD>c заменяет символы, которые не входят во множество <code>SEARCHLIST</code> 
                 на <code>REPLACEMENTLIST</code>, например: 
                 <PRE>tr/a-zA-Z/ /cs;</PRE>
                 заменит неалфавитные символы. 
               <DT>
               <DD>d Стирает символы, которые ни на что не заменяются. 
               <DT>
               <DD>s Переводит последовательность символов, которые заменяются 
                 на один и тот же символ в один символ.</DD>
             </DL>
             Например: 
             <PRE>$a = 'CCCCCCCCC';
 $a =~ tr/C/D/s;</PRE>
             теперь <code>$a = 'D'</code> <A NAME="index_html_SECTION005"></A> 
             <h3>П2.4 Языковые конструкции Perl</h3>
             <A NAME="index_html_SECTION0051"></A> 
             <h4>П2.4.1 Ссылки</h4>
             <A NAME="index_html_SECTION00511"></A> 
             <h4>П2.4.1.1 Основные понятия</h4>
             <p align=justify> В предыдущих версиях Perl была реализована возможность 
               только символьных ссылок. Perl версии 5 и выше позволяет использовать 
               не только символьные ссылки на переменные, но и ``жесткие'' ссылки 
               на любые данные. Так как любой скаляр может быть ссылкой, а массивы 
               и хэши состоят из скаляров, то можно с легкостью организовать массив 
               массивов, массив хэшей, хэш массивов и так далее. ``Жесткие'' ссылки 
               следят за счетчиком ссылки и как только счетчик становится равным 
               нулю, автоматически удаляют ссылку. Символьные ссылки содержат только 
               имя переменной, также как символьная ссылка файловой системы содержит 
               просто имя файла. Ссылки могут быть созданы несколькими способами: 
             <OL>
               <LI> Используя бэкслэш оператор перед переменной, подпрограммой 
                 или простой константой. (Это работает почти как <code>&amp;</code> 
                 - создается еще одна ссылка, так как одна уже существует в символьной 
                 таблице.) 
                 <PRE>$varref = \$foo;
 $arref = @ARGV;
 $hashref = \%ENV;
 $coderef = \&amp;handler;</PRE>
               <LI> Ссылка на массив может быть создана с использованием квадратных 
                 скобок: 
                 <PRE>$arrayref = [1,2,['a','b','c']];</PRE>
                 По адресу <code>$arrayref[2][1]</code> будет храниться значение 
                 <code>b</code>. 
               <LI> Ссылка на произвольный хэш может быть создана с использованием 
                 фигурных скобок: 
                 <PRE>$hashref = {
     'Earth' =&gt; 'Moon',
     'Jupiter' =&gt; 'Kallisto',
     ...
 };</PRE>
               <LI> Ссылка на подпрограмму может быть создана с использованием 
                 слова <code>sub</code>, без определения имени подпрограммы: 
                 <PRE>$coderef = sub { print &quot;Hello!\n&quot; };</PRE>
               <LI> Ссылки часто возвращаются конструкторами. Объекты Perl на самом 
                 деле являются ссылками на специальную сущность, которая знает, 
                 какой пакет ассоциировать с объектом. Конструкторы это специальные 
                 подпрограммы, которые умеют создавать эту ассоциацию.</LI>
             </OL>
             Чтобы извлечь информацию, на которую указывает ссылка, тоже существует 
             несколько методов: 
             <OL>
               <LI> Можно сделать идентификатор ссылки частью имени переменной 
                 или подпрограммы: 
                 <PRE>$bar = $$scalarref;
 push(@$arrayref,$filename);
 $$arrayref[0] = &quot;January&quot;;
 $$hashref{&quot;key&quot;} = &quot;value&quot;;
 &amp;$coderef(1,2,3);
 $refrefref = \\\&quot;how are you?&quot;;
 print $$$$refrefref;</PRE>
                 - напечатает ``how are you?''.<BR>
                 Нужно понимать, что раскрытие ссылки имеет более высокий приоритет, 
                 чем извлечение значения переменной. 
               <LI> Можно поступить как и в предыдущем случае, но заключить выражение 
                 после знака <code>$</code>в фигурные скобки. Приведенный пример 
                 тогда будет выглядеть таким образом: 
                 <PRE>$bar = ${$scalarref};
 push(@{$arrayref},$filename);
 ${$arrayref}[0] = &quot;January&quot;;
 ${$hashref}{&quot;key&quot;} = &quot;value&quot;;
 &amp;{$coderef}(1,2,3);</PRE>
                 В данном случае использование фигурных скобок ничего не меняет, 
                 но в общем случае в скобках может стоять произвольное выражение, 
                 даже подпрограмма: 
                 <PRE>&amp;{ $dispatch{$index} }(1,2,3);</PRE>
               <LI> В случае массива или хэша можно использовать такую запись: 
                 <PRE>$arrayref-&gt;[0] = &quot;January&quot;;
 $hashref-&gt;{&quot;key&quot;} = &quot;value&quot;;</PRE>
                 Левая часть должна быть выражением, возвращающим ссылку, возможно 
                 также являющуимся раскрытием ссылки: 
                 <PRE>$array[$x]-&gt;{&quot;foo&quot;}-&gt;[0] = &quot;January&quot;;</PRE>
               <LI> Если ссылка является ссылкой на объект, то раскрытие данных 
                 происходит также, как уже было описано выше.</LI>
             </OL>
             Функция <code>ref()</code> может быть использована для определения 
             типа объекта, на который указывает ссылка. Функция <code>bless()</code> 
             может быть использована для ассоциирования ссылки с пакетом, функционирующим 
             как объектный класс. <A NAME="index_html_SECTION00512"></A> 
             <h4>П2.4.1.2 Символьные ссылки</h4>
             <p align=justify> Мы рассмотрели, что происходит, если величина, используемая 
               в качестве ссылки, не была определена ранее. Что же происходит, 
               если она уже определена и не является жесткой ссылкой? В таком случае 
               она обрабатывается как символьная ссылка. То есть значение скаляра 
               рассматривается как имя переменной, а не прямая ссылка на переменную. 
             <PRE><TT> &macr;
 <code>$name = &quot;foo&quot;;</code>
 <code>$$name = 1;</code>   - то же самое, что <code>$foo = 1; </code>
 <code>${$name} = 2;</code> - то же самое, что <code>$foo = 2;</code>
 <code>${$name x 2 }</code> = 3; 	 -то же самое, что <code>$foofoo = 3;</code>
 <code>$name-&gt;[0] = 4;</code> 	 -то же самое, что <code>$foo[0] = 4;</code>
 <code>@$name = ();</code>  - обнуляет массив <code>@foo</code>
 <code>&amp;$name();</code>  - вызывает <code>&amp;foo</code>
 </TT></PRE>
             <A NAME="index_html_SECTION0052"></A> 
             <h4>П2.4.2 Регулярные выражения</h4>
             <p align=justify> Perl позволяет использовать регулярные выражения. 
               Для того чтобы пояснить, что же представляет из себя регулярное 
               выражение приведем несколько примеров:<BR>
               <code>/SWAP.*/</code> - соответствуют все слова начинающиеся со 
               <code>SWAP</code> и заканчивающихся произвольным набором символов. 
               Точка обозначает произвольный символ, звездочка - то, что символ, 
               стоящий перед ней, входит в слово 0 и более раз. Все метасимволы, 
               которые будут описаны ниже, бозначают вхождение того, что стоит 
               перед ними.<BR>
               <code>/\w*/</code> - соответствуют слова состоящие только из алфавитных, 
               цифровых символов и символа подчерк. <code>\w</code> - соответствует 
               алфавитным, цифровым символам и символу подчерк, звездочка - тому, 
               что эти символы могут входить произволное количество раз. Здесь 
               мы приведем только основные метасимволы. Для более подробной информации 
               смотрите соответствующие страницы man по Perl. 
             <PRE><TT> &macr;
 <code>*</code> 	  соответствует 0 или более вхождений
 <code>+</code> 	  соответствует 1 или более вхождений
 <code>?</code> 	  соответствует 1 или 0 вхождений
 <code>{n}</code>  соответствует ровно n вхождений
 <code>{n,}</code>  соответствует по крайней мере n вхождений
 <code>{n,m}</code>  соответствует по крайней мере n,
               	 но не более m вхождений
 </TT></PRE>
             Метасимвол <code>*</code> эквивалентен <code>{0,}</code>, <code>+</code> 
             эквивалентен <code>{1,}</code> и <code>?</code> эквивалентен <code>{0,1}</code>. 
             Ограничений на величину m и n нет. Эта стандартная конструкция работает 
             в ``жадном'' режиме, то есть: регулярному выражению <code>a.*b</code> 
             будет соответствовать всевозможный набор слов начинающихся с символа 
             <code>a</code> и кончающихся символом <code>b</code>, в том числе 
             слова типа <code>abcab</code>. В таких словах есть подпоследовательности 
             символов, которые также удовлетворяют условиям регулярного выражения. 
             Если после каждого из описанных метасимволов поставить знак <code>?</code>, 
             то подобные последовательности будут опускаться. Шаблоны обрабатываются 
             как строка в двойных кавычках, поэтому приведенные ниже последовательности 
             также будут обрабатываться: 
             <PRE><TT> &macr;
 <code>\l</code> 	 - передвижение на символ вниз
 <code>\u</code>  - передвижение на символ вверх
 </TT></PRE>
             А также все перечисленные ранее бакслэш-последовательности. В Perl-е 
             определены также: 
             <PRE><TT> &macr;
 <code>\w</code>  - соответствуют алфавитные и цифровые
               	  символы а также символ подчерк
 <code>\$W</code>  - соответствуют все символы не входящие
        во множество символов w
 <code>\s</code>  - символы пробела, табуляции, возврата каретки
 <code>\S</code>  - все символы не входящие во множество символов
  s
 <code>\d</code>  - цифровые символы
 <code>\D</code>  - нецифровые символы
 </TT></PRE>
             Обратите внимание, что <code>\w</code> отмечает только отдельные символы, 
             а не все слово. Чтобы отметить все слово нужно использовать <code>\w+</code>. 
             Также определены следующие команды: 
             <PRE><TT> &macr;
 <code>\b</code>  - соответствуют границы слова
 <code>\B</code>  - соответствуют не-границы слова
 <code>\A</code>  - соответствуют только начало строки
 <code>\Z</code>  - соответствуют только конец строки
 </TT></PRE>
             При использовании конструкции типа ( ... ), <code>\&lt;digit&gt;</code> 
             подставляет подстроку из скобок с номером <code>digit</code>. Можно 
             использовать скобки для отделения подшаблона. Если в скобках имеется 
             более, чем 9 подстрок, то переменные <code>$10</code>, <code>$11</code>, 
             ... содержат соответствующие подстроки. <code>$+</code> возвращает 
             то, чему соответствует последняя конструкция в скобках. <code>$&amp;</code> 
             возвращает подставленную строку. <code>$`</code> возвращает все перед 
             подставленной строкой, <code>$'</code> возвращает все после подставленной 
             строки. 
             <PRE>  $_ = 'abcdefghi';
   /def/;
   print &quot;$`:$&amp;:$'\n&quot;; - напечатает abc:def:ghi</PRE>
             На этом мы закончим описание регулярных выражений, для более подробной 
             информации читайте <code>manual page</code>. <A NAME="index_html_SECTION0053"></A> 
             <h4>П2.4.3 Зарезервированные переменные</h4>
             <p align=justify> В Perl есть имена имеющие специальное значение. 
               Многие из них аналогичны зарезервированным именам в <code>shell</code>. 
               <BR>
               Если вы хотите использовать длинные имена переменных, в заголовке 
               программы требуется сказать: <BR>
               <code>use English;</code> <BR>
               Многие переменные доступны только для чтения, то есть при попытке 
               присвоения такой переменной какого-либо значения напрямую или по 
               ссылке происходит ошибка. 
             <p align=justify><STRONG>$_</STRONG> В эту переменную по умолчанию 
               происходит ввод, присваивание, в нее складываются результаты поиска 
               по заданному образцу. 
             <PRE>  while(&lt;&gt;){...}</PRE>
             или, что то же самое: 
             <PRE>  while($_= &lt;&gt;) {...}</PRE>
             <p align=justify><STRONG>$&lt;digit&gt;</STRONG> Эта переменная была 
               описана в предыдущем параграфе. Она доступна только для чтения, 
               так же как и переменные <code>$&amp;</code>, <code>$`</code>, <code>$'</code> 
               и <code>$+</code>. 
             <p align=justify><STRONG>$.</STRONG> Эта переменная содержит номер 
               строки, которая была почитана последней из файла, который был прочитан 
               последним. Она также доступна только для чтения. 
             <p align=justify><STRONG>$/</STRONG> Содержит символ по которому разделяются 
               вводимые записи. По умолчанию содержит символ перевода строки. Она 
               похожа на переменную <code>RS</code> из <code>awk</code>. 
             <p align=justify><STRONG>$|</STRONG> По умолчанию имеет значение 0. 
               Если содержит ненулевое значение, то происходит сброс буферов каждый 
               раз после осуществления вывода (на печать, на экран и т.д.). 
             <p align=justify><STRONG>$,</STRONG> Содержит символ-разделитель полей 
               для оператора печати. Подобна переменной <code>OFS</code> в <code>awk</code>. 
             <p align=justify><STRONG>$</STRONG> Содержит символ-разделитель записей 
               для оператора печати. Подобна переменной <code>ORS</code> в <code>awk</code>. 
               (Вы можете определить $ вместо того, чтобы печатать n в конце печати.) 
             <p align=justify><STRONG>$&quot;</STRONG> Подобна переменной <code>$,</code>. 
               Но используется при обращении к списку величин в двойных кавычках 
               (или другой строке, которая требует интерпретации). По умолчанию 
               содержит символ пробел. 
             <p align=justify><STRONG>$;</STRONG> Содержит символ-разделитель для 
               эмуляции многомерных хэшей. Если ссылаться на такой элемент хэша 
               как <code>$foo{$a,$b,$c}</code> то реально это будет происходить 
               так: <code>$foo{join($;,$a,$b,$c)}</code>. Не путайте с <code>@foo{$a,$b,$c}</code>, 
               так как это тоже самое, что<code>($foo{$a},$foo{$b},$foo{$c})</code>. 
               По умолчанию содержит значение <code>\034</code> такое же как переменная 
               <code>SUBSEP</code> в <code>awk</code>. 
             <p align=justify><STRONG>$#</STRONG> Формат для печати чисел. Подобна 
               переменной <code>OFMT</code> в <code>awk</code>. Первоначально содержит 
               значение %.20g. 
             <p align=justify><STRONG>$%</STRONG> Содержит номер текущей выводимой 
               страницы. 
             <p align=justify><STRONG>$=</STRONG> Содержит длину текущей страницы 
               (количество печатных срок), обычно содержит значение 60. 
             <p align=justify><STRONG>$-</STRONG> Содержит значение, определяющее 
               количество оставшихся на странице строк, например количество еще 
               не напечатанных строк для печатного канала вывода. 
             <p align=justify><STRONG>$~ </STRONG> Содержит имя текущего формата 
               сообщений. Обычно имя дескриптора файла. 
             <p align=justify><STRONG>$^</STRONG> Содержит имя текущего формата 
               заголовка страницы. Обычно содержит имя дескриптора файла с добавлением 
               в конце <code>_TOP</code> 
             <p align=justify><STRONG>$:</STRONG> Содержит множество символов после 
               которых вывод сроки может быть прерван и начат снова после перевода 
               строки. 
             <p align=justify><STRONG>$!</STRONG> Если эта переменная используется 
               в числовом контексте, то содержит текущее значение errno (номер 
               ошибки) со всеми обычными сообщениями. В строковом контексте содержит 
               соответствующее системное сообщение об ошибке. 
             <p align=justify><STRONG>$@</STRONG> Содержит сообщение о синтаксической 
               ошибке, допущенной во время исполнения последней команды <code>eval()</code>. 
               Если содержит значение 0, то команда была исполнена корректно. Но 
               заметьте, что сообщения не накапливаются в этой переменной. 
             <p align=justify><STRONG>$$</STRONG> Содержит идентификатор текущего 
               процесса. 
             <p align=justify><STRONG>$&lt;</STRONG> Содержит идентификатор пользователя 
               (UID), которому принадлежит текущий процесс. 
             <p align=justify><STRONG>$&gt;</STRONG> Содержит эффективный UID текущего 
               процесса. 
             <p align=justify><STRONG>$(</STRONG> Содержит идентификатор группы 
               (GID) пользователя, которому принадлежит текущий процесс. 
             <p align=justify><STRONG>$)</STRONG> Содержит эффективный GID текущего 
               процесса. 
             <p align=justify><STRONG>$0</STRONG> Содержит имя файла, в котором 
               находится исполняемая программа. 
             <p align=justify><STRONG>$ARGV</STRONG> Содержит имя текущего файла, 
               из которого происходит чтение. 
             <p align=justify><STRONG>@ARGV</STRONG> Содержит массив аргументов 
               командной строки, которые были переданы программе. 
             <p align=justify><STRONG>@INC</STRONG> Содержит список точек входа 
               в программу, в которых используются конструкции <code>do EXPR</code>, 
               <code>require</code> и <code>use</code>. 
             <p align=justify><STRONG>%INC</STRONG> Содержит входы для каждого 
               файла, который включается посредством использования операторов <code>do</code> 
               или <code>require</code>. Ключами являются имена файлов, а значениями 
               места их расположения. 
             <p align=justify><STRONG>%ENV</STRONG> Содержит текущее окружение 
               процесса. Изменением содержимого хэша можно изменить окружение порожденного 
               (дочернего) процесса. 
             <p align=justify><STRONG>%SIG</STRONG> Этот хэш используется для установки 
               обработчиков различных сигналов. Например: 
             <PRE>  sub handler {
       local($sig) = @_;
       print &quot;Caught a SIG$sig - shutting down\n&quot;;
       close(LOG);
       exit(0);
   }
   $SIG{'INT'} = 'handler';
   $SIG{'QUIT'} = 'handler';
   ...
   $SIG{'INT'} = 'DEFAULT';
   $SIG{'QUIT'} = 'IGNORE';</PRE>
             <A NAME="index_html_SECTION0054"></A> 
             <h4>П2.4.4 Встроенные функции</h4>
             <p align=justify><STRONG>abs VALUE</STRONG> Возвращает абсолютное 
               значение аргумента. 
             <p align=justify><STRONG>accept NEWSOCKET, GENERICSOCKET</STRONG> 
               подобно системному вызову <code>accept(2)</code> ждет соединения. 
               Возвращает запакованный адрес, если соединение произошло успешно 
               и <code>FALSE</code> в противоположном случае. 
             <p align=justify><STRONG>atan2 Y,X</STRONG> Возвращает <code>arctg(Y/X)</code>. 
             <p align=justify><STRONG>bind SOCKET, NAME</STRONG> Привязывает сетевой 
               адрес к сокету, также как системный вызов <code>bind</code> в <code>OS 
               UNIX</code> или любой другой системе, поддерживающей <code>BSD Sockets</code>. 
               Если привязка произошла успешно, возвращает <code>TRUE</code>, в 
               противном случае - <code>FALSE</code>. Переменная <code>NAME</code> 
               должна содержать запакованный адрес, соответствующего для сокета 
               типа. Тип адреса для разных видов сокетов определяется в терминах 
               языка <code>C</code> структурой <code>sockaddr</code>, которая представляет 
               собой абстрактный тип, содержащий все данные, необходимые для сокета. 
             <p align=justify><STRONG>binmode FILEHANDLE</STRONG> Позволяет читать 
               или писать файл с соответствующим дескриптором в бинарном режиме. 
             <p align=justify><STRONG>bless REF, PACKAGE</STRONG> Эта функция присоединяет 
               объект на который указывает ссылка <code>REF</code>, к пакету <code>PACKAGE</code>, 
               если он определен, если же он опущен, то к текущему пакету. Для 
               удобства возвращает ссылку, так как <code>bless()</code> часто является 
               последним оператором в конструкторе. 
             <p align=justify><STRONG>caller EXPR</STRONG> Возвращает контекст 
               текущего вызова подпрограммы. В скалярном контексте возвращает <code>TRUE</code>, 
               если мы находимся внутри подпрограммы, <code>eval()</code> или <code>require()</code>. 
               <code>FALSE</code> в противоположном случае. В списковом контексте 
               возвращает: 
             <PRE>  ($package, $filename, $line) = caller;</PRE>
             С аргументом <code>EXPR</code> возвращает более сложную информацию, 
             которая используется отладчиком для печати карты стека. Значение <code>EXPR</code> 
             отмечает глубину стека до текущей записи. 
             <PRE>  ($package, $filename, $line,
    $subroutine, $hasargs, $wantargs) = caller($i);</PRE>
             <p align=justify><STRONG>chdir EXPR</STRONG> Изменяет текущую директорию 
               на указанную в <code>EXPR</code>, если это возможно. Если <code>EXPR</code> 
               опущено, то устанавливает в качестве текущей директории домашнюю 
               директорию. Возвращает <code>TRUE</code> в случае успеха и <code>FALSE</code> 
               иначе. 
             <p align=justify><STRONG>chmod LIST</STRONG> Изменяет права доступа 
               к файлам указанным в <code>LIST</code>. Первым аргументом должна 
               быть маска доступа в цифровом формате. Возвращает число файлов права 
               доступа к которым были успешно сменены. 
             <PRE>  $cnt = chmod 0700 'foo','bar';
   chmod 700 @executables;</PRE>
             <p align=justify><STRONG>chown LIST</STRONG> Изменяет хозяина или 
               группу, которой принадлежит список файлов. Первыми двумя аргументами 
               должны быть uid и gid. Возвращает количество успешных изменений. 
             <p align=justify><STRONG>chr NUMBER</STRONG> Возвращает символ, представленный 
               номером <code>NUMBER</code> в наборе символов. Например, <code>chr(65)</code> 
               вернет <code>A</code>. 
             <p align=justify><STRONG>close FILEHANDLE</STRONG> Закрывает файл 
               с дескриптором <code>FILEHANDLE</code>. Для более подробной информации 
               читайте <code>manual page</code>. 
             <PRE>  open(OUTPUT '/usr/home/petrov');
   ...
   close OUTPUT;</PRE>
             <p align=justify><STRONG>closedir DIRHANDLE</STRONG> Закрывает каталог 
               открытый вызовом <code>opendir()</code>. 
             <p align=justify><STRONG>connect SOCKET,NAME</STRONG> Пытается соединиться 
               с удаленным сокетом (по аналогии с системным вызовом). Возвращает 
               <code>TRUE</code> в случае успешного соединения и <code>FALSE</code> 
               в противоположном случае. Переменная <code>NAME</code> должна содержать 
               запакованный адрес соответствующего данному сокету типа. 
             <p align=justify><STRONG>cos EXPR</STRONG> Возвращает косинус <code>EXPR</code>, 
               выраженного в радианах. Если <code>EXPR</code> опущено, возвращает 
               косинус <code>$_</code>. 
             <p align=justify><STRONG>dbmopen ASSOC, DBNAME, MODE</STRONG> Связывает 
               <code>dbm(3)</code> или <code>ndbm(3)</code> файл с ассоциативным 
               массивом. <code>ASSOC</code> - имя ассоциативного массива. <code>DBNAME</code> 
               - имя базы данных (без .dir или <code>.pag</code> расширения). Если 
               база данных не существует, то она создается с правами доступа указанными 
               в <code>MODE</code>. 
             <PRE>  dbmopen(%HIST,'/usr/lib/news/history', 0600);
   while (($key, $val) = each %HIST){
       print $key, '=', unpack('L',$val),\n;}
   dbmclose(%HIST);</PRE>
             <p align=justify><STRONG>dbmclose ASSOC</STRONG> Прерывает связь между 
               файлом и ассоциативным массивом. 
             <p align=justify><STRONG>defined EXPR</STRONG> Возвращает <code>TRUE</code> 
               или <code>FALSE</code>, в зависимости от того определено значение 
               <code>EXPR</code> или нет. Многие операции возвращают неопределенное 
               значение в случае конца файла, неинициализированной переменной, 
               системной ошибки или при подобной ситуации. Если речь идет о хэше, 
               то defined покажет только определены ли ли величины, ничего не говоря 
               о существовании ключей. Для определения существования ключей используется 
               функция <code>exists()</code>. 
             <p align=justify><STRONG>delete EXPR</STRONG> Стирает указанную величину. 
               Возвращает удаленную величину или значение не определено в случае, 
               если удаление не произошло. 
             <PRE>  foreach $key (keys %array) {
      delete $array{$key};
   }</PRE>
             Но более быстро то же самое можно сделать используя функцию <code>undef()</code>. 
             <p align=justify><STRONG>die LIST</STRONG> Вне <code>eval()</code> 
               печатает значение <code>LIST</code> в <code>STDERR</code> и выходит 
               из программы с текущим значением <code>$!</code>. Если значение 
               <code>$!</code> есть ноль, то принимает значение <code>$? &gt;&gt; 
               8</code>. Если значение <code>$? &gt;&gt; 8</code> есть ноль, то 
               принимает значение 255. Внутри <code>eval()</code> сообщение об 
               ошибке помещается в переменную <code>$@</code> и <code>eval()</code> 
               прерывается с неопределенным значением. 
             <PRE>  open(FL, &quot;/root/rm-rf&quot;) || die &quot;Can't open file.\n&quot;;</PRE>
             <p align=justify><STRONG>do BLOCK</STRONG> Функцией не является. Возвращает 
               значение последней операции внутри блока. 
             <p align=justify><STRONG>do EXPR</STRONG> Использует величину <code>EXPR</code> 
               как имя файла и далее запускает содержимое этого файла, как программу 
               на Perl. Обычно это используется для включения библиотечных подпрограмм. 
             <PRE>  do 'stat.pl';</PRE>
             Это то же самое, что: 
             <PRE>  eval 'cat stat.pl';</PRE>
             Однако подключать библиотечные модули более удобно используя <code>use</code> 
             и <code>require</code>. 
             <p align=justify><STRONG>each ASSOC_ARRAY</STRONG> Возвращает массив 
               из двух элементов, содержащий ключ и значение из хэша, причем по 
               очереди перебирает все пары <code>($key, $value)</code>. 
             <PRE>  while (($key,$value) = each %ENV){
   print &quot; $key = $value \n&quot;;
   }</PRE>
             <p align=justify><STRONG>eof FILEHANDLE</STRONG> Возвращает 1, если 
               следующее считывание возвращает конец файла или если <code>FILEHANDLE</code> 
               не был открыт. При опущении аргумента <code>eof</code> обрабатывает 
               последний файл, из которого происходило считывание. Но на практике 
               эта функция редко используется, так как в Perl-е операторы чтения 
               возвращают неопределенное значение в конце файла. 
             <p align=justify><STRONG>eval EXPR</STRONG> <code>EXPR</code> выполняется 
               как маленькая программа в контексте основной программы. Определенные 
               переменные и подпрограммы остаются определенными и в дальнейшем. 
               Возвращается значение, которое возникает при обработке последнего 
               выражения. Если <code>EXPR</code> опущено, то обрабатывается <code>$_</code>. 
             <p align=justify><STRONG>exec LIST</STRONG> Исполняет внешнюю программу 
               и НИКОГДА не возвращает управление. На самом деле (в <code>UNIX</code>) 
               производится системный вызов семейства <code>exec</code>, который 
               подменяет программу, исполняющуюся в рамках текущего процесса. Если 
               <code>LIST</code> представляет собой список из более, чем одного 
               аргумента, то вызывается <code>execvp(3)</code> с аргументами из 
               <code>LIST</code>. Если аргумент только один, то он проверяется 
               на метасимволы <code>shell</code>. Если они присутствуют, то он 
               далее передается <code>/bin/sh -c</code> для обработки. Если же 
               их нет, то аргумент передается напрямую <code>execvp</code>, который 
               более эффективен. 
             <p align=justify><STRONG>exists EXPR</STRONG> Возвращает <code>TRUE</code>, 
               если в хэше есть ключи и даже в том случае, когда значения <code>VALUE</code> 
               не определены. 
             <p align=justify><STRONG>exit EXPR</STRONG> Обрабатывает <code>EXPR</code> 
               и осуществляет немедленный выход с полученной величиной. 
             <PRE>  $ans = &lt;STDIN&gt;;
   exit 0 if $ans =~ /^[Xx]/;</PRE>
             Если <code>EXPR</code> опущено, то осуществляет выход с нулевым статусом. 
             <p align=justify><STRONG>exp EXPR</STRONG> Возвращает е (основание 
               натурального логарифма e = 2.718281828...) в степени <code>EXPR</code>. 
               По умолчанию обрабатывается <code>$_</code>. 
             <p align=justify><STRONG>fork</STRONG> Делает системный вызов <code>fork(2)</code>. 
               Возвращает pid (идентификатор процесса) дочернего процесса родительскому 
               процессу и 0 дочернему процессу. Значение не определено в случае 
               неуспешного завершения команды. Неуспех может произойти, например, 
               в случае установки в системе ограничения на количество процессов 
               данного пользователя. Вот небольшой пример использования этой функции. 
             <PRE>  unless ($pid = fork) {
       unless (fork) {
           exec &quot;what you really wanna do&quot;;
           die &quot;no exec&quot;;
           some_perl_code_here;
           exit 0;
       }
       exit 0;
   }
   waitpid($pid,0);</PRE>
             <p align=justify><STRONG>getc FILEHANDLE</STRONG> Возвращает следующий 
               символ из файла чтения, присоединенный к <code>FILEHANDLE</code> 
               или пустую строку в случае конца файла. Если <code>FILEHANDLE</code> 
               опущен, то считывание происходит из <code>STDIN</code>. 
             <p align=justify><STRONG>goto LABEL</STRONG> Эта функция осуществляет 
               переход на точку программы <code>LABEL</code> и продолжает выполнение 
               программы с этой точки. Точка не может находиться внутри подпрограммы 
               или <code>foreach</code> цикла, так как в этих случаях требуется 
               предварительная инициализация. Использовать в качестве <code>LABEL</code> 
               выражение не рекомендуется, хотя такая возможность и предоставляется. 
             <p align=justify><STRONG>grep BLOCK, LIST</STRONG> 
             <p align=justify><STRONG>grep EXPR, LIST</STRONG> Обрабатывает <code>BLOCK</code> 
               или <code>EXPR</code> для каждого элемента <code>LIST</code> и возвращает 
               список элементов для которых значение выражения <code>TRUE</code>. 
               В скалярном контексте возвращает число элементов для которых <code>EXPR 
               TRUE</code>. 
             <p align=justify><STRONG>hex EXPR</STRONG> Возвращает десятичное значение 
               <code>EXPR</code>, интерпретируемого как шестнадцатеричная строка. 
               По умолчанию обрабатывает переменную <code>$_</code>. 
             <p align=justify><STRONG>kill LIST</STRONG> Посылает сигнал списку 
               процессов <code>LIST</code>, первым элементом списка должен быть 
               номер сигнала. Возвращает число процессов, которым сигнал был послан 
               успешно. В отличие от <code>shell</code>, если номер сигнала отрицателен, 
               то он посылается группе процессов. 
             <p align=justify><STRONG>int EXPR</STRONG> Возвращает целую часть 
               <code>EXPR</code>, если <code>EXPR</code> опущено, то обрабатывает 
               переменную <code>$_</code>. 
             <p align=justify><STRONG>join EXPR,LIST</STRONG> Соединяет в единую 
               строку строки из <code>LIST</code>. При этом в качестве разделителей 
               между элементами <code>LIST</code> ставит значение <code>EXPR</code>. 
               Например: 
             <PRE>  $_ = join( ':',$login,$passwd,
   $uid,$gid,$gcos,$home,$shell);</PRE>
             <p align=justify><STRONG>keys ASSOC_ARRAY</STRONG> Возвращает обычный 
               массив, состоящий из ключей ассоциативного массива <code>ASSOC_ARRAY</code>. 
               В скалярном контексте возвращает число ключей. 
             <PRE>  @keys = keys %ENV;</PRE>
             <p align=justify><STRONG>length EXPR</STRONG> Возвращает длину <code>EXPR</code> 
               в символах. По умолчанию обрабатывает переменную <code>$_</code>. 
             <p align=justify><STRONG>link OLDFILE,NEWFILE</STRONG> Создает файл 
               <code>NEWFILE</code>, присоединенный к файлу <code>OLDFILE</code>. 
               (В <code>OS UNIX</code> создание нескольких имен для одного файла) 
               Возвращает 1 в случае успеха и 0 иначе. 
             <p align=justify><STRONG>listen SOCKET, QUEUESIZE</STRONG> Делает 
               то же самое, что и одноименный системный вызов. Возвращает <code>TRUE</code> 
               в случае успеха, <code>FALSE</code> иначе. 
             <p align=justify><STRONG>local EXPR</STRONG> На самом деле гораздо 
               эффективнее использовать функцию <code>my</code>. Функция <code>local</code> 
               делает перечисленные переменные локальными в блоке, подпрограмме, 
               <code>eval</code> или <code>do</code>. Если переменных более, чем 
               одна, то они должны объединяться скобками. 
             <PRE>  sub RANGEVAL{
       local($min,$max,$thunk) = @_;
       local $result = '';
       local $i;
       for ($i = $min; $i &lt; $max; $i++) {
           $result = eval $thunk;
       }
       $result;
   }</PRE>
             <p align=justify><STRONG>log EXPR</STRONG> Возвращает натуральный 
               логарифм <code>EXPR</code>, по умолчанию обрабатывает переменную 
               <code>$_</code>. 
             <p align=justify><STRONG>map EXPR,LIST</STRONG> Подставляет каждый 
               элемент из списка <code>LIST</code> в <code>EXPR</code> (которое 
               может быть блоком) и возвращает список полученных после обработки 
               величин. 
             <PRE>  @chars = map(chr, @nums);</PRE>
             <p align=justify><STRONG>mkdir FILENAME,MODE</STRONG> Создает директорию 
               с именем <code>FILENAME</code> и правами доступа указанными в переменной 
               <code>MODE</code>. В случае успеха возвращает 1, в противном случае 
               возвращает 0 и устанавливает значение переменной <code>$!(errno)</code>. 
             <p align=justify><STRONG>my EXPR</STRONG> Эта функция (так же как 
               и описанная ранее функция <code>local</code>) делает перечисленные 
               переменные локальными в пределах блока, подпрограммы, eval или do. 
               Если список состоит более чем из одного элемента, то он должен быть 
               заключен в скобки. Все элементы в списке должны быть фактическими 
               параметрами. В отличие от local, переменные локализованные функцией 
               <code>my</code> не видны снаружи блока, подпрограммы или другой 
               конструкции, внутри которой <code>my</code> употребляется. 
             <p align=justify><STRONG>next LABEL</STRONG> Употребляется подобно 
               continue оператору в <code>C</code> - запускает следующую итерацию 
               цикла. 
             <PRE>   line: while (&lt;STDIN&gt;) {
    next line if /^#/;
    ...
    }</PRE>
             <p align=justify><STRONG>oct EXPR</STRONG> Возвращает десятичное значение 
               <code>EXPR</code>, интерпретируемого как строка в восьмеричном формате. 
               (Если строка начинается с <code>0x</code>, то интерпретируется, 
               как строка в шестнадцатеричном формате.) 
             <p align=justify><STRONG>open FILEHANDLE,EXPR</STRONG> Открывает файл, 
               имя которого описано в переменной <code>EXPR</code> и привязывает 
               его к <code>FILEHANDLE</code>. Если <code>EXPR</code> опущено, то 
               переменная с таким же именем как <code>FILEHANDLE</code> содержит 
               имя файла. Если имя файла начинается со знака: 
             <PRE><TT> &macr;
 <code>&lt;</code>  файл открывается на чтение.
 <code>&gt;</code>  файл открывается на запись.
 <code>&gt;&gt;</code>  файл открывается для добавления.
 <code>|</code>   имя файла расценивается как команда,
     с которой будет организован программный канал,
     то есть вывод в дескриптор FILEHANDLE будет
     передаваться на вход программе EXPR.
 </TT></PRE>
             <p align=justify> Если знак <code>|</code> указывается после имени 
               команды, то вывод этой команды будет ассоциирован с дескриптором 
               <code>FILEHANDLE</code>, из которого будет производиться чтение. 
               Интересно, что нельзя открыть двойной программный канал, то есть 
               ассоциировать ввод и вывод команды с дескриптором файла (что соответствовало 
               бы системному вызову <code>popen</code> в <code>UNIX</code>). 
             <p align=justify>В случае, когда имя файла оканчивается вертикальной 
               чертой, оно расценивается как имя команды, вывод которой будет интерпретироваться 
               как ввод из файла (аналог функции <code>popen(3)</code>). 
             <PRE>  open(LOG, '&gt;&gt;/usr/spool/news/twitlog');</PRE>
             <p align=justify><STRONG>open DIRHANDLE,EXPR</STRONG> Открывает директорию 
               с именем <code>EXPR</code>, возвращает <code>TRUE</code> в случае 
               успеха. 
             <p align=justify><STRONG>ord EXPR</STRONG> Возвращает числовое значение 
               в таблице ASCII первого символа <code>EXPR</code>. По умолчанию 
               обрабатывает переменную <code>$_</code>. 
             <p align=justify><STRONG>print FILEHANDLE,LIST</STRONG> Печатает строку 
               или несколько строк, разделенных запятой. <code>FILEHANDLE</code> 
               может быть именем скалярной переменной, содержащей дескриптор файла. 
               Если эта переменная опущена то печать идет в выбранный канал вывода. 
               Если переменная <code>LIST</code> тоже опущена, то печатает переменную 
               <code>$_</code> в <code>STDOUT</code>. 
             <p align=justify><STRONG>printf FILEHANDLE, LIST</STRONG> Эквивалентно 
               <code>print FILEHANDLE, sprintf(LIST)</code>. Первый аргумент <code>LIST</code> 
               интерпретируется как формат печати. 
             <p align=justify><STRONG>rand EXPR</STRONG> Возвращает выбранное случайным 
               способом значение между 0 и <code>EXPR</code>. <code>EXPR</code> 
               должно быть положительным. По умолчанию производит выборку в диапазоне 
               между 0 и 1. (Замечание: если ваша функция постоянно возвращает 
               слишком большие или слишком малые значения, то скорее всего была 
               допущена ошибка при компиляции вашей версии Perl. Было установлено 
               неверное значение <code>RANDBITS</code>.) 
             <p align=justify><STRONG>read FILEHANDLE,SCALAR,LENGTH,OFFSET</STRONG> 
               Считывает <code>LENGTH</code> байт данных из <code>FILEHANDLE</code> 
               в переменную <code>SCALAR</code>. Возвращает число считанных байт 
               или неопределенное значение в случае ошибки. Если вы хотите считать 
               данные не с начала строки, то для этого нужно установить значение 
               переменной <code>OFFSET</code>. 
             <p align=justify><STRONG>readlink EXPR</STRONG> Возвращает значение 
               символьной ссылки, если она существует. Если же ее нет, то выдает 
               fatal error и устанавливает значение переменной <code>$!</code>. 
               По умолчанию обрабатывает переменную <code>$_</code>. 
             <p align=justify><STRONG>redo LABEL</STRONG> Перезапускает цикл без 
               повторной обработки условия. Блок continue, если он есть не исполняется. 
               Если <code>LABEL</code> опущена, то команда выполняется для внутреннего 
               цикла. 
             <PRE>  line: while(&lt;STDIN&gt;) {
       while ($_ ne '\') {
 	if (ord $_ &lt; 86) {
 	  ...
 	}
 	redo line;
       }
       print;
    }</PRE>
             <p align=justify><STRONG>ref EXPR</STRONG> Возвращает <code>TRUE</code>, 
               если <code>EXPR</code> является ссылкой и <code>FALSE</code> в противоположном 
               случае. Полученное значение зависит от типа объекта на который указывает 
               ссылка. Существует несколько встроенных типов данных: 
             <UL>
               <LI> REF
               <LI> SCALAR
               <LI> ARRAY
               <LI> HASH
               <LI> CODE
               <LI>GLOB</LI>
             </UL>
             Если объект, на который указывает ссылка, находится в пакете (<code>package</code>), 
             то в таком случае возвращается имя пакета. 
             <PRE>  if (ref($r) eq &quot;HASH&quot;) {
       print &quot; Это ссылка на ассоциативный массив.\n&quot;;
   }
   if (!ref($r)) {
       print &quot; А это не ссылка вовсе! \n&quot;;</PRE>
             <p align=justify><STRONG>require EXPR</STRONG> Используется для подключения 
               модулей. 
             <PRE>  require &quot;oraperl.pm&quot;;</PRE>
             <p align=justify><STRONG>reset EXPR</STRONG> Обычно используется в 
               <code>continue</code> блоке в конце цикла для переустановки значений 
               переменных. <code>EXPR</code> интерпретируется как список отдельных 
               символов. Значения переменных и массивов, имена которых начинаются 
               с одного из этих символов списка переустанавливаются. Например: 
             <PRE><TT> &macr;
 <code>reset 'X'</code>  переустановит все X переменные
 <code>reset 'a-z'</code>  переустановит все переменные,
                                      имена которых состоят из маленьких букв.
 </TT></PRE>
             <p align=justify><STRONG>rm FILENAME</STRONG> Удаляет файл или директорию 
               с заданным именем. Возвращает 1 в случае успеха, 0 в противоположном 
               случае и устанавливает значение переменной <code>$!</code>. По умолчанию 
               обрабатывает аргумент <code>$_</code>. 
             <p align=justify><STRONG>scalar EXPR</STRONG> Выражение будет трактоваться 
               в скалярном контексте. Возвращает значение <code>EXPR</code>. 
             <p align=justify><STRONG>seek FILEHANDLE, POSITION, WHENCE</STRONG> 
               Позволяет установить курсор в файле, определенном в переменной <code>FILEHANDLE</code>, 
               на позицию <code>POSITION</code> в режиме, указанном в переменной 
               <code>WHENCE</code>. Если переменная <code>WHENCE</code> содержит 
               значение 0, то позиция отсчитывается от начала файла, если 1 то 
               от текущей позиции и если 2, то от конца файла. Возвращает 1 в случае 
               успеха и 0 иначе. 
             <p align=justify><STRONG>select FILEHANDLE</STRONG> Возвращает текущий 
               выбранный <code>FILEHANDLE</code>. Направляет вывод в <code>FILEHANDLE</code>. 
             <p align=justify><STRONG>select RBITS,WBITS,EBITS,TIMEOUT</STRONG> 
               Вызывает системный вызов <code>select(2)</code> с определенной аргументами 
               битовой маской. 
             <p align=justify><STRONG>shift ARRAY</STRONG> Сдвигает массив <code>ARRAY</code> 
               влево с удалением первого элемента и возвращает удаленный элемент. 
               Если в массиве нет элементов, то возвращает неопределенное значение. 
               Если <code>ARRAY</code> опущен, то обрабатывает массив <code>@ARGV</code> 
               в главной программе и массив <code>@_</code> в подпрограммах. 
             <p align=justify><STRONG>sin EXPR</STRONG> Возвращает синус выражения 
               <code>EXPR</code> (выраженного в радианах). Если аргумент опущен, 
               то обрабатывается переменная <code>$_</code>. 
             <p align=justify><STRONG>sleep EXPR</STRONG> Дает процессу команду 
               остановки на <code>EXPR</code> секунд. Если аргумент опущен, то 
               процесс зависает навсегда. В таком случае ``сон'' можно прервать, 
               послав ему сигнал. Возвращает число секунд, в течение которых процесс 
               был в состоянии остановки. 
             <p align=justify><STRONG>socket SOCKET,DOMAIN,TYPE,PROTOCOL</STRONG> 
               Создает сокет и привязывает его к дескриптору файла <code>SOCKET</code>. 
               Остальные параметры описываются так же, как и в одноименном системном 
               вызове. В начале программы необходимо написать <code>use Socket;</code>. 
             <p align=justify><STRONG>sort SUBROUTINE,LIST</STRONG> Сортирует аргументы 
               из <code>LIST</code> и возвращает отсортированный список. Если список 
               является массивом, то несуществующие элементы массива не учитываются 
               и не возвращаются. Ниже приведено несколько примеров. 
             <PRE>    @articles = sort @files;</PRE>
             - Лексическая сортировка без использования подпрограммы. 
             <PRE>  @articles = sort{$a cmp $b} @files;</PRE>
             - То же самое, но с использованием подпрограммы. 
             <PRE>  @articles = sort{$a &lt;=&gt; $b} @files;</PRE>
             - Численная сортировка по возрастанию. 
             <p align=justify><STRONG>splice ARRAY,OFFSET,LENGTH,LIST</STRONG> 
               Удаляет из массива <code>ARRAY</code> элементы, отмеченные в переменных 
               <code>OFFSET</code> и <code>LENGTH</code> и заменяет их элементами 
               списка <code>LIST</code>, если таковые имеются. Возвращает удаленные 
               из массива элементы. Длина массива растет или уменьшается, если 
               это необходимо. Если переменная <code>LENGTH</code> опущена, то 
               удаляет все, начиная с <code>OFFSET</code>. 
             <p align=justify><STRONG>split /PATTERN/,EXPR,LIMIT</STRONG> Разбивает 
               строку на массив строк и возвращает его. В скалярном контексте возвращает 
               число полученных полей и помещает полученный массив в <code>@_</code>. 
               Если <code>EXPR</code> опущено то разбивается строка <code>$_</code>. 
               Если <code>PATTERN</code> тоже опущен, то разбиение происходит по 
               символу пробел. Символы, указанные в <code>PATTERN</code>, служат 
               разделителями для полей. Разделители могут быть длиннее, чем один 
               символ. Если переменная <code>LIMIT</code> задана и имеет неотрицательное 
               значение, то разбиение будет происходить на число полей не более 
               указанного в <code>LIMIT</code>. Если переменная не определена, 
               то пустые поля отбрасываются, если имеет отрицательное значение, 
               то это интерпретируется Perl-ом, как отсутствие ограничения на длину 
               возвращаемого массива. Если шаблону соответствует пустая строка, 
               то <code>EXPR</code> будет разбито на отдельные символы. Например: 
             <PRE>  print join(':',split(/ */,'hi there'));</PRE>
             напечатает строку <code>h:i:t:h:e:r:e</code>. 
             <p align=justify><STRONG>sqrt EXPR</STRONG> Возвращает корень квадратный 
               из значения <code>EXPR</code>. По умолчанию обрабатывает переменную 
               <code>$_</code>. 
             <p align=justify><STRONG>system LIST</STRONG> Делает то же самое, 
               что и функция exec <code>LIST</code>, за одним исключением: вместо 
               того, чтобы просто начать выполнять программу , как это делает <code>exec, 
               system</code> делает <code>fork</code> и порождает еще один процесс, 
               причем родительский процесс ждет завершения дочернего. 
             <p align=justify><STRONG>tell FULEHANDLE</STRONG> Возвращает текущую 
               позицию курсора в файле <code>FILEHANDLE</code>. Если аргумент опущен, 
               то обрабатывает файл, который читался последним. 
             <p align=justify><STRONG>tie VARIABLE,PACKAGENAME,LIST</STRONG> Привязывает 
               переменную к пакету, который будет заносить значения в эту переменную. 
               Переменная <code>VARIABLE</code> содержит имя переменной, переменная 
               <code>PACKAGENAME</code> содержит имя пакета. Дополнительные аргументы 
               передаются методу <code>new</code> этого пакета. Обычно это такие 
               аргументы, которые в дальнейшем могут быть переданы в качестве параметров 
               <code>dbm_open()</code> функции из <code>C</code>. 
             <PRE>  tie(%HIST, NDBM_File,'/usr/lib/news/history', 1, 0);
   while(($key,$val) = each %HIST) {
       print $key, '= ', unpack('L',$val),&quot;\n&quot;;
   }
   untie(%HIST);</PRE>
             Пакет, реализующий ассоциативный массив, должен содержать следующие 
             методы: <BR>
             <code>TIEHASH objectname, LIST</code> <BR>
             <code>DESTROY this </code><BR>
             <code>FETCH this, key </code><BR>
             <code>STORE this, key, value</code> <BR>
             <code>DELETE this, key </code> <BR>
             <code>EXISTS this, key </code><BR>
             <code>FIRSTKEY this </code><BR>
             <code>NEXTKEY this, lastkey</code><BR>
             Пакет, реализующий обычный массив, должен содержать следующие методы: 
             <BR>
             <code>TIEARRAY objectname, LIST</code> <BR>
             <code>DESTROY this </code> <BR>
             <code>FETCH this, key </code> <BR>
             <code>STORE this, key, value </code> <BR>
             Пакет, реализующий скаляры, должен содержать следующие методы : <BR>
             <code>TIESCALAR objectname, LIST </code><BR>
             <code>DESTROY this </code><BR>
             <code>FETCH this </code><BR>
             <code>STORE this, value </code><BR>
             <p align=justify><STRONG>truncate FILEHANDLE, LENGTH</STRONG> Обрезает 
               файл FILEHANDLE до заданной длины. 
             <p align=justify><STRONG>undef EXPR</STRONG> Делает значение <code>EXPR</code> 
               неопределенной величиной, в случае, когда аргумент опущен ничего 
               не меняет. Не следует пытаться применять эту функцию к зарезервированным 
               переменным, потому что результат может оказаться непредсказуемым. 
             <p align=justify><STRONG>unlink LIST</STRONG> Удаляет список файлов 
               и возвращает число удачно удаленных файлов. Если вы не являетесь 
               суперпользователем, то эта функция не может удалять каталоги. Даже 
               в случае, когда программа запускается с привилегиями суперпользователя, 
               будьте осторожны, лучше использовать функцию <code>rmdir</code>. 
             <p align=justify><STRONG>untie VARIABLE</STRONG> Разрывает связь между 
               переменной и пакетом. 
             <p align=justify><STRONG>unshift ARRAY, LIST</STRONG> Производит действие 
               противоположное действию функции <code>shift</code>. Присоединяет 
               <code>LIST</code> к началу массива <code>ARRAY</code> и возвращает 
               новое количество элементов в массиве. 
             <p align=justify><STRONG>use Module LIST</STRONG> Осуществляет присоединение 
               модуля к программе. 
             <PRE>  use strict qw(subs,vars,refs);</PRE>
             <p align=justify><STRONG>values ASSOC_ARRAY</STRONG> Возвращает обычный 
               массив, состоящий из значений ассоциативного массива <code>ASSOC_ARRAY</code>. 
               В скалярном контексте возвращает число элементов полученного массива. 
               Элементы массива могут располагаться в произвольном порядке. 
             <p align=justify><STRONG>wantarray</STRONG> Возвращает <code>TRUE</code>, 
               если контекст исполняющейся подпрограммы списковый, <code>FALSE</code> 
               в противоположном случае. 
             <p align=justify><STRONG>write</STRONG> создает запись (возможно состоящую 
               из нескольких строк) в соответствующем файле, используя формат ассоциированный 
               с этим файлом. Формат для текущего канала вывода может быть установлен 
               посредством присваивания переменной <code>$~{ }</code> имени формата. 
               <A NAME="index_html_SECTION0055"></A> 
             <h4>П2.4.5 Подпрограммы и модули</h4>
             <A NAME="index_html_SECTION00551"></A> 
             <h4>П2.4.5.1 Подпрограммы</h4>
             <p align=justify> Описать и использовать подпрограмму можно несколькими 
               способами: 
             <OL>
               <LI> <code>sub NAME;</code> - подразумевает описание в дальнейшем 
                 тела подпрограммы. 
               <LI> <code>sub NAME BLOCK</code> - непосредственное описание. 
               <LI> <code>$subref = sub BLOCK</code> - анонимное описание. 
               <LI> <code>use PACKAGE qw(NAME1, NAME2, NAME3)</code> - включение 
                 подпрограмм из модулей.</LI>
             </OL>
             Вызвать подпрограмму можно тоже несколькими способами: 
             <OL>
               <LI> <code>&amp;NAME(LIST)</code> - скобки обязательны для <code>&amp;</code> 
                 формы. 
               <LI> <code>NAME(LIST)</code> - <code>&amp;</code> не обязательно 
                 со скобками. 
               <LI> <code>NAME LIST</code> - скобки можно опустить в случае предварительного 
                 описания или включения подпрограммы из модуля.</LI>
             </OL>
             Аргументы передаются подпрограмме в виде локального массива <code>@_</code>, 
             его элементы являются ссылками на реальные скалярные параметры. Подпрограмма 
             возвращает значение, полученное в результате исполнения последнего 
             оператора подпрограммы. Как уже говорилось, подпрограмма вызывается 
             использованием префикса <code>&amp;</code> перед ее именем, в Perl 
             5 этот префикс не обязателен. Пример: 
             <PRE>  sub MAX {
       my $max = pop(@_);
       foreach $foo (@_) {
           $max = $foo if $max &lt; $foo;
       }
       $max;
   }
   ...
   $bestmark = &amp;MAX(1,2,3,4,5);</PRE>
             Подпрограмма может вызываться рекурсивно. Если подпрограмма вызывается 
             с использованием <code>&amp;</code> формы, то список аргументов необязателен. 
             Если вы хотите создать внутри модуля его собственную, невидимую снаружи 
             подпрограмму, то описание должно быть анонимным: 
             <PRE>  my $subref = sub {...}
   &amp;$subref(1,2,3);</PRE>
             <A NAME="index_html_SECTION00552"></A> 
             <h4>П2.4.5.2 Пакеты</h4>
             <p align=justify> Perl поддерживает механизм альтернативного именного 
               пространства для каждого отдельного пакета. Обычная программа является 
               пакетом с именем <code>main</code>. Можно ссылаться на переменные 
               или дескрипторы файлов из других пакетов посредством использования 
               префикса перед именем переменной, состоящего из имени пакета и двойного 
               двоеточия: <code>$Package::Variable</code>. Если имя пакета нулевое, 
               то предполагается использование переменной из <code>main</code> 
               пакета. То есть <code>$::sail</code> эквивалентно <code>$main::sail</code>. 
               Пакеты могут включать в себя другие пакеты, в таком случае чтобы 
               обратиться к переменной нужно применить описанное обозначение рекурсивно: 
               <code>$OUTER::INNER::var</code>. <BR>
               В пакете могут содержаться только переменные, чьи имена начинаются 
               с буквы или подчерка, остальные переменные содержатся в пакете main. 
               Кроме того зарезервированные переменные, как то <code>STDIN, STDOUT, 
               STDERR, ARGV, ARGVOUT, ENV,</code> <code>INC</code> и <code>SIG</code> 
               также содержатся в главном пакете. 
             <PRE>package mypack;
 sub main::mysub {
     ...
 }</PRE>
             <A NAME="index_html_SECTION00553"></A> 
             <h4>П2.4.5.3 Таблицы символов</h4>
             <p align=justify> Таблицы символов пакета хранятся в ассоциативном 
               массиве с тем же именем и двойным двоеточием в конце. Для пакетов 
               включенных в пакет имя символьной таблицы составляется аналогичным 
               образом: <code>%OUTER::INNER::</code>. <A NAME="index_html_SECTION00554"></A> 
             <h4>П2.4.5.4 Конструкторы и деструкторы пакетов</h4>
             <p align=justify> Существует две функции специального вида - конструкторы 
               и деструкторы. Это <code>BEGIN</code> и <code>END</code> программы 
               в их описании необязательно использование <code>sub</code>. Подпрограмма 
               <code>BEGIN</code> исполняется сразу, как только это возможно, то 
               есть в момент, когда она полностью определена, даже перед тем как 
               обрабатывается остаток содержащего файла. В файле может быть несколько 
               блоков <code>BEGIN</code>. Они исполняются в порядке определения. 
               <BR>
               Подпрограмма <code>END</code> исполняется в самом конце. В файле 
               может содержаться несколько <code>END</code> блоков, они исполняются 
               в обратном порядке. <A NAME="index_html_SECTION00555"></A> 
             <h4>П2.4.5.5 Классы</h4>
             <p align=justify> В Perl 5 нет специального синтаксиса для описания 
               классов, но пакеты могут функционировать как классы, если они содержат 
               подпрограммы функционирующие как методы. Такие пакеты могут также 
               брать некоторые методы из других пакетов-классов. Для этого необходимо 
               перечислить имена других пакетов в массиве <code>@ISA</code>. <A NAME="index_html_SECTION00556"></A> 
             <h4>П2.4.5.6 Модули</h4>
             <p align=justify> В Perl 5 понятие пакетов расширено в понятие модулей. 
               Модули это пакеты находящиеся в одноименном файле, включенном в 
               библиотеку. Модули подключаются следующим образом: 
             <PRE>  use Module; или use Module LIST;</PRE>
             Это эквивалентно: 
             <PRE>  BEGIN { require &quot;Module.pm&quot;; import Module; }</PRE>
             Все модули имеют расширение <code>.pm</code>. Если именное пространство 
             модуля пересекается с именным пространством основной программы то 
             всегда используется <code>use</code>, если не пересекается то можно 
             использовать <code>require</code>. <BR>
             Стандартные модули Perl описаны в документации. <A NAME="index_html_SECTION006"></A> 
             <h3>П2.5 Объектная ориентация</h3>
             <p align=justify> Понятие объектной ориентации зиждется на трех простых 
               определениях: 
             <OL>
               <LI> Объект это просто ссылка. 
               <LI> Класс это просто пакет, который содержит методы для работы 
                 с объектными ссылками. 
               <LI> Метод это просто подпрограмма, которая имеет своим первым аргументом 
                 объектную ссылку (или имя пакета для статического метода).</LI>
             </OL>
             <A NAME="index_html_SECTION0061"></A> 
             <h4>П2.5.1 Объекты</h4>
             <p align=justify> В отличие от C++, Perl не имеет специального синтаксиса 
               для описания конструкторов. Конструктор, как уже говорилось раньше, 
               это просто подпрограмма, которая возвращает ссылку ассоциированную 
               с классом (как правило с тем, где определена подпрограмма). Например, 
               типичный конструктор: 
             <PRE>  package Critter;
   sub new { bless {} }</PRE>
             <code>{}</code> создает ссылку на анонимный хэш.<BR>
             В пределах класса методы как правило работают с обычными ссылками. 
             Конструктор может привязать объект к другому классу, в таком случае 
             предыдущая привязка бывает забыта, так как объект не может принадлежать 
             одновременно нескольким классам. <A NAME="index_html_SECTION0062"></A> 
             <h4>П2.5.2 Классы</h4>
             <p align=justify> В отличие от <code>C++</code>, Perl не имеет специального 
               синтаксиса для описания классов. Классом является пакет, чьи подпрограммы 
               выступают в качестве методов. Для каждого пакета определен специальный 
               массив <code>@ISA</code>, в котором перечислены пакеты, подключенные 
               к данному пакету. Таким образом в Perl реализован механизм наследования 
               методов. Метод, принадлежащий другому объекту, подключается как 
               подпрограмма. <A NAME="index_html_SECTION0063"></A> 
             <h4>П2.5.3 Методы</h4>
             <p align=justify> В Perl-е метод имеет синтаксис простой подпрограммы. 
               В качестве первого аргумента метода выступает объект или пакет. 
               Существует два типа методов: статические и виртуальные методы.<BR>
               Статические методы имеют первым аргументом имя класса. Они обеспечивают 
               функциональность для класса в целом, а не для отдельных объектов 
               принадлежащих классу. Конструкторы являются, как правило, статическими 
               методами. Многие статические методы просто игнорируют свой первый 
               аргумент, так как заранее знают, какому пакету они принадлежат. 
               Другой способ использования статических методов состоит в том, что 
               метод работает с объектом, используя имя: 
             <PRE>  sub find {
       my ($class, $name) = @_;
       $objtable{$name};
   }</PRE>
             Виртуальные методы имеют первым аргументом ссылку на объект. Обычно 
             они помещают эту ссылку в переменную <code>self</code> или <code>this</code> 
             и в дальнейшем используют ее как обычную ссылку. 
             <PRE>  sub display {
       my $self = shift;
       my @keys = @_ ? @_ : sort keys %$self;
       foreach $key (@keys) {
 	  print &quot;\t$key =&gt; $self -&gt;{$key}\n&quot;;
       }
   }</PRE>
             <A NAME="index_html_SECTION0064"></A> 
             <h4>П2.5.4 Вызов метода</h4>
             <p align=justify> Существует два способа обратиться к методу. Во-первых, 
               можно вызвать его просто как подпрограмму. Но в таком случае не 
               работает механизм наследования. Второй способ лучше просто проиллюстрировать 
               примерами. 
             <PRE>  $fred = find Critter &quot;Fred&quot;;
   display $fred, 'Height', 'Weight';</PRE>
             Это можно записать так: 
             <PRE>  display {find Critter &quot;Fred&quot;} 'Height', 'Weight';</PRE>
             <A NAME="index_html_SECTION0065"></A> 
             <h4>П2.5.5 Деструкторы</h4>
             <p align=justify> Когда удаляется последняя ссылка на объект, этот 
               объект автоматически удаляется. Это может произойти даже после завершения 
               программы, если ссылки на объект содержались в глобальных переменных. 
               Если необходимо контролировать процесс удаления объекта, можно определить 
               в объекте специальный метод, называемый <I>деструктором</I>. Деструктор 
               объекта (в отличие от <code>C++</code>) имеет фиксированное имя 
               <code>DESTROY</code> и вызывается перед удалением объекта. В нем 
               можно реализовать дополнительные процедуры, необходимые для корректного 
              завершения (например, удаление временных файлов, используемых объектом). 
<HR>
<hr>

<!--#include virtual="/footer.raw"-->

</body></html>