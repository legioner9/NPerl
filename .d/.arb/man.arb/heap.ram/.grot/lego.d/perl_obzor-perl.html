<html>
<body bgcolor="#DDE1C2">
<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">

<title>Заметки по языку Perl</title>
</head>
<body bgcolor="#DDE1C2">
<!--#include virtual="/header.raw"-->
<h3>Версия для печати</h3>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/141.shtml">Perl</a>"
</b>
 <small>(<a href="./">Многостраничная версия</a>)</small>
<hr noshade size=1>

<a name="index_html"></a>
<h1>Заметки по языку Perl</h1>
<p>Автор: <a href="mailto:dmitriykDOGgenphysDOTphysDOTmsuDOTru">
Дмитрий Кувшинов</a>
<br>Оригинал: <a href="http://genphys.phys.msu.su/~dmitriy/perl/">genphys.phys.msu.su</a>

<font color=red size=-1>Убедительная просьба, перед тем, как что-то
запускать, нужно убедиться, что 
скрипт не вытрет половину жесткого диска на сервере.</font>
</center>
<p>


1. Функции<br>

<ul>
        <li>Скаляры<br>
</li>
    <li>
<a href="#mass_html" target="_new">Массивы</a>
</li>
      <ul>
        <li>
<a href="#mass_html_objavlenue" target="_new">Объявление</a>
        <li>
<a href="#mass_html_2Darr" target="_new">Двумерный массив</a>
        <li>
<a href="#mass_html_ex" target="_new">Примеры использования</a>
        <ul>
          <li>
<a href="#mass_html_news" target="_new">Постраничный вывод новостей с разбиением по датам</a>
          <li>
<a href="#mass_html_spisok" target="_new">Пример работы со списками</a>
        </ul>
     </ul>
        <li>
<a href="#hash_html" target="_new">Хеши</a> </li>
      <ul>
        <li>
<a href="#hash_html_open"
target="_new">Объявление</a>
</li>
        <li>
<a href="#hash_html_dost" target="_new">Доступ к
элементам</a>
</li>
        <li>
<a href="#hash_html_show"
target="_new">Вывод</a>
</li>
  <ul>
  <li>
<a href="#hash_html_vstt">Вывод хеша в порядке вставки
с использованием Tie::IxHash</a>
</li>
  <li>
<a href="#hash_html_vst">Вывод хеша в порядке вставки
без использования Tie::IxHash</a>
</li>
  </ul>

        <li>
<a href="#hash_html_sort" target="_new">Сортировки</a>
</li>
        <li>
<a href="#hash_html_subh" target="_new">Всторенные хеши</a>
</li>
        <li>
<a href="#hash_html_slice" target="_new">Хеши slice</a>
</li>
        <li>
<a href="#hash_html_hhash" target="_new">Хеши хешей</a>
</li>
        <li>
<a href="#hash_html_massh" target="_new">Массивы хешей</a>
</li>
        <li>
<a href="#hash_html_harr" target="_new">Хеши массивов</a>
</li>
        <li>
<a href="#hash_html_hashn">Хеш хешей хешей массивов</a>
        <li>
<a href="#hash_html_ex" target="_new">Примеры</a>
</li>
  <ul>
        <li>
<a href="#hash_html_007" target="_new">Шпионская программа</a>
</li>
        <li>
<a href="#hash_html_journal" target="_new">Программа вывода номеров журнала</a>
</li>
        <li>
<a href="#hash_html_log">Простой анализатор логов на хеше хешей массивов</a>
  </ul>

      </ul>
        <li>
<a href="#file_html" target="_new">Ввод/Вывод</a>
</li>
  <ul>
    <li>
<a href="#file_html_otkr" target="_new">Открытие файлов</a>
    <li>
<a href="#file_html_skan" target="_new">Сканирование директорий</a>
  </ul>

        <li>Ссылки<br>
</li>
        <li>Встроенные функции<br>
</li>
        <li>Встроенные переменные<br>
</li>
        <li>Примеры</li>
</ul>
 <p align=justify>
 
2. <a href="#regex_html" target="_new">Регулярные выражения</a>

<ul>
        <li>
<a href="#regex_html_opred" target="_new">Определения</a>
</li>
     <ul>
            <li>
<a href="#regex_html_single" target="_new">одиночные символы (characters)</a>
</li>
        <li>
<a href="#regex_html_klass" target="_new">классы символов (character classes)</a>
</li>
            <li>
<a href="#regex_html_altern" target="_new">альтернативные шаблоны (alternative match patterns)</a>
</li>
        <li>
<a href="#regex_html_kvant" target="_new">квантификаторы (quantifiers)</a>
</li>
        <li>
<a href="#regex_html_menim" target="_new">мнимые символы (assertions)</a>
</li>
        <li>
<a href="#regex_html_brefs" target="_new">ссылки на найденный текст (backreferences)</a>
</li>
     </ul>
        <li>
<a href="#regex_html_funct" target="_new">Функции, использующие регулярные выражения</a>
</li>
     <ul>
            <li>
<a href="#regex_html_split" target="_new">split</a>
</li>
            <li>
<a href="#regex_html_grep" target="_new">grep</a>
</li>
            <li>
<a href="#regex_html_map" target="_new">map</a>
</li>
            <li>
<a href="#regex_html_other" target="_new">другие</a>
</li>
     </ul>
        <li>
<a href="#regex_html_work" target="_new">Как работают регулярные выражения</a>
</li>
        <li>
<a href="#regex_html_logika" target="_new">Логические операции в регулярных выражениях</a>
</li>
        <li>
<a href="#regex_html_subroutines" target="_new">Вызов функций и подпрограмм</a>
</li>
        <li>
<a href="#regex_html_vstr" target="_new">Использование встроенных переменных</a>
</li>
        <li>
<a href="#regex_html_examples" target="_new">Несложные примеры</a>
</li>
        <li>
<a href="#regex_html_exprogs" target="_new">Рабочие программы, использующие регулярные выражения</a>
</li>
     <ul>
            <li>
<a href="#regex_html_match" target="_new">Выделение чисел в математической записи</a>
</li>
            <li>
<a href="#regex_html_work1" target="_new">Облегчение поиска работы</a>
</li>
            <li>
<a href="#regex_html_newsline" target="_new">Очень простое решение для зеркала новостной ленты</a>
</li>
            <li>
<a href="#regex_html_findres" target="_new">Вывод результатов поиска</a>
            <li>
<a href="#regex_html_passwd" target="_new">Проверка пароля на определенное число букв или цифр</a>
     </ul>
        <li>
<a href="#regex_html_FAQ" target="_new">Список наиболее употребительных регулярных выражений.</a>
</li>
</ul>

<p align=justify>
3. Модули
<p align=justify>
<ul>
        <li>Концепции</li>
        <li>Классы</li>
        <li>Объекты</li>
        <li>Пакеты</li>
        <li>
<a href="#modules_html_ex" target=_new>Примеры</a>
</li>
        <ul>
        <li>
<a href="#modules_html_upload" target=_new>Подгружение файлов на сервер через веб-страничку</a>
</li>
        <li>
<a href="#modules_html_upload" target=_new>Заполнение и отправка удаленной формы на сервер с помощью сценария</a>
</li>
        <li>
<a href="#modules_html_redir" target=_new>Редирект пользователя, находящегося за файрволом</a>
</li>
        <li>
<a href="#modules_html_excel">Создание файла Excel</a>
</li>
    <li>
<a href="#modules_html_file_find">File::Find</a>,
        <a href="#modules_html_image_size">Image::Size</a>,
        <a href="#modules_html_mime_lite">Mime::Lite</a>,
        <a href="#modules_html_image_magick">Image::Magick</a>,
        <a href="#modules_html_ole">Winword files</a>,
        <a href="#modules_html_spreadsheet_writeexcel">Spreadsheet::WriteExcel</a>,
        <a href="#modules_html_mp3_info">MP3::Info</a>,
        <a href="#modules_html_mason">Mason</a>,
        <a href="#modules_html_lwp_simple">LWP::Simple</a>,
        <a href="#modules_html_calendar">Calendar::Simple</a>
        </ul>
</ul>
<p align=justify>
4. <a href="#sub_html" target="_new">Подпрограммы</a>
<ul>
        <li>Объявление</li>
        <li>Примеры</li>
        <ul>
          <li>
<a href=files/pop_b4_smtp.html>pop before smtp for sendmail and popa3d(and other pop3 daemons)</a>
          </li>
        </ul>
</ul>
<p align=justify> 
5. Операторы
<p align=justify>
<ul>
        <li>Условные операторы</li>
        <li>Приоритеты операторов</li>
        <li>Часто используемые решения</li>
</ul>
<p align=justify> 
6. Отладка программ
<p align=justify> 
<ul>
        <li>Диагностические сообщения</li>
        <li>Диагностические ключи</li>
        <li>Примеры</li>
</ul>
<p align=justify> 
7. <a_ href="pipes.shtml" target=_new>Процессы</a>
<p align=justify>
<ul>
        <li>Управление процессами</li>
        <li>
<a href="files/time.html" target=_new>Работа со встроенными таймерами</a>
</li>
        <li>Межпроцессные взаимодействия</li>
        <li>Примеры</li>
</ul>
<p align=justify>
8. <a href="#base_html_fast" target=_new>Базы данных</a>
<p align=justify> 
<ul>
        <li>МySQL</li>
        <li>PostGree SQL</li>
        <li>Хеширование данных</li>
        <li>
<a href="#base_html_fast" target=_new>Системы хранения и быстрого извлечения данных</a>
</li>
        <li>Примеры</li>
</ul>
<p align=justify>   
9. Сокеты
<p align=justify>
<ul>
        <li>Основные принципы</li>
        <li>
<a href="#socket_html_ex">Примеры</a>
</li>
        <ul>
        <li>
<a href="#socket_html_upload">Подгружение файла(-ов) на сервер через веб-страничку</a>
</li>
        </ul>

</ul>
10. Использование бибилотек
<ul>
        <li>
<a href="#lwp_html" target="_new">LWP FAQ by
fido7.ru.cgi.perl</a>  by Paul Kulchenko (paulclinger@yahoo.com), updated
03/04/2000<br>
</li>
</ul>
11. Низкоуровневое программирование железа, микроконтроллеры и т.д.
<ul>   
        <li>последовательный порт</li>
        <li>
<a href="#lpt_html" target="_new">параллельный порт</a>
<br>
</li>
        <li>программирование микроконтроллеров и внешних процессоров(??)</li>
</ul>
12. Применение логики квантовых компьютеров
<ul>
<li>Выделение простых чисел из заданного диапазона
<li>
<a href="files/factors.html">Факторизация числа</a>
<li>
<a href="files/quantium.html">Модули Quantum::Entanglement и Quantum::Superpositions</a>

</ul>
<a href="http://genphys.phys.msu.ru/cgi-bin/dk/addperl.pl"
target="_new">Perl - полезности</a>
<br>
<br>
Если есть что сказать, пишите по <a
href="mailto:dmitriy@gateway.phys.msu.su?subject=about perl pages
&Body=hi!">e-mail</a>. <br>
<br>И еще, все я наверное напишу не скоро, что-то
посканировал, но в процессе написания вижу, что проще свое написать, чем
править отсканированное, да и себе полезней. Сканированное постепенно
убиваю, на данный момент около 70% текста написано собственноручно. Данный
текст можно копировать и видоизменять по собственному усмотрению. На весь
написанноый мной текст(за исключением сосканированного ранее ради полноты картины) распространяется лиценция
GPL.<p>
<hr>

<a name="files_time_html"></a>
<h4>
<a name=files_time_html_time>Работа со временем</a>
</h4>

Скорость работы программы можно определить, используя команду time:

<font color=green>
<pre>
bash-2.05$ time ./time.pl

real    0m0.613s
user    0m0.487s
sys     0m0.074s
bash-2.05$
</pre>
</font>

Ниже приведено несколько примеров программ, выводящих текущее время.

<font color=green>
<pre>
&time($time);
print "$time\n";

sub time{
  $time = sprintf("%02d/%02d/%02d b %02d:%02d:%02d", $tm->hour,$tm->min, $tm->sec, $tm->mday, $tm->mon+1, $tm->year+1900);
  return $time;
}
</pre>
</font>
Еще один способ:

<font color=green>
<pre>
#!/usr/bin/perl

my ($wday,$mday,$mon,$year,$time) =
 (split(" ",gmtime(time+10800)))[0,2,1,4,3];

print "$wday, $mday $mon $year $time GMT\n";

print (split("\s",gmtime(time+10800)))->[0,2,1,4,3];
print "\n";
</pre>
</font>
Тест для Григорианского календаря на високосность:

<font color=green>
<pre>
year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)
</pre>
</font>
Время можно вывести и вот так:
<font color=green>
<pre>
@d=split(/[ ]+/, scalar localtime);
</pre>
</font>
печатает:
<font color=green>
<pre>
$d[0]=='Wed'
$d[1]=='Jun'
$d[2]=='5'
$d[3]=='14:59:35'
$d[4]=='2002'
</pre>
</font>
Еще и так:

<font color=green>
<pre>
&Date($time);
print "$time\n";
sub Date {
        ($Second, $Minute, $Hour, $DayOfMonth, $Month, $Year, $Weekday,
        $DayOfYear, $IsDST) = localtime(time);
        $RealYear = $Year + 1900;
        $Month++;
        if($Month < 10) {$Month = "0" . $Month}
        if($DayOfMonth < 10) {$DayOfMonth = "0" . $DayOfMonth}
        if($Hour < 10) {$Hour = "0" . $Hour}
        if($Minute < 10) {$Minute = "0" . $Minute}
        if($Second < 10) {$Second = "0" . $Second}
        $date = "$DayOfMonth-$Month-$RealYear";
        $approval_date = "$RealYear|$Month|$DayOfMonth";
        $time = "$Hour:$Minute:$Second";
}
</pre>
</font>
И так:
<font color=green>
<pre>
#!/usr/bin/perl
use POSIX qw();
my $time = POSIX::strftime "%H:%M:%S", localtime time;
print "$time\n";
</pre>
</font>
Если возникла необходимость локализовать время в соответствии с часовым поясом, то
<font color=green>
<pre>
#!/usr/bin/perl
use POSIX qw();
my $time = POSIX::strftime "%H:%M:%S", localtime(time+3*3600);
print "$time\n";
</pre>
</font>
Спасибо: S.Nitsulenko, Vladimir Podgorny, Artem Chuprina, Dmitry Koteroff (from <a href="http://talk.mail.ru/forum/fido7.ru.perl">fido7.ru.perl</a>
<hr>

<a name="files_log_html"></a>
<a name=files_log_html_log>
<b>Простой анализатор логов на хеше хешей массивов</b>
</a>
<font color=green>
<pre>
#!/usr/bin/perl

open F, "&lt;/var/log/rambler.access.log" or die "can't open: $!\n"; @mass=&lt;F&gt;; close F;

for $gr(grep{!$m{$_}++} map{/S?E?T (.*?) / if /usr/ or m!/~user/!} @mass){
  for $line(@mass){
    ($ip, $n, $m, $data, $k, $method, $url, $protocol, $status, $size, $from, $brouser) =
      split /\s/ => $line;
    push @{$hash{$gr}{$ip}}, $size if $line=~m!$gr!;
  }
}
for $a(sort keys %hash){ my ($u, $j);
  print "file $a: \n\t";
  for $key(sort keys %{$hash{$a}}){ $j++;
    print "  '$key' \t => [ ";
    print 1+$#{$hash{$a}{$key}};
    my $i;
    for(@{$hash{$a}{$key}}){$i+=$_}
    print " $i";
    $u+=$#{$hash{$a}{$key}}+1;
    print " ]\n\t";
  }
  print "  dlya $a hitov $u, hostov $j\n";
  print "\t\n";
}</pre>
</font>
эта программа сплитит каждую строчку лог-файла по разделютелю пробел.
Если написать обработчик логов, т.е. программу, которая анализирует, по чему 
можно сплитить лог, то все здорово. А вообще по хорошему, необходимо, 
чтобы при установке программы она сама запрашивала, какие логи за что 
ответственны и как их анализировать. Главный принцип работы - 
структурирование по ip-адресу, строится хеш для страницы, потом хеш для
адреса, и массив каждому ключу этого хеша вес скачанной информации.
Рамерность массива - число запросов данного ip к данному файлу. сумма
элементов
<font color=green>for(@{$hash{$a}{$key}}){$i+=$_}</font> - полный рамер
величины 
информации, выкачанной пользователем.
При помощи небольших изменений(тут нужно знать схему построения хеша хешей
массивов) можно
выделять и сортировать любую информацию по любым броузерам или охвату
территории.
Соотвественно условие <font color=green>map{/S?E?T (.*?) / if /usr/ or
m!/~user/!}</font> говорит о том,
что нужно сплитить. Изменим программу допустим как-то так:

<font color=green>
<pre>
#!/usr/bin/perl
use CGI 'param';
$dir1=param('d1');
$dir2=param('d2');
open F, "&lt;/var/log/rambler.access.log" or die "can't open: $!\n"; @mass=&lt;F&gt;; close F;

for $gr(grep{!$m{$_}++} map{/S?E?T (.*?) / if /$dir1/ or m!$dir2!} @mass){
  for $line(@mass){
    ($ip, $n, $m, $data, $k, $method, $url, $protocol, $status, $size, $from, $brouser) =
      split /\s/ => $line;
    push @{$hash{$gr}{$ip}}, $size if $line=~m!$gr!;
  }
}
for $a(sort keys %hash){ my ($u, $j);
  print "file $a: \n\t";
  for $key(sort keys %{$hash{$a}}){ $j++;
    print "  '$key' \t => [ ";
    print 1+$#{$hash{$a}{$key}};
    my $i;
    for(@{$hash{$a}{$key}}){$i+=$_}
    print " $i";
    $u+=$#{$hash{$a}{$key}}+1;
    print " ]\n\t";
  }
  print "  dlya $a hitov $u, hostov $j\n";
  print "\t\n";
}</pre>
</font>

Вводя команду вида <font color=green>bash2-05$ log.pl d1=www
d2=/~user/</font> 
получим данные о числе заходов пользователя на данную страницу и статистику 
по файлам. Не знаю, как насчет других анализаторов логов, но этот намного
легковесней и состоит из пары десятков строк. Но, он имеет очень большой
минус,
он весь логфайл держит в памяти, т.к. для полной статистики по логфайлу 
необходимо анализировать весь лог. Введя условия в 
<font color=green>map{/S?E?T (.*?) / if /usr/ or m!/~user/!}</font>, можно
ограничить 
выборку конкретной директорией. Хотя впрочем это не настолько трудная
задача, можно читать каждую дирректорию по отдельности.
В любом случае при анализе логов происходит полное чтение логфайла, в
предложенном варианте 
программы чтение однократное, но и машину повесить может. Но, вобщем, это
решабельно...
<p>
<hr>

<a name="files_file_find_html"></a>
<a name=files_file_find_html_file_find><b>Стирание  символа перевода каретки</b></a><br>
Более сложная задача, убрать все неправильные символы перевода
каретки ^M, которые, допустим, появляются при передаче файлов far'ом на свой
сайт:

<p>

<font color=green><pre>

#!/usr/bin/perl -w
use strict;
use File::Find;

find( \&wanted, '/var/www/html/allsitecopy' );

sub wanted {
  return if /^\.\.?$/ and not /\.html?$/i and not -f;
     local $/;
     open F, "< $File::Find::name" or do {
         warn "Cannot read from $File::Find::name: $!";
         return;
         };
     binmode F;
     my $mass = &lt;F&gt;;
     close F;
     $mass =~ tr/\cM//d;
     open F, "> $File::Find::name" or do {
         warn "Cannot write to $File::Find::name: $!";
         return;
         };
     binmode F;
     print F $mass;
     close F;

     print "$File::Find::name all ok!\n";
}
</pre></font>

Не рекомендую запускать подобные программы, не разобравшись, правильно
ли оно закрывает открытые файлы. Это все конечно очень здорово, что это
можно
cделать, но все-таки голову на плечах нужно иметь, сначала попробовать 
на маленькой поддиректории, убедится, что все ок и только после этого
 что то делать программой с серьезными данными.
<p><a name=files_file_find_html_req><b>Подсчет определенных файлов во всех вложенных
директориях</b></a><br>
Пример использования модуля <font color=green>File::Find</font> для
рекурсивного(вход во все поддиректории) просмотра
или подсчета числа html или shtml или htm файлов(эти три вида файлов
определяеются реглярным выражением <font color=green>s?html?</font>):
<font color=green><pre>
#!/usr/bin/perl -w
use File::Find;
find \&wanted, '/var/www/html';
sub wanted {print $count++, "\t$File::Find::name all ok!\n" if /s?html?/i}
</pre></font>
Всего 4 строчки против в среднем 10-20... удобно,быстро, и, главное,
лениво.<p>
<hr>

<a name="files_image_size_html"></a>
<h4>
<a name=files_image_size_html_image_size>Get image size</a>
</h4>
Предположим необходимо узнать размер картинок, чтобы выставить их размеры во
вновь генерируемом <font color=green>html</font>. Для этого нужно взять
модуль <a href="http://search.cpan.org/search?dist=Image-Size"
target=_new>Image-Size-*.*.tar.gz</a> установить его, затем <font
color=green>man Image::Size</font> и для какой-то картинки получим размер с
помошью несложного скрипта:
<font color=green>
<pre>
#!/usr/bin/perl
use Image::Size;
($x, $y) = imgsize("/var/www/html/images/mnu_item.gif");
print "$x x $y\n";

[root@www devel]# ./image.pl
15 x 15
[root@www devel]# 
</pre>
</font>
<hr>

<a name="files_mime_lite_html"></a>
<h4>
<a name=files_mime_lite_html_mime_lite>Mail with attachement</a>
</h4>
Приведенная программа позволяет отправить открытку с веб странички.
Подпрограмма <font color=green>&vibor()</font> читает директорию с
картинками в формате jpg (можно и в других форматах). Далее перед формой
происходит вывод самих картинок, которые находятся в определенной
директории. Около каждой картинки ставится чекбокс, отмечая который
выбирается нравящаяся картинка. Так-же предусмотрена проверка на заполнение
всех полей в форме. Есть один минус, такая программа полностью открывает
relay, но в принципе все аналогичные программы так и работают. Если сделать
постраничный вывод картинок из директории, то можно отправлять картинки из
галереи, содержащей 1000 фотографий или рисунков.

<font color=green>
<pre>
#!/usr/bin/perl -w
print "content-type:text/html\n\n";
use lib '/usr/local/etc/httpd/cgi-bin/photo/MIME-Lite-2.117/lib';
use Mime::Lite;
use CGI 'param';
$dir="/usr/local/etc/httpd/htdocs/otkritki";
$url="http://www.server.ru/otkritki";
   $emls = param('emls');
   $cont = param('cont');
  $email = param('email');
   $name = param('name');
$subject = param('subject');
   $body = param('body');
    $img = param('img');
$pic=$dir."/".$img;
open F, "&lt;begin"; @mass1=&lt;F&gt;; close F;
open F, "&lt;end"; @mass2=&lt;F&gt;; close F;
print @mass1;
if($cont eq 'mail'){
   if($email ne '' && 
        $img ne '' && 
       $emls ne '' && 
       $name ne '' && 
    $subject ne '' && 
       $body ne ''){
      &sent();
   }
unless($email ne '' && 
         $img ne '' && 
        $emls ne '' && 
        $name ne '' && 
     $subject ne '' && 
        $body ne ''){
  print qq~&lt;p&gt;&lt;center&gt;&lt;b&gt;Не заполнено одно из полей формы,
         либо не выбрана картинка!!&lt;/b&gt;&lt;/center&gt;~;
  &form()
  }
}
else{&form()}

sub sent{
$msg = MIME::Lite-&gt;new(
              From    =&gt;qq{"$name" &lt;$email&gt;},
              To      =&gt;$emls,
              Subject =&gt;$subject,
              Type    =&gt;'multipart/mixed'
            );

$msg-&gt;attach(Type  =&gt;'text',
              Data    =&gt; qq{$body}
            );
$msg-&gt;attach(Type  =&gt;'image/jpeg',
              Path    =&gt;$pic,
              Filename=&gt;'new_year.jpg',
            );
$msg-&gt;attach(Type  =&gt;'text',
              Data    =&gt; qq{ Vasha otkritka! }
            );
$msg-&gt;send;
print qq{&lt;center&gt;&lt;b&gt;Ваше сообщение отправлено!&lt;/b&gt;&lt;/center&gt;};
&form();

}

sub form{
print "&lt;form action=http://www.server.ru/cgi/photo/letter.pl method=post&gt;\n";
&vibor();
print "&lt;a name=up&gt;&lt;/a&gt;";
print qq~&lt;center&gt;&lt;b&gt;Выберите фотографию из списка и отправьте
         &lt;a href=#post&gt;открытку&lt;/a&gt;&lt;/b&gt;&lt;/center&gt;
         &lt;table CELLSPACING=10 CELLPADDING=10&gt;\n~;
foreach $file(@files){ $i++;
  my $big=$file;
  $big=~s!mini_!!g;
  print qq~&lt;td&gt;&lt;a href=$url/$big target=_new&gt;&lt;img
           src=$url/$file border=0&gt;&lt;/a&gt;&lt;/td&gt;&lt;td
           valign=bottom&gt;&lt;input type=radio name=img
           value=$big&gt;&lt;/td&gt;&lt;/tr&gt;\n~ if $i%2 == 0;
  print qq~&lt;tr&gt;&lt;td&gt;&lt;a href=$url/$big target=_new&gt;&lt;img
           src=$url/$file border=0&gt;&lt;/a&gt;&lt;/td&gt;&lt;td
           valign=bottom&gt;&lt;input type=radio name=img value=$big
           &gt;&lt;/td&gt;\n~ if $i%2 != 0;
}
print qq~&lt;/table&gt;&lt;a
name=post&gt;&lt;/a&gt;&lt;b&gt;&lt;center&gt;&lt;a
href=#up&gt;наверх&lt;/a&gt;&lt;/center&gt;&lt;/b&gt;&lt;br&gt;
&lt;BR&gt;&lt;b&gt;Введите адрес получателя:&lt;/b&gt;&lt;br&gt; 
&lt;input type=text name=emls size=46 value=$emls&gt;&lt;BR&gt;
&lt;b&gt;Введите Ваш адрес:&lt;/b&gt;
&lt;br&gt;
&lt;input type=text name=email size=46 value=$email&gt;&lt;br&gt;
&lt;B&gt;Ваше имя: &lt;/B&gt;&lt;BR&gt;
&lt;input type=text name=name size=46 value=$name&gt;&lt;br&gt;
&lt;B&gt;Заголовок письма:&lt;/B&gt;&lt;BR&gt;
&lt;input type=text name=subject size=46 value=$subject&gt;&lt;br&gt;
&lt;B&gt;Текст письма:&lt;/B&gt;&lt;BR&gt;
&lt;textarea name=body rows=8 cols=50&gt;$body&lt;/textarea&gt;&lt;br&gt;
&lt;input type=submit value="Отправить!"&gt;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&lt;input type=hidden name=cont value=mail&gt;
&lt;input type=reset value="очистить."&gt;
&lt;/form&gt;
~;
}

sub vibor{
  opendir(DIR,$dir) or (warn "Cannot open $dir: $!" and next);
  rewinddir(DIR);
  @files=grep {!(/^\./) && /mini_/io && -f "$dir/$_"} readdir(DIR);
  closedir (DIR);
  return @files;
}
print @mass2;
</pre>
</font>

Пример работы этого скрипта смотрите <a
href="http://www.pereplet.ru/cgi/photo/letter.pl">здесь</a>.
<p align=justify>
В данном случае почтовая программа типа Netscape или www.mail.ru при
прочтении письма делает файл видимым, т.е. картинка видна сразу. Прочитав
документацию на content-type для определенного типа файла, можно ту-же саму
картинку выгружать, скажем в photoshop. Поискав в www.google.com название
контент-тайпа, скажем, файла в формате excel, можно по одному нажатию на
файл запускать соответствующее расширению файла приложение. Приведенная ниже
подпрограмма высылает данные из базы пользователю в формтае excel так, что
при нажатии на приаттаченный файл, помимо картинки, запускается microsoft
excel:
<font color=green>
<pre>
    do{
        my $msg = MIME::Lite->new(
                From    =>qq{"Young scientist"},
                To      =>$email,
                Subject =>qq{"Ваши данные"},
                Type    =>'multipart/mixed'
                                );
        $msg->attach(Type  =>'text',
                      Data => qq{"$data"}
                    );
        $msg->attach(Type => 'image/jpeg',
                     Path => '/usr/local/photo/head.jpg',
                 Filename =>'head.jpg'
                    );
        $msg->attach(Type => 'application/x-msexcel',
                     Path => "$dir/users/$login/mydata.xls",
                 Filename =>'mydata.xls'
                    );
        $msg->send;
      print qq{&lt;center&gt;&lt;b&gt;На Ваш адрес отправлено сообщение с Вашими данными!&lt;/b&gt;&lt;/center&gt;};
    } if grep{/^$login\t(.*)\t(.*?)\n/} @tmp;

</pre>
</font>
<hr>

<a name="files_image_magick_html"></a>
<h4>
<a name=files_image_magick_html_image_magick>Содание маленьких картинок для галереи.</a>
</h4>
<p align=justify>
Допустим у Вас есть 100000 картинок, ну или около того. Все они различного
размера, могут быть и 1000х1000 и 200х234. Необходимо получить маленьких
100000 картинок, высотой 60 пикселов
и соответствующей шириной. Это можно сделать при помощи модуля  <font
color=green>use Image::Magick</font> Скачиваем модуль <a
href="http://search.cpan.org/search?dist=PerlMagick">PerlMagick-*.*.*.tar.gz
</a>. Проделываем стандартную распаковку модуля:
<font color=green>
<pre>
gunzip -c PerlMagick-5.39.tar.gz | tar -xvf -
</pre>
</font>
затем устанавливаем его
<font color=green>
<pre>
cd PerlMagick
perl Makefile.PL
make
make test
make install
</pre>
</font>
И пишем следующий скрипт:
<font color=green>
<pre>
#!/usr/bin/perl -w

use lib '/usr/local/etc/httpd/bin/devel/IS';
use Image::Size;
use Image::Magick;

my $tumb="/usr/local/etc/httpd/images";
my $dir="/usr/local/etc/httpd/devel/pics";
my $vis=60; #высота картинки
while(<$tumb/*.*>){
   $_="aaa.gif" unless /\.(gif|jpg|jpeg|png)/i;
   $uu=$_;
   $uu=~s!.*/!!;
   print "$uu\t=>\tmini_$uu\n";
   my($image, $x);
   $image = Image::Magick->new;
   my ($w, $h) = imgsize($_);
   my $t=int($w/($h/$vis)) if $h/$vis != 0;
   $x = $image->Read($_);
   warn "$x" if "$x";
   $x = $image->Resize(geometry=>'100x100"+1"00"+1"00', width=>$t, height=>$vis);
   warn "$x" if "$x";
   $_=~s!.*/!!;
   $x = $image->Write("$dir/mini_$_");
   warn "$x" if "$x";
}
</pre>
</font>
<p align=justify>
Циклом <font color=green>while(<$tumb/*.*>){to do}</font> просматриваем
содержимое директории с картинками. При помощи модуля <a
href="#files_image_magick_html_imgsize">Image::Size</a> устанавливаем размеры исходной картинки. В
переменной <font color=green>$vis=60;</font> определяем высоту маленькой
картинки на выходе. Строчкой  <font color=green>my ($w, $h) =
imgsize($_);</font> берем реальные размеры картинки и, чтобы ширина картинки
была  пропорциональна высоте(ведь не известно, картинки какого размера лежат
в директории), строчкой <font color=green>my $t=int($w/($h/$vis)) if $h/$vis
!= 0;</font> масштабируем ширину. Логика проста, берем реальный размер
картинки, делим на <font color=green>$vis</font>, получаем коэффициент
пропорциональности между размерами, т.е. допустим картинка, исходная, больше
маленькой например в 2,34567 раз. Далее делим на этот коэффициент ширину
картинки и получаем уменьшенную копию картинки высотой в <font
color=green>$vis</font> пикселов и соответствующей этой высоте ширине(как
это автоматически делает, т.е. сохраняет пропорции, <font
color=green>photoshop</font> любой версии), далее
берем целую часть от этогй высоты функцией int, условие <font color=green>if
$h/$vis != 0</font> исключает деление на 0. Итак, в переменной <font
color=green>$t</font> содержится ширина картинки, вызываем функцию <font
color=green>Resize</font>, которй передаем два параметра, ширину и высоту и
на выходе имеем маленькую картинку <font color=green>mini_pic.gif</font> с
названием отличным от большой <font color=green>pic.gif</font>. Условие
<font color=green>$_="aaa.gif" unless /\.(gif|jpg|jpeg|png)/i;</font>
предназначено для того, чтобы выделить из директории с файлами только файлы
картинок. Скрипт просто перезаписывает
одну и ту-же картинку. Хотя можно было бы и пропускать шаг цикла <font
color=green>while</font>. <p align=justify>Собственно вот и все.
<p align=justify>
Далее можно написать скрипт, выводящий маленькие картинки из директории,
пользуясь тем-же
модулем <a href="#files_image_magick_html_image_size">Image::Size</a>, нужно только
<hr>

<a name="files_ole_html"></a>
<h4>
<a name=files_ole_html_ole>Чтение файлов в формате *.doc для Word 6 и Word
7(doc2txt or doc2html).</a>
</h4>
<p>
Преположим Вы владеете сайтом, на который сваливается информация
в формате *.doc. Много информации. Даже, быть может, 
структурированной. Необходимо эту информацию перевести в "божеский" вид,
т.е. выцепить из таких файлов текст. Скачиваем следующие модули:
<p>
<a href="http://search.cpan.org/search?dist=Unicode-Map" target=_new>Unicode-Map</a>
<br>
<a href="http://search.cpan.org/search?dist=Startup" target=_new>Startup</a>
<br>
<a href="http://search.cpan.org/search?dist=OLE-Storage" target=_new>OLE-Storage</a>
<br>
<p>
Устанавливаем их. Мне пришлось убрать строку N1099 при установке Startup.
Ну, это вылилось в отсутствие мануала по одному из многочисленных методов 
этого модуля, ибо эта строчка находилась
в самом конце моудля, где обычно находятся описания и комментарии.
<p>
Далее берем файл, удовлетворяющий описанным выше условиям и 
пишем скрипт(предварительно прочитав man lhalw):
<font color=green>
<pre>
#!/usr/bin/perl
print qx[lhalw --to_stdout Label.doc]
</pre>
</font>
А можно и просто из командной строки
<font color=green>
<pre>
[root@www OLE-Storage-0.386]# lhalw --to_stdout Label.doc


Кому:   "ФАМИЛИЯ" "ИМЯ" "ОТЧЕСТВО"
------------------------------ ОБРАТНЫЙ АДРЕС ------------------------------
WWW.RBC.RU, отдел "Новости экономики".

[root@www OLE-Storage-0.386]#
</pre>
</font>
А вообще, старайтесь сохранять файлы в формате *.rtf, ибо Microsoft Office
страдает поддержкой форматов
<hr>

<a name="files_mp3_info_html"></a>
<h4>
<a name=files_mp3_info_html_mp3_info>Извлечение и запись информации в *.mp3</a>
</h4>

Считать информацию, хранящуюся в <font color=green>*.mp3</font> 
файле, можно при помощи модуля
<a
href="http://theoryx5.uwinnipeg.ca/mod_perl/cpan-search?search=Mp3-info&filetype=+distribution+name+or+description&join=and&arrange=file&download=auto&stem=no&case=clike&site=ftp.funet.fi&age="
target=_new>MP3::Info</a>. 
Нехитрая програмка, вытаскивающая данные о той или иной записи:
<font color=green>
<pre>
#!/usr/bin/perl

my $file="/root/test.mp3";

use MP3::Info;

my $tag = get_mp3tag($file);
my $info = get_mp3info($file);

print "$_\t=>\t$info->{$_}\n" for sort keys %$info;
print "$_\t=>\t$tag->{$_}\n" for sort keys %$tag
</pre>
</font>

Программа выдаст примерно следующее:
<font color=green>
<pre>
[root@www MP3-Info-1.00]# ./u.pl
BITRATE =>      160
COPYRIGHT       =>      0
FRAMES  =>      93498
FRAME_LENGTH    =>      49
FREQUENCY       =>      44.1
LAYER   =>      3
MM      =>      3
MODE    =>      0
MS      =>      72.0499999999902
PADDING =>      0
SECS    =>      229.07205
SIZE    =>      4581441
SS      =>      49
STEREO  =>      1
TIME    =>      03:49
VBR     =>      0
VERSION =>      1
ALBUM   =>      Ist der Ruf erst ruiniert...
ARTIST  =>      Tic Tac Toe
COMMENT =>      http://www.delit.net
GENRE   =>      Rock
TITLE   =>      Lдstern
TRACKNUM        =>      32
YEAR    =>      2000
[root@www MP3-Info-1.00]#
</pre>
</font>
Обращаться к хешам, которые возвращаются функциями, можно как и при работе с
<font color=green>perl -e 'print "$k\t=>\t$v\n"
while(($k, $v)=each %ENV)'</font>
<p>
Собственно модуль так-же умеет записывать информацию о записи в mp3. файл, 
а как это сделать читайте в <font color=green>man MP3::Info</font>
<hr>

<a name="files_hh_html"></a>
<font color=green>
<pre>

        use Tie::IxHash;
        tie(%myhash, Tie::IxHash);
        for ($i=0; $i<20; $i++) {
            $myhash{$i} = 2*$i;
        }
        @keys = keys %myhash;
        # @keys = (0,1,2,3,...)

</pre>
</font>

from <a href="http://www.perl.com/perl/faq/">Daily Perl FAQ
<hr>

<a name="files_spreadsheet_writeexcel_html"></a>
<h4>
<a name=files_spreadsheet_writeexcel_html_spreadsheet_writeexcel>Использование Spreadsheet::WriteExcel</a>
</h4>

Задача, есть результаты школьных олимпиад. Нужно разослать результаты по
школам. Исходные данные 
лежат в файле в виде:
<font color=green>
<pre>
2#МОК#Федяков#Андрей#9#М#ГОР#ВОРОНЕЖ#УЛ ШЕНДРИКОВА 7#394086#0732 317825#0#0#0#0#0#0#0#0#0#0#0#0
2#МОК#Амшеникова#Наталия#8#М##ВОРОНЕЖ#УЛ ШЕНДРИКОВА 7#394086#0732 317821#0#0#0#2#0#3#5#0#3#5#0#18
2#УЧЕБНО ВОСПИТАТЕЛЬНЫЙ КОМПЛЕКС#Протасов#Виталий#8#М#ГОР#ВОРОНЕЖ#УЛ ГЕРОЕВ СИБИРЯКОВ 5#394051#80732 335836#7#0#7#0#7#0#2#0#7#7#0#37
1#МУНИЦИПАЛЬНЫЙ ЛИЦЕЙ#Головин#Алексей#8#М#ГОР#ВОРОНЕЖ#УЛ ЛИЗЮКОВА 81#394088#0732 137587#7#7#7#7#7#6#7#7#7#7#0#69
0#ЯЗ ГИМНАЗИЯ ИМ А В КОЛЬЦОВА#Корж#Дмитрий#11#Б##ВОРОНЕЖ# ВОЛОДАРСКОГО 41#394000#0732 552759#3#8#6#8#7#4#6#0#0#0#0#42
0#ЯЗ ГИМНАЗИЯ ИМ А В КОЛЬЦОВА#Ладная#Екатерина#11#Б##ВОРОНЕЖ# ВОЛОДАРСКОГО 41#394000#0732 552759#4#5#4#7#6#3#3#0#0#0#0#32
0#ЯЗ ГИМНАЗИЯ ИМ А В КОЛЬЦОВА#Кузнецова#Наталья#11#Б##ВОРОНЕЖ# ВОЛОДАРСКОГО 41#394000#0732 552759#4#5#4#6#6#4#3#0#0#0#0#32
0#ЯЗ ГИМНАЗИЯ ИМ А В КОЛЬЦОВА#Де-Жорж#Инна#11#Б##ВОРОНЕЖ# ВОЛОДАРСКОГО 41#394000#0732 552759#4#5#4#6#6#4#3#0#0#0#0#32
0#ЯЗ ГИМНАЗИЯ ИМ А В КОЛЬЦОВА#Загонова#Виктория#11#Б##ВОРОНЕЖ# ВОЛОДАРСКОГО 41#394000#0732 552759#4#5#4#8#5#1#3#0#0#0#0#30
0#ГИМНАЗИЯ ИМ А В КОЛЬЦОВА#Гудков#Илья#11#Б#ГОР#ВОРОНЕЖ#УЛ ВОЛОДАРСКОГО 41#394000#0732 552759#4#4#4#6#3#2#3#0#0#0#0#26
2#МОК#Вдовина#Вера#11#Б##ВОРОНЕЖ#УЛ ШЕНДРИКОВА 7#394086#80732 317825#2#6#5#5#2#2#2#0#0#0#0#24
72#ШКОЛА#Холявка#Марина#11#Б##ВОРОНЕЖ# ЮЖНОМОРАВСКАЯ 18#394062#0732 331084#5#6#8#7#9#6#9#0#0#0#0#50
4#СРЕДНЯЯ ШКОЛА#Лукина#Дарья#11#Б#ГОР#ВОРОНЕЖ#БУЛЬВАР ПИОНЕРОВ 14#394038#0732 336762#3#6#6#2#3#3#2#0#0#0#0#25
4#СРЕДНЯЯ ШКОЛА#Кварацхелия#Кристина#11#Б#ГОР#ВОРОНЕЖ#БУЛЬВАР ПИОНЕРОВ 14#394038#0732 336730#3#5#6#3#3#3#0#0#0#0#0#23
...
и т.д.
</pre>
</font>
Сначала это, правда, был файл *.dbf, но его при помощи программы
<font color=green>
<pre>
#!/usr/bin/perl
qx[dbfdump --fs="\x18" --rs="\x19"  olimp.dbf >one.txt];
</pre>
</font>
сделали текстовым, потом <font color=green>perl -i -n -p -e 's!\x18!#!;
s!\x19!\n!;' one.txt</font> получили исходный. 
Нужно сделать рассылку по школам, т.е. отсортировать по городам, по
названиям школ
и в каждую поместить по пользователю. Выходные данные должны быть в формате
<font color=green>excel</font>,
т.к. для каждого конверта нужны полный адрес школы и список результатов
каждого учащегося.
Причем, <font color=green>excel</font> позволяет отдавать на печать файлы
постранично, т.е. для каждой школы отдельная 
страничка и потом удобно все это раскладывать по конвертам, т.е. нужно в
файле <font color=green>excel</font> поставить
разрывы страниц. Данную задачу реализует следующий скрипт:

<font color=green>
<pre>
#!/usr/bin/perl
use Spreadsheet::WriteExcel;

open F, "&lt;one.txt"; @mass=&lt;F&gt;; close F;

@res1=grep{s!^(.*?#.*?#)(.*?#.*?#.*?#.*?#)(.*?#.*?#)!$3$1$2!} @mass;
@res = grep{!$_{$_}++} 
       map{/^(.*?#.*?#).*?#.*?#/} @res1;

for $gr(@res){
  for $line(@res1){push @{$hash{$gr}{$1}}, $2 
    if $line=~m!$gr(.*?#.*?#)(.*)$!}
}

my $workbook = Spreadsheet::WriteExcel->new("olimp2.xls");
my $sheet = $workbook->addworksheet("all children");
my $format = $workbook->addformat();

$format ->set_text_wrap();
$format->set_bold();
$format->set_size(11);
$format->set_color('blue');
$format->set_align('center');
$sheet->set_column(1, 3, 70);
$sheet->set_row(0,30);
$sheet->activate();

print "end build hash\n";

print "write file...\n";

for $a(sort keys %hash){
  $m=$a; $m=~s!#! !ig; 
  for $key(sort keys %{$hash{$a}}){
    $pb++;
    $u=$key; $u=~s!#! !ig; $i++;
    my $from = join " " => @{[split /#/ => ${$hash{$a}{$key}}[0]]}[4..6];
    $sheet->write($i, 0, "$m $u $from", $format)  if $pb >= 2000;
    for my $test(sort @{$hash{$a}{$key}}){ $i++; $h++;
      my $name = join " " => @{[split /#/ => $test]}[0 .. 3];
      my $nums = join " " => @{[split /#/ => $test]}[7 .. 18];
      $sheet->write($i, 0, "$name $nums") if $pb >= 2000;
    }
    print "$pb\n" if $pb % 1000 == 0;
    $sheet->set_h_pagebreaks($i+1) if $pb >= 2000;
  }
}

print "$m $u $from\n";
print "$h - done\n";
</pre>
</font>

Разберем его работу. Скрипт использует хеши хешей массивов. Строчка 
<font
color=green>@res1=grep{s!^(.*?#.*?#)(.*?#.*?#.*?#.*?#)(.*?#.*?#)!$3$1$2!}
@mass;</font>
заполняет массив будущими ключи хеша по названию города и улицы, т.к. в
городе Саратов
вполне может встретится воронежская или ленинградская улица, что смешает
результаты.
Строчка <font color=green>@res = grep{!$_{$_}++} map{/^(.*?#.*?#).*?#.*?#/}
@res1;</font> убирает
повторяющиеся элементы для вложенного хеша, т.е. выделяет названия адресов
школ.

Цикл 
<font color=green>
<pre>
for $gr(@res){
  for $line(@res1){push @{$hash{$gr}{$1}}, $2 
    if $line=~m!$gr(.*?#.*?#)(.*)$!}
}
</pre>
</font>
заполняет хеш хешей массивов. Далее требуется чтение <font color=green>man
Spreadsheet::WriteExcel</font> 
и начинаем вывод их хеша и запись файла <font color=green>excel</font>.
Строчка 
<font color=green>my $from = join " " => @{[split /#/ =>
${$hash{$a}{$key}}[0]]}[4..6];</font>
расшифровывается как взять нулевой элемент массива <font
color=green>${$hash{$a}{$key}}</font>, потом
разрезать его по строчкам в массив по разделителю #: <font
color=green>[split /#/ => ${$hash{$a}{$key}}[0]]</font>.
Далее взять от массива срез, превратить его в строку, которая будет являться
адресом. Одно "но", <font
color=green>excel</font>
не позволяет ставить более 1000 <font color=green>pagebreaks</font> для
каждого открытого файла, и поэтому приходится
придумывать различные условия, вроде постраничного вывода. Т.к. надо было
сделать быстро, то дабы не писать постраничный вывод обошелся условием
<font color=green>if $pb >= 1000 ... etc...</font>.<p>
Т.е. следите за обновлениями <a href="http://www.cpan.org"
target=_new>www.cpan.org</a>
<hr>

<a name="files_mason_html"></a>
<h4>
<a name=files_mason_html_mason>Mason - онлайновый парсер статических файлов на perl</a>
</h4>
<p>
Программа, позволяющая полностью управлять статическим и, если того
захотеть, динамическим наполнением сайта. Или писать вызовы обращений к базе
данных прямо в тексте html-страницы.  
<p>
Для её запуска необходимы <font color=green>Apache</font> и <font
color=green>mod_perl</font>.
<p>
В <font color=green>httpd.conf</font> нужно дописать то, о чем написано в
<font color=green>man HTML::Mason</font>. После этого Ваш сайт(вне
зависимости от его размера) ну, если не становится ручным пони, то уж точно
чем нибудь типа уральского тяжеловоза. Все описания и другие оставшиеся
слова можно прочитать на сайте <a href="http://www.masonhq.com/"
target=_new>http://www.masonhq.com/</a>. Сначала <a
href="http://search.cpan.org/search?dist=HTML-Mason">HTML-Mason</a>, потом
<a href="http://search.cpan.org/search?dist=mod_perl">mod_perl</a>, далее
некоторая возня с service httpd restart на предмет "в httpd.conf нужно
дописать то, о чем написано в <font color=green>man HTML::Mason</font>, ну,
примерно то, что нужно
написать". Потом создать директорию <font color=green>/path/to/dir/for/mason</font>.
После её создания пишем
простой <font color=green>test.html</font>:

<font color=green>
<pre>
   &lt;HTML&gt;
   &lt;HEAD&gt;
   &lt;TITLE&gt;Yo! Wazzup!!!!
   % my $noun = 'World';
   % my $date = qx[date];
   Hello &lt;% $noun %&gt;!
   Today is &lt;% $date %&gt;
   % my $ua = $r-&gt;header_in('User-Agent');
   % if ($ua =~ /msie/i) {
     Welcome, Internet Explorer users
   ...
   % } elsif ($ua =~ /mozilla/i) {
     Welcome, Netscape users
   ...
   % }
   &lt;/TITLE&gt;&lt;/HEAD&gt;
   &lt;BODY BGCOLOR="#FFFFFF"&gt;
   &lt;H1&gt;Yo! Wazzup!!!!&lt;/H1&gt;
   &lt;& index.file &>
   &lt;/BODY&gt;
   &lt;/HTML&gt;
</pre>
</font>

строчка, в которой содержится сам код, должна начинаться с символа <font
color=green>%</font>:<font color=green>% my $noun = 'World';</font> 
Если не хочется кадый раз ставить символ процента, то код можно поставить в
между тегами 
<font color=green>
<pre>
&lt;%perl&gt; 
... to do...
&lt;/%perl&gt;
</pre>
</font>
Аналогично директивам SSI из html странички можно вызывать и файлы(в том
числе и текстовые, например если создается библиотека).
<font color=green>
<pre>
&lt;& index.html &>
</pre>
</font>
Можно так-же делать включения скриптов вида
<font color=green>
<pre>
%# &lt;& /include/all_newsheads.msn &>
</pre>
</font>
Хотя так-же спокойно можно включать скрипты командой <font
color=green>qx[lalalala]</font>
<p>
<p>

Например обращение к базе данных на серверной стороне:
<font color=green>
<pre>
    &lt;html&gt;
      &lt;head&gt;&lt;title&gt;&lt;% $headline %&gt;&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
      &lt;h2&gt;&lt;% $headline %&gt;&lt;/h2&gt;
      By &lt;% $author %&gt;, &lt;% $date %&gt;&lt;p&gt;
      
      &lt;% $body %&gt;
      
      &lt;/body&gt;&lt;/html&gt;

      &lt;%init&gt;
      # Fetch article from database
      my $dbh = DBI::connect ...;
      my $sth = $dbh-&gt;prepare("select * from articles where id = ?");
      $sth-&gt;execute($article_id);
      my ($headline,$date,$author,$body) = $sth-&gt;fetchrow_array;
      # Massage the fields
      $headline = uc($headline);
      my ($year,$month,$day) = split('-',$date);
      $date = "$month/$day";
      &lt;/%init&gt;

      &lt;%args&gt;
      $article_id
      &lt;/%args&gt;
</pre>
</font>

Фактически блок <font color=green>&lt;%init&gt;</font>  эквивалентен блоку
<font color=green>&lt;%perl&gt;</font>. При таком введении наиболее читаемые
компоненты (особенно для непрограммистов) содержат <font
color=green>HTML</font> в одном непрерывном блоке наверху, с простыми
заменами для динамических элементов, и никаких отвлекающих и запутывающих
блоков кода на <font color=green>perl</font>. 

<p>

Примеры работы, <a href="http://www.pereplet.ru"
target=_new>http://www.pereplet.ru</a>, литературный журнал, где каждое
высказывание в дискуссии по определенному произведению прицепляется к
определенному произведению <font color=green>html</font>. И практически на
одном <font color=green>mason</font>'е написан научный сервер <a
href="http://www.nature.ru" target=_new>http://www.nature.ru</a>
<hr>

<a name="files_lwp_simple_html"></a>
<h4>
<a name=files_lwp_simple_html_lwp_simple>Программа, позволяющая скачивать и сохранять файлы с удаленного сервера</a>
</h4>
<font color=green>
<pre>
   #!/usr/bin/perl

   use strict;
   use LWP::Simple;

   my $url="http://www.server.ru/mp3/";
   my $dir="/path/to/your/mp3/dir";

   grep {getfile("$url$1.mp3") 
         if m!&lt;A HREF="(.*?)\.mp3"&gt;!i} 
         split /\n/ => get $url;

   sub getfile{
     print "$_[0]\t=\tbegin...\n";
     print @{[head $_[0]]}[1],"\n";
     my $res = LWP::UserAgent-&gt;new-&gt;request(new HTTP::Request GET=&gt; $_[0]);
     $_[0]=~s!.*/!!;
     if ($res-&gt;is_success) {
       open (ABC, "&gt;$dir/$_[0]") or die "Can't create $dir/$_[0]: $!";
       binmode(ABC);
       print ABC $res-&gt;content; close ABC or die $!;
     } else {
       print $res-&gt;status_line;
     }
     return 1;
   }
</pre>
</font>
конструкция 
<font color=green>
<pre>
   grep {getfile("$url$1.mp3") 
         if m!&lt;A HREF="(.*?)\.mp3"&gt;!i} 
         split /\n/ =&gt; get $url;
</pre>
</font>
берет листинг директории(например без индексного файла) <font
color=green>get $url</font>, сплитит его по 
переводу каретки, возвращает массив, который в цикле перебирается и если
есть линк 
на <font color=green>*.mp3</font>, то подпрограмме передается  адрес файла <font
color=green>$url$1.mp3</font>.
В строке <font color=green>print @{[head $_[0]]}[1],"\n";</font> берется
<font color=green>head</font>, возвращающий массив и из 
него вытаскивается второй элемент, который является размером файла и затем
<hr>

<a name="files_pop_b4_smtp_html"></a>
<center>
<h4>
<a name=files_pop_b4_smtp_html_pop_b4_smtp>pop before smtp для popa3d(другие демоны pop-аутентификации можно дописать,
о чем здесь ниже)</a>
</h4>
</center>
<p align=justify>
Когда конфигурируют <font color=green>sendmail</font>, в файле <font color=green>/etc/mail/access</font> содержатся
правила для доставки почты, смысл которых заключается в том, что
можно отправлять почту только с определенных айпиадресов, прописанных в файле <font color=green>/etc/mail/access</font>. 
Что не очень удобно, если обладатель почтового ящика довольно часто перемещается по миру и из-за этих 
правил не может отправлять почту через свой адрес. Для преодоления данной трудности существуют
два патча: <a href="http://www.sendmail.org/~ca/email/auth.html" target=_new>SMTP AUTH</a> и 
<a href="http://spam.abuse.net/adminhelp/smPbS.shtml" target=_new>pop before smtp</a>. Ни одну 
из них поставить не удалось, и пришлось поступить следующим образом: идем на сайт 
<a href="http://people.oven.com/bet/pop-before-smtp/" target=_new>pop before smtp
for Postfix</a>, скачиваем тамошний модуль, распаковываем его и находим в распакованном файл <font color=green>popa3d-0.4.patch</font>(там и для других демонов батчи есть, см. <font color=green>README</font>). Согласно написанному правим сишные исходники демона <font color=green>popa3d</font>, компилируем демон, получаем бинарник и перезаписываем его в <font color=green>/usr/sbin/popa3d</font>. В результате в логах при <font color=green>pop3</font>-аутентификации добавляется ip-адрес снявшего почту. Итого имеем имя и адрес снимающего почту. Дальше нужно написать некую программу, которая умеет смотреть, что добавляется в лог-файл, извлекать оттуда имя и ip-адрес и запысывать ip в <font color=green>/etc/mail/access</font>:

<font color=green>
<pre>
#!/usr/bin/perl -wT

use strict;
use File::Tail;
use Fcntl ':flock';
use Date::Parse;

my $l = '/var/log/messages'; #путь до логфайла
my $file="/etc/mail/access"; #путь до файла с relay'ями на ip
my (@q, $fi, $ip);
my $relay = 60;#время открытого релея после popa3d-аутентификации для ip, снявшего почту

&tail(); 

while (1){
    m&^(.*\d+:\d+:\d+).*\[(.*?)\]$& if $_=$fi-&gt;read; #get ip and name
    my $time = str2time($1) + $relay or next; $ip=$2; #таймер
    next if $time &lt; time;  
    open A, "&gt;&gt;$file" or die "can't open: $!";    flock A, 2;
    print "\tВремя для $ip пошло(всего $relay секунд), relay открыт\n";
    print A "$2\t\tRELAY\n"; 
    close A; &makemap(); #закрываем и делаем ребилд для /etc/mail/access.db
    push @q, $time; 
    while(1){
     do{ my @file;
       open B, "&lt;$file" or die "can't open: $!";  flock B, 1;
       do{ push @file, $_ unless m%^$ip%} while (&lt;B&gt;); #не нужны ip, у которых кончилось время
       close B;
       print "\tВремя для $ip закончилось, relay закрыт\n"; 
       open C, "&gt;$file" or die "can't open: $!"; 
       flock C, 1;
       print C join "" =&gt; grep{!m&^$ip(\t)\1+RELAY$&} @file;
       close C; &proverka();
       &makemap(); #закрываем и делаем ребилд для /etc/mail/access.db
       last
     } if $q[0] &lt; time; sleep 1
    } $#q=-1;
}

sub makemap{qx[makemap hash /etc/mail/access&lt;/etc/mail/access]}

sub tail{ 
  return $fi = File::Tail-&gt;new(
    name =&gt; $l,
    maxinterval =&gt; 1,
    adjustafter =&gt; 1000000000,
    interval =&gt; 4,
    tail =&gt; 0)
}

sub proverka{
    open D, "&lt;$file" or die "can't open: $!"; flock D, 1;
    my @debug=&lt;D&gt;; close D;
    open E, "&gt;$file" or die "can't open: $!"; flock E, 1;
    print E join "" =&gt; grep{!m/Authentication passed/} @debug;
    close E;
}
</pre>
</font>

Вобщем берется модуль <font color=green>File::Tail</font> со спана и натравливается на логфайл. Соответственно 
по нему читаются маны и т.д. В чем прелесть, можно написать <font color=green>shell-script</font>(взял из 
<font color=green>init-redhat-alex</font> из <font color=green>pop before smtp</font> 
для почтовика <font color=green>Postfix</font>) и сделать приведенный скрипт демоном, который по добавлению в логфайл открывает на 30 секунд <font color=green>RELAY</font> для того,
кто перед этим снял почту, используя стандартные методы аутентификации<font color=green>POP3</font>. можно релей открывать на 15 секунд... но, вобщем, вроде-бы защиту от спамеров оно гарантирует. Ниже методы проверки адреса на <font color=green>relay</font>. 
Ну а на сервере, через который происходит отправка почты, выглядит это примерно так(результат отправки почты при помощи
написанных на perl pop и smtp клиентов, см. ниже):
<font color=green>
<pre>
[root@tv pop-before-smtp-1.28]# /root/pop-before-smtp-1.28/contrib/init-redhat-alex start
Запуск pop-before-smtp:                                  [ OK ]
[root@tv pop-before-smtp-1.28]# 
	Время для 194.218.214.122 пошло(всего 60 секунд), relay открыт
	Время для 194.218.214.122 закончилось, relay закрыт.

</pre>
</font>
Можно сделать так, чтобы эти сообщения писались в то-же <font color=green>/var/log/message</font>. Программа очень нехитрая, написана на несложном языке, соответственно модификации для остальных видов демонов приветствуются.
<p align=justify>Соответственно можно подправить <font color=green>sendmail.cf</font> на предмет
подсказки пользователю, что он должен сделать, чтобы отправить почту:
<font color=green>
<pre>
# check client name: first: did it resolve?
R$*		$: &lt; $&{client_resolve} &gt;
R&lt;TEMP&gt;		$#error $@ 4.7.1 $: "450 Relaying temporarily denied. Cannot resolve PTR record for " $&{client_addr}
R&lt;FORGED&gt;	$#error $@ 5.7.1 $: "550 Relaying denied. IP name possibly forged " $&{client_name}
R&lt;FAIL&gt;		$#error $@ 5.7.1 $: "550 Relaying denied. IP name lookup failed, please, get your mail for check relay" $&{client_name}
R$*             $: &lt;?&gt; $&{client_name}

</pre>
</font>

Теперь пытаемся отправить почту из Нью-Йорка например через www.online.ru
и получаем ответ(исходник smtp.pl см. ниже):
<font color=green>
<pre>
[root@www devel]# ./smtp.pl
SMTP RCPT command failed:
5.7.1 &lt;user@last.my.server.ru&gt;... Relaying denied. IP name lookup 
failed, please, get your mail for check relay[194.218.214.122]

 at ./smtp.pl line 18
[root@www devel]#
</pre>
</font>

<p align=justify>
Логин телнетом на 25-й порт <font color=green>sendmail</font>'а для открытого релея(при закрытом ругнется и напишет <font color=green>relaing denyed</font> и разорвет соединение):

<font color=green>
<pre>
[root@tv /root]# telnet tv 25
Trying 212.142.230.135...
Connected to tv.server.ru (212.142.230.135).
Escape character is '^]'.
220 tv.server.ru ESMTP Sendmail 8.11.2/8.11.2; Sun, 24 Mar 2002 02:10:00 +0300
mail from:&lt;test@tv.server.ru&gt;
250 2.1.0 &lt;test@tv.server.ru&gt;... Sender ok
rcpt to:&lt;user@last.my.server.ru&gt;
250 2.1.5 &lt;user@last.my.server.ru&gt;... Recipient ok
data
354 Enter mail, end with "." on a line by itself
dfg
.
250 2.0.0 g2NNANt15274 Message accepted for delivery
</pre>
</font>

Pop-3 клиент на perl:
<font color=green>
<pre>
#!/usr/bin/perl

use Net::POP3;

$p=Net::POP3-&gt;new("tv.server.ru")
  or die "cant open connection to server: $!\n";
$p-&gt;login("test","rusalka") or die "Cant  authentificate: $!\n";
$m=$p-&gt;list or die "cant get list of undeleted mesg: $!\n";
foreach $list(keys %$m){
$msg=$p -&gt; get($list);
print "@$msg\n";
}
</pre>
</font>

И smtp клиент:

<font color=green>
<pre>
#!/usr/bin/perl

$to = 'user@last.my.server.ru';
$from = 'test@tv.server.ru';

use MIME::Lite;

$msg = MIME::Lite-&gt;new(
        To       =&gt;$to,
        From     =&gt;$from,
        Subject  =&gt;'Helloooooo, nurse!',
        Type    =&gt;'multipart/mixed'
                        );
$msg->attach(Type     =&gt;'text',
             Data     =&gt; qq{test}
            );
MIME::Lite-&gt;send('smtp', "tv.server.ru", Timeout=&gt;60);
$msg-&gt;send;
</pre>
</font>

Вобщем все, но лучше бы протестировать открывающий релей скрипт, потому, что  мог допустить какую-то ошибку. 


<hr>

<a name="files_apache_html"></a>
<center><h4><a name=files_apache_html_apache>Использование регулярных выражений в apache</a></h3></center>
<p align=justify>
Преположим есть веб-сервер, на котором пользователям нужно 
завести домашние директории. В конфигурационном файле <font color=green>httpd.conf</font> они должны иметь
в <font color=green>/home/user/</font> директорию <font color=green>public_html</font>, тогда стандартным образом пользовательские директории могут вызываться примерно так: <font color=green>http://www.server.su/~user/</font>
Нужно сделать так, чтобы пользователи могли исполнять
скрипты и программы в своих директориях. Заводим в 
директории <font color=green>/home/user/public_html</font> директорию <font color=green>cgi-bin</font>. В <font color=green>httpd.conf</font>
пишем 
<font color=green><pre>
ScriptAliasMatch ^/~(.*)/ex/(.*) "/home/$1/public_html/cgi-bin/$2"
</pre></font>
<p align=justify>
и после этого <font color=green>service restart httpd</font> и пользователи могут исполнять и вызывать свои скрипты по адресу <font color=green>http://www.server.su/~user/ex/test.pl</font>
<hr>

<a name="files_spisok_html"></a>
<center>
<h4>
<a name=files_spisok_html_spisok>Работа со списками</a>
</h4>
</center>
Задача, есть ряд вида:
<pre>
<font color=green>
.3
.3.1
.3.1.1
.2
.2.1
.2.1.1
.2.1.1.1
.1
</font>
</pre>
<p align=justify>Найти максимальное число с максимальным вложением единичек.
Решение, если убрать точки, будет максимальным числом.
Его и надо выделить:
<pre>
<font color=green>
#!/usr/bin/perl -w
$_=qq~.3
.3.1
.3.1.1
.2
.2.1
.2.1.1
.2.1.1.1
.1
~;

print ".", join "." => split m!! =>
     @{[reverse sort {$a <=> $b} grep{s!\.!!g} split m%\n%]}[0];
print "\n";
</font>
</pre>
<p align=justify>Как это работает: конструкця <font color=green>@{[</font> тут 
действия со списками <font color=green>]}</font> возвращает массив элементов, из 
которого можно выделить нужный по номеру элемента массива 
<font color=green>@{[blah-blah]}[0]</font>. В переменной <font color=green>$_</font> 
содержится искомая "строка" из цифр, поэтому её можно разбивать по переводу 
каретки: <font color=green>split m%\n%</font>. После 
<font color=green>split m%\n%</font> для <font color=green>grep{s!\.!!g}</font> 
возвращается список, который из каждого элемента списка вырезает символ 
точки(экранированный символ, т.к. символ точки в <font color=green>regex</font> 
означает любой символ). Дальше возвращается список чисел без точки, 
которые сортируются при помощи <font color=green>sort {$a <=> $b}</font>. 
Скобки <font color=green>{$a <=> $b}</font> 
нужны для того, чтобы была произведена числовая, а не символьная сортировка.
 Т.е. в случае <font color=green>print join "\n" => sort {$a <=> $b} grep{s!\.!!g} @blah-blah</font> функция <font color=green>sort</font> вернет такой список, где максимальным будет число, содержащее в начале себя тройку как максимальное число, т.е. критическим будет "старший бит":
<pre>
<font color=green>
1
2
21
211
2111
3
31
311
</font>
</pre>
<p align=justify>далее при помощи <font color=green>reverse</font> оборачивается 
возвращаемый <font color=green>sort</font> список и берется нулевой элемент массива, 
состоящий из числа(в данном случае) <font color=green>2111</font>(что как число
<font color=green>2111</font> в целом больше, чем <font color=green>311</font>). Этот нулевой элемент затем режется по символу ноль(или по пустому символу, ведь между цифрой <font color=green>2</font> и <font color=green>1</font> не стоит ничего, вот по этому то <font color=green>ничего</font> и режется): <font color=green>split m!! => @{[blah-blah]}[0]</font>. Обычно в конструкции <font color=green>split</font> ставятся два косых слеша <font color=green>split //, $string;</font> эти два косых слеша есть не что иное как поиск по подстановке <font color=green>m//</font>. А при указании буквы <font color=green>m</font> в регулярном выражении слеши можно заменять любыми символами, например <font color=green>split mЫЫ</font>. Далее при обычном синтаксисе ставится запятая, эту запятую можно заменить на стрелочку <font color=green>=&gt;</font> без потери функциональности. Итого имеем <font color=green>split m!! => @{[blah-blah]}[0]</font>, т.е. массив,  который нужно вывести в прежнем виде, т.е. <font color=green>.2.1.1.1</font>, чего и делаем: <font color=green>print ".", join "." => split m!! => @{[blah-blah]}[0]</font>
<p align=justify>
Другое более короткое решение той-же задачи от Artem Chuprina(from fido7.ru.perl):<pre>
<font color=green>
perl -lne 'if (/(\d+)/ && ($1 > $num || ($1 == $num && length($_) > 
length($res)))) { $num = $1; $res = $_ }; END { print $res }' test.dat
</font>
</pre>
<hr>

<a name="files_chmod_html"></a>
<h4><a name=files_chmod_html_chmod>Backup прав доступа на файлы и директории[only for unix like
systems]</a></h4>
Программа, восстанавливающая пермишны на файлы например в случае
непреднамеренного использования команды <font color=green>chmod -R 777
*.*</font> из корневой директории(или в аналогичных ситуациях). В
комментариях разъяснена работа программы:

<pre><font color=green>
#!/usr/bin/perl -w

use strict;
use File::Find;

my ($test, $dir, $db, $pwd, $tmp);

$db="/home/user/cgi/xxx.dat";

###################
#program section  #
###################

&exc(); #read exceptions
unlink $db if !-z $db and $ARGV[0] eq 'r';
#стираем файл старой базы при команде r в случае если он ненулевого размера

find \&read => "$dir" if $ARGV[0] eq 'r';
#начать сканировать поддиректории если с командной строки пришло r

rewrite() if $ARGV[0] eq 'w';
#начать восстанавливать права на файлы, если с командной строки пришло w

##################
#subroutines     #
##################

sub read {#чтение прав
  $test=sprintf "%04o" => (stat($File::Find::name))[2] & 07777;
  #получить права на файл ли директорию
  &readchmod("$File::Find::name\t$test\n");
  #вызов подпрограммы для записи базы
}

sub readchmod{#запись прав
  open F, ">>$db" or die "Can't open $db: $!";
  print F $_[0];
  print "$_[0]"; #смотрим, что записывается
  close F;
}

sub rewrite{#перезапись прав
  open F, "<$db" or die "Can't open $db: $!";
  while(<F>){ chop; #читаем построчно в $_ и отъедаем от него перевод
каретки
    my ($file, $chmod) = split /\t/;
    qx [chmod $chmod $file]; #даем системную команду chmod
    print "$chmod\t=>\t$file\n"; #смотрим, что делает программа
  } close F;
}

sub exc{
  do{print "Type './chmod.pl ?' or './chmod.pl h'\n"; exit 0}
    if $#ARGV==-1;#обрабатываем пустой ввод вида ./chmod.pl

  do {print "Your command must be 'w', 'r', 'h' or '?'!\n"; exit 0}
    if $ARGV[0]!~m%^[wr?h]$% and $#ARGV!=-1;
  #обрабатываем все остальные буквы, кроме необходимых

  do{ print qq~
Программа создает базку пермишнов на файлы и директории на
случай экстренных ситуаций вроде неправильного или случайного
использования команды chmod -R 777 из корневой директории.

chmod.pl [w|r|h|?] [/полный/путь/до/директории]

Для указания директории, от которой будет создаваться база
пермишнов, нужно ввести команду  "r /path/you/dir"

Для создания базы на права для файлов и дирректорий
Вы должны ввести "r".

Для восстановления прав на файлы и директории вы должны
ввести команду "w".

Справка по командам "?" или "h". 

Второй аргумент должен быть полным путем к директории, от которой нужно
начинать рекурсивно сохранять права. По умолчанию стоит текущая
директория. Например если Вы запустили программу из корневой директории,
 то текущей директорией начала просмотра подкаталогов будет считаться 
корневая директория, если в файле /home/user/.shrc внесена переменная
окружения $ENV{PWD}.

  ~; exit 0} 
    if $ARGV[0]=~m!^[?h]$!; #выводим хелп

  if($ARGV[1] eq ''){#есл не ввели второго аргумента в командной строке
                     #то определяем переменную $dir
    #while(my ($k, $v)=each %ENV){print "$k\t=>\t$v\n"}
    #смотрим, что содержит переменная окружения,
    #содержащаяся в /home/user/.shrc
    $dir=$ENV{PWD};
    #определяем директорию запуска скрипта, чтобы с этой точки начать
    #поход по поддиректориям 
  } else {
    -d $ARGV[1] or die "$!";#если то, что пришло вторым аргументом
                            #директория, то идем дальше, иначе читаем
                            #ошибку
    $dir=$ARGV[1];
  }

  return 1;
}
</font></pre>

Если нашли a lot of bugs - <a
href="mailto:dmitriy@genphys.phys.msu.su?subject=chmod">пишите</a>.
<p><br>
<hr>

<a name="files_uniqhash_html"></a>
<center>
<h4>
<a name=files_uniqhash_html_uniqhash>Как найти уникальные ключи в двух хешах?</a>
</h4>
</center>

<p>
Во первых нужно извлечь ключи из хешей и затем выбирать
уникальные элементы из массива:
<font color=green>
<pre>
        %seen = ();
        for $element (keys(%foo), keys(%bar)) {
            $seen{$element}++;
        }
        @uniq = keys %seen;
</pre>
</font>
или так:
<font color=green>
<pre>
        @uniq = keys %{{%foo,%bar}};
</pre>
</font>
если необходимо использовать минимальный размер памяти:
<font color=green>
<pre>
        %seen = ();
        while (defined ($key = each %foo)) {
            $seen{$key}++;
        }
        while (defined ($key = each %bar)) {
            $seen{$key}++;
        }
        @uniq = keys %seen;
</pre>
</font>

для того, чтобы выбрать повторения из массива можно воспользоваться строчкой:
<font color=green>
<pre>
        @uniq=grep{!$hash{$_}++} @mass;
</pre>
</font>
для того, чтобы убрать строки в массиве, содержащие какие-то произвольные одинаковые данные, можно немного модифицировать приведенную строчку:
<font color=green>
<pre>
        @uniq=grep{!$hash{$1}++ if m&$name\001($value)\001$other\n&} @mass;
</pre>

<hr>

<a name="files_find_html"></a>
<center>
<h4>
<a name=files_find_html_find>РПЙУЛ РП УФЕРЕОЙ УПЧРБДЕОЙК УМПЧ Ч РТЕДМПЦЕОЙСИ</a>
</h4>
</center>
<p align=justify>
ъБДБЮБ, УДЕМБФШ РПЙУЛПЧЙЛ ЮФПВЩ УПТФЙТПЧБМ ТЕЪХМШФБФЩ РП ТЕМЕЧБОФОПУФЙ,
ЙМЙ, ЮФП ФП-ЦЕ УБНПЕ, ПГЕОЙЧБМ РПИПЦЕУФШ, УФЕРЕОШ ПДЙОБЛПЧПУФЙ УМПЧ.
<p align=justify>
ьФХ ЪБДБЮХ ВПМЕЕ НЕОЕЕ ТЕБМЙЪХЕФ РТЙЧЕДЕООЩК ОЙЦЕ УЛТЙРФ:  
<font color=green>
<pre>
#!/usr/bin/perl -w
use locale;

%oo=("ВХДЕФ"=>1, "БЖТЙЛБ"=>1, "ЪБЧФТБ"=>1);

$b="БЖТЙЛБ БЖТЙЛБ ВХДЕФ БЖТЙЛБ ЪБЧФТБ";
$o="БЖТЙЛБ ВХДЕФ ЧЮЕТБ ЪБЮЕН ЮФП-ФП";
$tw="БЖТЙЛБ ОЕВХДЕФ ЧЮЕТБ ВХДЕФ ЪБЧФТБ";
$tb="БМСУЛБ БМСУЛБ ВХДЕФ ВХДЕФ ВХДЕФ УЕЗПДОС";

@m=($b, $o, $tb, $tw); rrand(\@m);
print join "\n", @m,"\n";

for $i(0 .. $#m){
  $h{$i}{$1}++ while $m[$i]=~m!((\w[\w-]*){4,30})!g;
  $vr{$i}=$m[$i];
}

for $r(keys %h){print "\n"; 
  my (@ee, $u, $trr);
  for $n(keys %{$h{$r}}){
    do{
      $t = join " " => $vr{$r};
      $u+=1;
      push @ee => $h{$r}{$n};
    } if exists $oo{$n};
  } 
  print "$t ",$u + $ee[0]-1,"\n";
}

sub rrand{
  my $m = shift; my $i;
  for($i=@$m; --$i;){
    my $j = int rand($i+1);
    net if $i==$j;
    @$m[$i,$j] = @$m[$j,$i]
  }
}
</pre>
</font>
<p align=justify>
ЕУФШ ЛБЛПК-ФП ФЕЛУФ Ч РЕТЕНЕООБИ <font color=green>$b</font>,<font
color=green>$o</font>,<font color=green>$tw</font>,<font color=green>$tb</font>, ЪБЗПОСЕФУС ЧУЕ Ч НБУУЙЧ. дМС
ПФМБДЛЙ РЙЫЕФУС РПДРТПЗТБННБ <font color=green>rrand()</font>, ЛПФПТБС РЕТЕУФБЧМСЕФ УМХЮБОЩН ПВТБЪПН
ЬМЕНЕОФЩ НБУУЙЧБ. дБМЕЕ ЙДЕФ ГЙЛМ, РПДУЮЙФЩЧБАЭЙК ЮБУФПФЩ ПДЙОБЛПЧЩИ УМПЧ Ч
РЕТЕНЕООЩИ Й ЪБОПУСЭЙК ЬФЙ ЮБУФПФЩ Ч ИЕЫ ИЕЫЕК. ч ИЕЫЕ ИЕЫЕК 1(Ф.Л.
ОХХНЕТБГЙС ЬМЕНЕОФПЧ НБУУЙЧБ ВЩМБ УМХЮБОЩК ПВТБЪПН ЙЪНЕОЕОБ, ФП ХДПВОП
ПВТБЭБФШУС ЮЕТЕЪ ОПНЕТ НБУУЙЧБ) УПДЕТЦБФУС РТЕДРПМПЦЙН ДМС РЕТЕНЕООПК $b ФБЛЙЕ ДБООЩЕ:
<font color=green>
<pre>
     $b = "БЖТЙЛБ БЖТЙЛБ ВХДЕФ БЖТЙЛБ ЪБЧФТБ";

     $h{1}=(
            "БЖТЙЛБ" => 3,
            "ВХДЕФ" => 1,
            "ЪБЧФТБ" => 1
           ); 
</pre>
</font>
<p align=justify>
Ф.Е. УМПЧП <font color=green>БЖТЙЛБ</font> РП ЮБУФПФЕ ХРПФТЕВМЕОЙС Ч ФТЙ ТБЪБ ВПМШЫЕ Ч ЖБКМЕ, ЮФП
ДБЕФ ЕНХ ВПМШЫЙЕ ЫБОУЩ ЧЩМЕЪФЙ Ч УРЙУПЛ РЕТЩИ ТЕЪХМШФБФПЧ. дБМЕЕ УМЕДХАФ
УМПЧБ <font color=green>ВХДЕФ</font> Й <font color=green>ЪБЧФТБ</font>, ЛПФПТЩЕ ФБЛ-ЦЕ ЙЗТБАФ ОЕНБМПЧБЦОХА ТПМШ Ч РПДОСФЙЙ
УУЩМЛЙ ОБЧЕТИ ЙЪ ТЕЪХМШФБФПЧ РПЙУЛПЧПЗП ЪБРТПУБ. дБМЕЕ Ч ГЙЛМЕ ПВЯСЧМСЕФУС
ИЕЫ(ЪБДБЮБ ВЩМБ УДЕМБФШ, Б ОЕ РБНСФШ УЬЛПОПНЙФШ), ЛПФПТЩК ВХДЕФ ЧЩЧПДЙФШ
ТЕЪХМШФБФЩ ЪБРТПУБ.
<p align=justify>
дБМЕЕ ЙДЕФ ГЙЛМ:
<font color=green>
<pre>
     for $r(keys %h){print "\n";
       my (@ee, $u, $trr);
       for $n(keys %{$h{$r}}){
         do{
           $t = join " " => $vr{$r};
           $u++;
           push @ee => $h{$r}{$n};
         } if exists $oo{$n};
       } 
       print "$t ",$u + $ee[0]-1,"\n";
     }
</pre>
</font>
<p align=justify>
ЪБРТБЫЙЧБЕН ЮЙУМЕООПЕ ОБЪЧБОЙЕ ИЕЫБ Ч РЕТЕНЕООХА <font color=green>$r</font>, УЮЙФЩЧБЕН У Её РПНПЭША
ИЕЫЙ ИЕЫЕК. ъДЕУШ ЖХОЛГЙЕК <font color=green>exists</font> ТЕБМЙЪПЧБО РПЙУЛ ПВЭЙИ ЛМАЮЕК Ч ДЧХИ
ИЕЫБИ: Ч ИЕЫЕ, РПУФХРБАЭЕН ОБ ЧЧПД, Й ФЕЛХЭЕН РП ЫБЗХ ГЙЛМБ ИЕЫЕ ИЕЫЕК.
еУМЙ ЙОЖПТНБГЙС УПДЕТЦЙФУС Ч ОБЮБМШОПН ЧФПТПН ИЕЫЕ <font
color=green>%vr</font>, ФП ЪБРТБЫЙЧБЕН Её
<font color=green>$vr{$r}</font>. уФТПЮЛБ <font color=green>$u++</font> ПФЧЕЮБЕФ ЪБ ЛПМЙЮЕУФЧП ЧИПЦДЕОЙК ЧУЕИ УМПЧ, ЪБДБООЩИ Ч
ЪБРТПУЕ, Ч ЙУЛПНХА УФТПЛХ(ЖБКМ). дПРХУФЙН ОБ ЧИПДЕ ЖТБЪБ "<font color=green>ВХДЕФ БЖТЙЛБ
ЪБЧФТБ</font>", ЕУМЙ ИПФС ВЩ ПДОП УМПЧП ЙЪ ЬФПК ЖТБЪЩ УПЧРБМП УП УМПЧПН Ч ПЮЕТЕДОПК
УФТПЛЕ(ЧЕДШ ЙЪОБЮБМШОП УФТПЛБ ВЩМБ РПВЙФБ ОБ ЮБУФПФОЩК ИЕЫ) ФП МПЛБМШОБС РЕТЕНЕООБС
<font color=green>$u</font>
ХЧЕМЙЮЙФ УЧПЕ ЪОБЮЕОЙЕ ОБ ЕДЙОЙЮЛХ. еУМЙ ДЧБ УМПЧБ Ч УФТПЛЕ Й Ч ЪБРТПУЕ
ПДЙОБЛПЧЩ, ФП <font color=green>$u=2</font>, ЕУМЙ ФТЙ - <font color=green>$u=3</font> Й ФБЛ ДБМЕЕ, УМПЧ Ч ЪБРТПУЕ НПЦЕФ ВЩФШ МАВПЕ 
ЛПМЙЮЕУФЧП. дБМЕЕ ЙДЕФ УФТПЮЛБ 
<font color=green>
<pre>
     push @ee => $h{$r}{$n};
</pre>
</font>
<p align=justify>
ЛПФПТБС ЪБОПУЙФ ЮБУФПФЩ УМПЧ(<font color=green>3,1,1</font> ЛБЛ ВЩМП ЧЩЫЕ Ч РТЙНЕТЕ) Ч ФЕЛХЭЕК
УФТПЛЕ. дБМШЫЕ ЙДЕФ УБНБ <font color=green>exists</font> Й РПУМЕ ОЕё ТБЪВЙТБЕНУС У ЧЕУПН
РПЧФПТСАЭЙИУС УМПЧ Й ЧЕУПН РПМОЩИ УПЧРБДЕОЙК. ф.Е. ДПМЦОП ВЩФШ ФБЛ, ЮФПВЩ 
РПМОПЕ УПЧРБДЕОЙЕ ЖТБЪЩ ЙНЕМП ВПМШЫЕЕ ЪОБЮЕОЙЕ, ОЕЦЕМЙ ЮЕН ОЕРПМОПЕ
УПЧРБДЕОЙЕ + РБТБ РПЧФПТПЧ. оП ЖХОЛГЙС ЖЕДЕФ УЕВС РП ИЙФТПНХ, ДПРХУФЙН,
ЕУМЙ ОХЦОП ОБКФЙ УРЕГЙБМЙЪЙТПЧБООХА ЙОЖПТНБГЙА ФЙРБ "<font color=green>иЕЫ ИЕЫЕК ИЕЫЕК ИЕЫЕК
ИЕЫЕК НБУУЙЧПЧ</font>", ФП ЧЕУ РПЧФПТЕОЙК УМПЧ ВХДЕФ ВПМШЫЕ, Ф.Е. ЧЛМБД ЮМЕОБ
<font color=green>$ee[0]-1</font>(ТБЪОЙГБ Ч ЕДЙОЙГБИ ОБ УМХЮБК ОЕРТЕДОБНЕТЕООПЗП РПЧФПТБ) ВПМШЫЕ, ЮЕН
<font color=green>$u</font>. ч ФП-ЦЕ
<hr>

<a name="files_post_html"></a>
<center>
<h4>
<a name=files_post_html_postdata>Заполнение и отправка данных из скрипта формы на удаленном сервере</a>
</h3>
</center>

Допустим нужно регулярно отправлять на какую-нибдуь доску объявлений 
данные, причем необходимо заполнить несколько полей и при этом подгружать 
несколько картинок. Для того, чтобы заполнить текстовые поля name и descr 
в форме:
<font color=green>
<pre>
&lt;form action="http://www.server.ru/cgi-bin/gbook.pl" method=post&gt;
&lt;input type=text name=name size=20&gt;&lt;br&gt;
&lt;input type=text name=descr size=20&gt;&lt;br&gt;
&lt;input type=submit value="Submit"&gt;&lt;br&gt;
&lt;input type=reset value="clear"&gt;
&lt;/form&gt;
</pre>
</font>
нужно написать следующий скрипт(соответствующие значения полей name и descr
указаны в квадратных скобках):
<font color=green>
<pre>
#!/usr/bin/perl -w
use HTTP::Request::Common qw(POST);
use LWP::UserAgent;
$ua = LWP::UserAgent->new();
my $req = POST 'http://www.server.su/cgi-bin/gbook.pl',
  [ name => 'lalala', 
   descr => 'aaa'];
print $content = $ua->request($req)->as_string;
</pre>
</font>
Если в форме полей больше, чем в приведенном примере, то их нужно просто перечислить в квадратных
скобочках через запятую, причем после поледнего поля запятую ставить не
нужно:
<font color=green>
<pre>
my $req = POST 'http://www.server.su/cgi-bin/gbook.pl',
  [ name => 'lalala',
   email => 'user\@host.ru',
    text => qx{
bla-bla-bla
alalalalal hahahaha test

s privetom,
Vasya
}
   descr => 'aaa'];
</pre>
</font>
Если необходимо подгрузить помимо текста еще и картинку(картинки), то нужно указать
<font color=green>Content_Type => 'form-data'</font>: 
<font color=green>
<pre>
#!/usr/bin/perl -w
$test = "http://www.server.ru/add.html";
$file = "test.gif";
use HTTP::Request::Common qw(POST);
use LWP::UserAgent;
use CGI qw(header -no_debug);

my $req = POST $test,
Content_Type => 'form-data',
Content      => [
        user => 'vasya',
    password => '123456',
       image => [$file],
        href => 'aaaaaaaaaaaa',
     profile => '13',
       ratio => '333333',
         alt => 'Hot News!',
                ];
my $res = LWP::UserAgent->new->request($req);
print header, $res->is_success ? $res->content : $res->status_line;
print $req->as_string;
</pre>
</font>
если необходимо подгружать одновременно несколько картинок(любое число), без текста, то
это описано <a
href="../modules.html#upload">тут<a>
или слегка модифицировав POST-запрос:
<font color=green>
<pre>
my $req = POST $test,
Content_Type => 'form-data',
Content      => [
        user => 'vasya',
    password => '123456',
      image1 => [$file1],
      image2 => [$file2],
      image3 => [$file3],
      image4 => [$file4],
        href => 'aaaaaaaaaaaa',
     profile => '13',
       ratio => '333333',
         alt => 'Hot News!',
                ];
</pre>
</font>

Вобщем такими методами можно отправлять картинки и/или сообщения через интернет
на различные доски объявлений и подобные типы сервисов
 без участия человека. Так-же неплохо бы
найти и прочитать в интернете последнюю версию 
LWP FAQ by fido7.ru.cgi.perl by Paul Kulchenko (paulclinger@yahoo.com)

<p>
Данную программу можно приспособить, например, для отправки SMS-сообщений
через <a href="http://www.mts.ru/cgi-bin/cgi.exe?function=sms_send">www.mts.ru/sms</a> или иные странички.
В случае биллайна нужно позвонить по определенному телефону, после чего
на sms.beemail.ru будет выделен e-mail адрес, через который можно отпавлять
почту через sms. Но биллайн не разрешает отправку пересылаемых
сообщений(которые содержат Forward, т.е. нужно писать скрипт через
procmailrc или smrsh, который бы перенаправлял сообщения на sms.beemail.ru).
Так-же mts поддерживает отправку на sms простых картинок, но нужно с ними
предварительно договариватся о формате.

&nbsp;
<hr>

<a name="files_calendar_html"></a>
<center><h4><a name=files_calendar_html_calendar>Выводим даты при помощи модуля Calendar::Simple</a></h4></center>

Пример прямо из <font color=green>man Calendar::Simple</font>
<font color=green><pre>
#!/usr/bin/perl -w

use strict;
use Calendar::Simple;

my @months = qw(January February March April May June July August
                         September October November December);
                         
my $mon = shift || (localtime)[4] + 1;
my $yr = shift || ((localtime)[5] + 1900);
                         
my @month = calendar($mon, $yr);
                         
print "\n$months[$mon -1] $yr\n\n";
print "Su Mo Tu We Th Fr Sa\n";
foreach (@month) {
  print map { $_ ? sprintf "%2d ", $_ : '   ' } @$_;
  print "\n";
}
</pre></font>
  на выводе имеем:
  
  <font color=green><pre>
** Joe's Own Editor v2.8 ** Copyright (C) 1995 Joseph H. Allen **
File /root/raznoe/Calendar-Simple-1.06/aa.pl not changed so no update needed.
[root@www /root]# /root/raznoe/Calendar-Simple-1.06/aa.pl

August 2002

Su Mo Tu We Th Fr Sa
             1  2  3
 4  5  6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30 31
[root@www /root]#
              
              </pre>
<hr>

<a name="files_nums_html"></a>
<center>
<h4>
<a name=files_nums_html_find>Работа с двоичными числами</a>
</h4>
</center>

&gt; Hужно записать в файл шестнад. числа, т.е. записывая \x41 - все ОК, но
если мне<br>
&gt; нужное число я вычисляю, то как его потом записать как шестнад. число?
<p align=justify>
Перво-наперво надо навести порядок в понятиях. Шестнадцатеричных
чисел не существует, существует шестнадцатеричное представление
чисел. Так шестнадцатеричное представление числа "десять" есть <font
color=green>A</font>,
двоичное представление числа "десять" - <font color=green>1010</font> и т.д.
Скалярные переменные в Перл могут хранить как числа так и их
строковые представления (они также могут хранить и другие
значения, например "числа с плавающей точкой", но нас они
пока не интересуют). Преобразования между числами и их
строкыми представлениями в десятичной системе в Перл прозрачны,
т.е. выполняются автоматически, остальные варианты преобразований
необходимо осуществлять явно. Например:
<font color=green>
<pre>
$x_dec = 10;   # Переменная $x_dec содержит число "десять"
$x_10 = "10";  # Переменная $x_10 содержит строку с десятичным
	       # представлением числа "десять"
	       </pre>
</font>
	       В данном случае эти переменные практически идентичны. Т.е.
	       <font color=green>
<pre>
print $x_dec;
print $x_10;
	       </pre>
</font>
<p align=justify>
	       напечатают строку "10" (число из <font
color=green>$x_dec</font> будет преобразовано
в десятичное представление автоматически). А
<font color=green>
<pre>
$y = $x_dec + 1;
$z = $x_10 + 1;
</pre>
</font>
<p align=justify>
запишут в переменные <font color=green>$y</font> и <font
color=green>$z</font> число "одиннадцать" поскольку
строка из <font color=green>$x_10</font> будет автоматически преобразована в
число из
его десятичного представления. Остальные часто используемые
преобразования:
<font color=green>
<pre>
$a_hex = sprintf('%X', 10);    # Число в строку с его шестнадцатеричным
			       # представлением
			       
$a_hex = sprintf('%X', "10");  # строку с десятичным представлением можно
			       # точно так же преобразовать в строку с
			       # десятичным...
			       			       
$a = 0xA;                      # Шестнадцатеричные представления чисел можно
			       # использовать в константах. В $a будет
			       # число "десять"
			       			       
$a = hex("A");		       # Строку с шестнадцатеричным
			       # представлением числа - в число
			       </pre>
</font>
<p align=justify>
			       А судя по приведенному Вами примеру, Вам
нужно записать в файл
байт (октет) со значением <font color=green>XX</font>, где <font
color=green>XX</font> задан в виде строки с его
шестнадцатеричным представлением.
<font color=green>
<pre>
$x = "7F";
$code = hex($x);
print FILE ord($code);
</pre>
</font>
<p align=justify>
Если значение задано в виде числа или его десятичном представлении,
достаточно просто:
<font color=green>
<pre>
print FILE ord($x);
</pre>
</font>

<p> by Andrey Sapozhnikov from fido7.ru.perl
<hr>

<a name="files_cpan_html"></a>
<center><h4><a name=files_cpan_html_cpan>Ежедневные обновления CPAN</a></h4></center>
<p align=justify>По адресу <a href="http://search.cpan.org/recent">http://search.cpan.org/recent</a>
можно найти ежедневные обновления архива модулей <a
href="http://www.cpan.org">CPAN</a>. Кадый день добавляется(или обновляется) в среднем 20
модулей(из них около 10 новых). Например недавно вышла очередная версия
модуля для доступа к
локальным ресурсам при помощи smb-client <a
href="http://search.cpan.org/author/ALIAN/Filesys-SmbClientParser-2.3/">Filesys::SmbClientParser</a>
<hr>

<a name="files_quantium_html"></a>
<center><h4><a name=files_quantium_html_find>Использование квантовой логики в программировании</a></h4></center>



<p alygn=justify>
Quantum::Entanglement позволяет моделировать программирование квантового компьютера (<a href="http://slashdot.org/developers/02/02/10/0016204.shtml?tid=145">Slashdot | Quantum Programming with Perl</a>). Сделаем предположение, что состояние переменной определяется двумя возможными числами <font color=green>1</font> и <font color=green>0</font>(т.н. кубит). Если таких переменных много, то они могут находиться в кластерном("запутанном") состоянии (<font color=green>entangled state</font>), т.е. когда изменение одной из переменных ведет за собой мгновенное изменение всех других. Конечно, обычный компьютер производит вычисления последовательно(и изменение одной переменной не ведет за собой изменения остальных), но данный модуль, тем не менее, прозволяет проводить некоторые эксперименты над такими состояниями. 
<p alygn=justify>
В модуле <font color=green>Quantum::Entanglement</font> определена функция <font color=green>entangled()</font>, которая на входе имеет значения пар амплитуд и чисел, и на выходе имеет скаляр из суперпозиции этих состояний. Например
<font color=green><pre>
$die = entangle( 1=>1, 1=>2, 1=>3, 1=>4, 1=>5, 1=>6);
</pre></font>
создает суперпозицию состояний <font color=green>1 .. 6</font>. В дальнейшем <font color=green>$die</font> является равновероятным для каждого состояния до тех пор, пока мы не попытаемся определить, какое-же из этих состояний содержит переменная <font color=green>$die</font>.
<p align=justify>
Теперь нужно определить, что происходит, когда мы наблюдаем нашу переменную и что подразумевается под наблюдением. В широком смысле определение "что-то, что показывает значение переменной" является правильным. Можно довольно многими видами сравнения определить "содержание" переменной, даже операторы типа <font color=green>eq</font> или <font color=green>&lt;=</font> могут сообщить о некоторых свойствах переменной. Каким образом определить, что переменная <font color=green>$die</font> является измеренной? Попадание значения переменной <font color=green>$die</font> в какое-то конкретное число(состояние)  из чисел <font color=green>1 .. 6</font> определяется возможностью этому числу выпасть при разыгрывании, например, игровой кости. Поскольку игральная кость выпадет в любом случае какой-то своей гранью, то результатом будет число и в идеальном варианте на каждую одну шестую от общего времени всех бросаний кости она будет иметь какой-то номер. Но при этом все остальные состояния уничтожатся. Т.е. в процессе полета кости переменная <font color=green>$die</font> существует(<font color=green>$die</font> - равновероятность выпадения одного из 6 номеров), а как только кость на столе успокоилась, то переменной <font color=green>$die</font>, определенной в смысле функции <font color=green>entangle</font> уже не существует, существует только лишь какое-то конкретное е╦ значение. При этом пядь шестых игроков хмуро расплачивается с одним счастливчиком. Это собирающее всех игроков вместе состояние и называется либо запутанным(<font color=green>entangled</font>), либо кластерным, либо странным. Рассмотрим программу:
<font color=green><pre>
#!/usr/bin/perl -w
use strict;
use Quantum::Entanglement qw(:DEFAULT);
my $foo = entangle(1=>2,1=>3,1=>5,1=>7);
               # |2> +|3> + |5> +|7>
print '$foo is greater than four' if ($foo > 4);
</pre></font>
данная программа равновероятно(с увеличеним числа е╦ запусков до бесконечности конечно) проводит сравнения либо с <font color=green>|2> + |3></font> либо с <font color=green>|5> +7></font>:
<font color=green><pre>
[root@tv demo]# perl -c rr.pl
rr.pl syntax OK
[root@tv demo]# chmod 755 rr.pl
[root@tv demo]# ./rr.pl
$foo is greater than four[root@tv demo]# ./rr.pl
[root@tv demo]# ./rr.pl
[root@tv demo]# ./rr.pl
[root@tv demo]# ./rr.pl
$foo is greater than four[root@tv demo]# ./rr.pl
[root@tv demo]# ./rr.pl
$foo is greater than four[root@tv demo]# ./rr.pl
$foo is greater than four[root@tv demo]# ./rr.pl
$foo is greater than four[root@tv demo]# ./rr.pl
$foo is greater than four[root@tv demo]# ./rr.pl
[root@tv demo]# ./rr.pl
[root@tv demo]#
</pre></font>
Если переменная <font color=green>$Quantum::Entanglement::conform</font> имеет значение <font color=green>true</font>: <font color=green>$Quantum::Entanglement::conform = 1;</font> то предпочтительным будет вывод <font color=green>$foo is greater than four</font>, т.е. более положительный ответ: 
<font color=green><pre>
#!/usr/bin/perl -w
use strict;
use Quantum::Entanglement qw(:DEFAULT);
my $foo = entangle(1,2,1,3,1,5,1,7);
               # |2> +|3> + |5> +|7>
$Quantum::Entanglement::conform = 1;
print '$foo is greater than four' if ($foo > 4);




File rr.pl saved
File rr.pl not changed so no update needed.
[root@tv demo]# ./rr.pl
$foo is greater than four[root@tv demo]# ./rr.pl
$foo is greater than four[root@tv demo]# ./rr.pl
$foo is greater than four[root@tv demo]# ./rr.pl
$foo is greater than four[root@tv demo]# ./rr.pl
$foo is greater than four[root@tv demo]# ./rr.pl
$foo is greater than four[root@tv demo]# ./rr.pl
$foo is greater than four[root@tv demo]#
</pre></font>
 

<p align=justify>

Напишем пример реализации умножения чисел:
<font color=green><pre>
#!/usr/bin/perl -w

use Quantum::Entanglement qw(:DEFAULT);

# зададим два массива независимых чисел

my @inputsA = (1,1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10);
my @inputsB = (1,1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10);

#слинкуем их, т.е. запутаем, сделаем зависимыми

my $inputsA = entangle( @inputsA );
my $inputsB = entangle( @inputsB );

# и теперь перемножим эти зависимые состояния чисел

my $answer = $inputsA * $inputsB;

# запомним основное исходное состояние, чтобы вызвать его снова, если потребуется

my $state = save_state($inputsA, $inputsB, $answer);

# выставим режим наибольшего благоприятствования, более положительный ответ

$Quantum::Entanglement::conform = 1;

print "введите два числа между 1 и 10 для перемножения\n";
while (<>) {
  last unless /(\d+)[^\d]*(\d+)/;
  1 if $inputsA == $1; # угу, действительно равно, но в пустом контексте
  1 if $inputsB == $2;
  print "\n$1 * $2 = $answer\n";
  ($inputsA, $inputsB, $answer) = $state->restore_state; # восстановим исходное состояние!
}
</pre></font>
на выводе получим:
<font color=green><pre>
** Joe's Own Editor v2.9.5 ** Copyright (C) 2001 **
File calc_cache.pl not changed so no update needed.
[root@tv demo]# ./calc_cache.pl
введите два числа между 1 и 10 для перемножения
1 2

1 * 2 = 2
3 4

3 * 4 = 12
9 9

9 * 9 = 81
q
[root@tv demo]#

</pre></font>

<p align=justify>
Что делает этот скрипт, т.к. состояния слинкованы(т.е. изменяя одно изменим все остальные), то их произведение будет связанным произведением комбинации из этих чисел. Т.к. <font color=green>$answer</font> является всевозможными комбинациями из произведений первых двух матриц <font color=green>@inputsA</font> и <font color=green>@inputsB</font>, то фактически получается, что написав строчку <font color=green>my $answer = $inputsA * $inputsB;</font> определили пространство произведений этих комбинаций(т.е. сразу задали всю таблицу умножения).
<p align=justify>
Далее происходит определение режима наибольшего благоприятствования <font color=green>$Quantum::Entanglement::conform = 1;</font> и само сравнение, уничтожающее сначала неопределенность <font color=green>$inputsA</font>(т.е. при вводе из консоли первого конкретного числа от таблицы умножения остается фактически один столбец с умножением одного числа на все оставшиеся) и, далее воодя второе число, устраняется неопределенность <font color=green>$inputsB</font>(который имеет разброс <font color=green>1 .. 10</font>). Т.е. изначально заданная система становится конкретизированной, из 100 возможных результатов получается одно. 
<p align=justify>
При распаковке <font color=green>Quantum-Entanglement.*.tar.gz</font> в директории <font color=green>demo/</font> лежит файл <font color=green>shor.pl</font>, реализующий алгоритм Шора для разложения числа на два множителя. В той-же директории лежит файл <font color=green>root_not.pl</font>, который умеет строить противоположные к начальному <font color=green>entangle(a,c,b,d)</font> состояния.
<p align=justify>
Всякий раз, когда связанные переменные находятся в таком взаимодействии или при вычислениях, результаты(ведь граней у вышеописанного кубика 6, а значит и 6 возможностей) будут в такой-же степени связаны друг с другом. Если числа могут быть коэффициентами таких состояний(например вероятность выпадения одного номера в 2 раза больше чем другого), то вполне логично предположить, что этими коэффициентами могут быть и комплексные числа. Только вместо обычного значения этого числа нужно использовать квадрат его модуля(например <font color=green>|1+2i|**2 == 5 == |1-2i|**2)</font>.  
<p align=justify>
Более подробно умножение комплексных чисел  описано <a href="http://www.perl.com/pub/a/2001/08/08/quantum.html?page=1">тут</a>.
<p align=justify>
<font color=green>Quantum::Superpositions</font>
<p align=justify>
(перевод из соответствующего мана)В стандартной интерпретации квантовой механики частицы существуют как функция вероятности. Например, частица, которая могла бы наблюдаться в состоянии <font color=green>A</font>, <font color=green>B</font>, или <font color=green>C</font>, может рассматриваться в таком некотором псевдосостоянии, где она присутствует одновременно во всех трех состояниях. Считается, что такая частица находится в состоянии суперпозиции. Исследования состояния суперпозиции уже довольно давно известны(см. <a href="http://nauka.relis.ru/cgi/nauka.pl?07+0101+07101024+HTML">Наука и жизнь - Квантовые компьютеры</a>, <a href="http://www.pereplet.ru/nauka/1180.html#1180">Квантовая суперпозиция макроскопических состояний</a>, <a href="http://www.pereplet.ru/nauka/314.html#314">Квантовый компьютер, для тех кто еще не понял</a>) и их целью является разработка надежных квантовых блоков памяти, в которых единичный бит(<font color=green>1</font> или <font color=green>0</font>) может являться свойством квантуемой частицы(qubit). Т.к. частица может быть физически введена в состояние суперпозиции в определенных условиях, то она может сохранять биты, являющиеся одновременно как <font color=green>0</font> так и <font color=green>1</font>. Определенные процессы, основанные на взаимодействиях одного или более кубитов(элементарных носителей информации) используются чтобы создавать квантовые логические затворы. Такие затворы могут, в свою очередь, использоваться для логичеких операциях на кубитах, позволяя проводить параллельные вычисления. Но математика для таких вычислений очень сложна. Описываемый модуль <font color=green>Quantum::Superpositions</font> предлагает другой подход, основанный на суперпозиции полных скалярных произведений.
<p align=justify>
В модуле <font color=green>Quantum::Superpositions</font> существуют два оператора <font color=green>any</font> и <font color=green>all</font>. Каждый из этих операторов берет спиоск значений(состояний) и помещает их в одну скалярную переменную. <font
color=green>any</font> и <font color=green>all</font> опреаторы устанавливают два различных вида суперпозиции, <font color=green>any</font> делает суперпозицию дизъюнктивной, которая(умозрительно конечно) может выводить состояние в любое из возможных согласно требованию алгоритма.
<p align=justify>
Оператор <font color=green>all</font> создает коньюктивную суперпозицию, которая является всегда в каждом из е╦ состояний одновременно. 
Суперпозиции - скалярные значения и, следовательно, могут участвовать в арифметических и логических операциях точно так же, как и любой другой тип скаляра. Но, когда операция применяется к суперпозиции, то она применяется параллельно к каждому из состояний, образовывающих ту или иную комбинацию.
<p align=justify>
Например, если состояния 1, 2, и 3 умножены на 2:
<font color=green><pre>
                $result = any(1,2,3) * 2;
</pre></font>
<p align=justify>
то результатом такого умножения будет соответственно столь же связанные состояния <font color=green>2</font>, <font color=green>4</font>, и <font color=green>6</font>. Если такое состояние проверить на равенство 4-м:
<font color=green><pre>
                if ($result == 4) { print "fore!" }
</pre></font>
<p align=justify>
то тогда сравнение так-же возвращает суперпозицию из двух вариантов "истина" и "ложь", т.к. равенство истинно для одного из состояний и ложно для двух других. Естественно, что значение, которое равновероятно(может быть либо истиной либо ложью) - бесполезно, но оно становится полезным, если добавить некоторый механизм, который определяет приоритет из этих значений.
Дизъюнктивная суперпозиция истинна, если любое из е╦ состояний истинно, принимая во внимание при этом, что коньюктивная суперпозиция истинна только в том случае, если все е╦ состояния истинны. То есть предыдущий пример напечатает <font color=green>fore</font>, в котором начиная с <font color=green>if</font> состояние эквивалентно:
<font color=green><pre>
               if (any(2,4,6) == 4)...
</pre></font>
<p align=justify>
т.е. если любой из <font color=green>2</font>,<font color=green>4</font> или <font color=green>6</font> равен <font color=green>4</font>, то условие истинно и блок выполняется. С другой стороны, если есть инструкция
<font color=green><pre>
               if (all(2,4,6) == 4)...
</pre></font>
<p align=justify>
то условие неверно, так как не истинно, что все <font color=green>2</font>, <font color=green>4</font>, и <font color=green>6</font> равны 4</font>. Операции также возможны между двумя суперпозициями:
<font color=green><pre>
               if (all(1,2,3)*any(5,6) < 21)
                       { print "no alcohol"; }

               if (all(1,2,3)*any(5,6) < 18)
                       { print "no entry"; }

               if (any(1,2,3)*all(5,6) < 18)
                       { print "under-age" }
</pre></font>
<p align=justify>
В этом примере строка <font color=green>"no alcohol"</font> выведется потому, что суперпозиция, произведеная умножением - декартово следствие соответствующих состояний двух операндов <font color=green>all(5,6,10,12,15,18)</font>. Так как все эти результирующие состояния меньше чем <font color=green>21</font>, то состояние является истинным.  Напротив, строка <font color=green>"no entry"</font> не выведется потому, что не все состояния, получаемые в результате операции <font color=green>all(1,2,3)*any(5,6)</font> меньше чем <font color=green>18</font>. Можно заметить, что тип первого операнда определяет тип результата операции, следовательно третья строка <font color=green>"under-age"</font> напечатана потому, что умножение дизъюнктивой суперпозиции на коньюнктивную суперпозицию дает результат, который является дизъюнктивым: <font color=green>any(5,6,10,12,15,18)</font>. Условие <font color=green>if</font> спрашивает, является ли любое из этих значений меньше чем <font color=green>18</font>, что и является истиной.
<p align=justify>
Составные суперпозиции могут быть любым видом скалярного значения - числом, строкой или ссылкой:
<font color=green><pre>
               $wanted = any("Mr","Ms").any(@names);
               if ($name eq $wanted) { print "Reward!"; }

               $okay = all(\&check1,\&check2);
               die unless $okay->();

               my $large =
                       all(    BigNum->new($centillion),
                               BigNum->new($googol),
                               BigNum->new($SkewesNum)
                       );
               @huge =  grep {$_ > $large} @nums;
</pre></font>
<p align=justify>
Более интересно, когда индивидуальные состояния - скалярные значения и суперпозиция так-же является скалярным значением, т.е. суперпозиция может состоять из состояний, являющихся такими-же суперпозициями.
<font color=green><pre>
               $ideal = any( all("tall", "rich", "handsome"),
                             all("rich", "old"),
                             all("smart","Australian","rich")
                           );
</pre></font>
<p align=justify>
Операции, вовлекающие такую составную суперпозицию работают рекурсивно и в параллельном из каждых ее уникальных состояний  и тогда реконструируют результат. Например:
<font color=green><pre>
               while (@features = get_description) {
                       if (any(@features) eq $ideal) {
                               print "True love";
                       }
               }
</pre></font>
<p align=justify>
Условие <font color=green>any(@features) eq $ideal</font> истинно, если входные характеристики соответствуют любой из трех добавленных коньюктивных суперпозиций. Т.е. если характеристики все вместе приравниваются к кажомой из <font color=green>"tall"</font>, <font color=green>"rich"</font> и <font color=green>"handsome"</font>, или ко всем из <font color=green>"smart"</font>, <font color=green>"Australian"</font> и <font color=green>"rich"</font>.
<p align=justify>
Иногда необходимо определить список состояний, из которых состоит данная суперпозиция. Фактически, сами по себе это не состояния, но значения к которым могут свертываться состояния - <font color=green>eigenstates</font>, являющиеся полезными. В смысле программирования это набор значений <font color=green>@ev</font> для данной суперпозиции <font color=green>$s</font> такой как
<font color=green><pre>
               `any(@ev) == $s' or `any(@ev) eq $s'
</pre></font>
<p align=justify>
Этот список обеспечивается оператором `eigenstates', который может обратится к любой суперпозиции
<font color=green><pre>
               print "The factor was: ",
                     eigenstates($factor);

               print "Don't use any of:",
                     eigenstates($badpasswds);
</pre></font>
<p align=justify>
Примеры, показанные выше имеют ту-же самую мета-семантику для обеих арифметических и булевых операций, а именно, что бинарный оператор применяется к декартовым состояниям из двух операций, независимо от того, является ли операция арифметической или логической. Таким образом сравнение двух супрпозиций дает суперпозицию <font color=green>1's</font> и <font color=green>0's</font>, давая возможность сравнить любые состояния между собой из двух суперпозиций. Недостаток применения метасемантической арифметики к логическим операциям состоит в том, что может быть потеряна полезная информация. Действительно, есть состояния, которые ответственны за успешное сравнение. Например, возможно определить, является ли любой номер в массиве <font color=green>@newnums</font> меньшим, чем все номера в массиве <font color=green>@oldnums</font>
<font color=green><pre>
               if (any(@newnums) < @all(oldnums)) {
                 print "New minimum detected";
               }
</pre></font>
<p align=justify>
Но это не очень хорошо в том смысле, что нельзя увидеть, какой элемент(-ы) <font color=green>@newnum</font> сделал условие истинным. Но, однако, возможно определить различную мета-сематнику для логических операций между суперпозициями; один также сохраняет интуитивную логику сравнений и ограничивает доступ к состоянию, которое вызвало истинность сравнения. Ключ должен отклоняться от арифметического представления суперпозиционного сравнения(а именно, что сравненная суперпозиция уступает суперпозиции сравниваемых комбинаций состояний) Вместо этого, различные операторы сравнения переопределены так, чтобы они формировали суперпозицию тех <font color=green>eigenstates</font> левого операнда, которые заставляют операцию быть истинными. Другими словами старая  мета-сематника накладывает результат каждого парралельного сравнения, в то время как новая мета-семантика левого операнда каждого параллельного сравнения выпонляется. Например под первоначальной семантикой сравнения
<font color=green><pre>
               all(7,8,9) <= any(5,6,7)        #A
               all(5,6,7) <= any(7,8,9)        #B
               any(6,7,8) <= all(7,8,9)        #C

       уступили бы:

               all(0,0,1,0,0,0,0,0,0)          #A (false)
               all(1,1,1,1,1,1,1,1,1)          #B (true)
               any(1,1,1,1,1,1,0,1,1)          #C (true)

       под новой семантикой они уступили бы:

               all(7)                          #A (false)
               all(5,6,7)                      #B (true)
               any(6,7)                        #C (true)
</pre></font>
<p align=justify>
Успешность сравнения(результата) больше не определена значениями конечных состояний, но определена числом состояний конечной суперпозиции. Модуль <font color=green>Quantum::Superpositions</font> обрабатывает логические операции и булевы преобразования именно этим способом. Под этой мета-семантикой возможно проверять сравнение и также определять, какой eigenstates левого операнда был ответственнен за успешное сравнение:
<font color=green><pre>
               $newmins = any(@newnums) < all(@oldnums);

               if ($newmins) {
                       print "New minima found:", eigenstates($newmins);
               }
</pre></font>
<p align=justify>
Таким образом, эта семантика обеспечивает механизм проведения параллельного исследования минимумов и максимумов:
<font color=green><pre>
               sub min {
                 eigenstates( any(@_) <= all(@_) )
               }

               sub max {
                 eigenstates( any(@_) >= all(@_) )
</pre></font>
<p align=justify>
Эти определения также весьма интуитивны, почти декларативны: минимум - любое значение, которое является "меньше или равным" чем все другие значения; максимум - любое значение, которое является "большим чем или равным" ко всем из них.
<p align=justify>
Строковая оценка суперпозиций
<p align=justify>
Преобразование суперпозиции в строковое представление производит строку, которая кодируется самым простым набором <font color=green>eigenstates</font> эквивалентов первоначальной суперпозиции. Если есть только один <font color=green>eigenstate</font> строчность этого состояния может быть представлено в строковом представлении. Это устраняет явное применение оператора <font color=green>eigenstates</font>, когда возможно только единственное состояние. Например
<font color=green><pre>
               print "lexicographically first: ",
                     any(@words) le all(@words);
</pre></font>
<p align=justify>
Во всех других случаях суперпозиции - преобразуются в формате: <font color=green>"all(eigenstates)"</font> или <font color=green>"any(eigenstates)"</font>.
<p align=justify>
Числовая оценка суперпозиций
<p align=justify>
Обеспечение неявного преобразования в числа(для ситуаций, где суперпозиции используются как операнды в арифметике или как индексы массива) бывает более лучшим, чем строковое представление, до тех пор, пока нет никакого механизма для фиксирования полного состояния суперпозиции в единственном не добавленном номере. Снова, если суперпозиция имеет единственный <font color=green>eigenstate</font>, то преобразование него выполняется стандартным образом. Например, чтобы вывести значение в элементе массива с самым маленьким индексом в наборе индексов <font color=green>@i</font>:
<font color=green><pre>
               print "The smallest element is: ",
                     $array[any(@i)<=all(@i)];

</pre></font>
<p align=justify>
Суперпозиции как аргументы подпрограмм
<p align=justify>
Когда суперпозиция применяется, как аргумент подпрограммы, эта подпрограмма применяет свое действие параллельно к каждому состоянию суперпозиции и переизмененные резльтаты так-же формируют аналогичный тип суперпозиции. Например, учитывая:
<font color=green><pre>
               $n1 = any(1,4,9);
               $r1 = sqrt($n1);

               $n2 = all(1,4,9);
               $r2 = pow($n2,3);

               $r3 = pow($n1,$r1);
</pre></font>
<p align=justify>
тут <font color=green>$r1</font> содержит дизъюнктивную суперпозицию <font color=green>any(1,2,3), $r2</font> содержит конюнктивную суперпозицию <font color=green>all(1,64,729)</font> и <font color=green>$r3</font> содержит конъюнктивную суперпозицию `any(1,4,9,16,64,81,729)'. поскольку встроенные функции <font color=green>sqrt</font> и <font color=green>pow</font> не знают о суперпозициях, моудль обеспечивает им механизм для информирования их относительно того, какие аргументы должны быть переделаны, чтобы образовать суперпозицию. Если вызывать <font color=green>use Quantum::Superpositions</font> со списком аргументов, то список определяет, какие параметры должны быть добавлены, чтобы сохранилось состояние суперпозиции. Унарные функции и подпрограммы могут быть квантованы как-то так:
<font color=green><pre>
               sub incr    { $_[0]+1 }
               sub numeric { $_[0]+0 eq $_[0] }

               use Quantum::Superpositions
                       UNARY         => ["CORE::int", "main::incr"],
                       UNARY_LOGICAL => ["main::numeric"];
</pre></font>
<p align=justify>
Для двойных функций и использования подпрограмм:
<font color=green><pre>
               sub max  { $_[0] < $_[1] ? $_[1] : $_[0] }

               sub same { my $failed; $IG{__WARN__}=sub{$failed=1};
                          return $_[0] eq $_[1] || $_[0]==$_[1] && !$failed;
                        }

               use Quantum::Superpositions
                       BINARY         => ['main::max', 'CORE::index'],
                       BINARY_LOGICAL => ['main::same'];
</pre></font>
<p align=justify>
Примеры, исследование простых чисел:
<p align=justify>
Программирования со скалярными суперпозициями возможно является лучшей заменой, которая привлечет к себе противников квантового исчисления: оно может оперировать с простыми числами. Здесь, например, <font color=green>0(1)</font> - проверка на простоту чиле, основанная на обычном делении:
<font color=green><pre>
               sub is_prime {
                 my ($n) = @_;
                 return $n % all(2..sqrt($n)+1) != 0
               }
</pre></font>
<p align=justify>
Подпрограмма берет аргумент <font color=green>$n</font> и считает(парралельно) его модуль относительно каждого целого числа между <font
color=green>2</font> и <font color=green>sqrt($n)</font>. Происходит коньюнктивная суперпозиция модуля который в тот момент сравнивается с нулем. Такое сравнение будет истинно только в том случае, если весь модуль - не нулевой, что является критерием числа, чтобы быть простым. Так как <font color=green>is_prime</font> берет скалярный параметр, то он так-же может являться суперпозицией. В качестве примера можно привести не меняющийся со временем фильтр, определяющий, является ли число частью пары из двух простых чисел:
<font color=green><pre>
               sub has_twin {
                       my ($n) = @_;
                       return is_prime($n) && is_prime($n+any(+2,-2);
               }
</pre></font>
<p align=justify>
Множества и их пересечения:
<p align=justify>
Операции со множествами особенно просты для исполнения, если применять superimposable(нет в словаре такого слова) скаляры. Например, учитывая список значений <font color=green>@elems</font>, представив его элементы как элементы множетсва, переменная <font color=green>$v</font> является элементом этого множества, если:
<font color=green><pre>
               $v == any(@elems) 
</pre></font>
<p align=justify>
обратите внимение, что такой тип определений эквивалентен определению <font color=green>eigenstate</font>. Та эквивалентность может использоваться, чтобы вычислять пересечения множества. Учитывая две дизъюнктивные суперпозиции <font color=green>$s1=any
(@elems1)</font> и <font color=green>$s2=any (@elems2)</font> представляя два множества, переменные, составляющие пересечения этих двух наборов должны быть eigenstates <font color=green>&lt;$s1&gt;</font> и <font color=green>$s2</font>. Следовательно:
<font color=green><pre>
                @intersection = eigenstates(all($s1, $s2));
</pre></font>
<p align=justify>
Этот результат может быть апроксимирован для параллельного применения к обычным элементам произвольного числа массивов:
<font color=green><pre>
               @common = eigenstates( all(     any(@list1),
                                               any(@list2),
                                               any(@list3),
                                               any(@list4),
                                         )
                            );
</pre></font>
<p align=justify> 
Факторизация
<p align=justify>
Разложение на числе на множители так-же очень просто, если использовать суперпозиции. 
Коэффициенты целого числа <font color=green>N</font> - все частные <font color=green>q</font> от 
<font color=green>N/n</font>(для всех положительных целых чисел <font color=green>n &lt;
N</font>), которые так-же являются итегралом. Положительный номер <font color=green>q</font> - <font color=green>floor(q)==q</font>. Следовательно факторизовать число можно можно как-то так:
<font color=green><pre>
               sub factors {
                 my ($n) = @_;
                 my $q = $n / any(2..$n-1);
                 return eigenstates(floor($q)==$q);
               } 
</pre></font>
<p align=justify>
Обработка запросов
<p align=justify>
Суперпозиции могут так-же применяться для поиска строки в массиве строк. Например, чтобы определить, появляется ли данная строка <font color=green>$target</font> в массиве строк <font color=green>@db</font>:
<font color=green><pre>
               use Quantum::Superpositions BINARY => ["CORE::index"];

               $found = index(any(@db), $target) >= 0;
</pre></font>
<p align=justify>
Определить, какая из строк базы данных содержат <font color=green>$target</font>:
<font color=green><pre>
               sub contains_str {
                       if (index($dbstr, $target) >= 0) {
                               return $dbstr;
                       }
               }

               $found = contains_str(any(@db), $target);
               @matches = eigenstates $found;
</pre></font>
<p align=justify>
Сравнение происходит гораздо быстрее, чем это умеет делать база данных, чтобы найти единственную строчку в любой из набора в базе.

<font color=green><pre>
               sub contains_targ {
                       if (index($dbstr, $target) >= 0) {
                               return $target;
                       }
               }

               $found = contains_targ($string, any(@targets));
               @matches = eigenstates $found;
</pre></font>
<p align=justify>
Или в каждой одновременно
<font color=green><pre>
               $found = contains_targ($string, all(@targets));
               @matches = eigenstates $found;
</pre></font>

<p align=justify>
Принимаются корректровки к переводу и примеры.

<p>&nbsp;
<hr>

<a name="files_factors_html"></a>
<font color=green>~30 sekund for my server p100, 32 ram, red hat linux7.1, perl 5.0.6</font>), пишем программу:
<font color=green>
<pre>
#!/usr/bin/perl -sw

use Quantum::Superpositions;

sub is_prime { return $_[0]==2 || $_[0] % all(2..sqrt($_[0])+1) != 0 }

do{print "$_ - простое число\n" if is_prime($_)} for map {2*$_+1} 1..1000;
</pre>
</font>
на выводе имеем нечто вроде:
<font color=green>
<pre>
** Joe's Own Editor v2.9.5 ** Copyright (C) 2001 **
File demo_Primes.pl not changed so no update needed.
[root@tv demo]# ./demo_Primes.pl
3 - простое число
5 - простое число
7 - простое число
11 - простое число
13 - простое число
17 - простое число
19 - простое число
23 - простое число
29 - простое число
31 - простое число
37 - простое число
41 - простое число
43 - простое число
47 - простое число
53 - простое число
59 - простое число
61 - простое число
67 - простое число
71 - простое число
73 - простое число
79 - простое число
83 - простое число
89 - простое число
97 - простое число
101 - простое число
103 - простое число
107 - простое число
109 - простое число

[root@tv demo]#
</pre>
</font>

Или нужно получить все сомножители какого-то числа:
<font color=green>
<pre>
#!/usr/bin/perl -w

use Quantum::Superpositions UNARY => ['CORE::int'];

sub factors {eigenstates (int($_[0] / any(2..$_[0]-1)) == ($_[0] / any(2..$_[0]-1)))}

print int($_), "\n factors: ", join(",", factors($_)), "\n" while (<>);
</pre>
</font>
На выводе имеем:
<font color=green>
<pre>
[root@tv demo]# ./factors.pl
8
8
factors: 2,4
121
121
factors: 11
56
56
factors: 7,8,14,2,4,28
78
78
factors: 13,39,2,3,26,6
    
[root@tv demo]# 
</pre>
</font>
<hr>

<a name="files_eratosfen_html"></a>
<center><h4><a name=files_eratosfen_html_find>Алгоритм Эратосфена</a></h4></center>
<p align=justify>Алгоритм, позволяющий получать простые числа, отличается по быстродействию
от приведенного ниже алгоритма с применением <font color=green>Quantum::Superpositions</font>:
<font color=green><pre>
$N = 1000000; 

@L = (1) x $N; 

$L[0] = 0; $L[1] = 0; 

$start = 2; 
$t0 = time; 
while($start<$N) { 
  if($L[$start]==0) { $start++; next; } 
  for($i=$start*2;$i<$N;$i+=$start) { $L[$i] = 0; } 
  $start++; 
} 
print "time: ".(time-$t0)."\n"; 

for($i=0;$i<$N;$i++) { 
  print $i." " if($L[$i]==1); 
} 
</pre></font>

Программа написана David A. Mzareulyan from <a
href="http://www.scientific.ru">http://www.scientific.ru
<hr>

<a name="files_mreg_html"></a>
<center>
<h4>
<a name=files_mreg_html_find>Регулярное выражение для выделения чисел в математической
записи</a>
</h4>
</center>
Вот таким вот регулярным выражением можно выделить все
числа в некоторых типах математической записи:
<font color=green>
<pre>
#!/usr/bin/perl

$_=qq~
1234
34 -4567
 3456
-0.35e-0,2
    56grf45
-.034 E20
     -.034 e2,01   -,045 e-,23
  -,034 e201  3e-.20
-,045 e-,23 e-0.88

4 E-0.20
22 
E-21
 -0.2 w         4 3
345
2 ^-,3
~;

$a='[+-]?\d*[,.]?\d+';print"$_\n"for/$a\s?[e^]$a|$a|[+-]?e$a/ig
</pre>
</font>

Соответственно идея в том, чтобы сократить число символов 
в строчке, заменяя их на содержимое переменной <font color=green>$a</font>. цикл 
<font color=green>for</font> идет пока
выполняется регулярное выражение(т.к. оно возвращает список значений
<font color=green>$_</font> в силу
наличия квантификатора <font color=green>g</font>), читающее переменную <font color=green>$_</font>
<hr>

<a name="files_com_html"></a>
<pre>
Чтение и запись в com-порт

Возможножность писать в компорт сильно зависит(в программном смысле) от
того, под какой операционной системой запущена программа. Если это *nix,
то компорт доступен как файл в директории /dev(железные устройства в
unix-like системах подобны файлам, которые можно читать и производить в них
запись), в других системах имя устройства отличаются. 
    This depends on which operating system your program is running on.
    In the case of Unix, the serial ports will be accessible through
    files in /dev; on other systems, the devices names will doubtless
    differ. Several problem areas common to all device interaction are
    the following

    lockfiles
        Your system may use lockfiles to control multiple access. Make
        sure you follow the correct protocol. Unpredictable behaviour
        can result from multiple processes reading from one device.

    open mode
        If you expect to use both read and write operations on the
        device, you'll have to open it for update (see the section on
        "open" in the perlfunc manpage for details). You may wish to
        open it without running the risk of blocking by using sysopen()
        and RDWR|O_NDELAY|O_NOCTTY' from the Fcntl module (part of
        the standard perl distribution). See the section on "sysopen"
        in the perlfunc manpage for more on this approach.

    end of line
        Some devices will be expecting a "\r" at the end of each line
        rather than a "\n". In some ports of perl, "\r" and "\n" are
        different from their usual (Unix) ASCII values of "\012" and
        "\015". You may have to give the numeric values you want
        directly, using octal ("\015"), hex ("0x0D"), or as a control-
        character specification ("\cM").

            print DEV "atv1\012";       # wrong, for some devices
            print DEV "atv1\015";       # right, for some devices

        Even though with normal text files, a "\n" will do the trick,
        there is still no unified scheme for terminating a line that is
        portable between Unix, DOS/Win, and Macintosh, except to
        terminate *ALL* line ends with "\015\012", and strip what you
        don't need from the output. This applies especially to socket
        I/O and autoflushing, discussed next.

    flushing output
        If you expect characters to get to your device when you print()
        them, you'll want to autoflush that filehandle. You can use
        select() and the $|' variable to control autoflushing (see the
        section on "$|" in the perlvar manpage and the "select" entry
        in the perlfunc manpage):

            $oldh = select(DEV);
            $| = 1;
            select($oldh);

        You'll also see code that does this without a temporary
        variable, as in

            select((select(DEV), $| = 1)[0]);

        Or if you don't mind pulling in a few thousand lines of code
        just because you're afraid of a little $| variable:

            use IO::Handle;
            DEV->autoflush(1);

        As mentioned in the previous item, this still doesn't work when
        using socket I/O between Unix and Macintosh. You'll need to
        hardcode your line terminators, in that case.

    non-blocking input
        If you are doing a blocking read() or sysread(), you'll have to
        arrange for an alarm handler to provide a timeout (see the
        "alarm" entry in the perlfunc manpage). If you have a non-
        blocking open, you'll likely have a non-blocking read, which
        means you may have to use a 4-arg select() to determine whether
        I/O is ready on that device (see the section on "select" in the
        perlfunc manpage.

    While trying to read from his caller-id box, the notorious Jamie
    Zawinski <jwz@netscape.com>, after much gnashing of teeth and
    fighting with sysread, sysopen, POSIX's tcgetattr business, and
    various other functions that go bump in the night, finally came up
    with this:

        sub open_modem {
            use IPC::Open2;
            my $stty = /bin/stty -g;
            open2( \*MODEM_IN, \*MODEM_OUT, "cu -l$modem_device -s2400 2>&1");
            # starting cu hoses /dev/tty's stty settings, even when it has
            # been opened on a pipe...
            system("/bin/stty $stty");
            $_ = <MODEM_IN>
<hr>

<a name="files_whirlwind_html"></a>
<a href="http://whirlwind.ru/">сайт</a>, посвященный
программированию на perl.

<p>
<hr>

<a name="files_redirect_html"></a>
<center><h4>Соединение  типа точка-точка</h4></center>
<p align=justify>
Существует некоторый класс проблем, которые требуют автоматической проверки
наличия удаленного сервиса, слушающего определенный порт. Например,
необходимо
узнать, когда будет запущен сервис на удаленной машине, или, например, когда
будет
запущен некий внутренний сервис. Или, в случае неустойчивой связи(удаленный
сервер
через мобильный телефон по GPRS в деревне, на котором необходимо
поддерживать непрерывную связь), нужно
отслеживать наличие соединения и по его исчезновению информировать
находящихся поблизости людей о том, что связи нет(с случае когда сотовй
телефон не умеет сам находясь, на crontab'е, восстанавливать соединение).
<p align=justify>
Задача сводится к написанию программы, умеющей автоматически опрашивать
удаленный порт и при наличии соединения редиректить информацию, посылаемую
на этот порт на другие определенные порты в зависимости от заголовка.
Аналогичное решение ssh - тунеллирование.
<p align=justify>
Предположим есть некоторая запускаемая каждое утро программа, обслуживающая
некоторое хитрое устройство(например мониторинг скорости водостока или
химический анализ речной воды на нескольких участках реки, до и после
сточного коллектора того или иного предприятия) в далекой сельской
глубинке(где и не пахло связью), с которым необходимо работать
одновременно нескольким городским пользователям.
<p align=justify>
Если программа, обслуживающая устройство, пишет данные в сокет, открываемый
ею без указания опции SO_REUSEADDR, то после каждого соединения
приходится ждать некоторе время, пока *nix разблокирует сокет для дальнейшей
работы после предыдущего соединения. Это замедляет работу и чтобы
обойти это препятствие необходимо сделать редиректор, обходящий блокировку
сокета. Приведенная ниже программа является промежуточной между
программой, управляющей неким устройством(типа описанных выше) и клиентскими
приложениями.
<p>
Схема работы:
<pre>
устройство <-> описываемое здесь промежуточное клиент-серверное приложение <-> клиенты
</pre>
<p align=justify>
В случае отсутствия соединения в системе постоянно висит процесс(запускаемый
например как service redirect start или ./redirect.pl &),
умеющий плодить дочерний процесс, опрашивающий удаленный хост. В случае
неудачного соединения процесс завершается и порождается заново например
через каждые
2 секунды. В случае соединения клиент логинится на удаленный сервер и плодит
пул процессов-серверов(для ускоренной обработки соединений), к которым далее
могут подсоединяться многочисленные клиенты.
<p align=justify>
Итак, базовый процесс подсоединился к удаленному клиенту, породил дочерние
процессы и готов к работе. Между исходным устройством и подсоединяющимися
клиентами возможен обмен данными и задача сводится к обмену данными между
разными процессами в памяти *nix-машины.
<p align=justify>
Для этого необхожимо открыть канал между процессами. Если обмен данными
невелик, то можно обойтись одной общей переменной на несколько процессов
и изменять её содержимое и соответственно отслеживать её состояние. Можно
поступить и по иному, открыть каналы в виде дескрипторов и контролировать
таким образом чтение и запись.
<pre>
<font color="#444444">#!/usr/bin/perl -w

</font><strong>use</strong> strict;
<strong>use</strong> IO::Socket;
<strong>use</strong> IO::Handle;
<strong>use</strong> Socket;
<strong>use</strong> Symbol;
<strong>use</strong> POSIX;
<strong>use</strong> Net::hostent;

<font color="#444444"># порт, на котором висит программа, управляющая устройством
</font><strong>my</strong> <font color="#2040a0">$port</font>=6001; 
<font color="#444444"># хост
</font><strong>my</strong> <font color="#2040a0">$host</font>=<font color="#008000">&quot;127.0.0.1&quot;</font>; 
<font color="#444444"># число плодящихся серверов
</font><strong>my</strong> <font color="#2040a0">$PREFORK</font>=<font color="#008000">&quot;1&quot;</font>; 
<font color="#444444"># число подключаемых клиентов
</font><strong>my</strong> <font color="#2040a0">$MAX_CLIENTS_PER_CHILD</font>=<font color="#008000">&quot;1&quot;</font>;
<font color="#444444"># хеш потомков
</font><strong>my</strong> <font color="#2040a0">%children</font>=<font color="4444FF"><strong>(</strong></font><font color="4444FF"><strong>)</strong></font>;
<font color="#444444"># численность порожденных потомков
</font><strong>my</strong> <font color="#2040a0">$children</font>=0;
<strong>my</strong> <font color="#2040a0">$f</font>=<font color="#008000">&quot;/.2/mnt/work/control.txt&quot;</font>;
<font color="#444444"># начальное заполнение пула серверов
</font>make_new_child<font color="4444FF"><strong>(</strong></font><font color="4444FF"><strong>)</strong></font> <strong>for</strong><font color="4444FF"><strong>(</strong></font>1 .. <font color="#2040a0">$PREFORK</font><font color="4444FF"><strong>)</strong></font>;
<font color="#444444"># обработчик сигнала CHLD, убивающиего потомка
</font><font color="#2040a0">$SIG</font><font color="4444FF"><strong>{</strong></font>CHLD<font color="4444FF"><strong>}</strong></font>=\&amp;REAPER;
<font color="#444444"># обработчик события, убивающего всю программу(остановка сервера) 
</font><font color="#2040a0">$SIG</font><font color="4444FF"><strong>{</strong></font>INT<font color="4444FF"><strong>}</strong></font>=\&amp;HUNTSMAN;
<font color="#444444"># поддерживаем численность потомков
</font><strong>while</strong><font color="4444FF"><strong>(</strong></font>1<font color="4444FF"><strong>)</strong></font><font color="4444FF"><strong>{</strong></font> 
  <font color="a52a2a"><strong>sleep</strong></font>; 
  <strong>for</strong><font color="4444FF"><strong>(</strong></font><strong>my</strong> <font color="#2040a0">$i</font>=<font color="#2040a0">$children</font>; <font color="#2040a0">$i</font>&lt;<font color="#2040a0">$PREFORK</font>; <font color="#2040a0">$i</font>++<font color="4444FF"><strong>)</strong></font><font color="4444FF"><strong>{</strong></font>
    make_new_child<font color="4444FF"><strong>(</strong></font><font color="4444FF"><strong>)</strong></font>
  <font color="4444FF"><strong>}</strong></font>
<font color="4444FF"><strong>}</strong></font>

<strong>sub<font color="ff0000"> make_new_child</font>{</strong> 
  <strong>my</strong><font color="4444FF"><strong>(</strong></font><font color="#2040a0">$pid</font>, <font color="#2040a0">$sigset</font>, <font color="#2040a0">$kidpid</font>, <font color="#2040a0">$server</font>, <font color="#2040a0">$client</font><font color="4444FF"><strong>)</strong></font>;

  <font color="#2040a0">$sigset</font>=POSIX::SigSet-&gt;<strong>new</strong><font color="4444FF"><strong>(</strong></font>SIGINT<font color="4444FF"><strong>)</strong></font>;
  sigprocmask<font color="4444FF"><strong>(</strong></font>SIG_BLOCK, <font color="#2040a0">$sigset</font><font color="4444FF"><strong>)</strong></font> <strong>or</strong> <strong>die</strong> <font color="#008000">&quot;can't block SIGINT for fork: <font color="#2040a0">$!</font><font color="#77dd77">\n</font>&quot;</font>;
  <strong>die</strong> <font color="#008000">&quot;fork: <font color="#2040a0">$!</font>&quot;</font> <strong>unless</strong> <font color="a52a2a"><strong>defined</strong></font> <strong>do</strong><font color="4444FF"><strong>{</strong></font><font color="#2040a0">$pid</font> = <font color="a52a2a"><strong>fork</strong></font><font color="4444FF"><strong>}</strong></font>;

  <strong>if</strong><font color="4444FF"><strong>(</strong></font><font color="#2040a0">$pid</font><font color="4444FF"><strong>)</strong></font><font color="4444FF"><strong>{</strong></font>
<font color="#444444"># базовый родительский процесс, содержимое этого условия никогда не
# будет видно из дочернего процесса

    </font>sigprocmask<font color="4444FF"><strong>(</strong></font>SIG_UNBLOCK, <font color="#2040a0">$sigset</font><font color="4444FF"><strong>)</strong></font> 
      <strong>or</strong> <strong>die</strong> <font color="#008000">&quot;can't unblock SIGINT for fork: <font color="#2040a0">$!</font><font color="#77dd77">\n</font>&quot;</font>;
<font color="#444444"># заполняем хеш номерами дочерних процессов
    </font><font color="#2040a0">$children</font><font color="4444FF"><strong>{</strong></font><font color="#2040a0">$pid</font><font color="4444FF"><strong>}</strong></font>=1; 
<font color="#444444"># увеличивам число процессов, обрабатывающих подключение
    </font><font color="#2040a0">$children</font>++; 
    <strong>return</strong>;
  <font color="4444FF"><strong>}</strong></font> <strong>else</strong> <font color="4444FF"><strong>{</strong></font>
<font color="#444444"># порожденный дочерний процесс, содержимое этого процесса никогда не 
# будет видно в базовом процессе

# переопределяем событие SIGINT чтобы избежять появления зомби
    </font><font color="#2040a0">$SIG</font><font color="4444FF"><strong>{</strong></font>INT<font color="4444FF"><strong>}</strong></font> = <font color="#008000">'DEFAULT'</font>; 
    <font color="#2040a0">$SIG</font><font color="4444FF"><strong>{</strong></font>CHLD<font color="4444FF"><strong>}</strong></font>=<font color="#008000">'IGNORE'</font>;

    sigprocmask<font color="4444FF"><strong>(</strong></font>SIG_UNBLOCK, <font color="#2040a0">$sigset</font><font color="4444FF"><strong>)</strong></font> 
      <strong>or</strong> <strong>die</strong> <font color="#008000">&quot;can't unblock SIGINT for fork: <font color="#2040a0">$!</font><font color="#77dd77">\n</font>&quot;</font>;

<font color="#444444"># плодим клиентов, соединяющихся с 
# исходной программой
    </font><strong>for</strong><font color="4444FF"><strong>(</strong></font><strong>my</strong> <font color="#2040a0">$i</font>=0;  <font color="#2040a0">$i</font>&lt;<font color="#2040a0">$MAX_CLIENTS_PER_CHILD</font>; <font color="#2040a0">$i</font>++<font color="4444FF"><strong>)</strong></font><font color="4444FF"><strong>{</strong></font> 
      <font color="a52a2a"><strong>sleep</strong></font> 2;

<font color="#444444"># открываем двусторонний сокет между процессами
# парент пишет в CHILD, который читается в порожденном процессе
# Дочерний процесс пишет в PARENT, который читается в родительском процессе
      </font><font color="a52a2a"><strong>socketpair</strong></font><font color="4444FF"><strong>(</strong></font>CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC<font color="4444FF"><strong>)</strong></font> 
        <strong>or</strong> <strong>die</strong> <font color="#008000">&quot;socketpair: <font color="#2040a0">$!</font>&quot;</font>;
<font color="#444444"># отключаем буверизацию у обоих
      </font>CHILD-&gt;autoflush<font color="4444FF"><strong>(</strong></font>1<font color="4444FF"><strong>)</strong></font>; 
      PARENT-&gt;autoflush<font color="4444FF"><strong>(</strong></font>1<font color="4444FF"><strong>)</strong></font>;
<font color="#444444"># соединяемся с исходной программой, в случае отказа
# в соединении(это значит что удаленная мониторинговая или иная 
# программа не работает), дочерний процесс умирает, 
# и скрипт заново порождает новый процесс в цикле while(1){ ... } 
      </font><strong>my</strong> <font color="#2040a0">$handle</font> = IO::Socket::INET-&gt;<strong>new</strong><font color="4444FF"><strong>(</strong></font> Proto    =&gt; <font color="#008000">'tcp'</font>,
                                          PeerAddr =&gt; <font color="#2040a0">$host</font>,
                                          PeerPort =&gt; <font color="#2040a0">$port</font><font color="4444FF"><strong>)</strong></font> 
        <strong>or</strong> <strong>die</strong> <font color="#008000">&quot;can't connect to port <font color="#2040a0">$port</font> on <font color="#2040a0">$host</font>: <font color="#2040a0">$!</font>&quot;</font>;

      <font color="a52a2a"><strong>print</strong></font> STDERR <font color="#008000">&quot;[Connected to <font color="#2040a0">$host</font>:<font color="#2040a0">$port</font>]<font color="#77dd77">\n</font>&quot;</font>;
      <strong>die</strong> <font color="#008000">&quot;can't fork: <font color="#2040a0">$!</font>&quot;</font> <strong>unless</strong> <font color="a52a2a"><strong>defined</strong></font> <strong>do</strong><font color="4444FF"><strong>{</strong></font><font color="#2040a0">$kidpid</font> = <font color="a52a2a"><strong>fork</strong></font><font color="4444FF"><strong>(</strong></font><font color="4444FF"><strong>)</strong></font><font color="4444FF"><strong>}</strong></font>;
<font color="#444444"># в случае соединения клиента с базовой программой
# делимся на два процесса, между котороыми окрываем двухсторонний сокет
      </font><strong>if</strong> <font color="4444FF"><strong>(</strong></font><font color="#2040a0">$kidpid</font><font color="4444FF"><strong>)</strong></font> <font color="4444FF"><strong>{</strong></font> 
        <strong>my</strong> <font color="4444FF"><strong>(</strong></font><font color="#2040a0">$byte</font>, <font color="#2040a0">$tmp</font><font color="4444FF"><strong>)</strong></font>; 
<font color="#444444"># выходим из парента, так как в паренте нужено писать только в чайлд
        </font><font color="a52a2a"><strong>close</strong></font> PARENT;
<font color="#444444"># побайтовое чтение из сокета, в данном случае удаленная программа на
# внешние команды возвращает либо слово ok, либо error
        </font><strong>while</strong><font color="4444FF"><strong>(</strong></font><font color="a52a2a"><strong>sysread</strong></font><font color="4444FF"><strong>(</strong></font><font color="#2040a0">$handle</font>, <font color="#2040a0">$byte</font>, 1<font color="4444FF"><strong>)</strong></font> <strong>eq</strong> 1<font color="4444FF"><strong>)</strong></font><font color="4444FF"><strong>{</strong></font> 
          <font color="#2040a0">$tmp</font>.=<font color="#2040a0">$byte</font>;
          <strong>do</strong><font color="4444FF"><strong>{</strong></font><font color="a52a2a"><strong>print</strong></font> CHILD <font color="#008000">&quot;<font color="#2040a0">$tmp</font><font color="#77dd77">\n</font>&quot;</font>; <font color="#2040a0">$tmp</font>=<font color="#008000">''</font> <font color="4444FF"><strong>}</strong></font> <strong>if</strong> <font color="#2040a0">$tmp</font> <strong>eq</strong> <font color="#008000">'ok'</font>;
          <strong>do</strong><font color="4444FF"><strong>{</strong></font><font color="a52a2a"><strong>print</strong></font> CHILD <font color="#2040a0">$tmp</font>,<font color="#008000">&quot;<font color="#77dd77">\n</font>&quot;</font>; <font color="#2040a0">$tmp</font>=<font color="#008000">''</font><font color="4444FF"><strong>}</strong></font> <strong>if</strong> <font color="#2040a0">$tmp</font> <strong>eq</strong> <font color="#008000">'error'</font>;
        <font color="4444FF"><strong>}</strong></font> 
        <font color="a52a2a"><strong>close</strong></font> CHILD;
<font color="#444444"># при завершении подпроцесса убиваем сервер и избегаем появления зомби
        </font><font color="a52a2a"><strong>kill</strong></font> <font color="#008000">&quot;TERM&quot;</font> =&gt; <font color="#2040a0">$kidpid</font>;
        <font color="a52a2a"><strong>waitpid</strong></font><font color="4444FF"><strong>(</strong></font><font color="#2040a0">$kidpid</font>,0<font color="4444FF"><strong>)</strong></font>;
      <font color="4444FF"><strong>}</strong></font> <strong>else</strong> <font color="4444FF"><strong>{</strong></font> 
<font color="#444444"># выходим из парента, так как в паренте нужно писать только в чайлд
        </font><font color="a52a2a"><strong>close</strong></font> CHILD; 
<font color="#444444"># создаем сервер, транслирующий ответы базовой программы клиентам
# и передающий команды клиентов исходной программе
        </font><font color="#2040a0">$server</font> = IO::Socket::INET-&gt;<strong>new</strong><font color="4444FF"><strong>(</strong></font> LocalPort =&gt; 2003,
                                         Type      =&gt; SOCK_STREAM, 
                                         Proto     =&gt; <font color="#008000">'tcp'</font>,
                                         Reuse     =&gt; 1,
                                         Listen    =&gt; 10<font color="4444FF"><strong>)</strong></font>; 
        <strong>die</strong> <font color="#008000">&quot;making socket: <font color="#2040a0">$@</font>&quot;</font> <strong>unless</strong> <font color="#2040a0">$server</font>;
<font color="#444444"># слушаем, что пишет в ответ сервер
        </font><strong>while</strong><font color="4444FF"><strong>(</strong></font><font color="#2040a0">$client</font>=<font color="#2040a0">$server</font>-&gt;<font color="a52a2a"><strong>accept</strong></font><font color="4444FF"><strong>(</strong></font><font color="4444FF"><strong>)</strong></font><font color="4444FF"><strong>)</strong></font><font color="4444FF"><strong>{</strong></font>
<font color="#444444"># отключаем буферизацию
          </font><font color="#2040a0">$client</font>-&gt;autoflush<font color="4444FF"><strong>(</strong></font>1<font color="4444FF"><strong>)</strong></font>;
          <strong>my</strong> <font color="4444FF"><strong>(</strong></font><font color="#2040a0">$line</font>, <font color="#2040a0">$line1</font><font color="4444FF"><strong>)</strong></font>;
<font color="#444444"># если есть данные от клиента
          </font><strong>while</strong> <font color="4444FF"><strong>(</strong></font><font color="a52a2a"><strong>defined</strong></font> <font color="4444FF"><strong>(</strong></font><font color="#2040a0">$line</font> = &lt;<font color="#2040a0">$client</font>&gt;<font color="4444FF"><strong>)</strong></font><font color="4444FF"><strong>)</strong></font><font color="4444FF"><strong>{</strong></font>
<font color="#444444"># то пишем их в клиента, работающего с внешним устройством 
            </font><font color="a52a2a"><strong>print</strong></font> <font color="#2040a0">$handle</font> <font color="#2040a0">$line</font>;
<font color="#444444"># в случае ответа внешнего устройства через CHILD передаем ответ клиенту
            </font><font color="a52a2a"><strong>chomp</strong></font><font color="4444FF"><strong>(</strong></font><font color="#2040a0">$line1</font>=&lt;PARENT&gt;<font color="4444FF"><strong>)</strong></font>;
<font color="#444444"># пишем пользователю ответ из парента через межпроцессный сокет чайлд/парент
# ответ устройства, соответственно ok или error,  зависимости от того, 
# прошла ли команда или нет
            </font><font color="a52a2a"><strong>print</strong></font> <font color="#2040a0">$client</font> <font color="#008000">&quot;<font color="#2040a0">$line1</font><font color="#77dd77">\n</font>&quot;</font>;
          <font color="4444FF"><strong>}</strong></font> 
          <font color="a52a2a"><strong>close</strong></font> <font color="#2040a0">$client</font>;
<font color="#444444"># закрываем соединение в случае конца работы пользователя
        </font><font color="4444FF"><strong>}</strong></font> 
<font color="#444444"># выходим из двусотроннего сокета со стороны чайлда, который писал в
# дексриптор PARENT
        </font><font color="a52a2a"><strong>close</strong></font> PARENT;
      <font color="4444FF"><strong>}</strong></font> 
<font color="#444444"># выходим из цикла порождающих пул процессов программ дабы не переполнить
# систему процессами, которые начнут без exit ветвится пока истинно while (1){}
    </font><font color="4444FF"><strong>}</strong></font> <strong>exit</strong>;
  <font color="4444FF"><strong>}</strong></font>
<font color="4444FF"><strong>}</strong></font>

<font color="#444444"># убиваем всех чайлдов сразу, в случае например, перезапуска компьютера

</font><strong>sub<font color="ff0000"> HUNTSMAN</font>{</strong>
  <strong>local</strong><font color="4444FF"><strong>(</strong></font><font color="#2040a0">$SIG</font><font color="4444FF"><strong>{</strong></font>CHLD<font color="4444FF"><strong>}</strong></font><font color="4444FF"><strong>)</strong></font>=<font color="#008000">'IGNORE'</font>;
  <font color="a52a2a"><strong>kill</strong></font> <font color="#008000">'INT'</font> =&gt; <font color="a52a2a"><strong>keys</strong></font> <font color="#2040a0">%children</font>;
  <strong>exit</strong>;
<font color="4444FF"><strong>}</strong></font>

<font color="#444444"># убиваем конкретного чайлда, в случае неработоспособности устройства, 
# с котороым надо коннектится клиентам... далее по смыслу перезапус через 2 секунды

</font><strong>sub<font color="ff0000"> REAPER</font>{</strong>
  <font color="#2040a0">$SIG</font><font color="4444FF"><strong>{</strong></font>CHLD<font color="4444FF"><strong>}</strong></font>=\&amp;REAPER;
  <strong>my</strong> <font color="#2040a0">$pid</font> = <font color="a52a2a"><strong>wait</strong></font>;
  <font color="#2040a0">$children</font>--;
  <font color="a52a2a"><strong>delete</strong></font> <font color="#2040a0">$children</font><font color="4444FF"><strong>{</strong></font><font color="#2040a0">$pid</font><font color="4444FF"><strong>}</strong></font>;
<font color="4444FF"><strong>}</strong></font>


</pre>
<p align=justify>
В принципе данные решения и идеи без особых затрат и при надлежащем умении
позволяют организовать и поддерживать целые сегменты сети без
дорогостоящей прокладки оптоволоконных кабелей или дорогостоящих спутниковых
приемников при условии полного отсутствия телефонных линий.
<p align=justify>
Какова цена этого мероприятия? 0.30$/Mb - GPRS BeeLine и 0.15$/Mb GPRS MTS
Прокладка же оптоволоконного кабеля и последующая разводка стоит около
20000$, примерно такая-же стоимость и у спутниковой тарелки. Конечно, иногда 
проложить телефонный кабель дешевле, но это зависит от конкретных условий...
А построенная на такого типа серверах-клиентах распределенная мониторинговая 
система обходится на порядки дешевле. И, к тому-же, без значительных изменений,
кроссплатформенна, так как данный скриптовый язык работает на многих типах
операционных систем.
<p align=justify>
В принципе, если написать обработчик входящих писем и отправку почтовых сообщений
через sms.beeline.ru на мобильный телефон, можно через сотовый
телефон посредством получения и отправки sms-сообщений осуществлять
мониторинг и администрирование удаленного сервера(соответственно отпадает
необходимость в сотовом notebooks).
<hr>
Синтакс расцвечен при помощи программы <a href="http://www.palfrader.org/code2html">Code2HTML</a>
<hr>

<a name="base_html"></a>
<h2>
<center>Базы данных</center>
</h2>
<br>
<ul>
	<li>МySQL</li>
	<li>PostGree SQL</li>
	<li>Хеширование данных</li>
	<li>
<a href="#base_html_fast">Системы хранения и быстрого извлечения данных</a>
</li>
	<li>
<a href="#base_html_ex">Примеры</a>
</li>
        <ul>
          <li>
<a href="#base_html_find">Поиск по степени совпадений слов</li>
        </ul>
</ul>


<h3>
<a name="base_html_fast">Системы хранения и быстрого извлечения данных</a>
</h3>
Есть сервер с большим количеством текстовых файлов, например очень посещаемая <font color=green>www_board</font>.
<p align=justify>
Допустим файл текстовый примерно такой:
<pre>
<font color=green>begin.file

вода
огонь воздух 
 сила тока, юзер, килограмм, метр, квантовые флуктуации, водка  и пр.


end.file</pre>
</font>
<p align=justify>
Из файла выбираются все слова на букву "<font color=green>в</font>" и их позиция в файле, т.е. допустим "<font color=green>водка</font>" стоит в файле на сотом байте. Функция <font color=green>seek</font> позволяет перемещаться не читая файл, что долго, а сразу к нужному байту. Есть файл-хеш(массивов) "<font color=green>буква => цифры</font>", позиций в файле: "<font color=green>все слова на букву "в" находятся там-то и там-то</font>".

<pre>
<font color=green>"в" 10 20000 30000 40000 50000 60000 </pre>
</font>
<p align=justify>
т.е. слова на букву "<font color=green>в</font>" стоят в файле на <font color=green>10</font> байте, <font color=green>20000</font> байте и т.д. И так по всем буквам. Это была первая буква "<font color=green>в</font>" слове, дальше еще один хеш построить, по сторой букве, т.е. есть слова на букву "<font color=green>в</font>" а среди этих влов есть позиции слов с "<font color=green>ва</font>" "<font color=green>вб</font>" "<font color=green>вв</font>" "<font color=green>вг</font>" "<font color=green>вд</font>" "<font color=green>ве</font>" и т.д. и скажем такое разбиение документа глубиной в слове до пятой или шестой буквы. Юзер ввел в форму слово "<font color=green>водка</font>", программа ищет начала позиции всех слов начинающихся на букву "<font color=green>в</font>", получает(если гигабайт текста) ссылки на 30 мегабайт слов, начинающихся на букву "<font color=green>в</font>". Вторая буква в слове водка это "<font color=green>о</font>". Т.е. поиск уже происходит в этих 30 мегах по букве "<font color=green>о</font>"(выборка 30 мегов делим на 33, получаем на втором шаге мегабайт из изначального гигабайта, если считать что слова размещены в файле(файлах) равновероятно, т.е. слов на букву "<font color=green>а</font>" столько же сколько и на букву "<font color=green>б</font>", "<font color=green>д</font>", "<font color=green>е</font>" и т.д.), третья буква в слове водка "<font color=green>д</font>". но, поиск уже происходит по тому мегабайту, который получился отсеиванием первых двух букв. Делим мегабайт на 33 буквы, получаем 30 килобайт слов, содержащих три буквы "<font color=green>вод</font>". Далее по индукции доходим до последней буквы "<font color=green>а</font>" в слове "<font color=green>водка</font>". 
<p align=justify>
Итого, чтоб не перебирать весь гиг информации, надо <font color=green>seek</font>'ом перебрать за 5 приемов <font color=green>30 мегабайт+1 мегабайт+30 килобайт+1 килобайт+30 байт+1 байт</font>. Ну и соответственно так-же устроен поиск если не с начала буквы, т.е. полное индексирование, слово "<font color=green>подводный</font>" например, где "<font color=green>вод</font>" стоит в середине слова. и так этой тройкой бегать во всему слову, вариантов <font color=green>C<sup>n</sup>
<sub>k</sub>=n!/(n-k)!k!</font>, где <font color=green>k</font> - три буквы "<font color=green>вод</font>" а <font color=green>n</font> - девять букв слова "<font color=green>подводный</font>".
<p align=justify>
Есть очень большой двоичный файл, который пронизан связами(чтобы удобно было ходить <font color=green>seek</font>'у по ним). Его можно открывать и сдвигать байты, чтобы дописать нужный файл(который изменил пользователь на сервере). Т.е. отследить нитку для слова(или, что то-же самое, для целой странички). Ведь сначала будут выстраиваться параллельные связи и только в конце, если слово более 6-8 букв, будут разветвления в этой структуре. По идее, можно добится того, что редактировать файлы можно будет непосредственно в этом двоичном файле. Т.е. набираешь <font color=green>cd req</font>(или <font color=green>cat /var/log/error.log | more</font> или <font color=green>tail -f /var/log/error.log</font>) и ты уже не в юниксовой файловой системе, а в этом файле, в котором стоит обработчик, такая-же консоль. А интерпретатор команд создает видимость, что ты сидишь в обычной директории и ворочаешь обычными файлами....
<p align=justify>
Что это дает? Довольно большую скорость доступа к очень большим текстовым архивам без применения базы данных, которая, как правило, держит индекс в памяти.
<p align=justify>
Поиск по маске слов.
<p align=justify>
Когда двое людей говорят о море, то сначало не ясно, о чем дальше пойдет речь, о рыбе, о кораблях, или о красивом вечернем прибое, а может и о отпуске. Далее из контекста разговора как правило в течении минуты можно разобратья о чем речь. Т.е. люди используют ассоциации и находят общий образный язык. Человеческий образ допустим море это отпуск. Однозначно ассоциируется с тем, какие круизы, какие корабли, какие гостинницы, пляж из гальки или из песка. Организованный отдых или дикарем. Вобщем при упоминании моря в таком контексте роджаются совершенно однозначные мысли.
<p align=justify>
Или например в другом контексте. То-же самое море может ассоциироваться с красивым горным пейзажем, с какими-то воспоминаниями. Что упрется в поиск фотографий, к примеру, или, если постарше, то к исторической информации об этих местах.
<p align=justify>
Итак, ассоциация это набор понятий, все более и более сужающийся по мере продолжительности раговора. Собственно люди иногда и расходятся, когда не находят общего языка, так-же и с поисковиками, выдает не то, что нужно.
<p align=justify>
Изначально было широкое понятие море, которое включало в себя понятие отдыха, рыбы, интересных съемок Ива Кусто или арктических путешествий Нансена с Амундсеном, а может быть и путешествие Кука. Далее информация разделилась на покатегории, по человеческим ассоциаиям. Допустим море интеренсо как место отдыха, остальные гигабайты отсеялись. Место отдыха однозначно ассоциируется с красивыми видами, прогулками на катерах, ну и с поиском жилья.
Т.е. человек невольно определяет круг вопросов, которые ему нужно решить, чтобы провести отпуск. Фактически, на простом разговорном языке мы уже произвели отсев нужной информации. И это не было релевантностью, которая есть максимальное число слов в данном документе.
<p align=justify>
Как сделать так, чтобы поисковая система сама отсеивала нужную информацию. Т.е. выдавала то, что необходимо. В первые минуты разговора между двумя людьми происходит знакомство их интересов, которые в подавляющем большинстве и определяют дальнейшие отношения. В первые минуты работы с поисковой системой происходит точно такое-же знакомство. Поисковик выдает резултьтаты. Нет того, что нужно, значит ухожу на другой поисковик. Предположим слово море выдает несколько ссылок: отдых, исследования океана, знаменитые путешествия(Моби Дик) и т.д.
<p align=justify>
Пользователь выбирает себе нужную категорию(как составить такие тематические категории автоматичекси, чуть ниже, это и есть поиск по маске слов), далее переходит на еще один вложенный уровень категорий, а в конечном итоге он интересуется путешествием Ниньи.
Вышел с первого уровня на второй, где стоят ссылки: Тихий океан. Гречекие корабли, мифический остров Атлантида, Индийский океан, морские сражения(и все это отсортировано по алфавиту скажем) и т.д. Появилась структура запроса, начиная от знакомства с основной тематикой диалога. Эту структуру можно генерировать автоматически.
<p align=justify>
Допустим словосочетакие "Альберт Эйнштейн" однозначно ассоциируется с атомной бомбой, теорией относительности и скажем с преобразованиями лоренца, как конечный запрос. При вводе словосочетания "Альберт Эйнштейн" сразу выводится тематический рубрикатор в алфавитном порядке. Поиск анализирует разные документы на предмет совпадений разных слов. И чем больше документы походят друг на друга, тем ближе к одной тематике результаты, т.е. больший шанс попасть в данную категорию и в данную букву при кортировке по алфавиту. Чем больше различаются данные слова, тем больший шанс попасть в другую ссылку, другую букву. Т.е. происходит поиск не конкретного слова, а идет анализ результатов, оценивается степень их совпадения между собой. И чем больше процентов "похожести" слов по тематике, тем больше вероятность соотнести эти 
докуметы между собой. Т.е. идет своеобразное выстраивание документов по тематике, используя одинаковые слова, а слова тянут за собой ассоциации. Т.е. не один запрос, как сказал пользователь, а на самом деле внутри машины может произойти 100000 сравнений документов между собой, никакая база данных не потянет такой одновременный поиск.  Иными словами при действиями с этими масками слов просиходит уже не сравнение конкрентых слов, а сравнени понятий, выражаемых этими словами. Ну а чем еще можно выразить какое-то отношение, помимо слов. 
<p align=justify>
Структура этого дерева может быть реализована на хешах хешей, хешей массивов, массивов хешей, а быть может и хеши slice. Или взаимные комбинации, может быть хеши хешей размерности N.


<h3>
<a name=base_html_ex></a>
<a href="files/find.html">Примеры</a>
</h3>
<hr>

<a name="2dmass_html"></a>
<h4><a name=2dmass_html_2Darr>Объявление двумерного массива</a></h4>
<font  color=green><pre>
#!/usr/bin/perl -w
use strict;
my @table;
my $i;
my $j;

for $i (0..10) {
     for $j (0..10) {
         $table[$i][$j] = $i * $j;
     }
}

#вывести:

for ($i = 0; $i < @table; $i++){
  for($j =0; $j < @{$table[$i]}; $j++){
    print "$i : $j : ", $table[$i][$j], "\n";
  }
}

#можно и так:

for $i (0..$#table) {
     for $j (0..$#{$table[$i]}) {
         print "$i : $j : " . $table[$i][$j] . "\n";
     }
}
</pre></font>
<hr>

<a name="add_html"></a>
<pre>Razmer fajla v kilobajtah:

$file = "files.zip";
$size=(stat("$Dir/$file"))[7];
print $size;</pre>
<br>from: <a href="http://www.talk.ru/article.html?ID=13823783&page=1" target=_top>http://www.talk.ru/article.html?ID=13823783&page=1</a>&nbsp<p>
<pre>открывает и читает из выбранной дирретории все файлы:

while(<$dir/journal/*.*>){
push(@files, $_);
}

типа sed. уничтожает ненавистный символ ^M, получающийся иногда при копировании 
с виндовой машины на юниксовую машину.
Может с успехом заменить любой нужный к замене символ во всех файлах текущей дирректории
perl -i -n -p -e 's/\cM//isgm' *.html

</pre>
<br>from: <a href="#сам_написал" target=_top>сам написал</a>&nbsp<p>
<pre>#!/usr/bin/perl
qx[dbfdump --fs="\x18" --rs="\x19"  pdffile.dbf >pdffile.txt];

преобразовать базу в текстовый файл. rs - конец строки, fs разделитель поля в строке</pre>
<br>from: <a href="#посоветовали" target=_top>посоветовали</a>&nbsp<p>
<pre>unpack('a8000a*', $tpls[8]) - делит переменную на массив, состоящий из 8 килобайтов.

while ($tpls[8]){
  ($s,$tpls[8])=unpack('a8000a*', $tpls[8]);
    push @arr, $s;
  }

</pre>
<br>from: <a href="#подсказали" target=_top>подсказали</a>&nbsp<p>
<pre>#!/usr/bin/perl -w

use POSIX qw(locale_h);
use DBI;

my $dbh = DBI->connect("dbi:XBase:SEJ_STR.DBF")
     || die "Can't connect: $DBI::errstr";

my $sth = $dbh->prepare( q{
        SELECT name, phone
        FROM mytelbook
  }) || die "Can't prepare statement: $DBI::errstr";

my $rc = $sth->execute
     || die "Can't execute statement: $DBI::errstr";

print "Query will return $sth->{NUM_OF_FIELDS} fields.\n\n";
print "Field names: @{ $sth->{NAME} }\n";

while (($name, $phone) = $sth->fetchrow_array) {
      print "$name: $phone\n";
}
# check for problems which may have terminated the fetch early
die $sth->errstr if $sth->err;

$dbh->disconnect;
</pre>
<br>from: <a href="#из_мана" target=_top>из мана</a>&nbsp<p>
<pre>How can I get the unique keys from two hashes?

    First you extract the keys from the hashes into arrays, and then
    solve the uniquifying the array problem described above. For
    example:

        %seen = ();
        for $element (keys(%foo), keys(%bar)) {
            $seen{$element}++;
        }
        @uniq = keys %seen;

    Or more succinctly:

        @uniq = keys %{{%foo,%bar}};

    Or if you really want to save space:

        %seen = ();
        while (defined ($key = each %foo)) {
            $seen{$key}++;
        }
        while (defined ($key = each %bar)) {
            $seen{$key}++;
        }
        @uniq = keys %seen;</pre>
<br>from: <a href="#perl_mailer" target=_top>perl mailer</a>&nbsp<p>
<pre>@matches = grep(/\^$field\^\|.*$search.*?\|/,@data); поиск в массиве нужных слов.</pre>
<br>from: <a href="http://www.talk.ru/article.html?ID=14062178&page=1" target=_top>http://www.talk.ru/article.html?ID=14062178&page=1</a>&nbsp<p>
<pre>undef $/;
@records = split /your_pattern/, <FH>;

И ВСЕ!!!!</pre>
<br>from: <a href="#_perl_mailer_" target=_top> perl mailer </a>&nbsp<p>
<pre>FORM ACTION="mailto:SuvorovAV@mail.ru" ENCTYPE=text/plain ФБЛ НПЦОП ПФРТБЧЙФШ НЩМП ЙЪ ЖПТНЩ ВЕЪ ЧУСЛЙИ УЛТЙРФПЧ</pre>
<br>from: <a href="http://partizan-team.chat.ru/" target=_top>http://partizan-team.chat.ru/</a>&nbsp<p>
<pre>
while(1) {
system("cat FILE | grep "criteria" | mail -s subject your@address.ru 1> /dev/null 2> /dev/null");
sleep(as much as you want:));
} 

так надо посылать письма без кронтаба.</pre>
<br>from: <a href="http://www.rt.mipt.ru/board" target=_top>http://www.rt.mipt.ru/board</a>&nbsp<p>
<pre>Как перл-программу запустить в "фоновом" режиме ./prog.pl 2>&1 >log &</pre>
<br>from: <a href="http://www.rt.mipt.ru/board" target=_top>http://www.rt.mipt.ru/board</a>&nbsp<p>
<pre>tr/bla1-bla1/bla2-bla2/ for var1, var2, var3;</pre>
<br>from: <a href="#fido7_ru_perl" target=_top>fido7.ru.perl</a>&nbsp<p>
<pre>как написать выражение, чтоб из строки типа /home/www/vasia/file.html выделить только имя файла:

s|.*/||</pre>
<br>from: <a href="http://www.machaon.ru/digest/www_board/messages/21777.html" target=_top>http://www.machaon.ru/digest/www_board/messages/21777.html</a>&nbsp<p>
<pre>выцепление емейлов с www.job.ru

#!/usr/bin/perl -wT
$url0="http://www.job.ru/cgi/list1.cgi?GR_NUM=";
$url1="%31&TOPICID=9&EDUC=2&TP=&Gr=&SEX=&AGEMIN=23&AGEMAX=&MONEY=200
&CDT=";
$url2="&LDAY=99&ADDR=%ED%CF%D3%CB%D7%C1&KWORD=&KW_TP=AND";
use LWP::Simple;
foreach($i=1; $i<=57; $i++){
$plus.="%31%2B";
$test=$url0.$plus.$url1.$url2,"\n";
print join "\n", grep{s/(.*) ([\w+\-\.]+\@[\w\-\.]+\.\w{2,3})(.*)/$2/ig} split
/\n/, get "$test";
print "$i\n";
}
</pre>
<br>from: <a href="#сам_написал" target=_top>сам написал</a>&nbsp<p>
<pre>use Socket;                      #загрузить inet_addr
s{                               #
  (                              #Сохранить имя хоста в $1
    (?:                          #Группирующие скобки
	  (?! [-_] )                 #ни подчеркивание, ни дефис
	  [\w-] +                    #кусок имени хоста
	  \.                         #и точка домена
	)+                           #повторить несколько раз
	[A-Za-z]                     #следующий символ - буква
	[\w-]+                       #домен верхнего уровня
  )                              #конец записи $1
}{                               #Заменить следующим
  "$1" .                         #исходн часть + пробел
    (($addr = gethostbyname($1)) #Если имеется адрес
	? "[" . inet_ntoa($addr). "]"#отформатировать
	: "[???]"                    #иначе пометить как сомнительный
	)
}gex
</pre>
<br>from: <a href="#__1089____1082___1085___1080___1078___1082___1080_" target=_top>&#1089; &#1082;&#1085;&#1080;&#1078;&#1082;&#1080;</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>sub koi2win {
    my $str = shift;
    $str =~ tr[\xE1\xE2\xF7\xE7\xE4\xE5\xF6\xFA\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF2\xF3\xF4\xF5\xE6\xE8\xE3\xFE\xFB\xFD\xFF\xF9\xF8\xFC\xE0\xF1\xC1\xC2\xD7\xC7\xC4\xC5\xD6\xDA\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD2\xD3\xD4\xD5\xC6\xC8\xC3\xDE\xDB\xDD\xDF\xD9\xD8\xDC\xC0\xD1\xB3\xA3][\xC0-\xFF\xA8\xB8];
    return $str;
}
</pre>
<br>from: <a href="#из_сети" target=_top>из сети</a>&nbsp<p>
<pre>sub win2koi {
    my $str = shift;
    $str =~ tr[\xC0-\xFF\xA8\xB8][\xE1\xE2\xF7\xE7\xE4\xE5\xF6\xFA\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF2\xF3\xF4\xF5\xE6\xE8\xE3\xFE\xFB\xFD\xFF\xF9\xF8\xFC\xE0\xF1\xC1\xC2\xD7\xC7\xC4\xC5\xD6\xDA\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD2\xD3\xD4\xD5\xC6\xC8\xC3\xDE\xDB\xDD\xDF\xD9\xD8\xDC\xC0\xD1\xB3\xA3];
    return $str;
}</pre>
<br>from: <a href="#из_сети" target=_top>из сети</a>&nbsp<p>
<pre>Vivesti vremya

&time($time);

...


sub time{
  $time = sprintf("%02d/%02d/%02d b %02d:%02d:%02d", $tm->hour,$tm->min, $tm->sec, $tm->mday, $tm->mon+1, $tm->year+1900);
  return $time;
}</pre>
<br>from: <a href="#сам_написал" target=_top>сам написал</a>&nbsp<p>
<pre>to-ge samoe no odnoj korotkoj strochkoy

#!/usr/bin/perl

my ($wday,$mday,$mon,$year,$time) =
 (split(" ",gmtime(time+10800)))[0,2,1,4,3];

print "$wday, $mday $mon $year $time GMT\n";

print (split("\s",gmtime(time+10800)))->[0,2,1,4,3];
print "\n";</pre>
<br>from: <a href="#sam_napisal" target=_top>sam napisal</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>17.29   2000-й год будет високосным? (год %4 ==0) -  правильный тест на
        високосный год?

О:      Да и нет соответственно. Вот полной тест для Григорианского
        календаря:

                 year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)</pre>
<br>from: <a href="#какой_то_вебсайт" target=_top>какой-то вебсайт</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>@d=split(/[ ]+/, scalar localtime);

оНКСВХЛ:

$d[0]=='Wed'
$d[1]=='Jun'
$d[2]=='5'
$d[3]=='14:59:35'
$d[4]=='2002'</pre>
<br>from: <a href="#dffddf" target=_top>dffddf</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>
</pre>
<br>from: <a href="" target=_top>
</a>&nbsp<p>
<pre>
<h1>...</h1>
</pre>
<br>from: <a href="<h1>сам</h1>" target=_top>
<h1>сам</h1>
</a>&nbsp<p>
<pre>
<h1>...</h1>
</pre>
<br>from: <a href="<h1>сам</h1>" target=_top>
<h1>сам</h1>
</a>&nbsp<p>
<pre>
<hr>
<h1>nu huynya vihodt</h1>
<hr>
<--
<script>
<hr>

<a name="apache_html"></a>
<center>
<h4>
<a name=apache_html_apache>Использование регулярных выражений в apache</a>
</h3>
</center>
<p align=justify>
Преположим есть веб-сервер, на котором пользователям нужно 
завести домашние директории. В конфигурационном файле <font color=green>httpd.conf</font> они должны иметь
в <font color=green>/home/user/</font> директорию <font color=green>public_html</font>, тогда стандартным образом пользовательские директории могут вызываться примерно так: <font color=green>http://www.server.su/~user/</font>
Нужно сделать так, чтобы пользователи могли исполнять
скрипты и программы в своих директориях. Заводим в 
директории <font color=green>/home/user/public_html</font> директорию <font color=green>cgi-bin</font>. В <font color=green>httpd.conf</font>
пишем 
<font color=green>
<pre>
ScriptAliasMatch ^/~(.*)/ex/(.*) "/home/$1/public_html/cgi-bin/$2"
</pre>
</font>
<p align=justify>
и после этого <font color=green>service restart httpd</font> и пользователи могут исполнять и вызывать свои скрипты по адресу <font color=green>http://www.server.su/~user/ex/test.pl</font>
<hr>

<a name="file_html"></a>
<ul>
<li>
<a href="#file_html" target="_new">Ввод/Вывод</a>
</li>
  <ul>
    <li>
<a href="#file_html_otkr" target="_new">Открытие файлов</a>
    <li>
<a href="#file_html_skan" target="_new">Сканирование  директорий</a>
    <li>
<a href="#file_html_chmod" target="_new">извлечение и запись данных о некоторых свойствах файлов</a>
  </ul>
</ul>
<font color=green>open</font> - открытие файла <br>
<font color=green>close</font> - закрытие файла <br>
<font color=green>print</font> - вывод в файл <br>
<font color=green>write</font> - запись в файл <br>
<font color=green>binmode</font> - установка двоичного режима <br>
<font color=green>read</font> - чтение входных данных <br>
<font color=green>readline</font> - считывание строки ввода <br>
<font color=green>getc</font> - считывание одиночного символа <br>
<font color=green>seek</font> - поиск заданной позиции в файле <br>
<font color=green>tell</font> - текущая позиция в файле <br>
<font color=green>stat</font> - информация о файле <br>
<font color=green>select</font> - выбор дескриптора файла для <font color=green>STDOUT</font> <br>
<font color=green>eof</font> - проверка конца файла <br>
<font color=green>flock</font> - блокировка файла <br>
<font color=green>chmod</font> - изменение прав доступа к файлу <br>
<font color=green>rename</font> - переименование файлов <br>
<font color=green>glob</font> - поиск файлов по шаблону <br>
<font color=green>unlink</font> - удаление файлов <br>
<font color=green>opendir</font> - открытие каталога <br>
<font color=green>closedir</font> - закрытие каталога <br>
<font color=green>readdir</font> - чтение содержимого каталога <br>
<font color=green>seakdir</font> - установка текущей позиции в каталоге <br>
<font color=green>telldir</font> - чтение текущей позиции в каталоге <br>
<font color=green>rewinddir</font> - установка текущей позиции на начало каталога <br>
<font color=green>chdir</font> - смена текущего каталога <br>
<font color=green>mkdir</font> - создание нового каталога <br>
<font color=green>rmdir</font> - удалить каталог <br>
<a name=file_html_otkr>
<h4>Открытие файлов</h4>
</a>
<font color=green>open</font> - открытие файла, функция открывает файл и создает дескриптор файла.
<font color=green>
<pre>
  open F, ">file.ext" or die "Не могу открыть файл $file.ext: $!";
  @m=<F>;
  close F;
</pre>
</font>
<p align=justify>
binmode устанавливает Бинарный режим.
<p align=justify>
<font color=green>read</font> - читает данные из дескриптора файла, параметры:

<pre>
<font color=green>read F, $scalar, $lenght, $pos;</pre>
</font>
<p align=justify>
В параметре <font color=green>$lenght</font> указывается число байтов, которые необходимо прочитать из дескриптора <font color=green>F</font> и записать их в скалярную переменную. Параметр <font color=green>$pos;</font> указывает, с какой позиции от начала скаляра нужно размещать считанные байты.

<p align=justify>

<font color=green>pack</font> - упаковка значений в бинарную структуру по шаблону. Параметры:

<font color=green>pack</font> шаблон, список.

Шаблон - последовательность букв, которая задает порядок и тип значений:
<font color=green>@</font> - заполнить двоичными нулями до след. абс. позиции.
<font color=green>a</font> - текстовая строка, заполняемая двоичными нулями.
<font color=green>С</font> - однобайтовое целое без знака
, для любого числа повторений испошьзуется символ <font color=green>*</font>.

<pre>
<font color=green>print pack("C*", 68, 69, 70, 71);
DEFG</pre>
</font>
<p align=justify>
<font color=green>unpack</font> возвращает структуру, упакованную функцией <font color=green>pack</font> с шаблоном, заданным при упаковке pack, в нашем случае C*.

<font color=green>substr</font> - подстрока тектстовой строки, переданная в качестве аргумента. Параметры:
<pre>
<font color=green>substr $text, $pos, $lenght, $regex;</pre>
</font>

<font color=green>$text</font> = передаваемый текст, <font color=green>$pos</font> - смещение, подстрока начинается с символа, имеющего заданное смещение от начала строки
<a name=file_html_skan>
<h4>Сканирование поддиректорий</h4>
</a>
<p align=justify>
Иногда бывает необходимо заменить во всех файлах всех поддиректорий
какое-либо слово или баннер. Можно воспользоваться программой, которая
рекурсивно ходит по поддиректориям и просматривает в них все файлы.
В принципе на основе этого скрипта возможно выводить дерево каталогов или
наводить статистику по всем файлам, допустим столько-то html, столько-то
txt. Или просто иногда поискать что-нибудь, используя аналог unix'овой
команды find. Приведенный код позволяет просматривать все файлы в
поддиректории и заменять в них код определенного баннера:
</p>

<pre>
<font color=green>
#!/usr/bin/perl
$dir="/usr/local/www/allsitecopy";
&scan($dir);
sub  scan {
  my $dir=$_[0];
  my (@files,$filen,$ndir,$n,$mass,@dirs);
  opendir D, $dir or warn "Cannot open $dir: $!" and next;
  @dirs=grep {!(/^\./) && -d "$dir/$_"} readdir D;
  rewinddir D;
  @files=grep {!(/^\./) && /html/i && -f "$dir/$_"} readdir D;
  closedir D;

  for $n(0..$#dirs) {
    $ndir=$dir."/".$dirs[$n];
    &scan($ndir);
  }
  for $n(0..$#files) {
    $filen=$dir."/".$files[$n];
    print "$filen all ok!\n" if($filen=~m!\.html$!i);
    if($filen=~m!\.html$!i){ local $/="\001";
      open F, "&lt;$filen"; $mass=&lt;F>; close F;
      open F, "&gt;$filen";
      $mass=~s%&lt;!--begin banner1--&gt;(.*?)&lt;!--end banner1--&gt;%%igsm;
      print F $mass;
      close F;
    }
  }
  return 1;
}
</pre>
</font>

можно немного модифицировать приведенный выше код:

<pre>
<font color=green>
#!/usr/bin/perl
my $dir="/usr/local/www/allsitecopy";
all_files($dir);
sub all_files{
  my $cur_dir = shift;
  chdir $cur_dir || warn "can't open dir $cur_dir\n";
  foreach(<*>){
   if (-f "$cur_dir/$_") { action("$cur_dir/$_"); }
   if (-d "$cur_dir/$_") { all_files("$cur_dir/$_"); }
  }
}

sub action{
  ...что то там сделать...
  my $file = shift;
  print "$file\n";
}
</pre>
</font>
Это-же можно сделать и из командной строки:
<pre>
<font color=green>
find /usr/local/www/allsitecopy -name \*.html -print | xargs \
  perl -p0i.bak -e 's/<\!--begin banner1-->(.*?)<\!--end
banner1-->//igs'
</pre>
</font>
from <a href="http://www.simplex.ru/news/win/" target=_new>Alex Farber</a>
<hr>

<a name="calendar_html"></a>
<center>
<h4>
<a name=calendar_html_calendar>Выводим даты при помощи модуля Calendar::Simple</a>
</h4>
</center>

Пример прямо из <font color=green>man Calendar::Simple</font>
<font color=green>
<pre>
#!/usr/bin/perl -w

use strict;
use Calendar::Simple;

my @months = qw(January February March April May June July August
                         September October November December);
                         
my $mon = shift || (localtime)[4] + 1;
my $yr = shift || ((localtime)[5] + 1900);
                         
my @month = calendar($mon, $yr);
                         
print "\n$months[$mon -1] $yr\n\n";
print "Su Mo Tu We Th Fr Sa\n";
foreach (@month) {
  print map { $_ ? sprintf "%2d ", $_ : '   ' } @$_;
  print "\n";
}
</pre>
</font>
  на выводе имеем:
  
  <font color=green>
<pre>
** Joe's Own Editor v2.8 ** Copyright (C) 1995 Joseph H. Allen **
File /root/raznoe/Calendar-Simple-1.06/aa.pl not changed so no update needed.
[root@www /root]# /root/raznoe/Calendar-Simple-1.06/aa.pl

August 2002

Su Mo Tu We Th Fr Sa
             1  2  3
 4  5  6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30 31
[root@www /root]#
              
              </pre>
</font>
<hr>

<a name="chmod_html"></a>
<h4>
<a name=chmod_html_chmod>Backup прав доступа на файлы и директории[only for unix like
systems]</a>
</h4>
Программа, восстанавливающая пермишны на файлы например в случае
непреднамеренного использования команды <font color=green>chmod -R 777
*.*</font> из корневой директории(или в аналогичных ситуациях). В
комментариях разъяснена работа программы:

<pre>
<font color=green>
#!/usr/bin/perl -w

use strict;
use File::Find;

my ($test, $dir, $db, $pwd, $tmp);

$db="/home/user/cgi/xxx.dat";

###################
#program section  #
###################

&exc(); #read exceptions
unlink $db if !-z $db and $ARGV[0] eq 'r';
#стираем файл старой базы при команде r в случае если он ненулевого размера

find \&read => "$dir" if $ARGV[0] eq 'r';
#начать сканировать поддиректории если с командной строки пришло r

rewrite() if $ARGV[0] eq 'w';
#начать восстанавливать права на файлы, если с командной строки пришло w

##################
#subroutines     #
##################

sub read {#чтение прав
  $test=sprintf "%04o" => (stat($File::Find::name))[2] & 07777;
  #получить права на файл ли директорию
  &readchmod("$File::Find::name\t$test\n");
  #вызов подпрограммы для записи базы
}

sub readchmod{#запись прав
  open F, ">>$db" or die "Can't open $db: $!";
  print F $_[0];
  print "$_[0]"; #смотрим, что записывается
  close F;
}

sub rewrite{#перезапись прав
  open F, "<$db" or die "Can't open $db: $!";
  while(<F>){ chop; #читаем построчно в $_ и отъедаем от него перевод
каретки
    my ($file, $chmod) = split /\t/;
    qx [chmod $chmod $file]; #даем системную команду chmod
    print "$chmod\t=>\t$file\n"; #смотрим, что делает программа
  } close F;
}

sub exc{
  do{print "Type './chmod.pl ?' or './chmod.pl h'\n"; exit 0}
    if $#ARGV==-1;#обрабатываем пустой ввод вида ./chmod.pl

  do {print "Your command must be 'w', 'r', 'h' or '?'!\n"; exit 0}
    if $ARGV[0]!~m%^[wr?h]$% and $#ARGV!=-1;
  #обрабатываем все остальные буквы, кроме необходимых

  do{ print qq~
Программа создает базку пермишнов на файлы и директории на
случай экстренных ситуаций вроде неправильного или случайного
использования команды chmod -R 777 из корневой директории.

chmod.pl [w|r|h|?] [/полный/путь/до/директории]

Для указания директории, от которой будет создаваться база
пермишнов, нужно ввести команду  "r /path/you/dir"

Для создания базы на права для файлов и дирректорий
Вы должны ввести "r".

Для восстановления прав на файлы и директории вы должны
ввести команду "w".

Справка по командам "?" или "h". 

Второй аргумент должен быть полным путем к директории, от которой нужно
начинать рекурсивно сохранять права. По умолчанию стоит текущая
директория. Например если Вы запустили программу из корневой директории,
 то текущей директорией начала просмотра подкаталогов будет считаться 
корневая директория, если в файле /home/user/.shrc внесена переменная
окружения $ENV{PWD}.

  ~; exit 0} 
    if $ARGV[0]=~m!^[?h]$!; #выводим хелп

  if($ARGV[1] eq ''){#есл не ввели второго аргумента в командной строке
                     #то определяем переменную $dir
    #while(my ($k, $v)=each %ENV){print "$k\t=>\t$v\n"}
    #смотрим, что содержит переменная окружения,
    #содержащаяся в /home/user/.shrc
    $dir=$ENV{PWD};
    #определяем директорию запуска скрипта, чтобы с этой точки начать
    #поход по поддиректориям 
  } else {
    -d $ARGV[1] or die "$!";#если то, что пришло вторым аргументом
                            #директория, то идем дальше, иначе читаем
                            #ошибку
    $dir=$ARGV[1];
  }

  return 1;
}
</font>
</pre>

Если нашли a lot of bugs - <a
href="mailto:dmitriy@genphys.phys.msu.su?subject=chmod">пишите</a>.
<p>
<br>
<hr>

<a name="cpan_html"></a>
<center>
<h4>
<a name=cpan_html_cpan>Ежедневные обновления CPAN</a>
</h4>
</center>
<p align=justify>По адресу <a href="http://search.cpan.org/recent">http://search.cpan.org/recent</a>
можно найти ежедневные обновления архива модулей <a
href="http://www.cpan.org">CPAN</a>. Кадый день добавляется(или обновляется) в среднем 20
модулей(из них около 10 новых). Например недавно вышла очередная версия
модуля для доступа к
локальным ресурсам при помощи smb-client <a
href="http://search.cpan.org/author/ALIAN/Filesys-SmbClientParser-2.3/">Filesys::SmbClientParser</a>
<hr>

<a name="eratosfen_html"></a>
<center>
<h4>
<a name=eratosfen_html_find>Алгоритм Эратосфена</a>
</h4>
</center>
<p align=justify>Алгоритм, позволяющий получать простые числа, отличается по быстродействию
от приведенного ниже алгоритма с применением <font color=green>Quantum::Superpositions</font>:
<font color=green>
<pre>
$N = 1000000; 

@L = (1) x $N; 

$L[0] = 0; $L[1] = 0; 

$start = 2; 
$t0 = time; 
while($start<$N) { 
  if($L[$start]==0) { $start++; next; } 
  for($i=$start*2;$i<$N;$i+=$start) { $L[$i] = 0; } 
  $start++; 
} 
print "time: ".(time-$t0)."\n"; 

for($i=0;$i<$N;$i++) { 
  print $i." " if($L[$i]==1); 
} 
</pre>
</font>

Программа написана David A. Mzareulyan from <a
href="http://www.scientific.ru">http://www.scientific.ru</a>
<hr>

<a name="factors_html"></a>
<p>

Допустим нужно получить список
всех простых чисел(мы ограничися перебором до тысячи, т.к. ждать долго <font color=green>~30 sekund for my server p100, 32 ram, red hat linux7.1, perl 5.0.6</font>), пишем программу:
<font color=green>
<pre>
#!/usr/bin/perl -sw

use Quantum::Superpositions;

sub is_prime { return $_[0]==2 || $_[0] % all(2..sqrt($_[0])+1) != 0 }

do{print "$_ - простое число\n" if is_prime($_)} for map {2*$_+1} 1..1000;
</pre>
</font>
на выводе имеем нечто вроде:
<font color=green>
<pre>
** Joe's Own Editor v2.9.5 ** Copyright (C) 2001 **
File demo_Primes.pl not changed so no update needed.
[root@tv demo]# ./demo_Primes.pl
3 - простое число
5 - простое число
7 - простое число
11 - простое число
13 - простое число
17 - простое число
19 - простое число
23 - простое число
29 - простое число
31 - простое число
37 - простое число
41 - простое число
43 - простое число
47 - простое число
53 - простое число
59 - простое число
61 - простое число
67 - простое число
71 - простое число
73 - простое число
79 - простое число
83 - простое число
89 - простое число
97 - простое число
101 - простое число
103 - простое число
107 - простое число
109 - простое число

[root@tv demo]#
</pre>
</font>

Или нужно получить все сомножители какого-то числа:
<font color=green>
<pre>
#!/usr/bin/perl -w

use Quantum::Superpositions UNARY => ['CORE::int'];

sub factors {eigenstates (int($_[0] / any(2..$_[0]-1)) == ($_[0] / any(2..$_[0]-1)))}

print int($_), "\n factors: ", join(",", factors($_)), "\n" while (<>);
</pre>
</font>
На выводе имеем:
<font color=green>
<pre>
[root@tv demo]# ./factors.pl
8
8
factors: 2,4
121
121
factors: 11
56
56
factors: 7,8,14,2,4,28
78
78
factors: 13,39,2,3,26,6
    
[root@tv demo]# 
</pre>
</font>
<hr>

<a name="hash_html"></a>
<h2>
<center>Хеши</center>
</h2>
<br>
<ul>
  <li>
<a href="#hash_html_open">Объявление</a>
</li>
  <li>
<a href="#hash_html_dost">Доступ к элементам</a>
</li>
  <li>
<a href="#hash_html_show">Вывод</a>
</li>

  <ul>
  <li>
<a href="#hash_html_vstt">Вывод хеша в порядке вставки с использованием
Tie::IxHash</a>
</li>
  <li>
<a href="#hash_html_vst">Вывод хеша в порядке вставки без использования
Tie::IxHash</a>
</li>
<li>
<a href="#hash_html_uniqhash">Выбор уникальных ключей в хеше</a>
  </li>
</ul>
  <li>
<a href="#hash_html_sort">Сортировки</a>
</li>
  <li>
<a href="#hash_html_subh">Всторенные хеши</a>
</li>

  <li>
<a href="#hash_html_slice">Хеши slice</a>
</li>
  <li>
<a href="#hash_html_hhash">Хеши хешей</a>
</li>
  <li>
<a href="#hash_html_massh">Массивы хешей</a>
</li>
  <li>
<a href="#hash_html_harr">Хеши массивов</a>
</li>
  <li>
<a href="#hash_html_hharr">Хеши хешей массивов</a>
  </li>
<li>
<a href="#hash_html_hashn">Хеш хешей хешей хешей массивов</a>

  </li>
<li>
<a href="#hash_html_ex">Примеры</a>
</li>
  <ul>
	<li>
<a href="#hash_html_007">Шпионская программа</a>
</li>
	<li>
<a href="#hash_html_journal">Программа вывода номеров журнала</a>
</li>
        <li>
<a href="#hash_html_log">Простой анализатор логов на хеше хешей
массивов</a>
  </li>
</ul>
</ul>

<p align="justify">Хэш - ассоциативный массив, т.к. доступ к данным
осуществляется при помощи ключа, ассоциированного со значением. 
</p>
<h3>
<a name="hash_html_open">Объявление</a>
</h3>
Хэши начинаются с префикса <font color="Green">%</font>: <font
color="Green">%hash</font>. Для работы с с хэш-массивами нужно, как и в
обычных массивах, использовать разыменовывающий префикс <font
color="Green">$</font>: <font color="Green">$hash{шляпа} =
серая;</font>
<p>
</p>

Хэш можно определить несколькими способами:
<div>
<pre>
<font color="Green">%hash = (
	'шляпа' =&gt; 'серая',
	'водка' =&gt; 'горькая',
	'вобла' =&gt; 'вкусная',
	'штаны' =&gt; 'широкие',
	'пиво' =&gt; 'темное',
	'игрушка' =&gt; 'любимая');

</font>
</pre>	
<font color="green">%hash = ();</font> #можно не указывать пустой хеш для
создания массива, perl может сам создавать пустой хэш.
<font color="green">
</font>
<pre>
<font color="green">$hash{'шляпа'} =
'серая';
$hash{'водка'} = 'горькая';
$hash{'вобла'} = 'вкусная';
$hash{'штаны'} = 'широкие';
$hash{'пиво'} = 'темное';
$hash{'игрушка'} = 'любимая';</font>
</pre>
</div>
<p align="justify">Если используется пробел при определении элемента хэша,
то этот пробел лучше поставить в одинарные кавычки <font
color="Green">$hash{'дырявая шляпа'} = 'серая';</font>
</p>

Добавить элементы в хеш можно так:
<div>
<pre>
<font color="Green">%hash = (
	'шляпа' =&gt; 'серая',
	'водка' =&gt; 'горькая',
	'вобла' =&gt; 'вкусная');
%hash = (%hash, 'кошка', 'мягкая');
foreach $k (keys %hash){
print "$k = $hash{$k}\n";
}</font>
</pre>
</div>

и так:
<div>
<font color="Green">
</font>
<pre>
<font color="Green">%hash = (
	'шляпа' =&gt; 'серая',
	'водка' =&gt; 'горькая',
	'вобла' =&gt; 'вкусная');
$hash{"дом"} = "большой";
$hash{"дым"} = "сизый";
foreach $k (keys %hash){
print "$k = $hash{$k}\n";
}</font>
</pre>
</div>

и еще например так:
<div>
<pre>
<font color="Green">
my %Years = ( 
      1999 =&gt; "golos1999.html", 
      2000 =&gt; "golos2000.html", 
      2001 =&gt; "golos2001.html",
    map{$_ =&gt; "golos$_.html"}(2002..2032)
            );

</font>
</pre>
</div>
т.е. если у нас есть файлы, которые группируются по годам, дням, месяцам или
еще как,
то дабы не переписывать скрипт, можно сказать 
<font color="Green">map { $_ =&gt; "golos$_.html" } (2002..2032)</font>
где год или неделя берется из какое-йнибудь переменной, в данном случае из
<font color="Green">$_</font>.<p>

</p>
<h3>
<a name="hash_html_dost">доступ к элементам</a>
</h3>
Проверка хэша на наличие элемента:
<div>
<pre>
<font color="Green">
%hash = (
	'шляпа' =&gt; 'серая',
	'водка' =&gt; 'горькая',
	'вобла' =&gt; 'вкусная');

if(exists($hash{"дождь"})){
	print "Элемент найден";
        }
else{
	print "Элемент не найден";
	}</font>
</pre>
</div>

Удалить элемент из хэша можно при помощи функции <font
color="Green">delete</font>:
<div>
<pre>
<font color="Green">
%hash = (
	'шляпа' =&gt; 'серая',
	'водка' =&gt; 'горькая',
	'вобла' =&gt; 'вкусная');

delete($hash{"шляпа"});
if(exists($hash{"шляпа"})){
	print "Элемент найден";
	}
else{
	print "Элемент не найден";
	}</font>
</pre>
</div>

<p align="justify">Функция <font color="Green">delete</font> может
вызываться для среза хэша, что приводит к удалению всех указанных ключей:

<font color="Green">delete @hash{'шляпа','водка','вобла'};</font> см.
perlfunc(1)
</p>
<p align="justify">Если нужно найти совпадающие ключи или не входящие в
другй хэш, то надо организовать перебор ключей хэша при помощи <font
color="Green">keys</font> и проверять, если ли текущий ключ в другом хэше.
Поиск совпадающих ключей:</p>
<div>
<pre>
<font color="Green">
my @common = ();
foreach(keys %hash1){
	push(@common, $_) if exists $hash2{$_};

}
</font>
</pre>
</div>
Поиск ключей, отсутствующих в другом хэше:
<div>
<pre>
<font color="Green">
my @test = ();
foreach(keys %hash1){
	push(@test, $_) unless exists $hash2{$_};
}
</font>
</pre>
</div>
<p align="justify">Если <font color="Green">keys</font> вызывается для
хэша, ключи которого представляют собой ссылки, то возвращаемые ей
ссылки не работают. Ключи преобразуются в строки, т.е. интерпретируются
так, словно они заключены в кавычки, при работе со ссылками они теряют
свои свойства. После преобразования в строку ссылка имеет вид </p>

<div>
<pre>
<font color="Green">
Class::Somewhere=HASH(0x72048)
ARRAY(0x72048)
</font>
</pre>
</div>
<p align="justify">Преобразованную ссылку нельзя вернуть к прежнему
виду, т.к. она из ссылки превратилась в строку. Нужно создать
специальный хэш, ключами которого являются ссылки, преобразованные в
строки, и значениями - настоящие ссылки.Можно воспользоваться модулем <font
color="Green">Tie::RefHash</font>. Пример показывает использование объектов
ввода/вывода для работы с файловыми манипуляторами.</p>
<div>
<pre>
<font color="Green">
use Tie::RefHash;
use IO::File;

tie %name, "Tie::RefHash";
foreach $filename("/etc/termcamp/", "/vminux", "/bin/cat"){
	$fh = IO::File-&gt;("&lt;$filename") or next;
	$name{$fh} = $filename;
}
print "open files: ", join(", values %name", "\n");
foreach $file(keys %name){
	seek($file, 0, 2);
	printf("%s is %d bytes long.\n", $name{$file}, $tell{$file});
}
</font>
</pre>
</div>
<p align="justify">Если в качестве ключа использована неопределенная
величина <font color="Green">undef</font>, то она преобразуется в пустую
строку. <font color="Green">undef</font> является вполне допустимым
значением в хэше. Но при выборке значения для ключа, отсутствующего в хэше
perl выдаст <font color="Green">undef</font>. Проверить наличие ключа можно
так: <font color="Green">exist($hash{$key});</font> определенность
ассоциированного значения: <font color="Green">defined($hash{$key});</font>
истинность: <font color="Green">if($hash{$key});</font>. Иногда <font
color="Green">undef</font>

нужно сохранять в кэше, т.е. ключ есть, но с ним не связано ничего
полезного, например программа, определяющая размер файлов из
переданного списка:</p>
<div>
<pre>
<font color="Green">
%name =();
while(&lt;&gt;){
	chomp;
	next if exist $name{$_};
	$name{$_} = -s $_;
}
</font>
</pre>
</div>

Этот код позволяет пропустить несуществующие и нулевые файлы, но записанные
в исходном списке.

<p align="justify">Хэши с несколькими значениями, ассоциированными
одним ключом. Т.к. скалярные величины, содержащиеся в хэше, могут быть
ссылками(которые могут быть скалярами), то ассоциировать несколько
значений одним ключом можно сохранив в <font
color="Green">$hash($key)</font> ссылку на массив со значениями,
ассоциированными с ключом <font color="Green">$key</font>. Операции с
хэшами(вставка, удаление, перебор и проверка существования(undef))
переписываются для операций с массивами(<font color="Green">push</font>,
<font color="Green">splice</font> и <font color="Green">foreach</font>).
Пример, реализующий вставку в хэш(обрабатывает выходные данные команды
who(1) и выводит краткий список пользователей с терминалами, на которых
они зарегестрированы):</p>

<div>
<pre>
<font color="Green">
%ttys=();
open (WHO, "who|");
while(<who>){
        ($user, $tty) = split;
        push(@ {$ttys{$user}}, $tty);
}
foreach $user (sort keys %ttys){
	print "$user: @{$ttys{$user}}\n"
}
</who>
</font>
</pre>
</div>
<p align="justify">в строке <font color="Green">push</font> содержится
версия <font color="Green">$tty{$user} = $tty</font> для многозначного хэша.
Все имена терминалов интерполируются в строке <font color="Green">print
@{$ttys{$user}}</font>. </p>

Пример программы, которая на название предмета выдает его свойство и
наоборот:<p>
</p>

<div>
<pre>
<font color="Green">
#!/usr/bin/perl -w 
$vziat = shift @ARGV or die $!;
%svojstvo = (
        "malina" =&gt; "vkusnaia",
        "svekla" =&gt; "krasnaya",
     "kozmodrom" =&gt; "nebolshoy",
       "magazin" =&gt; "dvuhetagnij");
%predmet = reverse %svojstvo;
if (exists $svojstvo{$vziat}){print "$vziat," ", $svojstvo{$vziat}\n";}
elsif (exists $predmet{$vziat}){print "$vziat," ", $predmet{$vziat}\n";}
</font>
</pre>
</div>
<div>
<pre>например если ввести в терминале:
bash-2.03$ ./1.pl malina
то скрипт выдаст:
malina  vkusnaia
или
bash-2.03$ ./1.pl vkusnaia
vkusnaia  malina</pre>
</div>
<p>
В чем различие <font color="green">delete</font> и <font
color="green">undef</font> для хешей?</p>
<p>

Хеши являются парами скаляров, первый - ключ, второй значение.
Ключ может быть строкой, в то время как значением хеша может 
быть любой вид скаляра: строка, число или ссылка. Если ключ 
содержится в хеше, то  <font color="green">exists($key)</font> возвратит
истину. Значение для
какого-то конкретного ключа может быть <font color="green">undef</font>'ом,
и <font color="green">$array{$key}</font>
возвратит так-же undef, но <font color="green">exists($key)</font> возвратит
истину.
Иными словами в хеше может быть реализована связка <font
color="green">('$key', 'undef')</font>
</p>
<p>
В качестве примера можно привести следующую таблицу <font
color="green">%ary</font>:

<font color="green">
<pre>              keys  values
            +------+------+
            |  a   |  3   |
            |  x   |  7   |
            |  d   |  0   |
            |  e   |  2   |
            +------+------+
</pre>
</font>
Этот хеш выглядит примерное так:
<font color="green">
<pre>            $ary{'a'}                        true
            $ary{'d'}                        false
            defined $ary{'d'}                true
            defined $ary{'a'}                true
            exists $ary{'a'}                 true (perl5 only)
            grep ($_ eq 'a', keys %ary)      true
</pre>
</font>
Если теперь сказать
<font color="green">
<pre>            undef $ary{'a'}
</pre>
</font>
То таблица будет читаться следующим образом:
<font color="green">
<pre>              keys  values
            +------+------+
            |  a   | undef|
            |  x   |  7   |
            |  d   |  0   |
            |  e   |  2   |
            +------+------+

</pre>
</font>
И теперь логические состояния в хеше уже немного другие, 
изменения показаны регистром
<font color="green">
<pre>            $ary{'a'}                       FALSE
            $ary{'d'}                       false
            defined $ary{'d'}               true
            defined $ary{'a'}               FALSE
            exists $ary{'a'}                true (perl5 only)
            grep ($_ eq 'a', keys %ary)     is true
</pre>
</font>
Отсюда следует вывод, что можно держать значение undef'ом, 
но ключ всегда должен быть определен.
</p>
<p>
Теперь рассмотрим операцию удаления элемента из хеша:
<font color="green">
<pre>            delete $ary{'a'}
</pre>
</font>
после этого таблица  будет выглядеть так:
<font color="green">
<pre>              keys  values
            +------+------+
            |  x   |  7   |
            |  d   |  0   |
            |  e   |  2   |
            +------+------+
</pre>
</font>
Состояния элементов в хеше уже другие, 
изменения показаны, как и в предыдущем примере, различающимся регистром.
<font color="green">
<pre>            $ary{'a'}                       is
false
            $ary{'d'}                       is false
            defined $ary{'d'}               is true
            defined $ary{'a'}               is false
            exists $ary{'a'}                is FALSE (perl5 only)
            grep ($_ eq 'a', keys %ary)     is FALSE


</pre>
</font>
from: <a href="mailto:perlreply@faq-by-day.org">perlreply@faq-by-day.org</a>
</p>
<h3>
<a name="hash_html_show">Вывод</a>
</h3>
Для того чтобы организовать циклы по элементам хэша, нужно использовать
функцию each:
<div>
<pre>
<font color="Green">
%hash = (
	'шляпа' =&gt; 'серая',
	'водка' =&gt; 'горькая',
	'вобла' =&gt; 'вкусная');

while(($key,$value) = each %hash){
	print "$key =&gt; $value\n";
	};

</font>
</pre>
</div>
Для перебора элементов не очень большого хеша можно воспользоваться foreach:
<div>
<pre>
<font color="Green">
%hash = (
	'шляпа' =&gt; 'серая',
	'водка' =&gt; 'горькая',
	'вобла' =&gt; 'вкусная');

foreach $key(keys %hash){
print $key,"\n"; #возвращает список ключей хеша
}

%hash = (
	'шляпа' =&gt; 'серая',
	'водка' =&gt; 'горькая',
	'вобла' =&gt; 'вкусная');    

foreach $value(values %hash){
print "$value\n"; #возвращает список значений хеша
}
</font>
</pre>
</div>

<p align="justify">Преимущество each заключается в том, что пары
ключ/значение извлекаются по одной, Если хэш содержит слишком много
ключей, отказ от предварительного построения полного списка существенно
экономит память и время, но функция each не позволяет управлять
порядком обработки пар. Перебор хэша при помощи while затрачивает мало
памяти. Можно любым образом форматировать выходные данные, при этом
нужны всего лишь две скалярные переменные, ключ и значение. </p>
<p
align="justify"> Цикл foreach перебирает заранее построенный
список ключей, поэтому после начала цикла он ничего не знает о
добавленных или удаленных ключах, ключи, добавляемые внутри цикла, не
включаются автоматически в список перебираемых ключей, а удаленные
внутри цикла ключи не удаляются из этого списка. </p>
Содержимое хэша можно вывести и так:
<pre>
<font color="Green">while (@Res = each %hash){
        print "$Res[0] = $Res[1]\n"
}</font>
</pre>
<p>Вывод хэша одной строкой.
</p>
<p>
можно воспользоваться функцией <font color="Green">map</font>:

<font color="Green">print map {"$_ =&gt; $hash{$_}\n"} keys %hash;</font>

</p>
<p align="justify">функция map позволяет работать с элементами в
произвольном порядке, в этом случае создается список строк(ключ =&gt;

значение), передаваемый функции <font color="Green">print</font>. Если
сохранить хэш во временном массиве, то он будет выведен как строка:</p>
<div>
<pre>
<font color="Green">
{
my @temp = %hash;
print "@temp";
}
</font>
</pre>
</div>
также можно вывести хэш и таким образом:

<font color="Green">print "@{[%hash]}\n";</font>

<p align="justify">в двух последних случаях мы интерполируем хэш как
список, что не позволяет предсказать или управлять порядком вывода пар
"ключ/значение". Данные в последних двух случаях выводятся в виде
списка ключей и значений, элементы которого разделяются текущим
содержимым переменной <font color="Green">$"</font>, т.е. не удастся
вывести каждую пару значений на новой строке или отделить ключи от
значений каким-либо символом. Приведем программу, которая читает файл
почтового ящика и выводит количество сообщений от каждого отправителя,
отправитель определяется по строке From(цель программы только
проиллюстрировать операции с хешами):</p>
<div>
<pre>
<font color="Green">
#!/usr/bin/perl -w
$file = $ARGV[0] || "-";
open(FILE, "&lt;$file") or die "$!";
while(&lt;FILE&gt;){
	if(/^From: (.*)/) { $from{$1}++ }
}
foreach $people(sort keys %from){
print "$people: $from{$people}\n";

}


</font>
</pre>
</div>
Запускаем программу чтения почтового ящика: bash-2.03$ ./1.pl
/usr/home/vovka/mbox



Для того, чтобы подсчитать число ключей хеша, можно воспользоваться функцией
<font color="green">scalar</font>:
<pre>
<font color="Green">
    $num_keys = scalar keys %hash;
</font>
</pre>
<p align="justify">Инвертирование хэша производится при помощи функции <font
color="Green">reverse</font>,
в котором ассоциированные значения исходного хэша являются ключами и
наоборот. Воспользуемся списковой эквивалентностью хэшей. В списковом
контексте <font color="Green">reverse</font> иетерпретирует <font
color="Green">%hash</font> как список и меняет местами составляющие его
элементов. Например: имеем хэш <font color="Green">%Glavfish =
("seledka"=&gt;"mokraia","skat"=&gt;"elektricheskij")</font>, если его
интерпретировать как список, то получим следующее <font
color="Green">("seledka","mokraia","skat","elektricheskij")</font>, после
инвертирования список выглядит так: <font
color="Green">("elektricheskij","skat","mokraia","seledka")</font>,
интерпретация его как хэша дает следующее: <font
color="Green">("elektricheskij"=&gt;"skat","mokraia"=&gt;"seledka")</font>. 

</p>
<h4>
<a name="hash_html_vstt">Вывод хеша в порядке вставки с использованием
Tie::IxHash</a>
</h4>
<p align="justify">Для перебора элементов хэша в порядке вставки, т.к. <font
color="Green">keys</font> и <font color="Green">each</font> выводят элементы
хеша неупорядоченно, можно воспользоваться модулем(либо операциями с
массивами) <font color="Green">Tie::IxHash</font>
</p>
<div>
<pre>
<font color="Green">
use Tie::IxHash
tie %hash, "Tie::IxHash";
#операции с %hash
@keys = keys %hash;
</font>
</pre>
</div>
<p align="justify">Модуль <font color="Green">Tie::IxHash</font> заставляет
функции <font color="Green">keys</font>, <font color="Green">each</font> и
<font color="Green">values</font> возвращать элементы в порядке занесения их
в хэш. Если у Вас нет такого модуля IxHash.pm то нужно зайти на <a
href="http://www.perl.com/CPAN-local/modules/index.html">CPAN/modules</a>,
найти его и установить, если у вас нет прав на установку библиотек, то в
первой строчке скрипта нужно написать <font color="Green">#!/put'/do/perl'a
-wT -I/put'/do/nugnogo/modulia</font> и установить модуль в Вышей домашней
директории. Пример использования <font color="Green">Tie::IxHash</font>:</p>

<div>
<pre>
<font color="Green">
use Tie::IxHash

tie %hash, "Tie::IxHash";
%hash = (
	'шляпа' =&gt; 'серая',
	'водка' =&gt; 'горькая',
	'вобла' =&gt; 'вкусная');

print "В упорядоченной вставке список хеша такой:\n";
foreach $qwerty (keys %hash){
	print " $qwerty\n";
}

print "Кроме того, предметы обладают некоторыми свойствами:\n";
while(($predmet, $opredelenie) = each %hash){
print $predmet $opredelenie,"\n";
}
</font>
</pre>
</div>
см. тех документацию по модулю <font color="Green">Tie::IxHash</font>. 
<p align="justify">


</p>
<h4>
<a name="hash_html_vst">Вывод хеша в порядке вставки без использования
Tie::IxHash</a>
</h4>
<p align="justify">

Без модуля <font color="green">Tie::IxHash</font> вывод хеша в порядке
вставки можно сделать при помощи дописывания числовой информации в хеш. Есть
файл <font color="green">news.dat</font>,
который выводится скриптом в таком порядке, в каком данные занесены в
файл. Необходимо удалить одновременно больше одной строчки из текста(не
важно строка это, или разделитесь, это однозначно определяется
переменной <font color="green">$/</font>). 

</p>
<pre>
<font color="green">#!/usr/bin/perl -wT
use CGI 'param';
@del=param;
sub del{
  pop @del; $mass=~s!"|&amp;(.*?);!!g;
  open F, "&lt;news.dat" or die "Err: $!"; @mass=&lt;F&gt;; close F;
  open F, "&gt;news.dat";
  foreach $un(@mass){ $as=$un; $i++; chomp $as; 
    $un=~s|(.*)new&gt;(.*?)&lt;/a&gt;(.*)\[(.*?)\]|$2$4|i;
    $un=~s!"|&amp;(.*?);!!g; chomp $un;
	$u{"$un"}="$as#$i#\n";
  }
  foreach $del(@del){
    $del=~s!"|&amp;(.*?);!!g; chomp $del;
    $terr="Link $u{$del} was deleted&lt;p&gt;\n" if (exists $u{"$del"}); 
    $terr=~s!\d{8}|#(.*?)#!!ig;
    print $terr; $terr="";
    delete $u{$del} if (exists $u{"$del"});
  }{ local $_;
  while (($km, $_) = each %u){ push @tmp, "$u{$km}"}
  }

  @temp=grep{s/#(\d+?)#//}
        map{ $_ -&gt; [1]}
        sort{$a-&gt;[0] &lt;=&gt; $b-&gt;[0]}
        map{[/#(\d+?)#/, $_]} 
        grep{!$_{$_}++} @tmp;
  print F reverse @temp;
  close F;
}

</font>
</pre>
<p align="justify">
Разъясним принцип работы скрипта. Исходная задача такова: на входе есть
несколько <font color="green">checkbox</font> из формы, в которых может быть
поставлено больше одной галочки. Требуется найти и вычеркнуть отмеченные
строчки. Файл <font color="green">news.dat</font> модержит строки вида:

<font color="green">12345678&lt;a
href="lalalal"&gt;tra-ta-ta&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;[AAA]</font>

чекбокс отмечается текстом tra-ta-ta, т.е. что-то вида

</p>
<pre>
<font color="green">  for ($i=$pos; $i&lt;$pos+$n; $i++) { 
    $res[$i]=~s|^(\d\d\d\d)(\d\d)(\d\d)|$3\.$2\.$1 |;
    print qq~&lt;tr&gt;&lt;td&gt;$res[$i]&lt;/td&gt;&lt;td&gt;
	&lt;input type=checkbox name="$1$3"
value="$1$3"&gt;&lt;/td&gt;&lt;/tr&gt;~
            if($res[$i]=~m!&gt;(.*?)&lt;/a&gt;(.*?)\[(.*?)\]!);
  }

</font>
</pre>
<p align="justify">
т.е. <font color="green">name="$1$3" value="$1$3" =&gt;
name=tra-ta-ta&amp;value=tra-ta-ta</font>.
Идея заключается в том, что  элементы хеша можно пронумеровать в
исходном порядке вставки, который будет исходным в силу того, что хеш
определяется foreach, который последовательно читает данные из массива.
поэтому говорим <font color="green">$i++</font>; в цикле, ставим цифру в
разделителе <font color="green">#\d+#</font> и получаем на выходе хеш:

</p>
<pre>
<font color="green">  foreach $un(@mass){ $as=$un; $i++; chomp $as; 
    $un=~s|(.*)new&gt;(.*?)&lt;/a&gt;(.*)\[(.*?)\]|$2$4|i;
    $un=~s!"|&amp;(.*?);!!g; chomp $un;
    $u{"$un"}="$as#$i#\n";
  }</font>
</pre>

Дальше начинаем в хеше искать данные, которые передались через <font
color="green">@del=param;</font>

<pre>
<font color="green">  foreach $del(@del){
    $del=~s!"|&amp;(.*?);!!g; chomp $del;
    $terr="Link $u{$del} was deleted&lt;p&gt;\n" if (exists $u{"$del"}); 
    $terr=~s!\d{8}|#(.*?)#!!ig;
    print $terr; $terr="";
    delete $u{$del} if (exists $u{"$del"});
  }</font>
</pre>
<p align="justify">
при помощи функции <font color="green">exists</font> проводится проверка на
наличие элемента в хеше. Итак, получили хеш с ключами, являющимися
подстроками строк из файла <font color="green">news.dat</font>, и значениями
самих строк, т.е. в памяти точно лежит файл, превосходящий по размеру <font
color="green">news.dat</font> чуть меньше чем в два раза.
Далее идет вытаскивание значений из файла, уже без удаленных(было сравнение
по подстроке):


</p>
<pre>
<font color="green">  { local $_;
  while (($km, $_) = each %u){ push @tmp, "$u{$km}"}
  }
</font>
</pre>
<p align="justify">
Замечательно, проверили, занесли в массив <font color="green">@tmp</font>.
Здесь локализация <font color="green">local $_;</font> применена для того,
чтобы убрать при использовании ключа <font color="green">-w</font> лишнего
warning из серверного лог-файла ошибок. Вытащили новый массив, который нужно
соранить в файл <font color="green">news.dat</font>. Теперь нужно убрать из
массива @tmp повторяющиеся элементы, отсортировать по номерам <font
color="green">#(\d+)#</font>, убрать эти номера из элементов массива <font
color="green">@tmp</font> и сохранить массив в прежнем виде:


</p>
<pre>
<font color="green">  @temp=grep{s/#(\d+?)#//}
        map{ $_ -&gt; [1]}
        sort{$a-&gt;[0] &lt;=&gt; $b-&gt;[0]}
        map{[/#(\d+?)#/, $_]} 
        grep{!$_{$_}++} @tmp;
  print F reverse @temp;</font>
</pre>
<p align="justify">
операция <font color="green">grep{!$_{$_}++}</font> удаляет из массива
повторяющиеся элементы,  <font color="green">map{[/#(\d+?)#/, $_]}</font>
создает временный список анонимных массивов, которые затем сортируются <font
color="green">sort{$a-&gt;[0] &lt;=&gt; $b-&gt;[0]}</font>, затем <font
color="green">map{ $_ -&gt; [1]}</font> приводит элементы массива в
удобоваримый вид и <font color="green">grep{s/#(\d+?)#//}</font> вырезает
нуумерацию массива, оставшуюся от начального формирования хеша <font
color="green">%u</font>.
Далее оборачиваем конечный массив  <font color="green">@temp</font> функцией
<font color="green">reverse</font> и получам такой-же файл news.dat, только
без элементов, отмеченных пользователем в чекбоксе.


</p>
<p align="justify">Еще один вывод хеша в порядке вставки без
использования приспособленных
для этого модулей:

</p>
<pre>
<font color="green">
my @qq = qw(a s d f g h j y f d e e t y u i v f s a e);
my @del = qw(f h u);
my (%to, %del, %exist);
map {$del{$_} = 1} @del;
for (my $i=$#qq; $i&gt;=0; $i--){
  if (!exists $exist{$qq[$i]}){
    $exist{$qq[$i]} = 1;
    $to{$i} = $qq[$i] unless(exists $del{$qq[$i]});
  }
}
my @tmp;
foreach (sort{$a&lt;=&gt;$b} keys %to){
  push @tmp, $to{$_};
  print "$to{$_}\n";
}
</font>
</pre>
автор: Monax from <a href="http://www.rt.mipt.ru/board"
target="_new">http://www.rt.mipt.ru/board</a>
<h3>
<a name="hash_html_sort">сортировки</a>
</h3>
Сортировка хэша:
<div>
<pre>
<font color="Green">
%hash = (
	'шляпа' =&gt; 'серая',
	'водка' =&gt; 'горькая',
	'вобла' =&gt; 'вкусная');

foreach $key(sort keys %hash){
	print "$key =&gt; $hash{$key}\n"; #отсортирует в алфавитном порядке
по значениям ключа
}

foreach $value(sort values %hash){
	print "$value\n"; #сортировка по значению
}

</font>
</pre>
</div>
Сортировка ключей по алфавиту ассоциированных значений:
<div>
<pre>
<font color="Green">
foreach $key(sort {$hash{$a} cmp $hash{$b}} keys %hash){
        print $key, " =&gt; ", $hash{$key},"\n";
}</font>
</pre>
</div>
Сортировка по длинне ассоциированных значений:
<div>
<pre>
<font color="Green">
@massive = sort{length($hash{$a}) &lt;=&gt; length($hash{$b})}
	keys %hash;
foreach $key(@massive){
	print $key, $hash{$key},"\n";
}
</font>
</pre>
</div>
Пример из <a
href="http://www.talk.ru/article.html?ID=4642888&amp;hilite=hash">fido7.ru.perl</a>:

<pre> &gt;&gt; Есть хеш массив (слово, частота), необходимо вывести в файл
пары
 &gt;&gt; (слово,частота) отсортированные по частоте. По ключю - просто, а
вот
 &gt;&gt; по значению затрудняюсь. Подскахите как проще сделать?
</pre>
<pre>
<font color="Green">
 my %hash=('for'=&gt;1000,'to'=&gt;1500,'in'=&gt;2000,'do'=&gt;500);
 foreach(sort {$hash{$a} &lt;=&gt; $hash{$b}} keys %hash) {
     print $_,'=',$hash{$_},"\n";
     }</font>
</pre>

Как можно хеш положить в строку? Например <a
href="http://deja.com/=dnc/getdoc.xp?AN=583891180">проблема</a>:<br>
<br>

tnc&gt; имеются логи http-gw. Плохость их<br>
tnc&gt; заключается в том, что на каждый запрос в логе появляется 4
строки,<br>
tnc&gt; совершенно не обязательно идущие подряд:<br>

<br>
<p align="justify">Создаешь хэш и держишь в нем те строчки, которые еще,
грубо говоря,
не закрыты, а как закроешь - удаляй. Конечно, некий заметный кусок
файла в памяти будет присутствовать, но не полностью же. 
</p>
Что-нибудь типа
<pre>
<font color="Green">
while(&lt;IN&gt;) {
  ($key, $no, $data) = parse($_); # расковыряли строчку
  $buf{$key}-&lt;[$no] = $data; # запихнули в хэш в виде массива
  next if $no &gt; 3; # нумеруем, ессно с нуля
  analyze($buf{$key}); # обработали
  delete $buf{key}; # удалили
}
</font>
</pre>

Слияние хешей выполняется как и слияние массивов:
<div>
<pre>
<font color="Green">
%hash1 = (
	'шляпа' =&gt; 'серая',
	'водка' =&gt; 'горькая',
	'вобла' =&gt; 'вкусная');
%hash2 = (
	'штаны' =&gt; 'широкие',
	'пиво' =&gt; 'темное',
	'игрушка' =&gt; 'любимая');
%allhash = (%hash1, %hash2);

</font>
</pre>
</div>
Чтобы сэкономить память, можно воспользоваться таким кодом:
<div>
<pre>
<font color="Green">
%hash=(); 
while (($key, $values) = each(%hash1)){
	$hash{$key} = $values;
	}
while (($key, $values) = each(%hash2)){
	$hash{$key} = $values;
	}
</font>
</pre>
</div>


Пример работы с хэшем и базой данных из <a
href="http://www.talk.ru/discussion.html?target=5728876&amp;tg=1">fido7.ru.perl</a>
(cм. ответ):
<pre>VS&gt;  Скажите, можно ли ввести в dbm-базу данных уже заполненный
значениями
VS&gt; хеш? Если да, то как?
</pre>
<pre>
<font color="Green">

 %hash1=("dfadf", "dfadfd");
 dbmopen (%hash, "hash", 0666);
 %hash=%hash1;
 dbmclose (%hash);</font>
</pre>
Как передать хэш в функцию? <a
href="http://www.talk.ru/discussion.html?target=5781212&amp;tg=1">fido7.ru.perl</a>
(см. всю дискуссию)<pre> &gt;  PK&gt; Вобщем то все передаеться, но
использовать его нельзяю
 &gt;  PK&gt; Hа <font color="Green">%_[0]</font> или <font
color="Green">$_[0]{??}</font> компилер ругаеться.<font color="Green">

 &gt; %a;
 &gt; &amp;f(\%a);
 &gt; sub f {
 &gt;     my $a = $($_[0]){'key'};
 &gt; }</font>
 &gt; кажется так, мог ошибится в написании. Смысл в передаче ссылки, а не
значения.
 </pre>
<pre>  Это можно сделать также:
 1. Неявной передачей ссылки (использование прототипов):
 <font color="Green">sub f(\%) {
   my $a=$_[0]-&gt;{'key'};
 }
 f(%a);</font>

 2. Передачей хэша как массива с четным числом
 элементов:
 <font color="Green">sub f {
     my $a={@_}-&gt;{'key'};
 }
 f(%a);</font>
</pre>
Пример использования хеша для транслитерации <a
href="http://www.talk.ru/discussion.html?target=8289806&amp;tg=1">fido7.ru.perl</a>:<pre>
RK&gt; Как сочнить такой <font color="Green">tr/../../</font> (и возможно
ли), чтобы
 RK&gt; "аб?я" -&gt; "abyoya"
 RK&gt; Т.е. транслитерацию сделать...</pre>

<p align="justify">самый простой и топорный вариант - сделать хеш 
с соответствиями типа я =&gt; ya сплитить строчки и заменять элементы 
полученного массива на нужные. что-то на подобие:</p>
<pre>
<font color="Green">
@letters = split //, $str;
for (@letters){$_ = $hash{$_}};
</font>
</pre>
<h3>
<a name="hash_html_subh">встроенные хеши</a>
</h3>
Переменные окружения, использующие встроенные хэши <font
color="Green">%SIG</font>, <font color="Green">%ENV</font>, <font
color="Green">%FORM{}</font>.

<p align="justify">
<font color="Green">%SIG</font> - хэш, в котором хранятся
обработчики различных 
ситуаций, возникающих в perl. Например строка <font color="Green">local
$SIG{__WARN__} = sub{};</font> отключает предупреждающие сообщения.</p>

<p align="justify">
<font color="Green">%ENV</font> содержит значения
переменных среды(окружения), заданных на момент запуска сценария(скрипта).
 Ключами обычно бывают имена переменных среды(но их состав зависит от
операционной системы), изменение этих значений 
 вызовет изменение окружения для процессов потомков.</p>
<pre>
<font
color="Green">
<p>
</p>

#!/usr/bin/perl/ -w
while (($key, $value) = each(%ENV)){
print "$key =&gt; $value\n";
}</font>
</pre>
программа выдает:
<pre>
<font color="Green">
SERVER_SOFTWARE =&gt; Apache/1.3.11 (FreeBSD) mod_perl/1.21 PHP/3.0.14 
GATEWAY_INTERFACE =&gt; CGI/1.1 
DOCUMENT_ROOT =&gt; /usr/local/www/data 
UNIQUE_ID =&gt; OZaSFsHofQoAAEd@Cn8 
REMOTE_ADDR =&gt; 195.202.122.14 
SERVER_PROTOCOL =&gt; HTTP/1.0 
SERVER_SIGNATURE =&gt; Apache/1.3.11 Server at www.mojdodir.ru Port 80
REQUEST_METHOD =&gt; GET 
REMOTE_HOST =&gt; www.mojdodir.ru
QUERY_STRING =&gt; 

HTTP_USER_AGENT =&gt; Mozilla/4.73 [en] (Win98; I) 
PATH =&gt; /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin 
HTTP_ACCEPT =&gt; image/gif, image/x-xbitmap, image/jpeg, image/pjpeg,
image/png, */* 
HTTP_CONNECTION =&gt; keep-alive 
REMOTE_PORT =&gt; 3633 
SERVER_ADDR =&gt; 195.202.122.14 
HTTP_ACCEPT_LANGUAGE =&gt; en,ru 
HTTP_CACHE_CONTROL =&gt; max-age=259200 
SCRIPT_NAME =&gt; /cgi-bin/1.pl 
SCRIPT_FILENAME =&gt; /usr/local/www/cgi-bin/1.pl 
HTTP_ACCEPT_ENCODING =&gt; gzip 
SERVER_NAME =&gt; www.mojdodir.ru
HTTP_PRAGMA =&gt; no-cache 
REQUEST_URI =&gt; /cgi-bin/1.pl 
HTTP_ACCEPT_CHARSET =&gt; iso-8859-1,*,utf-8 
HTTP_X_FORWARDED_FOR =&gt; 15.0.0.23 
SERVER_PORT =&gt; 30 
HTTP_HOST =&gt; www.mojdodir.ru 
SERVER_ADMIN =&gt; webmaster@www.mojdodir.ru 
HTTP_VIA =&gt; 1.0 cache.www.mojdodir.ru:3363 (Squid/2.3.STABLE1) 

</font>
</pre>
<p align="justify">Непосредственно из скрипта элементы хэша <font
color="Green">%ENV</font> можно вызывать 
<font color="Green">$ENV{'HTTP_CACHE_CONTROL'}</font> или <font
color="Green">$ENV{'HTTP_USER_AGENT'}</font>, 
смотря что нужно вызывать.</p>
<font color="green">%FORM</font> содержит данные, вводимые из формы методом
<font color="green">POST</font>: html форма такая: <br>
<br>
<font
color="Green">

&lt;form action="/cgi-bin/1.pl" method="post"&gt;<br>
&lt;input type="text" name="name1" size=10 maxlength=10&gt;<br>
&lt;input type="text" name="name2" size=10 maxlength=10&gt;<br>
&lt;input type="text" name="name3" size=10 maxlength=10&gt;<br>
&lt;input type="submit" value="send"&gt;<br>
&lt;input type="reset" value="reset"&gt;&lt;/form&gt;<br>
<br>
</font>
Если мы введем в поле name1 qwe, name2 rty, name3 asd и нажмем send, то
через STDIN передаются данные в виде: 
name1=qwe&amp;name2=rty&amp;name3=asd и содержимое хэша<p>
</p> 

<pre>
<font color="Green">
%FORM( 
	name1 =&gt; qwe,
	name2 =&gt; rty,
	name3 =&gt; asd);</font>
</pre>
Значения полей name* можно получать <font
color="Green">$FORM{'name1'}</font>, <font
color="Green">$FORM{'name2'}</font> и т.д.<br>
<br>

<h3>
<a name="hash_html_slice">хэши slice</a>
</h3> (перевод, статья находится по адресу
<a
href="http://www.sysarch.com/perl/tutorials/hash_slices.txt">http://www.sysarch.com/perl/tutorials/hash_slices.txt</a>)
<br>
Насколько хорошим является этот код??
<pre>
<font color="Green">
@array = qw( a b c d ) ;
@array{ @array } = ( [ @array ] ) x @array ;
</font>
</pre>
Основное определение хэша slice: <font color="Green">@hash{ @array } = (
list )</font> что эквивалентно (<font color="Green"> $hash{ $array[0] }, ...
$hash{ $array[$#array]  } ) = ( list )</font> Префиксный символ (<font
color="Green">@</font> ,<font color="Green">%</font>)
используется только для обозначения контекста, но не типа данных. Если
имеются два массива и мы ходим сопоставлять их данные, то мы поступаем
так: <pre>
<font color="Green">

@foo_array = qw( abc def ghi ) ;
@bar_array = qw( jkl mno pqr ) ;
@foo_to_bar{ @foo_array } = @bar_array
</font>
</pre>
теперь можно работать с массивами немного проще:
<pre>
<font color="Green">
$foo_value = 'def' ;
$bar_value = $foo_to_bar{ $foo_value } ;
</font>
</pre>
Можно даже сразу преобразовывать целый массив переменных foo одной
конструкцией: <font color="Green">@bar_values = @foo_to_bar{ @foo_values
};</font>
Еще одно использование хэша slice, производится проверка: находится ли
строка в данном массиве строк? Фактически мы не заботимся о том, что
находится в хеше slice, но 1 используется для большей ясности. <pre>
<font
color="Green">
@foo_array = qw( abc def ghi ) ;
@is_a_foo{ @foo_array } = (1) x @foo_array ;
$input = 'def' ;
if ( $is_a_foo{ $input } ) {
        ...
if ( exists( $is_a_foo{ $input } ) ) {
        ...
</font>
</pre> Оператор x называется оператором повторения, он дублирует
левый операнд значением правого операнда. В скалярном контексте он
копирует левый оперант как строку и возвращает его, т.е. мы имеем
контекст списка и левый операнд списка. Это позволяет создать новый
список с N копиями предыдущего списка. Для foo N = 3 и (скалярное
значение @foo_array) и мы получаем список (1, 1, 1) который
присваивается хешу slice. Программа, преобразующая строки в
нумерованные индексные значения. Используется оператор диапазона (..),
создающий список целых чисел, которые присваиваются хэшу slise: <pre>
<font
color="Green">
@foo_array = qw( abc def ghi ) ;
@foo_to_index{ @foo_array } = ( 0 .. $#foo_array ) ;
@foo_to_index{ @foo_array } = ( 1 .. @foo_array ) ;
$i_am_a_foo = 'def' ;
$foo_index = $foo_to_index{ $i_am_a_foo } ;
</font>
</pre> Названия %foo_to_bar, %is_a_foo, $foo_to_index подобраны
так, чтобы нагляднее показать принцип работы slise. Фактически была
проведена индексация входных данных и выходных данных в хеш splice.
Теперь рассмотрим хэш splice снова <font color="Green">@array{ @array } = (
[ @array ] ) x @array ;</font>.
Заметим, что хэш и массив(и скаляр) называются массивами, но это
различные переменные, в частности отличные по разделитеям. Левая часть
выражения - присваивание хэшу slice, но что-же стоит справа? Оператор x
и @array справа дублирует повторения счетчика и некоторый лист слева и
мы имеем контекстный список. Хеш slice есть список контекстов, мы
создаем скопированный список анонимного массива, который содержит
значения в @array. Это значит что хэш %array напоминает такой массив:
<pre>
<font color="Green">

%array = (
        'a' =&gt; [ 'a', 'b', 'c', 'd' ],  
        'b' =&gt; [ 'a', 'b', 'c', 'd' ],  
        'c' =&gt; [ 'a', 'b', 'c', 'd' ],  
        'd' =&gt; [ 'a', 'b', 'c', 'd' ],  
) ;
</font>
</pre> Если имеется набор псевдонимов(alias), то можно, обращаясь
к списку, вывести каждый из них в отдельности(ср. alias для сокращения
часто употребляемой команды в unix). Т.е. вводится любой из отдельных
элементов и мы получаем список данных. Если имеется список массивов, то
их можно обработать таким образом: <pre>
<font color="Green">
@foo_list = qw( a b c d );
@bar_list = qw( j k l m n o );
@baz_list = qw( w x );

@expand_aliases{ @foo_list } = ( [ @foo_list ] ) x @foo_list;
@expand_aliases{ @bar_list } = ( [ @bar_list ] ) x @bar_list;
@expand_aliases{ @baz_list } = ( [ @baz_list ] ) x @baz_list;
</font>
</pre>
Если есть лексемма неопределенного типа, то можно получить список
псевдонимов за 1 шаг <font color="Green">@aliases = @{ $expand_aliases{
$alias } } ;</font> Окружение @{} используется, чтобы разыменовать
сохраненный анонимный список в список для присвоения @aliases.


<p>

есть хэш, типа<font color="green">
<pre>$myhash{name}=qwert;
$myhash{age}=15;</pre>
</font>
как сделать автоматическое создание переменной=ключу хэша со значением
из этого хэша с этим же ключом, т.е. <font color="green">$name=qwert;
$age=15</font> и т.д.
</p>
<p>
либо так: 
<font color="green">
<pre>my %myhash;
$myhash{name}='qwert';
$myhash{age}=15;
for $abc (keys %myhash)
  {
    $$abc=$myhash{$abc};
  }
print "\$name=$name; \$age=$age\n и т.д.";
</pre>
</font>
либо так:
<font color="green">
<pre>$$_ = $myhash{$_} for keys %myhash;
</pre>
</font>
что в принципе одно и то-же...
from: <a
href="http://www.talk.ru/discussion.html?target=15537041&amp;page=1"
target="_new">fido7.ru.perl</a>

</p>
<p>
Объявление анонимного хеша:</p>
<p align="justify"> Ссылки на
существующие данные часто применяются для передачи аргументов функции,
но в динамическом программировании они бывают неудобны. Для любой
переменной есть два параметра, е? имя и адрес области памяти, где
хранится эта переменная. Скалярная величина, хранящая адрес области
памяти, назвается ссылкой. Значение,  хранящееся в памяти по данному
адресу называется субъектом(referent). <br>
Анонимные хеши в perl могут создаваться явно. При этом выделяется память для
хеша и возвращается ссылка на не?. 
<font color="green">
<pre>  $hash{map{$_ =&gt; $_*$_}(0 .. 4)}
  while(($k, $v) = each %$hash){
    print "$k =&gt; $v\n";
  }
  print $hash-&gt;{"3"}, "\n";
</pre>
</font>
</p>
<p align="justify">
в цикле использовалась ссылка <font color="green">$hash</font> на анонимный
хеш.
Обратиться к нужному элементу хеша можно и при помощи ассоциативного
оператора стрелка <font color="green">-&gt;</font>:

<font color="green">print $hash-&gt;{"3"}, "\n";</font>
Пример использования анонимного хеша для выкидывания повторяющихся элементов
из массива:
</p>
<pre>
<font color="green">keys %{{ map { $_, 1 } @array }} # @array -&gt;
anonymous hash -&gt; keys</font>
</pre>
Источник: <a href="http://www.simplex.ru/news/win/">Преф-Ньюс</a>

<h3>
<a name="hash_html_hhash">хеши хешей</a>
</h3>
<p align="justify">

Хеши, составленные из других хэшей, полезны при работе с текстовой
многоуровневой 
информационной системой (например, экспертной системой). В этих случаях 
текстовые ключи используются для последовательного просмотра различных 
уровней структуры данных. В следующем примере такой хэш создается за раз:
<font color="green">
<pre>%hash = (
      fruits =&gt; {
                favorite =&gt; "apples",
       'second favorite' =&gt; "oranges"
      },
  vegetables =&gt; {
                favorite =&gt; "corn",
       'second favorite' =&gt; "peas",
         'last favorite' =&gt; "turnip"
      },
        meat =&gt; {
                favorite =&gt; "chiken",
       'second favorite' =&gt; "beef"
      }

);
print $hahs{fruits}{favorite};

</pre>
</font>
</p>
<p align="justify">
Обратите внимание, что в таком хэше значениями для пар ключ/значение 
высупают другие хэши(точнее, ссылки на них). 
Кроме того, для конструкций типа <font color="green">{...}{...}</font>, 
между парами фигурных скобок неявно подставляется оператор-стрелка
<font color="green">-&gt;</font> - разыменования ссылок,
</p>
<p>
Создание хэша хэшей на лету:
</p>
<p align="justify">
Чтобы создать хэш хэшей элемент за элементом, используется та же схема, что
и 
в случае массива массивов, но с одним существенным отличием ? к хэшу всегда 
можно добавить новые ключ и значение, но добавление к массиву новых
элементов 
с пропусками индексов порождает неопределенные значения. Пример:
<font color="green">
<pre>%hash{fruits} = {favorite =&gt; "apples", 
        'second favorite' =&gt; "oranges"};

%hash{vegetables} = {favorite =&gt; "corn", 
            'second favorite' =&gt; "peas", 
             'least favorite' =&gt; "turnip"};

%hash{meat} = {favorite =&gt; "chicken", 
      'second favorite' =&gt; "beef"};

print $hash{fruits}{favorite};

</pre>
</font>
</p>
<p align="justify">
В следующей схеме генератор анонимного хэша комбинируется со списком
ключ/значение, 
возвращаемым внешней подпрограммой:
<font color="green">
<pre>for $key ("hash1", "hash2", "hash3") 
   { $hash{$key} = {$returnlist}; }

sub returnlist{

return (key1 =&gt; valuel, key2 =&gt; value2);
}

print $hash{hash1}{key2};
</pre>
</font>
</p>
<p>
Доступ к элеметнам хеша хешей
</p>
<p align="justify">
Чтобы получить отдельное значение, хранящееся в хэше хэшей, надо явно
указать набор 
последовательных ключей:
<font color="green">
<pre>%hash = (
     fruits =&gt; {favorite =&gt; "apples", 
       'second favorite' =&gt; "oranges"},

 vegetables =&gt; {favorite =&gt; "corn", 
       "second favorite' =&gt; "peas", 
        "least favorite' =&gt; "turnip"} 
);

print $hash{fruits}{"second favorite'};

</pre>
</font>
</p>
<p align="justify">
Используя стандартные приемы работы с обычными хэшами, можно 
организовать цикл по элементам хэша хэшей: 
<font color="green">
<pre>%hash = (
     fruits =&gt; {favorite =&gt; "apples", 
       'second favorite' =&gt; "oranges"},

 vegetables =&gt; {favorite =&gt; "corn", 
       "second favorite' =&gt; "peas"} 
);

for $food (keys %hash) { 
  print "$food:\n\t {"; 
  for $key (keys %{$hash{$food}}) {
    print "'$key1' =&gt; \"$hash{$food}{$key}\",";
  }
  print "}\n";
} 

</pre>
</font>
</p>
<p align="justify">
Чтобы сортировать записи хэш-таблицы по ключам, в заголовок цикла можно 
включить операцию сортировки:  
<font color="green">
<pre>%hash = (
      fruits =&gt; {favorite =&gt; "apples", 
                   second =&gt; "oranges"}, 
  vegetables =&gt; {favorite =&gt; "corn", 
                   second =&gt; "peas"}
);

for $food (keys %hash) { 
  print "$food:\n\t {"; 
  for $key (keys %{$hash{$food}}) {
    print "'$key1' =&gt; \"$hash{$food}{$key}\",";
  }
  print "}\n";
} 

</pre>
</font>
</p>
<p>
</p>
<h3>
<a name="hash_html_massh">массивы хэшей</a>
</h3>
<p align="justify">
Массивы хэш-таблиц позволяют индексировать числовым значением записи с 
именованными полями. В следующем примере создается массив хэшей:
<font color="green">
<pre>@array = (
    {
           favorite =&gt; "apples",
  'second favorite' =&gt; "оranges"
    },
    {
           favorite =&gt; "corn",
  'second favorite' =&gt; "peas",
    'last favorite' =&gt; "turnip"
    },
    {
           favorite =&gt; "chiken",
  'second favorite' =&gt; "beef"
    }    
print $array[0]{favorite};

</pre>
</font>
</p>
<p align="justify">
Обратите внимание, что для конструкций вида <font
color="green">[...]{...}</font>, 
как и для рассматриваемых ранее конструкций 
вида <font color="green">{...}{...}</font> и 
<font color="green">[???][[???]</font>, между парами скобок неявно 
подставляется оператор-стрелка <font color="green">-&gt;</font>
разыменования ссылок.

</p>
<p>
Создание массива хэшей ?на лету?
</p>
<p align="justify">
Можно создавать массивы хэшей шаг за шагом, присваивая 
ссылки на анонимные хэши элементам массива:

<font color="green">
<pre>@аггау[0] = {favorite =&gt; "apples",
    'second favorite' =&gt; "oranges"};

@array[1] = {favorite =&gt; "corn",
    'second favorite' =&gt; "peas", 
     'least favorite' =&gt; "turnip"};

@array[2] = {favorite =&gt; "chicken",
    'second favorite' =&gt; "beef"};

print $array[0]{favorite};
</pre>
</font>
</p>
<p align="justify">
Как и в случае массива массивов, вы можете воспользоваться функцией <font
color="green">push</font>:

<font color="green">
<pre>push @array, {favorite =&gt; "apples",
     'second favorite' =&gt; "oranges"};

push @array, {favorite =&gt; "corn",
     'second favorite' =&gt; "peas",
      'least favorite' =&gt; "turnip"};

push @array, {favorite =&gt; "chicken",
     'second favorite' =&gt; "beef"};

print $array[0]{favorite};
</pre>
</font>
</p>
<p align="justify">
В следующем примере мы последовательно читаем из текстовых строк пары 
ключ/значение и превращаем их в массив хэшей:

<font color="green">
<pre>$data[0] = "favorite:apples, second
favorite:оranges";
$data[1] = "favorite:corn, second favorite:peas, least favorite:turnip";
$data[2] = "favorite:chicken, second favorite:beef";
for $loopindex (O..$#data) {
  for $element(split ',', $data[$loopindex]){
    ($key, $value) = split ':', $element;
    $key=~s/^[\s\n]+//; #очистить от пробелов
    $key=~s/[\s\n]+$//;
    $value =~s/^[\s\n]+//;  #очистить от пробелов
    $value =~s/[\s\n]+$//;
    $array[$loopindex]{$key} = $value;
  }
}
print $array[0]{'second favorite'};
</pre>
</font>
</p>
<p align="justify">
Обратите внимание, что мы здесь воспользовались контекстно-чувствительной
процедурой автооживления ссылок (autovivification)
</p>
<p>
Доступ к элементам массива хэшей
</p>
<p align="justify">
Чтобы получить значение, хранимое; в массиве хэшей, надо указать индекс 
массива и ключ хэша:
<font color="green">
<pre>$array[0] = {favorite =&gt; "apples",
    'second favorite' =&gt; "oranges"};

$array[1] = {favorite =&gt; "corn",
    'second favorite' =&gt; "peas",
     'least favorite' =&gt; "turnip"};

$array[2] = {favorite =&gt; "chicken",
    'second favorite' =&gt; "beef"};

print $array[0]{favorite};

</pre>
</font>
</p>
<p align="justify">
В следующем случае мы полностью выводим массив хэшей с помощью цикла по
его элементам:
<font color="green">
<pre>$array[0] = {favorite =&gt; "apples",
               second =&gt; "oranges"};

$array[1] = {favorite =&gt; "corn",
               second =&gt; "peas",
                least =&gt; "turnip"};

$array[2] = {favorite =&gt; "chicken",
               second =&gt; "beef"};

for $loopindex (0..$#array) {
  print "array[$loopindex]:\n\t{";
  fоr $key (keys %{$array[$loopindex]})
    { 
      print "$key =&gt; $array[$loopindex]{$key},"; 
    }
  print "}\n";

</pre>
</font>
</p>
<p align="justify">
A вот как сделать то же самое, используя вместо индекса цикла ссылку:
<font color="green">
<pre>$array[0] = {favorite =&gt; "apples",
               second =&gt; "oranges"};

$array[1] = {favorite =&gt; "corn",
               second =&gt; "peas",
                least =&gt; "turnip"};

$array[2] = {favorite =&gt; "chicken",
               second =&gt; "beef"};

for $hashreference(@array) {
  print "{";
  for $key (sort keys %$hashreference) {
    print "$key =&gt; $array[$loopindex]{$key}, ";
  }
print ,"}\n";
}

</pre>
</font>
</p>
<p>

</p>
<h3>
<a name="hash_html_harr">хэши массивов</a>
</h3>
<p align="justify">
Хэши, состоящие из массивов, позволяют разбивать данные, индексированные 
числовым значением, на записи. В следующем примере мы объявляем хэш массивов
в одном предложении:
<font color="green">
<pre>%hasn = (
     fruits =&gt; ["apples", "oranges"], 
 vegetables =&gt; ["corn", "peas", "turnips"], 
       meat =&gt; ["chicken", "ham"],
);
print $hash{fruits}[0];
</pre>
</font>
</p>
<p align="justify">
Обратите внимание, что для конструкций вида <font
color="green">[...]{...}</font>, 
как и для рассматриваемых ранее конструкций 
вида <font color="green">{...}{...}</font> и 

<font color="green">[???][[???]</font>, между парами скобок неявно 
подставляется оператор-стрелка <font color="green">-&gt;</font>
разыменования ссылок.

</p>
<p>
Создание хэша массивов ?на лету?
</p>
<p align="justify">
Чтобы собрать хэш массивов из отдельных элементов, можно заносить в хэш под
нужным 
ключом ссылки на массивы, созданные генератором анонимных массивов:
<font color="green">
<pre>%hash{fruits} = ["apples", "oranges"];
%hash{vegetables} = ["corn", "peas", "turnips"];
%hash{meat} = ["chicken", "ham"];
print $hash{fruits}[0];
</pre>
</font>
</p>
<p align="justify">
Если вы предпочитаете другой вариант, можете воспользоваться функцией push 
и контекстно-чувствительной процедурой автооживления ссылок
(autovivification).
<font color="green">
</font>
</p>
<pre>
<font color="green">push
@{%hash{fruits}}, "apples", "oranges";
push @{%hash{vegetables}}, "corn", "peas", "turnips";
push @{%hash{meat}}, "chicken", "ham";
</font>
</pre>
<p>
Доступ к элементам хэша массивов
</p>
<p align="justify">

Вы всегда можете получить доступ к отдельному элементу данных, хранимому в
хэше массивов, указав ключ и индекс:
<font color="green">
<pre>%hasn = (
     fruits =&gt; ["apples", "oranges"], 
 vegetables =&gt; ["corn", "peas", "turnips"], 
       meat =&gt; ["chicken", "ham"],
);
print $hash{fruits}[0];
</pre>
</font>
</p>
<p align="justify">
В следующем примере мы полностью выводим отсортированный по значениям 
ключа хэш массивов, используя функцию 
<font color="green">join</font> для преобразования массивов в текстовые
строки: 
<font color="green">
<pre>%hasn = (
     fruits =&gt; ["apples", "oranges"], 
 vegetables =&gt; ["corn", "peas", "turnips"], 
       meat =&gt; ["chicken", "ham"],
);

for $key(sort keys %hash){
  print "$key\t[", join(", ", @{$hash{$key}}), "]\n";
}

</pre>
</font>

</p>
<h4>
<a name="hash_html_hharr">Хэш хешей массивов</a>
</h4>

<p align="justify">Допустим в информации есть двойная степень вложенности,
т.е. допустим 20 строк <font color="green">air</font> и в этих 20 строках
есть подкатегории по номерам, т.е. 20 строк состоят из трехподгрупп <font
color="green">air,mumbra</font>, <font color="green">air,kukumbra</font> и
<font color="green">air,telepuzikoff(on)</font>:

</p>
<pre>
<font color="green">

air,Acmar,one
air,Acmar,two
air,Airwell,one
air,Airwell,two
air,Ariston,one
air,Ariston,two
air,Ariston,three
air,Ariston,four
air,Mumbra,one
air,Mumbra,two
fridg,Ardor,one
fridg,Ardor,two
fridg,Ardor,three
fridg,Ardo-Young,one
fridg,Ardo-Young,two
fridg,Ardo-Young,three
wei,Tefal,one
wei,Tefal,two
wei,Tefal,three
</font>
</pre>

<p align="justify">Структурировать такую информацию можно при помощи гибрида
хеша хешей и хеша массивов, т.е. хеша хешей массивов:

</p>
<pre>
<font color="green">#!/usr/bin/perl
  
open F, "&lt;example" or die "can open: $!\n"; @mass=&lt;F&gt;; close F;

for $gr(grep{!$_{$_}++} map{/^(.*?),/} @mass){
  for $line(@mass){push @{$hash{$gr}{$1}}, $2 if $line=~m!^$gr,(.*?),(.*)!}
}

print "name hash\tkeys\t\tmassives\n\n";
for $a(sort keys %hash){
  print "hash $a: \n\t{\n\t";
  for $key(sort keys %{$hash{$a}}){
    print "'$key' \t =&gt; [ ";
    print join " | " =&gt; @{$hash{$a}{$key}};
    print " ]\n\t";
  }
  print "}\n";
}
</font>
</pre>

на выходе такая программа выдаст:

<pre>
<font color="green">name hash	keys		massives

hash air: 
	{
	'Acmar' 	 =&gt; [ one | two ]
	'Airwell'	 =&gt; [ one | two ]
	'Ariston'	 =&gt; [ one | two | three | four ]
	'Mumbra'	 =&gt; [ one | two ]
	}
hash fridg: 
	{
	'Ardo-Young'     =&gt; [ one | two | three ]
	'Ardor' 	 =&gt; [ one | two | three ]
	}
hash wei: 
	{
	'Tefal' 	 =&gt; [ one | two | three ]
	}

</font>
</pre>
 
Доступ к определенному элементу массива можно получить, указывая явно набор
ключей <font color="green">${$hash{$a}{$key}}[$n]</font>, где <font
color="green">$n &lt; $#{$hash{$a}{$key}}</font>
<h3>
<a name="hash_html_ex">Примеры</a>
</h3>
<p align="justify">
</p>
<h4>
<a name="hash_html_007">Шпионская программа</a>
</h4>
Допустим в Пентагоне нужно ввести авторизованный доступ к данным по
определенным правилам:
<p align="justify">
есть полный файл(<font color="green">data.crypt</font>) всех записей
вида(расшифрованный)


</p>
<pre>
<font color="green">London#явка1#доступ#прочее#логин1
Damask#явка2#доступ#прочее#логин2
Peru#явка3#доступ#прочее#логин3</font>
</pre>

И есть файл скажем для агента <font color="green">agent007.crypt</font>, в
котором описан вид доступа только 
к определенным данным:

<pre>
<font color="green">логин1
логин3</font>
</pre>

т.е. из файла <font color="green">data.crypt</font> нужно выбрать совпадения
строк с подстроками файла <font color="green">agent007.crypt</font> и
выбрать из <font color="green">data.crypt</font> все параметры
спецзадания(-ий). Результат нужно вывести в виде:


<pre>
<font color="green">&lt;A NAME=\"a\"&gt;
aasd
abf
Absc
afgh
&lt;A NAME=\"b\"&gt;
bcd
bgh
bfe
и т.д.
</font>
</pre> т.е. в отсортированном виде. Шпионы тоже люди. Скрипт
ниже решает данную задачу при помощи операций с массивами и
использованием хеша массивов(хотя наверное можно было сделать и проще,
здесь же главное показать использование хеша массивов): <pre>
<font
color="green">#!/usr/bin/perl -wT #ключ -T означает повышенную безопасность,
Пентагон все-таки
use strict;
my(@data, @new, $line, $m, @res, @sort, $k, %ha);
my($autor, $pesniya, $position, $u, $n, $im);
open F, "&lt;data.crypt" or die "Err: $!"; @data=&lt;F&gt;; close F;
open F, "&lt;agent007.crypt" or die "Err: $!" @data=&lt;F&gt;; close F;
foreach $line(@new){
  foreach $m (@data){push @res, "$m" if($m=~m/^(.*)#$line$/)}
}
  @sort=map{$_ -&gt; [1]}
        sort{$a-&gt;[0] cmp $b-&gt;[0]}
        map{[/^(.*)#/, $_]}
        grep{!$_{$_}++} @res;  
foreach $u('a' .. 'z'){
  foreach $n(@sort){push @{$ha{$u}}, $n if($n=~m/^$u/)}
}
for $k(sort keys %ha){print "&lt;a href=\"#$k\"&gt;$k&lt;/a&gt; "}
print "\n&lt;p&gt;&lt;center&gt;\n";
for $k(sort keys %ha){
  print "&lt;a name=\"$k\"&gt; &lt;/a&gt;&lt;br&gt;\n";
  foreach $im(@{$ha{$k}}){
    ($autor, $pesniya, $position)=split /#/, $im;
    print "$autor, $pesniya, $position&lt;br&gt;\n";
  }
}
print "&lt;/center&gt;";

</font>
</pre>
Разберем работу программы:

<pre>
<font color="green">foreach $line(@new){
  foreach $m (@data){push @res, "$m" if($m=~m/^(.*)#$line$/)}
}</font>
</pre>
<p align="justify">
Отсеять из файла <font color="green">data.crypt </font>разрешенные данные
для <font color="green">agent007.crypt</font> при помощи сравнения подстрок.

</p>
<pre>
<font color="green">@sort=map{$_ -&gt; [1]}
        sort{$a-&gt;[0] cmp $b-&gt;[0]}
        map{[/^(.*)#/, $_]}
        grep{!$_{$_}++} @res;  </font>
</pre>

<p align="justify">
Отсортировать данные для данного агента в алфавитном порядке по первой
ячейке из общей таблицы <font color="green">data.crypt</font> и убрать
повторения одинаковых строк.

</p>
<pre>
<font color="green">foreach $u('a' .. 'z'){
  foreach $n(@sort){push @{$ha{$u}}, $n if($n=~m/^$u/)}
}
</font>
</pre>
Создавть хеш массивов, где ключем будет буква, а значением будет массив из
строк спецзаданий.

<pre>
<font color="green">for $k(sort keys %ha){print "&lt;a
href=\"#$k\"&gt;$k&lt;/a&gt; "}</font>
</pre>

Вывести линейку начальных букв, по которым будут сортироваться результаты.


<pre>
<font color="green">for $k(sort keys %ha){
  print "&lt;a name=\"$k\"&gt; &lt;/a&gt;&lt;br&gt;\n";
  foreach $im(@{$ha{$k}}){
    ($autor, $pesniya, $position)=split /#/, $im;
    print "$autor, $pesniya, $position&lt;br&gt;\n";
  }
}</font>
</pre>
<p align="justify">
Вывести массивы, ассоциированные со значениями ключей букв. <font
color="green">@{$ha{$k}}</font> - просто обычный массив, доступ к которому
зависит от значения ключа <font color="green">$k</font>. Каждый элемент
массива стостоит из строки с разделителями <font color="green">#</font>, по
нему и разделяет функция <font color="green">split ($autor, $pesniya,
$position)=split /#/, $im;</font>

</p>
<h4>
<a name="hash_html_journal">Программа вывода номеров журнала</a>
</h4>
<p align="justify"> 	 Еще один пример использования хеша массивов для
вывода содержания журнала за несколько лет календарем.  Есть директория
с файлами  содержания журнала по номерам вида: <font
color="green">
<pre>1.1996.txt
2.1996.txt
3.1996.txt
4.1996.txt
5.1996.txt
...
и т.д. до 
5.2001.txt
</pre>
</font>
</p>
<p align="justify">
где первая цифра в названии файла это содержание журнала за данный месяц, а
вторая это год. 
Читаем эту директорию в массив и вызываем подпрограмму:
<font color="green">
<pre>while(&lt;$dir/journal/*.txt&gt;){push(@files, $_)}
&amp;calendar;

sub calendar{
  print qq~&lt;center&gt;&lt;font&gt;&lt;b&gt;Содержание 
         по номерам&lt;/b&gt;&lt;/font&gt;&lt;p&gt;&lt;/center&gt;~;
  @year1=grep{!$test{$_}++ if(/^(\d+)$/)} #выделяет число лет, за которые
есть номера журнала
                                          #и заодно удаляет одинаковыен
года, т.к. 
                                          #на каждый год приходится не
больше 12 
                                          #файлов: 1.1996, 2.1996, 3.1996...
         map{/\.(\d+)/, $_} @files; #выделяет года и заносит их во временный
массив
  foreach $line(@year1){ #цикл по годам.
    foreach $files(@files){
      push @{$numbers{$line}}, $files if($files=~m/$line/);
      #здесь производится заполнение хеша массивов ключами, 
      #которые являются годами, а значениями хешей буду являться
      #массивы номеров журнала за данный год, который является ключом.
      #т.е. в результате должно получиться что-то вида:
      #%hash = (
      #       1996 =&gt; ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
"11", "12"], 
      #       1997 =&gt; ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
"11", "12"], 
      #           ...
      #       2001 =&gt; ["1", "2", "3", "4", "5"] #до пятого номера потому,
что 
                                                #шестой номер на момент
написания этого
                                                #примера еще не вышел.
      #);
    }
  }
  print "&lt;center&gt;&lt;table&gt;";  #открываем табличку для вывода
результатов
  for $key (sort keys %numbers){#цикл по отсортированным в порядке
возрастания годам
    print "&lt;tr&gt;&lt;td&gt;&lt;font size=\"1\"&gt;&lt;b&gt;$key:
&lt;/b&gt;&lt;/font&gt;"; #печатаем год
    foreach $elem(@{$numbers{$key}}){ #вытаскиваем массив номеров журнала из
хеша, ключем
                                      #которому должен являться определенный
год
      if($elem=~m/\/(\d+).(\d+)\.txt/){$nj=$1; $yj=$2;
        if($nj eq $nomer &amp;&amp; $yj eq $year){#текущий номер для
просмотра выделяем красным:
          $temp1=qq~&lt;font size="1" color=red&gt;&lt;b&gt;$nj&lt;/a&gt;
&lt;/b&gt;&lt;/font&gt;\n~;
          push(@results123, $temp);
        }
        else{#остальные выделяем ссылкой
          $temp2=qq~&lt;font size="1"&gt;&lt;b&gt;&lt;a 
		            href="$url?month=$nj&amp;year=$yj"
class="menu"&gt;$nj&lt;/a&gt; 
                    &lt;/b&gt;&lt;/font&gt;\n~;
          push(@results123, $temp2)
        }
      }
    }
    #дальнейшая конструкция называется преобразованием Рэндела 
    #Шварца, смысл которой заключается
    #в том, чтобы отсортировать массив номеров журнала по возрастанию,
    #т.к. при извлечении из хеша они будут выстраиваться в порядке
    #1,11,12,2,3,4...
    @sort123= map{ $_ -&gt; [1]}
              sort{$a-&gt;[0] &lt;=&gt; $b-&gt;[0]}
              map{[/&gt;(\d+)&lt;\/a&gt;/, $_]} @results123;
    print @sort123; #печатаем табличку номеров журнала за 1995 год
    print "&lt;/td&gt;&lt;/tr&gt;";#закрываем строку таблички
    #обнуляем временные массивы
    $#results123=-1;
    $#sort123-1;
    #возвращаемся наверх и начинаем печатать строчку 
    #таблицы для следующих номеров следующего года.
  }
  print qq~&lt;/table&gt;&lt;/center&gt;~;
}

</pre>
</font>
Все вышеописанное выглядит в виде html примерно так:
</p>
<center>
<font>
<b>Содержание по
номерам</b>
</font>
<p>
</p>
</center>
<center>
<table>
<tbody>
<tr>
<td>
<font
size="1">
<b>1995: </b>
</font> <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=1&amp;year=1995"
class="menu">1</a> </b>
</font>
</td>
</tr>
<tr>
<td>
<font size="1">
<b>1996: </b>
</font> <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=1&amp;year=1996"
class="menu">1</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=2&amp;year=1996"
class="menu">2</a> </b>
</font>

 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=3&amp;year=1996"
class="menu">3</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=4&amp;year=1996"
class="menu">4</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=5&amp;year=1996"
class="menu">5</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=6&amp;year=1996"
class="menu">6</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=7&amp;year=1996"
class="menu">7</a> </b>
</font>

 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=8&amp;year=1996"
class="menu">8</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=9&amp;year=1996"
class="menu">9</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=10&amp;year=1996"
class="menu">10</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=11&amp;year=1996"
class="menu">11</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=12&amp;year=1996"
class="menu">12</a> </b>
</font>

</td>
</tr>
<tr>
<td>
<font size="1">
<b>1997: </b>
</font> <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=1&amp;year=1997"
class="menu">1</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=2&amp;year=1997"
class="menu">2</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=3&amp;year=1997"
class="menu">3</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=4&amp;year=1997"
class="menu">4</a> </b>
</font>

 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=5&amp;year=1997"
class="menu">5</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=6&amp;year=1997"
class="menu">6</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=7&amp;year=1997"
class="menu">7</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=8&amp;year=1997"
class="menu">8</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=9&amp;year=1997"
class="menu">9</a> </b>
</font>

 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=10&amp;year=1997"
class="menu">10</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=11&amp;year=1997"
class="menu">11</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=12&amp;year=1997"
class="menu">12</a> </b>
</font>
</td>
</tr>
<tr>
<td>
<font size="1">
<b>1998: </b>
</font> <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=1&amp;year=1998"
class="menu">1</a> </b>
</font>

 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=2&amp;year=1998"
class="menu">2</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=3&amp;year=1998"
class="menu">3</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=4&amp;year=1998"
class="menu">4</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=5&amp;year=1998"
class="menu">5</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=6&amp;year=1998"
class="menu">6</a> </b>
</font>

 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=7&amp;year=1998"
class="menu">7</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=8&amp;year=1998"
class="menu">8</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=9&amp;year=1998"
class="menu">9</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=10&amp;year=1998"
class="menu">10</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=11&amp;year=1998"
class="menu">11</a> </b>
</font>

 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=12&amp;year=1998"
class="menu">12</a> </b>
</font>
</td>
</tr>
<tr>
<td>
<font size="1">
<b>1999: </b>
</font> <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=1&amp;year=1999"
class="menu">1</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=2&amp;year=1999"
class="menu">2</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=3&amp;year=1999"
class="menu">3</a> </b>
</font>

 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=4&amp;year=1999"
class="menu">4</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=5&amp;year=1999"
class="menu">5</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=6&amp;year=1999"
class="menu">6</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=7&amp;year=1999"
class="menu">7</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=8&amp;year=1999"
class="menu">8</a> </b>
</font>

 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=9&amp;year=1999"
class="menu">9</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=10&amp;year=1999"
class="menu">10</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=11&amp;year=1999"
class="menu">11</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=12&amp;year=1999"
class="menu">12</a> </b>
</font>
</td>
</tr>
<tr>
<td>
<font size="1">
<b>2000: </b>
</font> <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=1&amp;year=2000"
class="menu">1</a> </b>
</font>

 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=2&amp;year=2000"
class="menu">2</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=3&amp;year=2000"
class="menu">3</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=4&amp;year=2000"
class="menu">4</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=5&amp;year=2000"
class="menu">5</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=6&amp;year=2000"
class="menu">6</a> </b>
</font>

 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=7&amp;year=2000"
class="menu">7</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=8&amp;year=2000"
class="menu">8</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=9&amp;year=2000"
class="menu">9</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=10&amp;year=2000"
class="menu">10</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=11&amp;year=2000"
class="menu">11</a> </b>
</font>

 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=12&amp;year=2000"
class="menu">12</a> </b>
</font>
</td>
</tr>
<tr>
<td>
<font size="1">
<b>2001: </b>
</font> <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=1&amp;year=2001"
class="menu">1</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=2&amp;year=2001"
class="menu">2</a> </b>
</font>
 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=3&amp;year=2001"
class="menu">3</a> </b>
</font>

 <font size="1">
<b>
<a
href="http://www.pereplet.ru/cgi/sej/rubr.cgi?month=4&amp;year=2001"
class="menu">4</a> </b>
</font>
 <font size="1" color="red">
<b>5 </b>
</font>
</td>
</tr>
</tbody>
</table>
</center>
<p>
</p>
<p>
</p>
<hr>

<a name="file_find_html"></a>
<a name=file_find_html_file_find>
<b>Стирание  символа перевода каретки</b>
</a>
<br>
Более сложная задача, убрать все неправильные символы перевода
каретки ^M, которые, допустим, появляются при передаче файлов far'ом на свой
сайт:

<p>

<font color=green>
<pre>

#!/usr/bin/perl -w
use strict;
use File::Find;

find( \&wanted, '/var/www/html/allsitecopy' );

sub wanted {
  return if /^\.\.?$/ and not /\.html?$/i and not -f;
     local $/;
     open F, "< $File::Find::name" or do {
         warn "Cannot read from $File::Find::name: $!";
         return;
         };
     binmode F;
     my $mass = &lt;F&gt;;
     close F;
     $mass =~ tr/\cM//d;
     open F, "> $File::Find::name" or do {
         warn "Cannot write to $File::Find::name: $!";
         return;
         };
     binmode F;
     print F $mass;
     close F;

     print "$File::Find::name all ok!\n";
}
</pre>
</font>

Не рекомендую запускать подобные программы, не разобравшись, правильно
ли оно закрывает открытые файлы. Это все конечно очень здорово, что это
можно
cделать, но все-таки голову на плечах нужно иметь, сначала попробовать 
на маленькой поддиректории, убедится, что все ок и только после этого
 что то делать программой с серьезными данными.
<p>
<a name=file_find_html_req>
<b>Подсчет определенных файлов во всех вложенных
директориях</b>
</a>
<br>
Пример использования модуля <font color=green>File::Find</font> для
рекурсивного(вход во все поддиректории) просмотра
или подсчета числа html или shtml или htm файлов(эти три вида файлов
определяеются реглярным выражением <font color=green>s?html?</font>):
<font color=green>
<pre>
#!/usr/bin/perl -w
use File::Find;
find \&wanted, '/var/www/html';
sub wanted {print $count++, "\t$File::Find::name all ok!\n" if /s?html?/i}
</pre>
</font>
Всего 4 строчки против в среднем 10-20... удобно,быстро, и, главное,
лениво.<p>
<hr>

<a name="find_html"></a>
<center>
<h4>
<a name=find_html_find>поиск по степени совпадений слов в предложениях</a>
</h4>
</center>
<p align=justify>
Задача, сделать поисковик чтобы сортировал результаты по релевантности,
или, что то-же самое, оценивал похожесть, степень одинаковости слов.
<p align=justify>
Эту задачу более менее реализует приведенный ниже скрипт:  
<font color=green>
<pre>
#!/usr/bin/perl -w
use locale;

%oo=("будет"=>1, "африка"=>1, "завтра"=>1);

$b="африка африка будет африка завтра";
$o="африка будет вчера зачем что-то";
$tw="африка небудет вчера будет завтра";
$tb="аляска аляска будет будет будет сегодня";

@m=($b, $o, $tb, $tw); rrand(\@m);
print join "\n", @m,"\n";

for $i(0 .. $#m){
  $h{$i}{$1}++ while $m[$i]=~m!((\w[\w-]*){4,30})!g;
  $vr{$i}=$m[$i];
}

for $r(keys %h){print "\n"; 
  my (@ee, $u, $trr);
  for $n(keys %{$h{$r}}){
    do{
      $t = join " " => $vr{$r};
      $u+=1;
      push @ee => $h{$r}{$n};
    } if exists $oo{$n};
  } 
  print "$t ",$u + $ee[0]-1,"\n";
}

sub rrand{
  my $m = shift; my $i;
  for($i=@$m; --$i;){
    my $j = int rand($i+1);
    net if $i==$j;
    @$m[$i,$j] = @$m[$j,$i]
  }
}
</pre>
</font>
<p align=justify>
есть какой-то текст в переменнах <font color=green>$b</font>,<font
color=green>$o</font>,<font color=green>$tw</font>,<font color=green>$tb</font>, загоняется все в массив. Для
отладки пишется подпрограмма <font color=green>rrand()</font>, которая переставляет случаным образом
элементы массива. Далее идет цикл, подсчитывающий частоты одинаковых слов в
переменных и заносящий эти частоты в хеш хешей. В хеше хешей 1(т.к.
нуумерация элементов массива была случаный образом изменена, то удобно
обращаться через номер массива) содержатся предположим для переменной $b такие данные:
<font color=green>
<pre>
     $b = "африка африка будет африка завтра";

     $h{1}=(
            "африка" => 3,
            "будет" => 1,
            "завтра" => 1
           ); 
</pre>
</font>
<p align=justify>
т.е. слово <font color=green>африка</font> по частоте употребления в три раза больше в файле, что
дает ему большие шансы вылезти в список перых результатов. Далее следуют
слова <font color=green>будет</font> и <font color=green>завтра</font>, которые так-же играют немаловажную роль в поднятии
ссылки наверх из результатов поискового запроса. Далее в цикле объявляется
хеш(задача была сделать, а не память сэкономить), который будет выводить
результаты запроса.
<p align=justify>
Далее идет цикл:
<font color=green>
<pre>
     for $r(keys %h){print "\n";
       my (@ee, $u, $trr);
       for $n(keys %{$h{$r}}){
         do{
           $t = join " " => $vr{$r};
           $u++;
           push @ee => $h{$r}{$n};
         } if exists $oo{$n};
       } 
       print "$t ",$u + $ee[0]-1,"\n";
     }
</pre>
</font>
<p align=justify>
запрашиваем численное название хеша в переменную <font color=green>$r</font>, считываем с её помощью
хеши хешей. Здесь функцией <font color=green>exists</font> реализован поиск общих ключей в двух
хешах: в хеше, поступающем на ввод, и текущем по шагу цикла хеше хешей.
Если информация содержится в начальном втором хеше <font
color=green>%vr</font>, то запрашиваем её
<font color=green>$vr{$r}</font>. Строчка <font color=green>$u++</font> отвечает за количество вхождений всех слов, заданных в
запросе, в искомую строку(файл). Допустим на входе фраза "<font color=green>будет африка
завтра</font>", если хотя бы одно слово из этой фразы совпало со словом в очередной
строке(ведь изначально строка была побита на частотный хеш) то локальная переменная
<font color=green>$u</font>
увеличит свое значение на единичку. Если два слова в строке и в запросе
одинаковы, то <font color=green>$u=2</font>, если три - <font color=green>$u=3</font> и так далее, слов в запросе может быть любое 
количество. Далее идет строчка 
<font color=green>
<pre>
     push @ee => $h{$r}{$n};
</pre>
</font>
<p align=justify>
которая заносит частоты слов(<font color=green>3,1,1</font> как было выше в примере) в текущей
строке. Дальше идет сама <font color=green>exists</font> и после неё разбираемся с весом
повторяющихся слов и весом полных совпадений. Т.е. должно быть так, чтобы 
полное совпадение фразы имело большее значение, нежели чем неполное
совпадение + пара повторов. Но функция федет себя по хитрому, допустим,
если нужно найти специализированную информацию типа "<font color=green>Хеш хешей хешей хешей
хешей массивов</font>", то вес повторений слов будет больше, т.е. вклад члена
<font color=green>$ee[0]-1</font>(разница в единицах на случай непреднамеренного повтора) больше, чем
<font color=green>$u</font>. В то-же
<hr>

<a name="hhharr_html"></a>
<h4>
<a name=hhharr_html_hashn>Хеш хешей хешей хешей массивов</a>
</h4>

<font color=green>
<pre>
#!/usr/bin/perl

foreach $lett(qw(meat beer)){
  foreach $num(qw(war peace)){
    foreach $tes(qw(one two)){
      foreach $users(qw(bred pitt)){
        @{$hhh{$lett}{$num}{$tes}{$users}}=qw(beer vodka);
      }
    }
  }
}
print "hash\tsubhash\t  subsubhash\tmassives\n";
for $let(sort keys %hhh) {
  print "hash $let: (\n";
  for $nums (sort keys %{$hhh{$let}}) {
    print "\tsubhash $nums (\n\t";
    for $ltr(sort keys %{$hhh{$let}{$nums}}){
      print "\tsubsubhash $ltr (\n\t";
      for $aa(sort keys %{$hhh{$let}{$nums}{$ltr}}){
        print "\t\t'$aa'  => [ ";
        print join " | " => @{$hhh{$let}{$nums}{$ltr}{$aa}};
        print " ]\n\t";
      }
      print ")\n\t";
    }
    print "    \t)\n";
  }
  print ")\n";
}

** Joe's Own Editor v2.8l ** Copyright (C) 1995 Joseph H. Allen **
File hhhsh.pl not changed so no update needed.
bash-2.05$ ./hhhsh.pl | less
hash    subhash   subsubhash    massives
hash beer: (
        subhash peace (
                subsubhash one (
                        'bred'  => [ beer | vodka ]
                        'pitt'  => [ beer | vodka ]
        )
                subsubhash two (
                        'bred'  => [ beer | vodka ]
                        'pitt'  => [ beer | vodka ]
        )
                )
        subhash war (
                subsubhash one (
                        'bred'  => [ beer | vodka ]
                        'pitt'  => [ beer | vodka ]
        )
                subsubhash two (
                        'bred'  => [ beer | vodka ]
                        'pitt'  => [ beer | vodka ]
        )
                )
)
hash meat: (
        subhash peace (
                subsubhash one (
                        'bred'  => [ beer | vodka ]
                        'pitt'  => [ beer | vodka ]
        )
                subsubhash two (
                        'bred'  => [ beer | vodka ]
                        'pitt'  => [ beer | vodka ]
        )
                )
        subhash war (
                subsubhash one (
                        'bred'  => [ beer | vodka ]
                        'pitt'  => [ beer | vodka ]
        )
                subsubhash two (
                        'bred'  => [ beer | vodka ]
                        'pitt'  => [ beer | vodka ]
        )
                )
)
bash-2.05$
</pre>
</font>

<p align=justify>
Хеши можно строить любой степени вложенности просто прибавляя лишний цикл и лишнюю пару фигурных скобок в 
<font color=green>$hhh{$lett}{$num}{$tes}{$users}</font>, т.е. 
<font color=green>$hhh{$lett}{$num}{$tes}{$users}{$dream}</font> уже будет хешем хешей хешей хешей хешей т.д.
<p align=justify>
А в конце, используя оператор 
<font color=green>@{а тут хеш хешей хешей хешей хешей ... n+1 ...}=qw(blah blah blah)</font> можно
приспособить <font color=green>хеш<sup>n</sup>
</font> массивов. Итого это будет выглядеть так:
<p align=justify>
<font color=green>@{$hhh{$lett}{$num}{$tes}{$users}}=qw(beer vodka);</font>
<p align=justify>
Соответственно дает быстрый доступ к катологизированной информации.
<p align=justify>
<hr>

<a name="hh_html"></a>
<font color=green>
<pre>

        use Tie::IxHash;
        tie(%myhash, Tie::IxHash);
        for ($i=0; $i<20; $i++) {
            $myhash{$i} = 2*$i;
        }
        @keys = keys %myhash;
        # @keys = (0,1,2,3,...)

</pre>
</font>

from <a href="http://www.perl.com/perl/faq/">Daily Perl FAQ</a>
<hr>

<a name="lwp_html"></a>
<br>
<br>

 LWP FAQ by Paul Kulchenko (paulclinger@yahoo.com), updated 03/04/2000<br>
<br>

 ====================================================================<br>
<br>

<ol>
	<li> How to get text file (http, ftp)?</li>
	<li> How to get jpeg/gif/bmp file and return it?</li>
	<li> How to access password protected file?</li>
	<li> How to set up REFERER and other HTTP header parameters?</li>
	<li> How to get specified part of file (first MAXSIZE bytes)?</li>
	<li> How to get and set up cookies?</li>
	<li> How to specify proxy servers?</li>
	<li> How to check for redirect?</li>
	<li> How to create parameters for POST method?</li>
	<li> How to upload file?</li>
	<li> How to access secure site (https://)</li>
	<li> How to get information about remote file?</li>
	<li> How to do "redirect" that works with both GET and POST?
       (Is it the same as "forward" does in Java?)</li>
</ol>
 ====================================================================
<br>
 1. Как получить текстовый файл, используя http или ftp?
 
<pre>
<font color="Green"> use LWP::UserAgent;
 use CGI qw(header -no_debug);

 my $URL = 'http://www.yahoo.com/';
 my $res = LWP::UserAgent->new->request(new HTTP::Request GET => $URL);
 print header, $res->is_success ? $res->content : $res->status_line;</font>
</pre>

 ====================================================================<br>
<br>

 2. Как скачать себе из сети файл jpeg/gif/bmp<br>
<br>
 
<pre>
<font color="Green">
 use LWP::UserAgent;
 use CGI qw(header -no_debug);
 $URL =
 'http://a100.g.akamaitech.net/7/100/70/0001/www.fool.com/art/new/butts/go99.
 gif';
 my $res = LWP::UserAgent->new->request(new HTTP::Request GET => $URL);
 binmode(STDOUT);
 print $res->is_success ? (header('image/gif'), $res->content)
                        : (header('text/html'), $res->status_line);</font>
</pre>

 ====================================================================<br>
<br>

 1.3. How to access password protected file?
<pre>
<font color="Green">
 BEGIN {
   package RequestAgent;
   use LWP::UserAgent;
   @ISA = qw(LWP::UserAgent);

   sub new { LWP::UserAgent::new(@_); }
   sub get_basic_credentials { return 'user', 'password' }
 }
 use CGI qw(header -no_debug);

 my $res = RequestAgent->new->request(new HTTP::Request GET => $URL);
 print header, $res->is_success ? $res->content : $res->status_line;</font>
</pre>

 ====================================================================<br>
<br>

 1.4. How to set up REFERER and other HTTP header parameters?
<pre>
<font color="Green">
 use LWP::UserAgent;
 use HTTP::Headers;
 use CGI qw(header -no_debug);

 my $URL = 'http://localhost/cgi-bin/hello.cgi';
 my $res = LWP::UserAgent->new->request(
   new HTTP::Request(
     GET => $URL,
     new HTTP::Headers referer => 'http://www.yahoo.com'),
 );
 print header, $res->is_success ? $res->content : $res->status_line;</font>
</pre>

 ====================================================================<br>
<br>

 1.5. How to get specified part of file (first MAXSIZE bytes)?
<pre>
<font color="Green">
 use LWP::UserAgent;
 use CGI qw(header -no_debug);

 my $URL = 'http://www.yahoo.com/';
 my $MAXSIZE = 1024;

 print header;
 my $res = LWP::UserAgent->new->request(
   new HTTP::Request(GET => $URL), \&callback, $MAXSIZE);

 sub callback { my($data, $response, $protocol) = @_; print $data; die }</font>
</pre>

 ====================================================================<br>
<br>

 1.6. How to get and set up cookies?
<pre>
<font color="Green">

 use LWP::UserAgent;
 use CGI qw(header -no_debug);
 use HTTP::Cookies;

 my $URL = 'http://mail.yahoo.com/';

 my $ua = new LWP::UserAgent;
 my $res = $ua->request(new HTTP::Request GET => $URL);
 my $cookie_jar = new HTTP::Cookies;
 $cookie_jar->extract_cookies($res);

 print header;
 if ($res->is_success) {
   my $req = new HTTP::Request GET => $URL;
   $cookie_jar->add_cookie_header($req);
   $res = $ua->request($req);
   print $res->is_success ? $res->as_string : $res->status_line;
 } else {
   print $res->status_line;
 }
</font>
</pre>
 ====================================================================<br>
<br>

 1.7. How to specify proxy servers?
<pre>
<font color="Green">
 use LWP::UserAgent;
 use CGI qw(header -no_debug);

 my $URL = 'http://www.yahoo.com/';
 my $ua = new LWP::UserAgent;

 $ua->proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/');
 $ua->proxy('gopher', 'http://proxy.sn.no:8001/');

 my $res = $ua->request(new HTTP::Request GET => $URL);
 print header, $res->is_success ? $res->content : $res->status_line;
</font>
</pre>
 ====================================================================<br>
<br>

 1.8. How to check for redirect?
<pre>
<font color="Green">
 use LWP::UserAgent;
 use CGI qw(header -no_debug);

 my $URL = 'http://www.yahoo.com/';
 my $res = LWP::UserAgent->new->request(new HTTP::Request GET => $URL);

 print header;
 print $res->request->url if $res->previous->is_redirect;
</font>
</pre>
 ====================================================================<br>
<br>

 1.9. How to create parameters for POST method?
<pre>
<font color="Green">
 use URI::URL;
 use HTTP::Request;
 use LWP::UserAgent;
 use CGI qw(header -no_debug);

 my $URL = 'http://yahoo.com/?login=mylogin&password=mypassword';
 my $uri = new URI $URL;
 my $method = 'POST';

 my $request;
 if (uc($method) eq 'POST') {
   my $query = $uri->query;
   (my $url = $uri->as_string) =~ s/\?$query$//;
   $request = new HTTP::Request ($method, $url);
   $request->header('Content-Type' => 'application/x-www-form-urlencoded');
   $request->content($query);
 } else {
   $request = new HTTP::Request ($method, $uri->as_string);
 };

 # add Host field as required in HTTP/1.1
 $request->header(Host => $uri->host_port) if $uri->scheme ne 'file';

 my $res = LWP::UserAgent->new->request($request);

 print header, $res->is_success ? $res->content : $res->status_line;
</font>
</pre>
 ====================================================================<br>
<br>

 1.10. How to upload file?
<pre>
<font color="Green">
 use HTTP::Request::Common;
 use LWP::UserAgent;
 use CGI qw(header -no_debug);

 my $URL = 'http://localhost/cgi-bin/survey.cgi';
 my $req = POST $URL,
   Content_Type => 'form-data',
   Content      => 

     name       => 'Paul Kulchenko',
     email      => 'paulclinger@yahoo.com',
     surveyfile => ['./survey.dat'], # this file will be uploaded
   ];

 my $res = LWP::UserAgent->new->request($req);

 print header, $res->is_success ? $res->content : $res->status_line;
</font>
</pre>
 ====================================================================<br>
<br>
 1.11. How to access secure site (https://)
 <pre>
<font color="Green">
#!/usr/bin/perl -w
$test = "http://www.test.ru/account/secure.html";
use HTTP::Request::Common;
use LWP::UserAgent;
use CGI qw(header -no_debug);
$ua = LWP::UserAgent->new();

my $req = POST $test,
                [
        user => 'vovka',
    password => '123321',
                ];

$content = $ua->request($req)->as_string;
#print "content-type: text/html\n\n";
#print $content;
print $req->as_string;
</font>
</pre>
 ====================================================================<br>
<br>
 
 1.12. How to get information about remote file?
 <pre>
<font color="Green">
 use LWP::UserAgent;
 use CGI qw(header -no_debug);

 my $url = 'http://yahoo.com/';
 my $res = LWP::UserAgent->new->request(HTTP::Request->new(HEAD => $url));

 print header;

 local $\ = "\n";
 if ($res->is_success) {
   $res->previous &&
   $res->previous->is_redirect and print 'redirected: ', $res->request->url;
   $res->last_modified         and print 'modified: ',
 scalar(localtime($res->last_modified));
   $res->content_length        and print 'size: ', $res->content_length;
 } else {
   print $res->status_line;
 }
</font>
</pre>
 ====================================================================<br>
<br>

 1.13. How to do "redirect" that works with both GET and POST?
       (Is it the same as "forward" does in Java?)
 <pre>
<font color="Green">
 use LWP::UserAgent;
 use CGI qw(header -no_debug);

 my $URL = 'http://www.yahoo.com/';
 my $MAXSIZE = 1024;

 local $| = 'non buffered';

 print header;
 my $res = LWP::UserAgent->new->request(
   new HTTP::Request(GET => $URL),
   sub { my($data, $response, $protocol) = @_; print $data }, # <= callback
   $MAXSIZE,
 );
</font>
</pre>
<hr>

<a name="lpt_html"></a>
<h4>Низкоуровневое программирование параллельных портов под *nix</h4>
<p>
На языке с запрограммировать lpt порт можно например так(примеры более или
менее продвинутых программ внизу текста по ссылкам):

<font color=green>
<pre>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;asm/io.h&gt;

#define base 0x278
#define time 100000

int main(){
  int x = 0x32;
  printf("идет импульс в парралельный порт !\n");
  if (ioperm(base,3,1))
  printf("Couldn't get port at %x\n", base), exit(1);
  if (ioperm(base, 3, 1)) {perror("ioperm"); exit(1);}
  while(1){
    outb(x, base);
    usleep(time);
    outb(0, base);
    usleep(time);
  }
}
exit(0);
</pre>
</font>

<p>Использованы две функции, <font color=green>ioperm</font> и
<font color=green>outb</font>. Первая устанавливает права на  
работу с портами ввода/вывода. Вторая пишет в порт, в основном она
предназначена для использования в ядре. Функция <font color=green>
inb</font> соответственно читает из порта.  
<p>
читая <font color=green>man ioperm</font>:<br>
<font color=green>Libc5</font> рассматривает <font color=green>ioperm</font>
как системный вызов, и поэтому в
<font color=green>unistd.h</font> есть ее прототип. В <font
color=green>Glibc1</font> этого прототипа нет.
В <font color=green>Glibc2</font>, в <font color=green>sys/io.h</font> и в
<font
color=green>sys/perm.h</font> этот прототип есть.
Второй вариант существует только в <font color=green>i386</font>.
<p>
<font color=green>lpt</font> порт - это несколько регистров, в которые можно писать командой 
скажем <font color=green>outb()</font>. <font color=green>278</font> 
порт это порт данных, если писать <font color=green>0x5</font>(двоичное <font
color=green>00000101</font> то <font color=green>2,5</font> вольта будут, в 
соответствии с единицами в двоичном числе, на 2-м  
и 4-м контактах). Если же писать через <font color=green>/dev/lp</font>, то получается
аналогично, но придется выставлять внешний сигнал <font
color=green>busy</font>. Этот
сигнал нужно выставлять или джампером на материнской плате, или 
в <font color=green>BIOS</font>, в зависимости от марки платы. когда включается порт на
материнской плате, то она устанавивает регистры на правильные порты
и прерывания,  затем, если сделать <font color=green>insmod linux</font>, то драйвер
прикрепляется на на соответствующие устройства и отвечает за
обмен по принтерному протоколу, т.е. правильно выставляет сигналы 
<font color=green>strobe init</font>. 
<br>(from некто john www.linux.org.ru)

<p>
Чтобы программировать порты на, скажем 
<a href="http://www.linuxgazette.com/issue49/pramode.html">python</a>,
можно воспользоваться <a href="http://www.swig.org/">Simplified Wrapper and Interface Generator - SWIG</a>.
<p>
Например программа пишущая в порт:
<font color=green>
<pre>
#include &lt;asm/io.h&gt;
int main(){
   iopl(3);
   outb(1, 0x378);
}
</pre>
</font>
Компилируем <font color=green>cc -O2 io.c</font>, помним, что использование только под суперюзером.
Что нужно сделать, чтобы написать то-же самое на <font
color=green>Python</font>? Воспользоваться
<font color=green>SWIG</font>, чтобы сделать возможным доступ из <font
color=green>Python</font> к <font
color=green>outb()</font>, <font
color=green>inb()</font> и <font
color=green>iopl()</font>.
Ниже пример io.c для SWIG:
<font color=green>
<pre>
#include &lt;asm/io.h&gt; 

int py_iopl(int level){
  return iopl(level);
}
void py_outb(unsigned char val, int port){
  outb(val, port);
}                                                
unsigned char py_inb(int port)
{
  return inb(port);
}                                
</pre>
</font>

Запускаем <font color=green>SWIG</font> и генерируем <font color=green>io.so</font>. Пример работы:
<font color=green>
<pre>
&gt;&gt;&gt;import io
&gt;&gt;&gt;io.py_iopl(3)
&gt;&gt;&gt;io.py_outb(10, 0x378)
&gt;&gt;&gt;io.py_inb(0x378)
10
&gt;&gt;&gt;
</pre>
</font>
<p>
Для того, чтобы включить код на языке <font color=green>с</font> в модуль <font color=green>perl</font>, читаем <font color=green>man perlxstut</font> или 
<p>
<a href="http://www.perldoc.com/perl5.6.1/pod/perlxstut.html#EXAMPLE-1"
target=_new>http://www.perldoc.com/perl5.6.1/pod/perlxstut.html#EXAMPLE-1</a>
<p>
именно первый пример!!!
<p>
создаем файл <font color=green>.xs</font> с таким кодом(т.е. оно его конечно
само создаст, но
то что оно создало, надо вытереть):
<font color=green>
<pre>
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;asm/io.h&gt;

#define base 0x278
#define time 100000

MODULE = port           PACKAGE = port          

int
main()
CODE:
  int x = 0x32;
  printf("Пошел импульс в паралельный порт !\n");
  if (ioperm(base,3,1))
    printf("Couldn't get port at %x\n", base), exit(1);
  if (ioperm(base, 3, 1)) {perror("ioperm"); exit(1);}
  while(1){
    outb(x, base); /*посылаем 00110010 в порт*/
    usleep(time);
    outb(0, base);
    usleep(time);
  }
exit(0);
</font>
</pre>
далее по инструкциям мана, затем 
<font color=green>
<pre>
[root@mobile100 port]# perl Makefile.PL; make; make test
Writing Makefile for port
gcc -c  -fno-strict-aliasing -I/usr/local/include -O2 -march=i386 -mcpu=i686
-DVERSION=\"0.01\" -DXS_VERSION=\"0.01\" -fPIC
-I/usr/lib/perl5/5.6.0/i386-linux/CORE  port.c
Running Mkbootstrap for port ()
chmod 644 port.bs
LD_RUN_PATH="" gcc -o blib/arch/auto/port/port.so  -shared -L/usr/local/lib
port.o     
chmod 755 blib/arch/auto/port/port.so
cp port.bs blib/arch/auto/port/port.bs
chmod 644 blib/arch/auto/port/port.bs
Manifying blib/man3/port.3pm
PERL_DL_NONLAZY=1 /usr/bin/perl -Iblib/arch -Iblib/lib
-I/usr/lib/perl5/5.6.0/i386-linux -I/usr/lib/perl5/5.6.0 test.pl
1..1
ok 1
[root@mobile100 port]# 
</pre>
</font>
<p>
и пишется скрипт:
<font color=green>
<pre>
#!/usr/bin/perl
use ExtUtils::testlib;
use Mytest;
Mytest::main();

File u.pl not changed so no update needed.
[root@mobile100 port]# ./u.pl
Пошел импульс в паралельный порт !

[root@mobile100 port]#
</font>
</pre>
период задается <font color=green>#define time 100000</font> - т.е. по 
программе выходит 5 герц
частота, а так 1/10 секунды = 100000. Соответственно от вида байта со 2-го
по 9-й пин(каждый пин это  один бит, допустим 0x32 это 00110010, т.е. 2-й
пин ноль, третий единица, четвертый и пятый нули, 6,7 - 1 и 8 и 9 нули) возникает разность потенциалов в
2,5 вольт, как показал осциллограф С1-74. Нуумерация пинов есть прямо на
принтерном порту.
<p>
Cобственно почему такой суррогат и не выложил готовый модуль<font
color=green>*.tar.gz</font>, не
разобрался с межпроцессорным взаимодействием между сишными и перловыми
программами(имхо, только через <font color=green>IPC</font> это сделать
грамотно и можно, но
это долго). Потому представляю вам, если более знакомы с
межпроцессорным взаимодействием через <font color=green>pipe</font> или
семафоры самим написать
данный код, перловая же часть более менее
понятна. 
<p>
По крайней мере на перле заняться низкоуровневым программированием
паралельных портов вполне себе даже можно.
<p>
Конфигурация машины(хотя это врядли важно, сишные библиотеки
стандартные):
<font color=green>
<pre>
p266, ASUS.

[root@mobile100 perl]# uname --all 
Linux mobile100 2.2.19-3.asp #1 Fri Apr 6 14:49:33 MSD 2001 i686
unknown
[root@mobile100 perl]# 
</font>
</pre>
Иксы соответственно стоят, воркстейшн. ASPLinux7.1
девелоперский. Еще, важно, нужно ОБЯЗАТЕЛЬНО заземлить корпуса
осциллографа и компьютера(правда я не заземлял, но оно в темноте
малость искрило). Иначе может сгореть компьютер. И не подключать к
этим контактам маленькие лампочки на 3,5 вольта, т.к. у неё вроде 
потребляемая мощность 
чего-то около полуватта, и не факт что <font color=green>lpt</font> порт
выдержит такую мощность. Вобщем
сигнал использовать только как сигнальный(на базу транзистора или на
вход иного усилителя). Ну вобщем кому надо тот поймет. Иначе можно
запросто пожечь материнскую плату или принтерный порт.
<p>
где про это все прочитать можно:
<ol>
<li> <a href="http://www.opennet.ru/docs/RUS/Lpg/lpg.txt.html"
target=_new>http://www.opennet.ru/docs/RUS/Lpg/lpg.txt.html</a> про пайпы и
семафоры и пр. что как-раз не вышло.
<li>
<a
href="http://www.linux.org.ru/books/HOWTO/Printing-HOWTO-3.html#ss3.1"
target=_new>http://www.linux.org.ru/books/HOWTO/Printing-HOWTO-3.html#ss3.1</a> 

там есть одна вещь, в биос компьютера должен быть включен <font color=green>parallel
port
*78/IRQ7</font>, ну, вобщем чтобы не было там <font
color=green>disabled</font>, 
иначе тогда когда говоришь <font color=green>modprobe lp</font> то в <font
color=green>/proc/devices</font> не
добавляется <font color=green>lp</font>, т.е. без драйвера обратиться к
параллельному порту не
получится.

<li>
<a href="http://www.thailinux.com/2001/01/21/topic4.html"
target=_new>http://www.thailinux.com/2001/01/21/topic4.html</a> - немного
программок, из латинского текста все ясно

<li>
<a
href="http://www.opennet.ru/docs/HOWTO-RU/mini/IO-Port-Programming.html"
target=_new>http://www.opennet.ru/docs/HOWTO-RU/mini/IO-Port-Programming.html</a>
ну детальнейшее описание просто(про perl ни слова)...
<li>
<a href=http://termin.narod.ru/p/parallel_port.htm>Описание
парралельного порта</a>
</ol>

<p>
В принципе можно обойтись без написания драйвера, оторвав от терминала и запустив скрипт
демоном.<p>
<p>
<hr>

<a name="mason_html"></a>
<center>
<h4>Mason - онлайновый парсер статических файлов на perl</h4>
</center>
<p>
Программа, позволяющая полностью управлять статическим и, если того
захотеть, динамическим наполнением сайта. Или писать вызовы обращений к базе
данных прямо в тексте html-страницы.  
<p>
Cool links about Mason from <a
href="http://www.lerner.co.il/atf/archive.html">http://www.lerner.co.il/atf/archive.html</a>:<p>
<font color=red>[all in english]</font>
<br>
<a href="http://www.linuxjournal.com/article.php?sid=4168">Content Management with Mason</a> <br>
<a href="http://www.linuxjournal.com/article.php?sid=4143">Session management with Mason</a>
<br>
<a href="http://www.linuxjournal.com/article.php?sid=4066">Press releases with Mason</a>
<br>
<a href="http://www.linuxjournal.com/article.php?sid=4002">Building sites with Mason</a>
<br>
from <a href="http://www.linuxjournal.com">http://www.linuxjournal.com</a>
<p>
Для её запуска необходимы <font color=green>Apache</font> и <font color=green>mod_perl</font>.
<p>
В <font color=green>httpd.conf</font> нужно дописать то, о чем написано в
<font color=green>man HTML::Mason</font>. После этого Ваш сайт(вне
зависимости от его размера) ну, если не становится ручным пони, то уж точно
чем нибудь типа уральского тяжеловоза. Все описания и другие оставшиеся
слова можно прочитать на сайте <a href="http://www.masonhq.com/"
target=_new>http://www.masonhq.com/</a>. Сначала <a
href="http://search.cpan.org/search?dist=HTML-Mason">HTML-Mason</a>, потом
<a href="http://search.cpan.org/search?dist=mod_perl">mod_perl</a>, далее
некоторая возня с service httpd restart на предмет httpd.conf .  
Example:

<font color=green>
<pre>
   &lt;HTML&gt;
   &lt;HEAD&gt;
   &lt;TITLE&gt;Yo! Wazzup!!!!
   % my $noun = 'World';
   % my $date = qx[date];
   Hello &lt;% $noun %&gt;!
   Today is &lt;% $date %&gt;
   % my $ua = $r-&gt;header_in('User-Agent');
   % if ($ua =~ /msie/i) {
     Welcome, Internet Explorer users
   ...
   % } elsif ($ua =~ /mozilla/i) {
     Welcome, Netscape users
   ...
   % }
   &lt;/TITLE&gt;&lt;/HEAD&gt;
   &lt;BODY BGCOLOR="#FFFFFF"&gt;
   &lt;H1&gt;Yo! Wazzup!!!!&lt;/H1&gt;
   &lt;& index.file &&gt;
   &lt;/BODY&gt;
   &lt;/HTML&gt;
</pre>
</font>

строчка, в которой содержится сам код, должна начинаться с символа <font
color=green>%</font>:<font color=green>% my $noun = 'World';</font> 
Если не хочется кадый раз ставить символ процента, то код можно поставить в
между тегами 
<font color=green>
<pre>
&lt;%perl&gt; 
... to do...
&lt;/%perl&gt;
</pre>
</font>
Аналогично директивам SSI из html странички можно вызывать и файлы(в том
числе и текстовые, например если создается библиотека).
<font color=green>
<pre>
&lt;& index.html &&gt;
</pre>
</font>
Можно так-же делать включения скриптов вида
<font color=green>
<pre>
%# &lt;& /include/all_newsheads.msn &&gt;
</pre>
</font>
Хотя так-же спокойно можно включать скрипты командой <font
color=green>qx[lalalala]</font>
<p>
<p>

Например обращение к базе данных на серверной стороне:
<font color=green>
<pre>
    &lt;html&gt;
      &lt;head&gt;&lt;title&gt;&lt;% $headline %&gt;&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
      &lt;h2&gt;&lt;% $headline %&gt;&lt;/h2&gt;
      By &lt;% $author %&gt;, &lt;% $date %&gt;&lt;p&gt;
      
      &lt;% $body %&gt;
      
      &lt;/body&gt;&lt;/html&gt;

      &lt;%init&gt;
      # Fetch article from database
      my $dbh = DBI::connect ...;
      my $sth = $dbh-&gt;prepare("select * from articles where id = ?");
      $sth-&gt;execute($article_id);
      my ($headline,$date,$author,$body) = $sth-&gt;fetchrow_array;
      # Massage the fields
      $headline = uc($headline);
      my ($year,$month,$day) = split('-',$date);
      $date = "$month/$day";
      &lt;/%init&gt;

      &lt;%args&gt;
      $article_id
      &lt;/%args&gt;
</pre>
</font>

Фактически блок <font color=green>&lt;%init&gt;</font>  эквивалентен блоку
<font color=green>&lt;%perl&gt;</font>. При таком введении наиболее читаемые
компоненты (особенно для непрограммистов) содержат <font
color=green>HTML</font> в одном непрерывном блоке наверху, с простыми
заменами для динамических элементов, и никаких отвлекающих и запутывающих
блоков кода на <font color=green>perl</font>. 

<p>

Примеры работы, <a href="http://www.pereplet.ru"
target=_new>http://www.pereplet.ru</a>, литературный журнал, где каждое
высказывание в дискуссии по определенному произведению прицепляется к
определенному произведению <font color=green>html</font>. И практически на
одном <font color=green>mason</font>'е написан научный сервер <a
href="http://www.nature.ru" target=_new>http://www.nature.ru</a> .<br>
<hr>

<a name="mass_html"></a>
<ul>
<li>
<a href="#mass_html">Массивы</a>
</li>
  <ul>
    <li>
<a href="#mass_html_objavlenue">Объявление</a>
   <li>
<a href="#mass_html_2Darr">Двумерные массивы</a>
    <li>
<a href="#mass_html_ex">Примеры использования</a>
	<ul>
    <li>
<a href="#mass_html_news">Постраничный вывод новостей с разбиением по датам</a>
    <li>
<a href="#mass_html_spisok">Пример работы со списками</a>    
	</ul>
  </ul>
</ul>
<a name=mass_html_objavlenue>
<h3>Объявление</h3>
</a>
Объявление массивов очень просто:
<pre>
<font color=green>
my @mass();
</pre>
</font>
Но массив, как и хэш, можно и не объявлять, перл это умеет делать сам.
<p align="justify">
Доступ к элементам массива осуществляется например таким образом(выводится случаный элемент массива):
<pre>
<font color=green>
print $mass[rand $#mass];
</pre>
</font>
<p align="justify">
В переменной <font color=green>$#mass</font> содержится размер массива-1, т.к. нуумерация элемента массива начинается с нулевого элемента.

<a name=mass_html_ex>
<h3>Примеры использования</h3>
</a>

<a name=mass_html_news>
<h4>Постраничный вывод новостей 
	с разбиением по датам</h4>
</a>
<p alygn=justify>	
Предположим есть файл <font color=green>news.dat</font> со строками(не суть что разделитель, разделитель 
определяется переменной <font color=green>$/</font>, 
которую можно в начале кода переопределить) вида:
<pre>
<font color=green>
20010717&lt;A href="http://www.netoscope.ru/news/" target=_new&gt;news1&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[Нетоскоп]
20010717&lt;A href="http://www.utro.ru/news/" target=_new&gt;news2&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[Утро]
20010718&lt;A href="http://www.compulenta.ru/" target=_new&gt;news3&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[Компьюлента]
20010718&lt;A href="http://www.compulenta.ru" target=_new&gt;news4&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[Компьюлента]
20010718&lt;A href="http://www.kommersant.ru/news/" target=_new&gt;news5&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[КоммерсантЪ]
20010719&lt;A href="http://www.echo.msk.ru/7news/" target=_new&gt;news6&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[Эхо Москвы]
20010719&lt;A href="http://www.echo.msk.ru/7news/" target=_new&gt;news7&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[Эхо Москвы]
</pre>
</font>
<p align=justify>
где даты поставлены задом наперед, сначала год, затем месяц, затем день, так сравнивать легче,
ибо год максимален, месяц тоже максимален, и деть тоже максимален. Иначе для сортировки по дате пришлось 
бы вводить двенадцатиричную систему счисления для месяцев и затем 60-тиричную систему счисления для часов, минут и секунд.
<p align=justify>
Приведенная ниже программа позволяет реализовать постраничный вывод текста, с 
линейкой прокрутки текста наподобие результатов, выдаваемых обычными поисковиками:
<pre>
<font color=green>
#!/usr/bin/perl -wT
print "content-type: text/html\n\n";
use CGI 'param';
   $pos = param('pos');
     $n = 5;
     $k = 5;
   $url = "q.pl";
open F, "&lt;news.dat"; @mass=&lt;F&gt;; close F;

@m1=grep{!$_{$_}++}
    map{/^(\d\d\d\d\d\d\d\d)/} @mass;

foreach $u(0 .. $#m1){
  foreach $n(@mass){
    chomp $m1[$u];
    push @{$ha{$m1[$u]}}, $n if($n=~m/^$m1[$u]/)
  }
}
print "&lt;a name=top&gt;";
for $k(reverse sort keys %ha){
  $k=~s|^(\d\d\d\d)(\d\d)(\d\d)|$3\.$2\.$1|;
  push(@re, " &lt;a href=\"#$k\"&gt;$k&lt;/a&gt; ");
}
print "&lt;center&gt;";
&res(@re); 
print "&lt;/center&gt;";
for $k(reverse sort keys %ha){
  $m=$k; $m=~s|^(\d\d\d\d)(\d\d)(\d\d)|$3\.$2\.$1|;
  $tr="&lt;b&gt;&lt;a name=\"$m\"&gt;$m&lt;/b&gt; &lt;a href=\"#top\"&gt;top&lt;/a&gt;&lt;ul&gt;";
  foreach $im(@{$ha{$k}}){ $im=~s!$k|&lt;br>!!; $tr.="&lt;li>$im";}
  $tr.="&lt;/ul&gt;";
  push @res, "$tr\n";
}
push @res, "";
&res(@res);
sub res{
  local @res=@_;
  if($#res>$n-1){
    print "&lt;p&gt;&lt;center&gt;&lt;font size=-1&gt;&lt;b&gt;";
    foreach($j=0; $j&lt;=$#res; $j++){
      push(@pervij,"$j") if($j&lt;=$pos && $j % $n == 0);
      push(@vtoroj,"$j") if($j&gt;=$pos+$n && $j % $n == 0);
    }
    foreach $elem(@pervij){
      if($elem/$n>=$pervij[$#pervij]/$n-$k && $res[$#res] ne '&lt;!--end--&gt;'){
        if($elem==$pervij[$#pervij] && $res[$#res] ne '&lt;!--end--&gt;'){push(@nach ,($elem/$n+1));}
        else{ push(@nach, " &lt;a href=\"$url?pos=$elem\"&gt;".($elem/$n+1)."&lt;\/a&gt; |\n");}
      }
      if($#pervij &gt; $k && $res[$#res] ne '&lt;!--end--&gt;'){
        push(@back, "&lt;a href=\"$url?pos=".($pos-$n)."\"&gt;&lt;&lt;&lt;\/a&gt;")
      }
    }  
    print $back[$#back];
    print @nach;
    foreach $elem1(@vtoroj){
      if ($elem1/$n&lt;=$pos/$n+$k && $res[$#res] ne '&lt;!--end--&gt;'){
        print " | &lt;a href=\"$url?pos=$elem1\"&gt;".($elem1/$n+1)."&lt;\/a> \n";
      }
      if($#vtoroj &gt; $k-1 && $res[$#res] ne '&lt;!--end--&gt;'){
        push(@back1, "&lt;a href=\"$url?pos=".($elem1)."\"&gt;&gt;&gt;&lt;\/a&gt;")
      }
    }  
    print "$back1[0]&lt;/b&gt;&lt;/font&gt;&lt;/center&gt;";
  }
  $#pervij=-1; $#vtoroj=-1; $#back=-1; $#nach=-1; $#back1=-1;
  print "&lt;p&gt;";
  for ($i=$pos; $i&lt;$pos+$n; $i++) { print $res[$i]}
}
</pre>
</font>

Разберем работу программы:<pre>
<font color=green>

@m1=grep{!$_{$_}++}
    map{/^(\d\d\d\d\d\d\d\d)/} @mass;
</pre>
</font>
<p align="justify">
составляем массив цифр, т.е. массив дат, <font color=green>map{/^(\d\d\d\d\d\d\d\d)/} @mass</font> составляет список цифр, указанных
в регулярном выражении. Следующая строчка <font color=green>grep{!$_{$_}++}</font> - убирает одинаковые даты, т.к. в списке новостей 
может быть несколько новостей за один день. Получаем массив <font color=green>@m1</font> с днями, которые были с новостями.
<pre>
<font color=green>
foreach $u(0 .. $#m1){
  foreach $n(@mass){
    chomp $m1[$u];
    push @{$ha{$m1[$u]}}, $n if($n=~m/^$m1[$u]/)
  }
}
</pre>
</font>
<p align="justify">
создаем хеш массивов <font color=green>@{$ha{$m1[$u]}}</font>, в которых определенному 
дню будет соответствовать несколько новостей.
<pre>
<font color=green>
for $k(reverse sort keys %ha){
  $k=~s|^(\d\d\d\d)(\d\d)(\d\d)|$3\.$2\.$1|;
  push(@re, " &lt;a href=\"#$k\"&gt;$k&lt;/a&gt; ");
}
print "&lt;center&gt;";
&res(@re); 
print "&lt;/center&gt;";
</pre>
</font>
<p align="justify">
выводим линейку дат, если при выводе 5 дней(значение числа дней содержится в переменной <font color=green>$n = 5;</font>) число 
новостей таково, что будет помещаться на более чем одной странички, вобщем для быстрой навигации.
<pre>
<font color=green>
for $k(reverse sort keys %ha){
  $m=$k; $m=~s|^(\d\d\d\d)(\d\d)(\d\d)|$3\.$2\.$1|;
  $tr="&lt;b&gt;&lt;a name=\"$m\"&gt;$m&lt;/b&gt; &lt;a href=\"#top\"&gt;top&lt;/a&gt;&lt;ul&gt;";
  foreach $im(@{$ha{$k}}){ $im=~s!$k|&lt;br>!!; $tr.="&lt;li>$im";}
  $tr.="&lt;/ul&gt;";
  push @res, "$tr\n";
}
push @res, "";
&res(@res);
</pre>
</font>
<p align="justify">
выводим из хеша список новостей по одной штуке, независимо от даты. Далее следует код вывода линейки
прокрутки для постраничного вывода результатов.
<pre>
<font color=green>
sub res{
  local @res=@_;
  if($#res>$n-1){
    print "&lt;p&gt;&lt;center&gt;&lt;font size=-1&gt;&lt;b&gt;";
    foreach($j=0; $j&lt;=$#res; $j++){
      push(@pervij,"$j") if($j&lt;=$pos && $j % $n == 0);
      push(@vtoroj,"$j") if($j&gt;=$pos+$n && $j % $n == 0);
    }
    foreach $elem(@pervij){
      if($elem/$n&gt;=$pervij[$#pervij]/$n-$k && $res[$#res] ne '&lt;!--end--&gt;'){
        if($elem==$pervij[$#pervij] && $res[$#res] ne '&lt;!--end--&gt;'){push(@nach ,($elem/$n+1));}
        else{ push(@nach, " &lt;a href=\"$url?pos=$elem\"&gt;".($elem/$n+1)."&lt;\/a&gt; |\n");}
      }
      if($#pervij &gt; $k && $res[$#res] ne '&lt;!--end--&gt;'){
        push(@back, "&lt;a href=\"$url?pos=".($pos-$n)."\"&gt;&lt;&lt;&lt;\/a&gt;")
      }
    }  
    print $back[$#back];
    print @nach;
    foreach $elem1(@vtoroj){
      if ($elem1/$n&lt;=$pos/$n+$k && $res[$#res] ne '&lt;!--end--&gt;'){
        print " | &lt;a href=\"$url?pos=$elem1\"&gt;".($elem1/$n+1)."&lt;\/a> \n";
      }
      if($#vtoroj &gt; $k-1 && $res[$#res] ne '&lt;!--end--&gt;'){
        push(@back1, "&lt;a href=\"$url?pos=".($elem1)."\"&gt;&gt;&gt;&lt;\/a&gt;")
      }
    }  
    print "$back1[0]&lt;/b&gt;&lt;/font&gt;&lt;/center&gt;";
  }
  $#pervij=-1; $#vtoroj=-1; $#back=-1; $#nach=-1; $#back1=-1;
  print "&lt;p&gt;";
  for ($i=$pos; $i&lt;$pos+$n; $i++) { print $res[$i]}
}
</pre>
</font>
<p align="justify">
локализуем массив <font color=green>@res</font>: <font color=green>local @res=@_;</font> - 
получили массив, переданный попрограмме. 
Далее <font color=green>if($#res>$n-1){blah blah blah}</font> если число элементов массива больше, чем 5, то 
показываем строчку прокрутки.
<p align="justify">
Разбиваем массив @res на массивы до текущей страницы(@pervij) и после текущей страницы(@vtoroj):
<pre>
<font color=green>
    foreach($j=0; $j&lt;=$#res; $j++){
      push(@pervij,"$j") if($j&lt;=$pos && $j % $n == 0);
      push(@vtoroj,"$j") if($j&gt;=$pos+$n && $j % $n == 0);
    }
</pre>
</font>
<p align="justify">
размерность массивов <font color=green>@pervij</font> и <font color=green>@vtoroj</font> 
кратна(кратность определяется оператором <font color=green>%</font>) числу <font color=green>$n</font>, 
т.е. это массивы
до текущей страницы и после текущей страницы, в броузере, если пользователь находится допустим на 10 
странице результатов
до текущей все то, что до цифры без ссылки, после текужей это все то, что после цифры без ссылки, включая линейки 
прокрутки <font color=green>&lt;&lt;</font> и <font color=green>&gt;&gt;</font>:


<font size=-1>
<b>
<a href="#q_pl_pos_25">&lt;&lt;</a> <a href="#q_pl_pos_5">2</a> |
 <a href="#q_pl_pos_10">3</a> |
 <a href="#q_pl_pos_15">4</a> |
 <a href="#q_pl_pos_20">5</a> |
 <a href="#q_pl_pos_25">6</a> |
7 | <a href="#q_pl_pos_35">8</a> 
 | <a href="#q_pl_pos_40">9</a>
 | <a href="#q_pl_pos_40">10</a>
 | <a href="#q_pl_pos_40">11</a>
 | <a href="#q_pl_pos_40">12</a> &gt;&gt;</a>
</b>
</font>
<p align="justify">
 Эти массивы содержат число пятерок(для <font color=green>$n=5;</font>) элементов массива <font color=green>@res</font>.
<pre>
<font color=green>
    foreach $elem(@pervij){
      if($elem/$n&gt;=$pervij[$#pervij]/$n-$k && $res[$#res] ne '&lt;!--end--&gt;'){
        if($elem==$pervij[$#pervij] && $res[$#res] ne '&lt;!--end--&gt;'){push(@nach ,($elem/$n+1));}
        else{ push(@nach, " &lt;a href=\"$url?pos=$elem\"&gt;".($elem/$n+1)."&lt;\/a&gt; |\n");}
      }
      if($#pervij &gt; $k && $res[$#res] ne '&lt;!--end--&gt;'){
        push(@back, "&lt;a href=\"$url?pos=".($pos-$n)."\"&gt;&lt;&lt;&lt;\/a&gt;")
      }
    }  
</pre>
</font>
Цикл для показа элементов предыдущих страниц <font size=-1>
<b>
<a href="#q_pl_pos_25">&lt;&lt;</a> 
<a href="#q_pl_pos_5">2</a> |
 <a href="#q_pl_pos_10">3</a> |
 <a href="#q_pl_pos_15">4</a> |
 <a href="#q_pl_pos_20">5</a> |
 <a href="#q_pl_pos_25">6</a> |
7 | <a href="#q_pl_pos_35">8</a> 
 | <a href="#q_pl_pos_40">9</a> </b>
</font>
 <p align="justify">
т.е. если <font color=green>$elem/$n&gt;=$pervij[$#pervij]/$n-$k</font>, то это значит, что выбираются 
страницы элементов до текущей позиции, включая её,
т.е. <font color=green>2, 3, 4, 5</font> и <font color=green>6</font> - цифра <font color=green>7</font> 
это текущая позиция, 
которая определяется условием 
<font color=green>if($elem==$pervij[$#pervij] && $res[$#res] ne '&lt;!--end--&gt;')</font>. Зачем тут 
стоит <font color=green>&lt;!--end--&gt;</font> будет видно
позднее в разборе админской части этой ленты новостей.
<p align="justify">
Условие <pre>
<font color=green>
      if($#pervij &gt; $k && $res[$#res] ne '&lt;!--end--&gt;'){
        push(@back, "&lt;a href=\"$url?pos=".($pos-$n)."\"&gt;&lt;&lt;&lt;\/a&gt;")
      }
</pre>
</font>
<p align="justify">
значит что если существуют элементы массива <font color=green>@pervij</font> больше, чем <font color=green>$k=5</font>, 
то для таких елементов нужно
ставить знички прокрутки <font color=green>&lt;&lt;</font> и <font color=green>&gt;&gt;</font>. 
Для массива <font color=green>@vtoroj</font> условия определяются аналогичным образом, учитывая, что
элементы для него должны быть больше определенного числа <font color=green>$pos</font>, которое 
определяет текущее значение показываемой пятерки дат.
Вывод самих новостей осуществляется циклом<pre>
<font color=green>
  for ($i=$pos; $i&lt;$pos+$n; $i++) { print $res[$i]}
</pre>
</font>
<p align="justify">
который берет элементы массива <font color=green>$res[$i]</font> до элемента <font color=green>$n</font>, т.е. 
допустим пользователь находится на странице <font color=green>10</font>,
значит должен производится вывод новостей с <font color=green>50</font> по <font color=green>55</font>-ю включительно.
<p align="justify">
Вывод результатов помещен в подпрограмму, т.е. существует некая переносимость кода из одного скрипта в другой.
В скрипте подпрограмма используется дважды, когда нужно вывести число дат по $n штук
 и когда нужно вывести сами новости в количестве $n штук на страничку.

</b>
</font>
<hr>

<a name="mp3_html"></a>
<h4>
<a name=mp3_html_mp3>Извлечение и запись информации в *.mp3</a>
</h4>

Считать информацию, хранящуюся в <font color=green>*.mp3</font> 
файле, можно при помощи модуля
<a
href="http://theoryx5.uwinnipeg.ca/mod_perl/cpan-search?search=Mp3-info&filetype=+distribution+name+or+description&join=and&arrange=file&download=auto&stem=no&case=clike&site=ftp.funet.fi&age="
target=_new>MP3::Info</a>. 
Нехитрая програмка, вытаскивающая данные о той или иной записи:
<font color=green>
<pre>
#!/usr/bin/perl

my $file="/root/test.mp3";

use MP3::Info;

my $tag = get_mp3tag($file);
my $info = get_mp3info($file);

print "$_\t=>\t$info->{$_}\n" for sort keys %$info;
print "$_\t=>\t$tag->{$_}\n" for sort keys %$tag
</pre>
</font>

Программа выдаст примерно следующее:
<font color=green>
<pre>
[ne-root@www MP3-Info-1.00]# ./u.pl
BITRATE =>      160
COPYRIGHT       =>      0
FRAMES  =>      93498
FRAME_LENGTH    =>      49
FREQUENCY       =>      44.1
LAYER   =>      3
MM      =>      3
MODE    =>      0
MS      =>      72.0499999999902
PADDING =>      0
SECS    =>      229.07205
SIZE    =>      4581441
SS      =>      49
STEREO  =>      1
TIME    =>      03:49
VBR     =>      0
VERSION =>      1
ALBUM   =>      Ist der Ruf erst ruiniert...
ARTIST  =>      Tic Tac Toe
COMMENT =>      http://www.delit.net
GENRE   =>      Rock
TITLE   =>      Lдstern
TRACKNUM        =>      32
YEAR    =>      2000
[root@www MP3-Info-1.00]#
</pre>
</font>
Обращаться к хешам, которые возвращаются функциями, можно как и при работе с
<font color=green>perl -e 'print "$k\t=>\t$v\n"
while(($k, $v)=each %ENV)'</font>
<p>
Собственно модуль так-же умеет записывать информацию о записи в mp3. файл, 
а как это сделать читайте в <font color=green>man MP3::Info</font>
<hr>

<a name="regex_html"></a>
<h2>
<center>Регулярные выражения</center>
</h2>
<p align=justify>
<ul>
	<li>
<a href="#regex_html_opred">Определения</a>
</li>
     <ul>
	    <li>
<a href="#regex_html_single">одиночные символы (characters)</a>
</li>
    	<li>
<a href="#regex_html_klass">классы символов (character classes)</a>
</li>
	    <li>
<a href="#regex_html_altern">альтернативные шаблоны (alternative match patterns)</a>
</li>
    	<li>
<a href="#regex_html_kvant">квантификаторы (quantifiers)</a>
</li>
    	<li>
<a href="#regex_html_menim">мнимые символы (assertions)</a>
</li>
    	<li>
<a href="#regex_html_brefs">ссылки на найденный текст (backreferences)</a>
</li>
     </ul>
	<li>
<a href="#regex_html_funct">Функции, использующие регулярные выражения</a>
</li>
     <ul>
	    <li>
<a href="#regex_html_split">split</a>
</li>
	    <li>
<a href="#regex_html_grep">grep</a>
</li>
	    <li>
<a href="#regex_html_map">map</a>
</li>
	    <li>
<a href="#regex_html_other">другие</a>
</li>
     </ul>
	<li>
<a href="#regex_html_work">Как работают регулярные выражения</a>
</li>
	<li>
<a href="#regex_html_logika">Логические операции в регулярных выражениях</a>
</li>
	<li>
<a href="#regex_html_subroutines">Вызов функций и подпрограмм</a>
</li>
	<li>
<a href="#regex_html_vstr">Использование встроенных переменных</a>
</li>
	<li>
<a href="#regex_html_examples">Примеры</a>
</li>
	<li>
<a href="#regex_html_exprogs">Рабочие программы, использующие регулярные выражения</a>
</li>
     <ul>
	    <li>
<a href="#regex_html_match">Выделение чисел в математической записи</a>
</li>
	    <li>
<a href="#regex_html_work1">Облегчение поиска работы</a>
</li>
	    <li>
<a href="#regex_html_newsline">Очень простое решение для зеркала новостной ленты</a>
</li>
            <li>
<a href="#regex_html_findres">Вывод результатов поиска</a>
            <li>
<a href="#regex_html_passwd">Проверка пароля на определенное число букв или цифр</a>
            <li>
<a href="#regex_html_apache">Пример использования регулярных выражений в apache</a>
     </ul>
	<li>
<a href="#regex_html_FAQ">Список наиболее употребительных регулярных выражений.</a>
</li>
</ul>
<h3>
<a name="regex_html_opred">Определения</a>
</h3>
<p align=justify>Регулярные выражения в perl одна из самых мощных его возможностей. regex позволяют в perl сопоставлять текст с указанным шаблоном, разбивать текст в массив по шаблону, производить замену текста по шаблону и многое многое другое. Так-же иногда регекспами называются операторы поиска и замены.
<p align=justify>Оператор <font color="Green">q(text)</font> заменяет строку text на строку, заключенную в одинарные кавычки(например если в <font color=green>q(text)</font> поставить символ q<font color=green>(text\n)</font>, то напечатает <font color=green>text\n</font> , т.е. <font color=green>\n</font> это два символа, подобно p<font color=green>rint 'amam $file'</font> напечатает <font color=green>amam $file</font>). В данном случае почти все специальные символы не будут интерпретироваться внутри <font color=green>q()</font>, исключая <font color=green>'\'</font> <pre>
<font color="Green">
$some=q(Don't may be);
</pre>
</font>
<p align=justify> Оператор <font color="Green">qq~text~;</font> (вместо значка <font color="Green">~</font> можно ставить например знак <font color="Green">|</font>) позволяет работать со строками и многострочными текстами. пользуясь этим оператором можно выводить целые куски html-кода и писать в этом коде имена скалярных переменных.
<p align=justify>
Оператор <font color="Green">qw("text")</font> разбивает строку на массив слов.
<pre>
<font color="Green">
@mass=qw("я вышел погулять и увидел как через реку строят новый мост");
#хотя с настроенной локалью будет работать и
@mass=qw(я вышел погулять и увидел как через реку строят новый мост);
for(@mass){print $_,"\n"}
</pre>
</font>
<p align=justify>

Оператор <font color=green>qr/pattern/</font> ключи - <font color=green>imosx</font>
работает подобно регулярному выражению <font color=green>s/.../.../</font>

<pre>
<font color=green>$rex=qr/my.STRING/is;
s#$rex#foo#;
#тоже самое, что и 
s/my.STRING/foo/is;
</pre>
</font>
Результат может использоваться подобно вызову подпрограммы(см perldoc perlop Regex quote like operator)

<pre>
<font color=green>$re=qr/$pattern/;
$string=~/foo${re}bar/; 
$string=~$re;           
$string=~/$re/;    </pre>
</font>  
   
Ключи <font color=green>imosx</font> стандартные(см. ниже)
<p align=justify>
Оператор <font color=green>qx/STRING/</font> работает как системная команда, подобно <font color=green>$output = `cmd 2>$1`;</font>. Программа, иллюстрирующая использование данного оператора:

<pre>
<font color=green>#!/usr/bin/perl
qx[dbfdump --fs="\x18" --rs="\x19"  pdffile.dbf &gt;pdffile.txt];</font>
</pre>
<p align=justify>
файл <font color=green>pdffile.dbf</font> содержит memo-поля(memo-поле содержит ссылку, подобно функции <font color=green>seek</font>, на текст в файле с расширением *.fpt), которые при помощи <font color=green>DBI.pm</font> мне когда-то давно выудить не удалось. Принимает разрешения FoxBASE4 и дампит файлы со встроенными <font color=green>memo</font>-полями в текстовый вид. Т.е. таким образом получилось вытащить информацию из файла memo-типа <font color=green>*.fpt</font>.
<p align=justify>
Допустим используя команду <font color=green>$perl_info = qx(ps $$);</font> мы выводим информацию о текущем процессе запущенного скрипта(каждая запущенная программа в UNIX имеет свой собственный уникальный идентификатор, который содержится во встроенной переменной <font color=green>$$</font> - достаточно уникальное число, можно использовать почти как счетчик случайных чисел). Если сказать <font color=green>$shell_info = qx'ps $$';</font> то выведет информацию о самом <font color=green>ps</font>. Т.е. скобки осуществляют своеобразное экранирование от двойной кавычки.
<p align=justify>
В перл есть три основных оператора, работающих со строками:<br>
<br>
<font color="Green">
<font color=green>m/.../</font>
</font> - проверка совпадений (matching),<br>
<font color="Green">
<font color=green>s/.../.../</font>
</font> - подстановка текста (substitution), <br>
<font color="Green">tr/.../</font> - замена текста (translation).<br>
<br>
Опертаор <font color="Green">
<font color=green>m/.../</font>
</font> анализирует входной текст и ищет в нем подстроку совпадающую с указанным шаблоном (он задан регулярным выражением). Оператор <font color="Green">
<font color=green>s/.../.../</font>
</font> выполняет подстановку одних текстовых фрагментов вместо других, при помощи регулярных выражений. Оператор <font color="Green">
<font color=green>tr/.../.../</font>
</font>  заменяет выходной текст, но при этом он не использует регулярные выражения, осуществляя замену посимвольно. 
<br>
<br>
Оператор <font color="Green">m/шаблон/</font> - поиск подстроки по определенному шаблону. Например
<font color="Green">print "$1 г.\n" while m!((\d){4})!g</font> 
найдет и выведет все даты в переменной <font color="Green">$_</font>.
В шаблоне не важно, что будет его ограничителем. Например при поиске гиперссылок,
 которые зачастую содержат символы <font color="Green">/</font>, 
разумнее пользоваться не <font color="Green">/</font>, а например 
<font color="Green">#</font> или <font color="Green">!</font> 
как символами ограничителями. В таком случае шаблон будет более прост для понимания другим
программистам, да и немного короче. В perl оператор <font color="Green">
<font color=green>m/.../</font>
</font> используется очень часто, и поэтому используется сокращение, без начальной буквы <font color="Green">m</font>. Если начальная буква есть, то в качетсве символов ограничителей можно исползовать любой другой символ.
<p align=justify>
Для оператора <font color="Green">m/pattern/</font> есть 6 параметров: <font color="Green">gimsxo</font>
<p align=justify>
<font color="Green">m/foo/g</font> говорит компилятору найти все 
<font color="Green">foo</font> в тексте, в то время как <font color="Green">m/foo/</font> 
найдет только 
первое вхождение подстроки <font color="Green">foo</font> в строке <font color="Green">$_</font>. 
В строке <font color="Green">$_</font> содержится обычный текст, как и в 
переменной <font color="Green">$text</font>$, <font color="Green">$_</font> такая-же переменная, 
только она существует всегда и вводится, когда не определена специально другая, по умолчанию. <p align=justify>
Например можно сказать 
<font color="Green">for (@mass){print $_,"\n"}</font> или 
<font color="Green">for $elem (@mass){print $elem,"\n"}</font>.
Эти две строчки делают одно и то-же, но в первом случае запись короче, 
да и зачастую бывает удобно использовать переменную <font color="Green">$_</font>, например, когда нужно 
выделить при помощи регулярного выражения определенные данные, пользуясь перебором 
массива(функция map):
<pre>
<font color="Green">
@res=map{/(\d\d\d\d)/} split /\s/, $texts; 
</pre>
</font>
что эквививалентно коду
<pre>
<font color="Green">
push @res, $1 while m!((\d){4})!g; #(в данном случае $_=$texts)
</pre>
</font>
или что эквивалентно конструкции
<pre>
<font color="Green">
foreach(split /\s/, $texts){
push @res, $1 if(/(\d\d\d\d)/g)
}
</pre>
</font>
<p align=justify>
Следующий параметр <font color="Green">m/foo/i</font>, 
говорит о том, что не нужно учитывать регистр при 
поиске по подстроке.
<p align=justify>
Параметр <font color="Green">m/foo/s</font> говорит от том, что строка, по которой производится поиск, состоит из одной строчки.
<p align=justify>
Например нужно выцепить все url картинок из странички www.astronomynow.com, чтобы сделать
локальное зеркало этой странички и пользователи могли с 
интересом читать последние новости астрономии:
<pre>
<font color="Green">
#!/usr/bin/perl -wT
use LWP::Simple;
$page=get "http://www.astronomynow.com";
&getlink($page);
sub getlink{
  local $_=$_[0];
  push(@res, "http://$2")
    while m{SRC\s*=\s*(["'])http://(.*?)\1\s*(.*?)WIDTH="100" HEIGHT="100"(.*?)>}igs
}
</pre>
</font>
<p align=justify>
В подпрограмме заводится при помощи функции 
<font color="Green">local</font> переменная, видимая 
только в области действия подпрограммы. Этой переменной присваивается значение
переменной <font color="Green">$page</font>, 
в которой содержится текст выкачанной <font color="Green">Simple.pm</font> странички.
<p align=justify>
Можно сделать немного по другому, сохранить
скачанную страничку в файл на диск и затем следующее:
<pre>
<font color="Green">
$/="\001";
open F, "&lt;page.html"; $page=&lt;F&gt;; close F;
&getlink($page); 
...
</pre>
</font>
<p align=justify>
Встроенная переменная <font color="Green">$/</font> содержит символ разделителя входных записей. Это может быть перевод каретки или, при upload far'ом на сервер файлов в не ASCI виде, она приобретают на конце строчки хитрый символ <font color="Green">^M</font>. 
<p align=justify> Если <font color="Green">$/</font> переопределить, то можно свободно
пользоваться дескрипторами открытия файлов для просмотра 
многострочного текста(<font color="Green">m/pattern/s</font>). 
Например когда открывается файл при помощи
функции <font color="Green">open F, "&lt;file.txt"; @mass=&lt;F&gt;</font>, 
то присваивая дескриптор <font color="Green">F</font> массиву
в массиве появятся строчки, разделенные символом, содержащимся в 
<font color="Green">$/</font>.<p align=justify>
Переопределив <font color="Green">$/</font> можно запросто написать: 
<pre>
<font color="Green">
open F, "&lt;file.txt"; $mass=&lt;F&gt;
</pre>
</font>
<p align=justify>
и в переменной <font color="Green">$mass</font> 
будет содержаться многострочный текст с точки зрения человека,
но программа будет видеть этот текст как одну строку и по тексту можно будет запросто 
пройтись поиском <font color="Green">m/pattern/igs</font> и выделить все необходимые подстроки.
<p align="justify">
Параметр <font color="Green">m/foo/o</font> говорит от том, что шаблон нужно компилировать только один раз. Если оператор используется в сочетании с операциями привязки <font color="Green">=~</font> и отрицание <font color="Green">!~</font>, то строкой, в которой ведется поиск, является переменная, стоящая слева от операции привязки. В противном случае поиск ведется в строке <font color="Green">$_</font>.
<p align="justify">
Оператор <font color="Green">s!pattern!substring!</font> - поиск в строке по шаблону <font color="Green">pattern</font> и замена найденного текста на <font color="Green">substring</font>. Как и для оператора <font color="Green">
<font color=green>m/.../</font>
</font>, косую черту можно не ставить, пригоден любой символ, который не находится в противореции с заданным выражением. Не рекомендуется использовать в качестве ограничителей <font color="Green">?</font> и <font color="Green">'</font>.
<p align="justify">
<font color="Green">s!/usr/local/etc/!/some/where/else!</font> - заменяет путь.<br>
<font color="Green">s(/usr/local/etc/)(/some/where/else)g</font> - заменяет все встречающимеся пути до файла.<br>
<br>

параметры: <font color="Green">egimsxo</font>
<font color="Green">e</font> - указывает, что substring нужно вычислить.
<p align="justify">
например нужно переделать все escape последовательности, для этого вызывается соответствующая подпрограмма:
<pre>
<font color="Green">$text =~ s/(&.*?;)/&esc2char($1)/egs;</font>
</pre>
т.е. из регулярного выражения происходит вызов подпрограммы.
<p align="justify">
<font color="Green">g</font> - заменить все одинаковые компоненты, а не один, как в отсутствии ключа <font color="Green">g</font>.<br>
<font color="Green">i</font> - не учитывать регистр.<br>
<font color="Green">m</font> - строка, в которой происходит поиск, состоит из множества строк.<br>
<font color="Green">s</font> - строка, в которой происходит поиск, состоит из одной строки.<br>
<font color="Green">x</font> - сложный шаблон, т.е. можно писать не в строчку, а для упрощения понимания разбивать шаблон на несколько строк, примеры об этом ниже.<br>
<font color="Green">o</font> -  компилировать шаблон один раз.<br>
<p align="justify">
Допустим нужно сделать поисковик, который ходит по директориям на сервере, но некоторые директории типа <font color="Green">/cgi-bin/</font> и т.п. индексировать нельзя. Объявляем переменную, которая будет содержать регулярное выражение, в данном случае перечисление или <font color="Green">img</font> или <font color="Green">image</font> или <font color="Green">temp</font> или <font color="Green">tmp</font> или <font color="Green">cgi-bin</font>: 
<pre>
<font color="Green">
$no_dir = '(img|image|temp|tmp|cgi-bin)';</font>
</pre>
<p align="justify">
Ключи регулярного выражения <font color="Green">m#$no_dir$#io</font> говорят о том, что компилировать содержимое <font color="Green">$no_dir</font> нужно только один раз(ключ <font color="Green">o</font>) и также еще не учитывать регистр(ключ <font color="Green">i</font>).
<p align="justify">
Оператор <font color="Green">tr/выражение1/выражение2/</font>, ключи <font color="Green">cds</font>
<p align="justify">
Смысл: замена <font color="Green">выражения1</font> на <font color="Green">выражение2</font>. Если указан ключ <font color="Green">с</font>, то это инверсия <font color="Green">выражения1</font>, т.е. в выражение один не входят содержащиеся в нем символы. если указа ключ <font color="Green">d</font>, то значит стереть замененные символы. Если указан ключ <font color="Green">s</font>, то значит заменить многочисленные повторяющиеся символы на одиночный символ.
<p align="justify">
Оператор <font color="Green">y/выражение1/выражение2/</font>(ключи <font color="Green">cds</font>), равносилен оператору <font color="Green">tr</font>.
<p align="justify">
Например в поисковой системе нужно приводить запрос в нижний регистр, дабы не зависеть от настроек локали:
<pre>
<font color="Green">
$CAP_LETTERS = '\xC0-\xDF\xA8';
$LOW_LETTERS = '\xE0-\xFF\xB8';

$code = '$html_text =~ ';
$code .= "tr/A-Z$CAP_LETTERS/a-z$LOW_LETTERS/";
$down_case = eval "sub{$code}";
</font>
</pre>
<h4>
<a name="regex_html_single">одиночные символы</a>
</h4>

В регулярном выражении любой символ соответствует самому себе, если только он не является метасимволом со специальным значением (такими метасимволами являются <font color=green>\</font>, <font color=green>|</font>, <font color=green>(</font>, <font color=green>)</font>, <font color=green>[</font>, <font color=green>{</font>, <font color=green>*</font>, <font color=green>+</font>, <font color=green>^</font>, <font color=green>$</font>, <font color=green>?</font> и <font color=green>.</font>). В следующем примере проверяется, не ввел ли пользователь команду "quit" (и если это так, то прекращаем работу программы): 
<pre>
<font color="Green">
while(<>){
  if(m/quit/){exit;}
}</font>
</pre>
<p align="justify">
Правильнее проверить, что введенное пользователем слово "quit" не имеет со-седних слов, изменяющих смысл предложения. (Например, программа выполнит заведомо неверное действие, если вместо "quit" пользователь введет команду "Don't quit!".) Это можно сделать с помощью метасимволов <font color=green>^</font> и <font color=green>$</font>. Заодно, что-бы сравнение было нечувствительно к разнице между прописными и заглавными буквами, используем модификатор <font color=green>i</font>:
<pre>
<font color="Green">
while (<>) 
{if (m/^quit$/i) {exit;} }
</font>
</pre>
<p align="justify">
Кроме обычных символов perl определяет специальные символы. Они вводятся с помощью обратной косой черты (escape-последовательности) и также могут встречаться в регулярном выражении: 
<ul>
	<li>
<font color=green>\077</font> - восьмеричный символ, </li>
	<li>
<font color=green>\а</font> - символ BEL (звонок),</li>
	<li>
<font color=green>\с[</font> - управляющие символы (комбинация Ctrl + символ, в данном случае это управляющий символ ESC),</li>
	<li>
<font color=green>\d</font> - соответствует цифре, </li>
	<li>
<font color=green>\D</font> - соответствует любому символу, кроме цифры,</li>
	<li>
<font color=green>\е</font> - символ escape (ESC),</li>
	<li>
<font color=green>\Е</font> - конец действия команд <font color=green>\L</font>, <font color=green>\U</font> и <font color=green>\Q</font>,</li>
	<li>
<font color=green>\f</font> - символ прогона страницы (FF),</li>
	<li>
<font color=green>\1</font> - следующая литера становится строчной (lowercase),</li>
	<li>
<font color=green>\L</font> - все последующие литеры становятся строчными вплоть до командй \Е,</li>
	<li>
<font color=green>\n</font> - символ новой строки (LF, NL),</li>
	<li>
<font color=green>\Q</font> - вплоть до команды <font color=green>\Е</font> все последующие метасимволы становятся обычными символами,</li>
	<li>
<font color=green>\r</font> - символ перевода каретки (CR),</li>
	<li>
<font color=green>\s</font> - соответствует любому из "пробельных символов" (пробел, вертикальная , или горизонтальная табуляция, символ новой строки и т. д.),</li>
	<li>
<font color=green>\S</font> - любой символ, кроме "пробельного", </li>
	<li>
<font color=green>\t</font> - символ горизонтальной табуляции (НТ, TAB),     </li>
	<li>
<font color=green>\u</font> - следующая литера становится заглавной (uppercase), </li>
	<li>
<font color=green>\U</font> - все последующие литеры становятся заглавными вплоть до команды <font color=green>\E</font>, </li>
	<li>
<font color=green>\v</font> - символ вертикальной табуляции (VT),</li>
	<li>
<font color=green>\w</font> - алфавитно-цифровой символ (любая буква, цифра или символ подчеркивания), </li>
	<li>
<font color=green>\W</font> - любой символ, кроме букв, цифр и символа подчеркивания,</li>
	<li>
<font color=green>\x1B</font> - шестнадцатиричный символ.</li>

</ul>
<p align=justify>

Bat также можете "защитить" любой метасимвол, то есть заставить perl рассматривать его как обыкновенный символ, а не как команду, поставив перед метасимволом обратную косую черту <font color=green>\</font>. Обратите внимание на символы типа <font color=green>\w</font>, <font color=green>\d</font> и <font color=green>\s</font>, которые соответствуют не одному, а любому символу из некоторой группы. Также заметьте, что один такой символ, указанный в шаблоне, соответствует ровно одному символу проверяемой строки. Поэтому для задания шаблона, соответствующего, например, слову из букв, цифр и символов подчеркивания, надо использовать конструкцию <font color=green>\w+</font>, как это сделано в следующем примере:

<pre>
<font color=green>$text = "Here is some text."
$text =~ s/\w+/There/;
print $text;
There is some text.
</pre>
</font>

<h4>
<a name=regex_html_klass>классы символов</a>
</h4>

Символы могут быть сгруппированы в классы. Указанный в шаблоне класс символов сопоставляется с любым из символов, входящим в этот класс. Класс - это
 совокупность символов, заключенный в квадратные скобки <font color=green>[</font> и <font color=green>]</font>. Можно указывать как отдельные символы, так и их диапазон (диапазон задается двумя крайними символами, соединенными тире). 
Наример, следующий код производит поиск гласных:
<pre>
<font color=green>$text ="Here is the text.";
if ($text =" /[aeiou]/) {print "Vowels: we got 'em.\n";}
Vowels: we got 'em.
</pre>
</font>
<p align=justify>Другой пример: с помощью шаблона <font color=green>[A-Za-z]+</font> (метасимвол <font color=green>+</font> означает утверждение: "один или более таких символов") ищется и заменяется первое слово:

<pre>
<font color=green>$text = "What is the subject.";
$text =" s/[A-Za-z]+/Perl/;
print $text;
Perl is the subject;</pre>
</font>
<p align=justify>
Если требуется задать минус как символ, входящий в класс символов, перед ним надо поставить обратную косую черту <font color=green>\-</font>. Если  сразу после открывающей квадратной скобки стоит символ <font color=green>^</font>, то смысл меяется на противоположный. А именно, этот класс сопоставляется любому символу, кроме перечисленных в квадратных скобках. В следующем примере производится замена фрагмента текста, составленного не из букв и не из пробелов:
<pre>
<font color=green>$text = "perl is the subject on page 493 of the book.";
$text =- s/[a-Za-z\s]+/500/;
print $text; 
perl is the subject on page 500 of the book.</pre>
</font>


<h4>
<a name=regex_html_altern>альтернативные шаблоны</a>
</h4>

Вы можете задать несколько альтернативных шаблонов, используя символ <font color=green>|</font> как разделитель. Альтернативные шаблоны позволяют превратить процедуру поиска из однонаправленного процесса в разветвленный:
если не подходит один шаблон perl подставляет другой и повторяет сравнение, и так до тех пор, пока не иссякнут все возможные альтернативные комбинации. Например, следующий фрагмент проверяет, не ввел ли пользователь "exit", "quit" или "stop":

<pre>
<font color=green>while (&lt;&gt;){
  if(m/exit|quit|stop/){exit;}
}
</pre>
</font>
<p align=justify>
Чтобы было ясно, где начинается и где заканчивается набор альтернативных шаблонов, их заключают в круглые скобки - иначе символы, расположенные справа и слева от группы шаблонов, могут смещаться с альтернативыми шаблонами.<p align=justify>
В следующем примере метасимволы <font color=green>^</font> и <font color=green>$</font> обозначают начало и конец строки и отделяются от набора альтернативных шаблонов с помощью скобок:
<pre>
<font color=green>while (&lt;&gt;){
  if(m/^(exit|quit|stop)$/){exit;}
}
</font>
</pre>
<p align=justify>Альтернативные варианты перебираются слева направо. Как только найдена первая альтернатива, для которой выполняется совпадение с шаблоном, перебор прекращается. Участки шаблона, заключенные в круглые скобки, выполняют специальную роль при выполнении операций поиска и замены. Если символ <font color=green>\</font>  находится в квадратных скобках, он интерпретируется как обычный символ. Поэтому если вы используете конструкцию шаблона вида <font color=green>[Tim|Tom|Tam]</font>, то она будет эквивалентна классу символов <font color=green>[Tioam|]</font>. Точно так же большинство других метасимволов и команд, специфичных для регулярных выражений - в частности, квантификаторы и мнимые символы, описанные в двух последующих разделах, - внутри квадратных скобок превращаются в обычные символы или escape-последовательности текстовых строк.
<h4>
<a name=regex_html_kvant>квантификаторы</a>
</h4>
<p align=justify>
Квантификаторы в регулярных выражениях<p align=justify>
Квантификаторы указывают на то, что тот или иной шаблон в строке может повторяться определенное количество раз. Например, можно использовать квантификатор <font color=green>+</font> для поиска мест неоднократного, повторения подряд латинской буквы <font color=green>е</font> и их замены на одиночную букву <font color=green>е</font>:
<pre>
<font color=green>$text = "Hello from Peeeeeeeeeeeeeeerl.";
$text =~ s/e+/e/:
print $text;
Hello from perl. 

</pre>
</font>
<h4>
<a name=regex_html_menim>мнимые символы</a>
</h4>
<p align=justify>
Мнимые символы в регулярных выражениях<p align=justify>
В perl имеются символы (метасимволы), которые соответствуют не какой-либо литере или литерам, а означают выполнение определенного условия (поэтому в английском языке их называют assertions, или утверждениями). Их можно рассматривать как мнимые символы нулевого размера, расположенные на границе между реальными символами в точке, соответствующей определенному условию:
<ul>
	<li>
<font color=green>^</font> - начало строки текста,</li>
	<li>
<font color=green>$</font> - конец строки или позиция перед символом начала новой строки, распо-ложенного в конце,</li>
	<li>
<font color=green>\b</font> - граница слова,</li>
	<li>
<font color=green>\В</font> - отсутствие границы слова,</li>
	<li>
<font color=green>\А</font> - "истинное" начало строки, </li>
	<li>
<font color=green>\Z</font> - "истинный" конец строки или позиция перед символом начала новой строки, расположенного в "истинном" конце строки,</li>
	<li>
<font color=green>\z</font> - истинный конец строки,</li>
	<li>
<font color=green>\G</font> - граница, на которой остановился предыдущий глобальный поиск, выполняемый командой <font color=green>m/.../</font>g,</li>
	<li>
<font color=green>(?= шаблон)</font> - после этой точки есть фрагмент текста, который соответствует указанному регулярному выражению,</li>
	<li>
<font color=green>(?! шаблон)</font> - после этой точки нет текста, который бы соответствовал указанному регулярному выражению,</li>
	<li>
<font color=green>(?&lt;= шаблон)</font> - перед этой точкой есть фрагмент текста, соответствующий указанному регулярному выражению,</li>
	<li>
<font color=green>(?&lt;! шаблон)</font> - перед этой точкой нет фрагмента текста, соответствующего указанному регулярному выражению.</li>
</ul>

Например, вот как выполнить поиск и замену слова, используя метасимволы границы слов:
<pre>
<font color=green>$text = "Here is some text.";
$text = s~/\b([A-Za-z)+)\b/There/;
print $text;
There is some text.</pre>
</font>
<p align=justify>
perl считает границей слова точку, расположенную между <font color=green>\w</font> и <font color=green>\W</font>, независимо от того, в каком порядке следуют эти символы . В следующем примере выводится сообщение о том, что пользователь ввел слово "yes", при условии, что оно единственное, что ввел пользователь. Для этого шаблон включает мнимые символы начала и конца строки:
<pre>
<font color=green>while (&lt;&gt;) {
 if (m/^yes$/) {
  print "Thank you for being agreeable.\n";
  } 
}
</pre>
</font>
<p align=justify>
Приведенный выше пример требует комментария. Прежде всего, бросается в глаза наличие двух групп метасимволов для начала и конца строки. В большинстве случаев они означают одно и то же, так как обычно символы новой строки (то есть <font color=green>\n</font>), встречающиеся внутри текстового выражения, не рассматриваются как вложенные строки. Однако если для команды <font color=green>
<font color=green>m/.../</font>
</font> или <font color=green>
<font color=green>s/.../.../</font>
</font> указан модификатор <font color=green>m</font>, то текстовое выражение будет рассматриваться как многострочный текст, в котором границами строк выступают символы новой строки <font color=green>\n</font>. В случае многострочного текста метасимвол <font color=green>^</font> сопоставляется с позицией после любого символа новой строки, а не только с началом текстового выражения. Точно также метасимвол <font color=green>$</font> - это позиция перед любым символом новой строки, расположенным внутри текстового выражения, а не обяательно конец текстового выражения или же позиция перед концевым символом <font color=green>\n</font>. Однако метасимвол <font color=green>\A</font> - начало текстового выражения, а метасимвол <font color=green>\Z</font> - конец текстового выра-жения или позиция перед концевым символом <font color=green>\n</font>, даже если в текстовом выражении имеются вложенные символы <font color=green>\n</font> и при выполнении операции поиска или йены указан модификатор <font color=green>m</font>. 
Метасимвол точка (<font color=green>.</font>) соответствует любому символу, кроме символа новой строки <font color=green>\n</font>. Независимо от того, задан ли модификатор <font color=green>m</font>, она не будет сопоставляться ни c внутренними, ни с концевыми символами <font color=green>\n</font>. Единственный способ заставить точку рассматривать <font color=green>\n</font> как обычный символ - использовать модификатор <font color=green>s</font>.<p align=justify>
Отсюда понятна разница между метасимволами <font color=green>\Z</font> и <font color=green>\z</font>. Если в качестве текстового выражения используется результат чтения входного потока данных, то с большой вероятностью данное выражение заканчивается символом <font color=green>\n</font>, за исключениeм того варианта, когда программа предусмотрительно "отщипнула" его с помощью функции <font color=green>chop</font> или <font color=green>chomp</font>. Метасимвол <font color=green>\Z</font> игнорирует концевой символ <font color=green>\n</font> если он случайно остался на месте, рассматривая обе ситуации как "конец строки". В отличие от него метасимвол <font color=green>\z</font> оказывается более пунктуальным и рассматривает концевой символ <font color=green>\n</font> как неотъемлемую часть проверяемого текстового выражения, если только пользователь не позаботился об удалении этого символа.<p align=justify>
Отдельно следует остановиться на метасимволе <font color=green>\G</font>. Он может указыватьсяв регулярном выражении только в том случае, если выполняется глобальный поиск (то есть если команда <font color=green>
<font color=green>m/.../</font>
</font> имеет модификатор <font color=green>g</font>). Метасимвол <font color=green>\G</font>, указанный в шаблоне, соответствует точке, на котброй остановилась предыдущая операция поиска. <p align=justify>

<h4>
<a name=regex_html_brefs>ссылки на найденный текст</a>
</h4>

<p align=justify>

Иногда нужно сослаться на подстроку текста, для которой получено совпадение с некоторой  частью шаблона. Например, при обработке файла, HTML может потребоваться выделять фрагменты текста, ограниченные открывающими и закрывающими метками HTML (например, &lt;А&gt; и &lt;/А&gt;). В начале уже приводился пример, в котором выделялся текст, ограниченнуй метками HTML &lt;А&gt; и &lt;B&gt;. Следующий пример позволяет выделять текст, расположенный между любыми правильно закрытыми метками:

<pre>
<font color=green>$text = "&lt;А&gt;Here is an anct1or.&lt;/А&gt;"; 
if($text=~m%&lt;([A-Za-z]+)&gt;[\w\s\.]+&lt;/\1&gt;%i){
}
</pre>
</font>
<p align=justify>
Вместо косой черты в качестве ограничителя шаблона использован другой символ. Это позволяет использовать символ косой черты внутри шаблона без предшествующей ему обратной косой черты.
Каждому фрагменту шаблона, заключенному в круглые скобки, соответствует определенная внутренняя переменная. Переменные пронумерованы, так что на них можно ссылаться внутри шаблона, поставив перед номером обратную косую черту (<font color=green>\1</font>, <font color=green>\2</font>, <font color=green>\3</font>,...). На значения переменных можно ссылаться внутри шаблона, как на обычный текст, поэтому <font color=green>&lt;/\1&gt;</font> соответствует &lt;/\A&gt;, если открываю-щей меткой служит<А>, и </IMG>, если открывающей меткой служит </IMG>.



Эти же самые внутренние переменные можно использовать и вне шаблона, ссылаясь на них как на скаляры с именами <font color=green>$1</font>, <font color=green>$2</font>, <font color=green>$3</font>,<font color=green>...</font>, <font color=green>$n</font>: 
<pre>
<font color=green>$text = "I have 4 apples.";
if ($text =- /(\(\d+)/) {
print "Here Is the number of apples: $1.\n";
Here is the number of apples: 4.
</pre>
</font>
<p align=justify>
Каждой паре скобок внутри шаблона после завершения операции поиска будет соответствовать скалярная переменная с соответствующим номером. Это можно 'использовать при выделении нужных для последующей работы фрагментов ана-лизируемой строки. В следующем примере мы изменяем порядок трех слов в тек-стовой строке с помощью команды <font color=green>
<font color=green>s/.../.../</font>
</font>: 

<pre>
<font color=green>$text = "I see you.";
$text=-s/^(\w+) *(\w+) *(\w+)/$3 $2 $1/; 
print $text; 
you see I.
</pre>
</font>
<p align=justify>
Переменные, соответствующие фрагментам шаблона, нуумеруются слева направо с учетом вложенности скобок. Например, после следующей операции поиска будут проинициализированы шесть переменных, соответствующих шести парам скобок:

<pre>
<font color=green>$text = "ABCDEFGH";
$text =- m/(\w(\w)(\w))((\w)(\w))/;
print "$1/$2/$3/$4/$5/$6/";
ABC/B/C/DE/D/E
</pre>
</font>
<p align=justify>
Кроме переменных, ссылающихся на найденный текст, можно использовать специальные переменные perl. 

<h3>
<a name="regex_html_funct">Функции, использующие регулярные выражения</a>
</h3>
Фактически, есть три функции, которые в качестве разделителя могут использовать регулярные выражение: <font color=green>split</font>, <font color=green>grep</font>, <font color=green>map</font> и еще можно воспользоваться специальными операторами <font color=green>...</font> и <font color=green>..</font> и используемыми совместно с ними условиями <font color=green>if</font>, <font color=green>unless</font> и просто логическими операторами.

<h4>
<a name=regex_html_split>split</a>
</h4>
<p align=justify>
Если необходимо разделить данные из <font color=green>STDIN</font> по нужному разделителю, то можно воспользоваться локализацией <font color=green>$/</font>:

<pre>
<font color=green>
sub example_local{
  local $/ = undef;
  @mass= split /pattern/, &lt;&gt;;
  return 1;
}
print scalar(@mass); 
</pre>
</font>
Можно разделять данные из файла и так:

<pre>
<font color=green>undef $/;
@res=split /pattern/, &lt;F&gt;;</pre>
</font>

что эквивалентно:

<pre>
<font color=green>while (&lt;F&gt;) {push @asdf, split}</pre>
</font>

После split можно ставить вместо запятой и стрелочку:

<pre>
<font color=green>@mass = split /(\d){4}/ => $file;</pre>
</font>

<p align=justify>В функции сплит можно воспользоваться макисмальным квантификатором <font color=green>*</font>, который в том числе и о символов, позволит разделить строку на символы, которых там нет(в силу того, что <font color=green>*</font> это 0 и более символов), т.е. посимвольно:

<pre>
<font color=green>@ruru = split /\001*/ => "lalalalalala";
#массив @ruru будет содержать элементы по одной букве.</pre>
</font>

Если строка состоит из нескольких строк, то можно поставить разделителем и символ начала новой строки:

<pre>
<font color=green>  $str = "asdf\nghjk\nqwer\n";
  @lines = split /^/ => $str;</pre>
</font>

Вобщем, в split можно вставлять любой поиск по шаблону.
<h4>
<a name=regex_html_grep>grep</a>
</h4>
Функция grep так-же позволяет запонять массив значениями. Например нужно получить список расширений файлов в заданной директории:

<pre>
<font color=green>while(<$dir/*.*>){push @files, $_}             #читаем директорию
@test = grep { s|.*/(.*?)\.(.*)|$2| } @files;  #оставляем в директории только расширения файлов
</pre>
</font>

можно использовать признак четности для занесения в массив:
<pre>
<font color=green>@test1=qw(1 2 3 4 5 6 7 8 9);
@evens = grep($_%2 == 1) @test1;
</pre>
</font>

Или более сложное регулярное выражение для вытаскивания всех e-mail адресов из текстовой странички:

<pre>
<font color=green>@mass=grep{s/(.*) ([\w+\-\.]+\@[\w\-\.]+\.\w{2,3})(.*)/$2/ig} split /\n/, $test;</pre>
</font>

Здесь используется укороченная запись: 

<pre>
<font color=green>@mass=grep {/pattern/} split /\n/, $test;</pre>
</font>

которая эквивалента записи из двух сторчек:

<pre>
<font color=green>@uuu=split /\n/, $test;
@mass=grep {/pattern/} @uuu;
</pre>
</font>
<h4>
<a name=regex_html_map>map</a>
</h4>
Функция map похожа по своей работе на обычное условие <font color=green>if</font>, допустим нужно разделить записи на блоки, разделенные четырьмя пробелами:

<pre>
<font color=green>
@probel = map m!\s{4}!, split /\n/, $test;
</pre>
</font>
<h4>
<a name=regex_html_other>other</a>
</h4>

Вывод строк из заданного интервала для данной строки:

<pre>
<font color=green>if(/pattern1/i .. /pattern2/i){...}
#истинность первого оператора включает конструкцию, а второго её выключает.
if($nomer1 .. $nomer2){...}</pre>
</font>

<font color=green>...</font> не возвратит истину, в отличии от <font color=green>..</font>, если условия выполняются в одной строке.

<pre>
<font color=green>if(/pattern1/i ... /pattern2/i){...}
if($nomer1 ... $nomer2){...}
</pre>
</font>
для многострочного файла

<pre>
<font color=green>print -ne 'print if 3 .. 15' file.txt</pre>
</font>
выведет строки файла с 3 по 15 строчку, та-же самая опреация но немного по другому:

<pre>
<font color=green>open F, "&lt;file";
while(&lt;F&gt;){
  print if(3 .. 15)
}</pre>
</font>
или с какой нибудь начальной и конечно разметкой, например есть вспомогательный файл шаблонов(просто различные виды html, в зависимости от действия пользователя) для разных определенны случаев, которые нужны исходя из контекста программы:

<pre>
<font color=green>open F, "&lt;file";
while(&lt;F&gt;){
  print if(/&lt;!--begin welcome--&gt;/i ... /&lt;!--end welcome--&gt;/i)
}</pre>
</font>

Такая конструкция позволяет выводить куски многострочного html кода(для однострочного нужно ставить оператор <font color=green>..</font>).

Условия в таких операторах можно ставить и разнотипными
<pre>
<font color=green>$file=qr/2345/;
while(&lt;F&gt;){
  print if(/^$/ .. 10); #увидим, что находится от пустой до 10-й строки
  print if(/^\001/ .. /$file/); #выведет все, что после нуля и до того что задано qr
}
</pre>
</font>
Программа чтения почтовых адресов из mbox или sent-mail:
<pre>
<font color=green>while(&lt;F&gt;){
  next unless /^From:?\s/i .. /^$/;
  while (/([^&lt;&gt;(,;)\s]+\@[^&lt;&gt;(,;)\s]+)/)g{
    print "$1\n" unless $test{$1}++;
  }
}</pre>
</font>

запускается <font color=green>./regex.pl /root/mail/sent-mail</font>  и выводит каждый емейл по одному разу.

<h3>
<a name="regex_html_vstr">Использование встроенных переменных</a>
</h3>

<ul>
	<li>
<font color=green>$'</font> - подстрока, следующая за совпадением.</li>
	<li>
<font color=green>$&</font> - совпадение с шаблоном поиска</li>
	<li>
<font color=green>$`</font> - подстрока, расположенная перед совпадением</li>
	<li>
<font color=green>$^R</font> - результат вычисления утверждения в теле шаблона</li>
	<li>
<font color=green>$n</font> - n-ный фрагмент совпадения</li>
	<li>
<font color=green>\n</font> - n-ный фрагмент совпадения вызываемый в самом шаблоне</li>
    <li>
<font color=green>$+</font> - фрагмент совпадения</li>
    <li>
<font color=green>$*</font> - разрешает выполнять поиск в многострочных файлах</li>
	<li>
<font color=green>@-</font> - спецмассив, который содержит начальную позицию найденного слова</li>
	<li>
<font color=green>@+</font> - массив, содержащий позицю последнего найденного слова</li>
</ul>

<p align=justify>
<font color=green>$&</font> - совпадение с шаблоном поиска, при последней операции поиска или замены. В отличии от переменной <font color=green>$_</font>, эту переменную переопределять как вздумается нельзя. 
<p align=justify>
<font color=green>$'</font> подстрока за совпадением с шаблоном поиска, её также можно только читать.
<p align=justify>
<font color=green>$`</font> - подстрока, расположенная перед совпадением, разрешается только её чтение.<p align=justify>
<font color=green>$^R</font> - результат вычисления утверждения в теле шаблона для последнего вычисления шаблона, если в нем идет счет или вызывается внешняя программа:

<pre>
<font color=green>$qwer="lala";
$qwer=~ /x(?{$var=5})/;
print $^R;
5</pre>
</font>
<font color=green>$+</font> - фрагмент совпадения в шаблоне, который в нем был последним в круглых скобках. Разрешается только чтение <font color=green>$+</font>.
<p align=justify>
<font color=green>$*</font> - разрешает выполнять поиск в многострочных файлах, булева переменная, если она взведена в <font color=green>1</font>,  то символы шаблона поиска <font color=green>^</font> и <font color=green>$</font> сопоставляются позициям перед и после внутренних символов новой строки, если <font color=green>0</font>, то от начала текста и до конца текста:

<pre>
<font color=green>$kim="lala\nfa\eti\nzvuki...";
$kim=~~ /^eti/; #совпадение не нашлось
$*=1;
$kim=~~ /^eti/; #совпадение нашлось</pre>
</font>

<font color=green>$n</font> - <font color=green>n</font>-ный фрагмент совпадения:

<pre>
<font color=green>print "$1 $2 $3\n" if(/^(\d)(\w)(\W)$/);</pre>
</font>

<font color=green>\n</font> - <font color=green>n</font>-ный фрагмент совпадения вызываемый в самом шаблоне, например поиск гиперссылок:

<pre>
<font color=green>/a href=(['"])(.*?)\1>/</pre>
</font>

Например нужно занести в массив только цифры из строчки <font color=green>"12@#34@@#@@###34@@##67##@@#@#@34"</font>:

<pre>
<font color=green>$_='12@#34@@#@@###34@@##67##@@#@#@34';
s/@/#/g;
s/(#)\1+/$1/g;
print join /\n/, split /#/, $_;</pre>
</font>

Регулярное выражение s/(#)\1+/$1/g; изпользует повторение переменной <font color=green>$1</font> (квантификатор <font color=green>+</font>) и если оно есть, то заменяет все подряд идущие <font color=green>#</font> между цифрами на одну #, содержащуюся в<font color=green>$1</font>(переменная <font color=green>$1</font> существует, если часть шаблона или шаблон указать в круглых скобках).
<p align=justify>
Допустим нужно определить, все ли цифры числа различны. Попробуем найти хотя-бы одно повторяющееся число:

<pre>
<font color=green>if(/(\d).*(?=\1)/g){
print "по крайней мере одна цифра $1 различна\n";
}</pre>
</font>


<p align=justify>Выражение берет 1-ю цифру и ищет её совпадения со всеми остальными, если есть, то говорит, что найдено и заканчивает работу. Регулярное выражение берет первое число при помощи (\d) и начинает его сравнивать со всеми остальными числами при помощи .*(?=\1). Если первое число в строке уникально, регулярное выражение начнет сопостовлять второе число со всеми восемью оставшимися числами. Если и второе число в строке уникально, то берется третье число и сравнивается со всеми остальными. И т.д., если совпадение было найдено, то регулярное выражение возвращает true и заканчивает свою работу, даже если в строке еще есть повторяющиеся числа.  Чтобы можно было просмотреть все повторяющиеся числа, можно воспользоваться модификацией предыдущего кода:

<pre>
<font color=green>$_ = '2314152467';
my @a = m/(\d)(?=\d*\1)/g ; 
if (@a){
  print join(',',@a)," - Repeat\n";
}
else{
  print "Ok\n" ;
}
</pre>
</font>
Этот усовершенствованный код работает до тех пор, пока не будут найдены все совпадения, если таковые вообще есть.
<p align=justify>
В perl 5.6 вводятся переменные <font color=green>@-</font> и <font color=green>@+</font>, комбинация которых может заменять переменные <font color=green>$`</font>, <font color=green>$&</font>, и <font color=green>$'</font>. После совпадения шаблона переменная <font color=green>$-[0]</font> содержит начало соответсвия текста шаблону, а переменная <font color=green>$+[0]</font> содержит конец соответсвия текста шаблону. В начале поиска обе являются нулями. Это значит, что можно вычислить значения <font color=green>$`</font>, <font color=green>$&</font>, и <font color=green>$'</font>:

<pre>
<font color=green>$do      = substr($stroka, 0, $-[0]);
$sovpalo = substr($stroka, $-[0], $+[0] - $-[0]);
$posle   = substr($stroka, $+[0]);</pre>
</font>

Например:

<pre>
<font color=green>$test="11-231234";
$test=~/\d{2}-\d{6}/;
print "$-[0], $+[0]";
0, 9
</pre>
</font>
<p align=justify>
Соответственное переменные <font color=green>$#-</font> и <font color=green>$#-</font> указывают размерность массивов <font color=green>@-</font> и <font color=green>@+</font>.
<p align=justify>
Переменная $^N.

<h3>
<a name="regex_html_work">Как работают регулярные выражения<a>
</h3>

<p align=justify>
Регулярные выражения, использующие квантификаторы, могут порождать процесс, который называется перебор с возвратом (backtracking). Чтобы произошло совпадение текста с шаблоном, надо построить соответствие между текстом и всем регулярным выражением, а не его частью. Начало шаблона может содержать квантификатор, который поначалу срабатывает, но впоследствии приводит к тому, что для части шаблона не хватает текста или возникает несоответствие между текстом и шаблоном. В таких случаях perl возвращается назад и начинает построение соответствия между текстом и шаблоном с самого начала, ограничивая "жадность" квантификатора (именно поэтому процесс и называется "перебор с возвратом"). 
Перечислим квантификаторы perl:
<ul>
	<li>
<font color=green>*</font> - ноль или несколько совпадений, </li>
	<li>
<font color=green>+</font> - одно или несколько совпадений, </li>
	<li>
<font color=green>?</font> - ноль совпадений или одно совпадение,   </li>
	<li>
<font color=green>{n}</font> - ровно <font color=green>n</font> совпадений,</li>
	<li>
<font color=green>{n,}</font> - по крайней мере <font color=green>n</font> совпадений,</li>
	<li>
<font color=green>{n,m}</font> - от <font color=green>n</font> до <font color=green>m</font> совпадений.</li>

</ul>

Например квантификатор <font color=green>+</font> соответствует фразе "один или несколько" и является жадным. Расмотрим пошагово принцип перебора с возвратом на примере квантификатора <font color=green>+</font>:

<pre>
<font color=green>'aaabc' =~/a+abc/;
</pre>
</font>

<font color=green>a+</font> сразу в силу жадности совпадает с тремя <font color=green>а</font>: 

<pre>
<font color=green>(aaa)bc</pre>
</font>

но после <font color=green>aaa</font> не следует строка "<font color=green>abc</font>", а следует "<font color=green>bc</font>". Поэтому результат - failed
поэтому анализатор должен откатиться назад и вернуть с помощью <font color=green>a+</font> два <font color=green>a</font>:

<font color=green>(aa)abc</font> 

т.е. на втором шаге шаблон найдет совпадение.
<p align=justify>
Рассмотрим пример работы еще одного жадного квантификатора <font color=green>*</font>(ноль или несколько совпадений):

<pre>
<font color=green>  amxdemxg    /.*m/</pre>
</font>
<p align=justify>
Сначала будет найдена вся строка <font color=green>abcdebfg</font> в силу жадности <font color=green>.*</font>, потом квантификатору нужно будет найти сравнение с буквой <font color=green>m</font>, произойдет ошибка. Квантификатор <font color=green>.*</font> отдаст одну букву и его содержимое будет уже <font color=green>amxdemx</font>. На конце снова нет буквы <font color=green>m</font>. Будет отдана еще одна буква и снова не будет найдено совпадение со всем шаблоном и наконец квантификатор <font color=green>.*</font> будет содержать подстроку <font color=green>amxde</font>, за которой уже стоит символ <font color=green>m</font>. И поиск на этом и закончится не смотря на то, что в строке <font color=green>amxdemxg</font> содержится не одна буква <font color=green>m</font>. Потому и говорят, что квантификаторы обладают жадностью, т.е. находят максимально возможное совпадение.
<p align=justify>
Допустим нужно найти совпадение:

<pre>
<font color=green>$uu="How are you? Thanks! I'm fine, you are ok??"; 
$uu=~s/.*you//;
print $uu;</pre>
</font>
<p align=justify>
Квантификатор <font color=green>.*</font> оставит  текст <font color=green>" are ok??"</font>, а вовсе не <font color=green>"? Thanks! I'm fine, you are ok??"</font>. Если же поставить ограничитель <font color=green>?</font>, который вместе со знаком квантификатора означает максимально возможное совпадение

<pre>
<font color=green>$uu="How are you? Thanks! I'm fine, you are ok??"; 
$uu=~s/.*you//;
print $uu;
</pre>
</font>
то переменная $uu будет содержать текст <font color=green>"? Thanks! I'm fine, you are ok??"</font>.

<p align=justify>
Предположим нужно найти совпадения типа network workshop, т.е. перекрытия.

<pre>
<font color=green>
$u='network';
$m='workshop';
print "перекрытие $2 найдено: $1$2$3\n" if("$u $m" =~/^(\w+)(\w+) \2(\w+)$/);</pre>
</font>

<font color=green>$1</font> сразу берет все слово в <font color=green>$u</font>, но дальше идет еще один максимальный квантификатор <font color=green>(\w+)</font>, которому тоже чего-то надо и он забирает из переменной <font color=green>\1</font> букву <font color=green>k</font>(причем только одну):

<pre>
<font color=green>
#!/usr/bin/perl
$uu="asdfg asdf";
$uu=/(\w+)(\w+)\s(\w+)(\w+)/;
print "$1 $2##$3 $4";
asdf g##asd f 
</pre>
</font>

далее пошаговая работа regex выглядит примерно так:

<pre>
<font color=green>
1: 'networ''k'=> '\sk' совпадает ли с '\sworkshop'     falure
2: 'netwo''rk'=> '\srk' совпадает ли с '\sworkshop'    falure
3: 'netw''ork'=> '\sork' совпадает ли с '\sworkshop'   falure
4: 'net''work'=> '\swork' совпадает ли с '\sworkshop'  ok
</pre>
</font>
и в результате программа выдаст:
<pre>
<font color=green>перекрытие work найдено: networkshop</pre>
</font>

Данный регексп не сработает, если 

<pre>
<font color=green>$u='networkwork';
$m='workshop';
</pre>
</font>
шаблон найдет перекрытия <font color=green>workwork</font>, а не <font color=green>work</font>. Чтобы этого избежать, нужно сделать минимальным  <font color=green>\1: /^(\w+?)(\w+) \2(\w+)$/</font>

<p align=justify>Квантификатор действует только на предшествующий ему элемент шаблона. Например, конструкция <font color=green>\d{2}[a-z]+</font> будет соответствовать последовательности из одной или нескольких строчных латинских букв, начинающейся с двух цифр, а не последовательности, составленной из чередующихся цифр и букв. Для выделения группы элементов, на которую действует квантификатор, используются круглые скобки: <font color=green>(\d{2}(a-z])+</font>
<p align=justify>


<h3>
<a name="regex_html_logika">Логические операции в регулярных выражениях</a>
</h3>

В регулярных выражениях perl есть синтаксические выражение, позволяющие в шаблонах использовать простые логические конструкции: 
<ul>
	<li>
<font color=green>(?= шаблон)</font> - после этой точки есть фрагмент текста, который соответствует указанному регулярному выражению</li>
	<li>
<font color=green>(?! шаблон)</font> - после этой точки нет текста, который бы соответствовал указанному регулярному выражению,</li>
	<li>
<font color=green>(?&lt;= шаблон)</font> - перед этой точкой есть фрагмент текста, соответствующий указанному регулярному выражению,</li>
	<li>
<font color=green>(?&lt;! шаблон)</font> - перед этой точкой нет фрагмента текста, соответствующего указанному регулярному выражению.</li>
	<li>
<font color=green>(?#текст)</font> - комментарий. Текст комментария игнорируется.</li>
	<li>
<font color=green>(?:шаблон)</font> или <font color=green>(?модификаторы:шаблон)</font> - группирует элементы шаблона. В отличие от обычных круглых скобок, не создает нумерованной переменной. Например, модификатор <font color=green>i</font> не будет делать различия между строчными и заглавными буквами, однако область действия этого модификатора будет ограничена только указанным шаблоном.</li>
	<li>
<font color=green>(?=шаблон)</font> - "заглядывание вперед". Требует, чтобы после текущей точки находился текст, соответствующий данному шаблону. Такая, конструкция обрабатывается как условие или мнимый символ, поскольку не включается В результат поиска. Например, поиск с помощью команды <font color=green>/w+(?=\s+)/</font> найдет слово, за которым следуют один или несколько "пробельных символов", однако сами они в результат не войдут.</li>
	<li>
<font color=green>(?!шаблон)</font> - случай, противоположный предыдущему. После текущей точки не должно быть текста, соотносимого с заданным шаблоном. Так, если шаблон <font color=green>w+(?=\s)</font> - это слово, за которым следует "пробельный символ", то шаблон <font color=green>w+(?!\s)</font> - это слово, за которым мет "пробельного символа".</li>
	<li>
<font color=green>(?&lt;=шаблон)</font> - заглядывание назад. Требует, чтобы перед текущей точкой находился соответствующий текст. Так, шаблон <font color=green>(?&lt;=\s)w+</font> интерпретируется как слово, перед которым имеется пробельный символ (в отличие от заглядывания вперед, заглядывание назад может работать только с фиксированным числом проверяемых символов).</li>
	<li>
<font color=green>(?&lt;!шаблон)</font> - отрицание предыдущего условия. Перед текущей точкой не должно быть текста, соотносимого с заданным шаблоном. Соответственно, от команды <font color=green>/(?&lt;!\s)w+/</font> требуется найти слово, перед которым нет пробельного символа.</li>
	<li>
<font color=green>(?{код})</font> - условие (мнимый символ), которое всегда выполняется. Сводится к выполнению команд perl в фигурных скобках. Вы можете использовать эту конструкцию, только если в начале сценария указана команда <font color=green>use re 'eval'</font>. При последовательном соотнесении текста и шаблона, когда perl доходит до такой конструкции, выполняется указанный код. Если полного соответствия для оставшихся элементов найти не удалось, то при возврате левее данной точки шаблона вычисления, проделанные с локальными переменными, откатываются назад. (Условие является экспериментальным. В документации, прилагаемой в perl, можно найти довольно детальное рассмотрение (с примерами) работы этого условия и возможных трудностей в случае его применения.)</li>
	<li>
<font color=green>(?&gt;шаблон)</font> - "независимый" или "автономный" шаблон. Используется для оптимизации процесса поиска, поскольку запрещает "поиск с возвратом". Такая конструкция соответствует подстроке, на которую налагается заданный шаблон, если его закрепить в текущей точке без учета последующих элементов шаблона. Например, шаблон <font color=green>(?&gt;а*)аb</font> в отличие от <font color=green>a*ab</font> не может соответствовать никакой строке. Если поставить в любом месте шаблон <font color=green>а*</font>, он съест все буквы <font color=green>а</font>, не оставив ни одной шаблону <font color=green>ab</font>. (Для шаблона <font color=green>а*аb</font> "аппетит" квантификатор <font color=green>*</font> будет ограничен за счет работы поиска с возвратами: после того как на первом этапе не удастся найти соответствие между шаблоном и текстом, perl сделает шаг назад и уменьшит количество букв <font color=green>а</font>, захватываемых конструкцией <font color=green>а*</font>.) </li>
	<li>
<font color=green>(?(условие)шаблон-да|шаблон-нет)</font> или (<font color=green>?(условие)шаблон-да)</font> - условный оператор, который подставляет тот или иной шаблон в зависимости от выполнения заданного условия. Более подробно описан в документации perl.</li>
	<li>
<font color=green>(?модификаторы)</font> - задает модификаторы, которые локальным образом меняют работу процедуры поиска. В отличие от глобальных модификаторов, имеют силу только для текущего блока, то есть для ближайшей группы круглых скобок, охватывающих конструкцию, Например, шаблон <font color=green>((?i)text)</font> соответcтвует слову "text" без учета регистра.</li>
</ul>

<p align=justify>

Поиск повторяющихся слов в регулярном выражении осуществляется при помощи т.н. обратных ссылок. Выше уже был приведен пример их использования для выбирания всех адресов рисунков с www.astronomynow.com:

<pre>
<font color=green>m{SRC\s*=\s*(["'])http://(.*?)\1\s+(.*?)WIDTH="100" HEIGHT="100"(.*?)>}igs</pre>
</font>

<font color=green>(["'])</font> - найти либо <font color=green>"</font> либо <font color=green>'</font> либо ничего, т.к. <font color=green>src=http://</font> может быть без кавычек. Как только был надено что-либо из этих трех позиций, через минимальное количество символов(регулярное выражение <font color=green>(.*?)</font>) символов оно заносится в специальную переменную <font color=green>\1</font>, которая вне <font color=green>m/.../</font> может быть вызвана как <font color=green>$1</font>(в <font color=green>s/.../.../</font> она вызывается в его левую половину как <font color=green>$1</font>). Дальше после <font color=green>*.gif|*.jpg|*.bmp</font> и т.д. должен обязательно идти хотя-бы один пробел <font color=green>\s+</font>, т.к. броузеры воспримут подстроку <font color=green>src=file.gifborder=0</font> как файл картинки с расширением <font color=green>gifborder=0</font>. Поэтому данное регулярное выражение вполне исправно работает, хотя оно было сделано для сайта, где в <font color=green>img src</font> ставится полный адрес, т.е. начинающийся с <font color=green>http://</font> Для других сайтов придется выстраивать полные пути в ссылках используя <font color=green>base href</font>, если есть или его <font color=green>url</font>. 

Если нужно найти какое-то по счету совпадение шаблона в строке, то это реализуется примерно так:

<pre>
<font color=green>while($str=~/WHAT/g){$n++}
$n++ while $str=~/WHAT/g;
$n++ while $str=~/(?=WHAT)/g;#для перекрывающихся совпадений
for($n=0; $n=~/WHAT/g; $n++){}</pre>
</font>

Каждое кратное совпадение 

<pre>
<font color=green>(++$n % 6) == 0;</pre>
</font>

Нужное Вам совпадение:

<pre>
<font color=green>$n=($str=~/WHAT/gi)[6]; #допустим шестое</pre>
</font>

Или каждое четное совпадение

<pre>
<font color=green>@mass=grep{$n++ %2==0} /WHAT/gi; </pre>
</font>

для нечетного нужно написать внутри <font color=green>grep</font>: <font color=green>$n++ %2==1</font>

Логические операции внутри регулярных выражений.


Если нужно найти последнее совпадение, то можно воспользоваться отрицанием опережающей проверки <font color=green>(?!WHAT)</font>:

<pre>
<font color=green>m#PATTERN(?!.*PATTERN)$#</pre>
</font>
т.е. нийти какой-то <font color=green>PATTERN</font>, при этом не должно найтись что-то еще(<font color=green>.*</font>) и <font color=green>PATTERN</font>, т.е. результат - последнее совпадение;

<p align=justify>

Минимальные квантификаторы <font color=green>*?</font>, <font color=green>+?</font>, <font color=green>??</font>,<font color=green>{}?</font>

<p align=justify>

допустим нужно найти двойку, перед которой не стоит 3 или пробел:

<pre>
<font color=green>print "$1\n" while m%2(?![3\s])gm%;</pre>
</font>
<p align=justify>

используется условие по отрицанию, <font color=green>A(?!B)</font>: найти <font color=green>А</font>, перед которым не находится <font color=green>В</font>. Чтобы найти двойку, за которой стоит 3 или пробле(<font color=green>\s</font>), то можно воспользоваться: 

<pre>
<font color=green>print "$1\n" while m%2(?=[3\s])gm%;</pre>
</font>

или 

<pre>
<font color=green>print "$1\n" while m%2(?![^3\s])gm%;</pre>
</font>
<p align=justify>
где используется <font color=green>^</font>, <font color=green>[^3\s]</font>, который значит следущее: в класс символов, которые нужно найти, не входят <font color=green>3</font> и пробел, или другими словами найти все кроме <font color=green>3</font> и <font color=green>\s</font>.
<p align=justify>

Допустим существует HTML-документ, в котором произвольное число вложенных таблиц [&<font color=green>lt;table&gt;.*&lt;/table&gt;</font>]. Требуется "вырезать" по очереди самые вложенные таблицы (не содержащие внутри [<font color=green>&lt;table&gt;.*&lt;/table&gt;</font>]), и, соответственно, выводить. И так - рекурсивно до конца вырезать изнутри всю таблицу. Ниже представлена программа, реализующая эту задачу при помощи логического оператора <font color=green>(?!...)</font>:

<pre>
<font color=green>
#!/usr/bin/perl -wT

$file=qq|s&lt;table&gt;aaa bbb
      &lt;table&gt;cc&lt;table&gt;ccc
      &lt;table&gt; 2&lt;table&gt;bb&lt;/table&gt; &lt;table&gt;cc&lt;/table&gt;    &lt;/table&gt;&lt;/table>cc
  &lt;/table&gt;
     ddd&lt;/table&gt;d
|;

print $file;
&req($file);
sub req {
  if($file=~m%(&lt;table&gt;((?!.*&lt;table&gt;).*?)&lt;/table&gt;)%igs){
    $file=~s%(&lt;table&gt;((?!.*&lt;table&gt;).*?)&lt;/table&gt;)%%igs;
    print "Virezali --$1--";
    &req($file);
  }
return $file;
}</pre>
</font> 

<p align=justify>
Продолжаем рассматривать логические операторы в регулярных выражениях на опретаорах типа OR, AND или NOT.
<p align=justify>

Регексп истиннен, если <font color=green>/AM|BMA/</font> или <font color=green>/AM/ || /BMA/</font> и если есть перекрытие типа <font color=green>/BMAM/</font>.
Так-же и <font color=green>/AM/ && /BMA/</font>: 

<pre>
<font color=green>/^(?=.*AM)(?=.*BMA)/s</pre>
</font>

Выражение истинно если <font color=green>/AM/ и /BMA/</font> совпадают при перекрытии которое не разрешено:

<pre>
<font color=green>/AM.*BMA|BMA.*AM/s</pre>
</font>

Выражение истинно, если шаблон <font color=green>/ABC/</font> не совпадает:

<pre>
<font color=green>!~/ABC/</pre>
</font> 

или

<pre>
<font color=green>/^(?:(?!ABC).)*$/s</pre>
</font>

Выражение истинно, если <font color=green>ABC</font> не совпадает, а <font color=green>VBN</font> совпадает:
<pre>
<font color=green>/(?=^(?:(?!ABC).)*$)VBN/s</pre>
</font>

Несовпадение можно проверить несколькими способами:

<pre>
<font color=green>unless($str =~ /MMM/){...}
if(!($str =~ /MMM/)){...}
if($str !~ /MMM/){...}</pre>
</font>

Для обязательного совпадения в двух шаблонах:

<pre>
<font color=green>unless ($str !~ /MMM/ && $str !~ /BBB/){...}
#или
if ($str =~ /MMM/ && $str =~ /BBB/){...}</pre>
</font>

Хотя бы в одном

<pre>
<font color=green>unless ($str !~ /MMM/ || $str !~ /BBB/){...}
#или
if ($str =~ /MMM/ || $str =~ /BBB/){...}</pre>
</font>










<p align="justify">
Регулярные выражения - основа работы с операторами <font color="Green">
<font color=green>m/.../</font>
</font> и <font color="Green">
<font color=green>s/.../.../</font>
</font>, так как они передаются последним в качестве аргументов. Разберемся, как устроено регулярное выражение <font color="Green">\b([A-Za-z)+)\b</font>, осуществляющее поиск отдельных слов в строке:
<pre>
<font color="Green">
$text = "Perl is the  subject.";
$text =~/\b([A-Za-z]+)\b/;
print $1;
</font>
</pre>
<p align="justify">
Выражение <font color="Green">\b([A-Za-z]+)\b</font> включает в себя группирующие метасимволы <font color="Green">(</font> и <font color="Green">)</font>, метасимвол границы слова <font color="Green">\b</font>, класс всех латинских букв <font color="Green">[A-Za-z]</font> (он объединяет заглавные и строчные буквы) и квантификатор <font color="Green">+,</font> который указывает на то, что требуется найти один или несколько символов рассматриваемого класса. Поскольку регулярные выражения, как это было в предыдущем примере, могут быть очень сложными, разберем их по частям. В общем случае регулярное выражение состоит из следующих компонентов:
<p align=justify>

Совпадение с любым символом<p align=justify>

В perl имеется еще один мощный символ - а именно, точка <font color=green>(.)</font>. В шаблоне он соответствует любому знаку, кроме символа новой строки. Например, следующая команда заменяет в строке все символы на звездочки (использован модификатор <font color=green>g</font>, обеспечивающий глобальную замену):
<pre>
<font color=green>$text = "Now is the time.";
$text =~ s/./*/g;
print $text;
********************</pre>
</font>
<p align=justify>
А что делать, если требуется проверить совпадение именно с точкой? Символы вроде точки (конкретно, <font color=green>\|()[{^$*+?.</font>), играющие в регулярном выражении осббую роль) называются, как уже было сказано выше, метасимволами, и если вы хотите, чтобы они внутри шаблона интерпретировались как обычные символы, метасимволу должна предшествовать обратная косая черта. Точно так же обратная косая черта предшествует символу, используемому в качестве ограничителя для команды <font color=green>
<font color=green>m/.../</font>
</font>, <font color=green>
<font color=green>s/.../.../</font>
</font> или <font color=green>
<font color=green>tr/.../.../</font>
</font>, если он встречается внутри шаблона и не должен рассматриваться как ограничитель. Рассмотрим пример: 

<pre>
<font color=green>$line = ".Hello!"; 
if ($1ine =- m/\./) {
  print "Shouldn't start a sentence with a perlod!\n";
}
Shouldn't start a sentence with a perlod!
</pre>
</font>

Если нужно найти самый короткий текстовый фрагмент <font color=green>/QQ(.*?)FF/</font> в <font color=green>"QQ ff QQ ff FF"</font>, однако оно найдет <font color=green>"ff QQ ff"</font>. Шаблон всегда находит левую строку минимальной длины, которая соответствует всему шаблону, т.е. это вся строка в этом примере. Для правильного шаблона нужно воспользоваться логическими операторами в регулярных выражениях: <font color=green>/QQ((?:(?!QQ).)*)FF/</font>,
т.е. сначала <font color=green>QQ</font>, потом <font color=green>не QQ</font>, потом <font color=green>FF</font>.

<p align=justify>
Конструкции <font color=green>(?&lt;=шaблoн)</font> и <font color=green>(?&lt;!шаблон)</font> работают только с шаблонами, соответствующими фиксированному числу символов. Иными словами, в шаблонах, указываемых для <font color=green>(?&lt;=...)</font> и <font color=green>(?&lt;!...)</font>, не должно быть квантификаторов.<p align=justify>
Эти условия полезны, если нужно проверить, что перед определенным фрагментом текста или после него находится нужная строка, однако ее не требуется включать в результат поиска. Это бывает необходимо, если в коде используются спе-циальные переменные <font color=green>$&</font> (фрагмент, для которого найдено соответствие между текстом и регулярным выражением), <font color=green>$`</font> (текст, предшествующий найденному фрагменту) и <font color=green>$'</font> (текст, следующий за найденным фрагментом). Более гибким представляется применение нумерованных переменных <font color=green>$1</font>, <font color=green>$2</font>, <font color=green>$3</font>, ... в которые заносятся отдельные части найденного фрагмента.<p align=justify>
В следующем примере ищется слово, за которым следует пробел, но сам пробел не включается в результат поиска:
<pre>
<font color=green>$text = "Маrу Tom Frank ";
while ($text =~ /\w+(?=\s)/g) {print $& . "\n";}
Маrу
Tom
Frank
</pre>
</font>
<p align=justify>
Того же результата можно добиться, если заключить в круглые скобки интересу-ющую нас часть шаблона и затем использовать ее как переменную <font color=green>$1</font>:
<pre>
<font color=green>$text = "Mary Tom Frank ";
while ($text =~ /(\w+)\s/g) {
  print $1 . "\n";
}
Маrу
Tom
Frank
</pre>
</font>
<p align=justify>
Следует четко понимать, что вы имеете в виду, когда используете то или иное условие. Рассмотрим следующий пример:
<pre>
<font color=green>
$text="Mary+Tom";
if($text=~m|(?!Mary\+)Tom|){
  print "Tom is without Mary!\n";
}
else{
  print "Tom is busy...\n";
}</pre>
</font>

Вопреки нашим ожиданиям, perl напечатает:
<font color=green>Tom is without Mary!</font>
Это произойдет по следующей причине. Пробуя различные начальные точки входной строки, от которой начинается сопоставление шаблона и текста, pеr1 рано или поздно доберется до позиции, расположенной прямо перед именем "<font color=green>Tom</font>". Условие <font color=green>(?!Маry\+)</font> требует, чтобы после текущей точки не находился текст *<font color=green>Маry+</font>", и это условие для рассматриваемой точки будет выполнено. Далее, perl последовательно проверяет, что после текущей точки следуют буквы "Т", "o" и "m", и это требование также в силе (после проверки условия <font color=green>(?!Маry\+)</font> текущая точка остается на месте). Тем самым найдено соответствие между подстрокой "Тоm" и шаблоном, поэтому команда поиска возвращает значение истина.<p align=justify>
Регулярное выражение <font color=green>(?!Mary\+)....Tom</font>, резервирующее четыре символа под текст "<font color=green>Маry+</font>", для приведенного выше случая выведет то, что требовалось, но выдаст ошибочный ответ, если перед именем "Тоm" нет четырех символов:

<pre>
<font color=green>
$text="O, Tom! ";
if($text =~ m|(?!Mary\+)....Tom|){
  print "Tom is without Mary!\n";
}
else{
  print "Tom is busy...\n";
}

Tom is busy...
</pre>
</font>
Наконец, если более точно сформулировать, чего требуется, получится нужный результат: 
<pre>
<font color=green>
$text="Mary+Tom";
if($text=~m|(?&lt;!Mary\+)Tom|){
  print "Tom is without Mary!\n";
}
else{
  print "Tom is busy...\n";
}

Tom is busy...
</pre>
</font>

Вспомнить и написать про строчку вида 

<pre>
<font color=green>push @mass, $li unless($li=~m/(([2 .. 12]).*?1995)|(([6 .. 12]).*?2001)|/)</pre>
</font>; perldoc perlop [0-9.]


<p align=justify>
Модификаторы команд <font color=green>
<font color=green>m/.../</font>
</font> и <font color=green>
<font color=green>s/.../.../</font>
</font>
<p align=justify>
В perl имеется несколько модификаторов, используемых с командами <font color=green>
<font color=green>m/.../</font>
</font> и <font color=green>
<font color=green>s/.../.../</font>
</font>:
<ul>
	<li>
<font color=green>i</font> - игнорирует различие между заглавными и строчными буквами. </li>
	<li>
<font color=green>s</font> - метасимволу "точка" разрешено соответствовать символам <font color=green>\n</font>.</li>
	<li>
<font color=green>m</font> - разрешает метасимволам <font color=green>^</font> и <font color=green>$</font> привязываться к промежуточным символам <font color=green>\n</font>, имеющимся в тексте. Не влияет на работу метасимволов <font color=green>\А</font>, <font color=green>\Z</font> и <font color=green>\z</font>.</li>
	<li>
<font color=green>х</font> - игнорирует "пробельные символы" в шаблоне (имеются в виду "истинные" пробелы, а не метасимволы <font color=green>\s</font> и пробелы, созданные через escape-последовательности). Разрешает использовать внутри шаблона комментарии.</li>
	<li>
<font color=green>g</font> - выполняет глобальный поиск и глобальную замену.</li>
	<li>
<font color=green>с</font> - после того как в скалярном контексте при поиске с модификатором <font color=green>g</font> не удалось найти очередное совпадение, не позволяет сбрасывать текущую позицию поиска. Работает только для команды <font color=green>
<font color=green>m/.../</font>
</font> и только вместе с модификатором <font color=green>g</font>.</li>
	<li>
<font color=green>о</font> - запрещает повторную компиляцию шаблона при каждом обращении к данному оператору поиска или замены, пользователь, однако, должен гарантировать, что шаблон не меняется между вызовами данного фрагмента кода.</li>
	<li>
<font color=green>е</font> - показывает, что правый аргумент команды <font color=green>
<font color=green>s/.../.../</font>
</font> - это фрагменты выполняемого кода. В качестве текста для подстановки будет использовано возвращаемое значение - возможно, после процесса интерполяции.</li>
	<li>
<font color=green>ee</font> - показывает, что правый аргумент команды <font color=green>
<font color=green>s/.../.../</font>
</font> - это строковое выражение, которое надо вычислить и выполнить как фрагмент кода (через функцию <font color=green>eval</font>). В качестве текста для подстановки используется возвращаемое значение - возможно, после процесса интерполяции </li>
</ul>
<p align=justify>
Особенности работы команд <font color=green>
<font color=green>m/.../</font>
</font> и <font color=green>
<font color=green>s/.../.../</font>
</font>
<p align=justify>

До сих пор мы рассматривали регулярные выражения, используемые в качестве шаблонов для команд <font color=green>
<font color=green>m/.../</font>
</font> и <font color=green>
<font color=green>s/.../.../</font>
</font>, и не особо интересовались, как работают эти команды. Настало время восполнить пробелы.<p align=justify>
Команда <font color=green>
<font color=green>m/.../</font>
</font> ищет текст по заданному шаблону. Ее работа и возвращаемое значение сильно зависят от того, в скалярном или списковом контексте она используется и имеется ли модификатор <font color=green>g</font> (глобальный поиск). <p align=justify>
Команда <font color=green>
<font color=green>s/.../.../</font>
</font> ищет прототип, соответствующий шаблону, и, если поиск оказывается успешным, заменяет его на новый текст. Без модификатора замена производится только для первого найденного совпадения, с модификатором <font color=green>g</font> выполняются замены для всех, совпадений во входном тексте. Команда возвращает в качестве результата число успешных замен или пустую строку (условие ложь false), если ни одной замены сделано не было.  
В качестве анализируемого текста используется <font color=green>$_</font> (режим по умолчанию) или выражение, присоединенное к шаблону с помощью оператора <font color=green>=~</font> или <font color=green>!~</font>. В случае поиска (команда <font color=green>
<font color=green>m/.../</font>
</font>) конструкция, расположенная слева от операторов <font color=green>=~</font> или <font color=green>!~</font>, может и не быть переменной. В случае замены (команда <font color=green>
<font color=green>s/.../.../</font>
</font>) в левой части должна стоять скалярная переменная, или элемент массива, или элемент хэша, или же команда присвоения одному из указанных объектов.<p align=justify>
Вместо косой черты в качестве ограничителя для аргументов команд <font color=green>
<font color=green>m/.../</font>
</font> и <font color=green>
<font color=green>s/.../.../</font>
</font> можно использовать любой символ, за исключением "пробельного символа", буквы или цифры. Например, в этом качестве можно использовать символ комментария, который будет работать как ограничитель:

<pre>
<font color=green>$text="ABC-abc";
$text =~ s#B#xxx#ig;
print $text;
AxxxC-axxxc
</pre>
</font>
<p align=justify>
В качестве ограничителей не стоит использовать вопросительный знак и апостроф (одинарную кавычку) - шаблоны, с такими ограничителями обрабатываются специалиным образом.
Если команда <font color=green>
<font color=green>m/.../</font>
</font> использует символ косой черты в качестве разделителя, то букву m можно опустить:
<pre>
<font color=green>
while (defined($text = &lt;&gt;)) 
{ if ($text =~/^exit$/i) {exit;} }</pre>
</font>
<p align=justify>
Если в качестве ограничителя для команды <font color=green>
<font color=green>m/.../</font>
</font> используется вопросительный знак, то букву m также можно опустить. Однако шаблоны, ограниченные символом <font color=green>?</font>, в случае поиска работают особым образом (независимо от наличия или отсутствия начальной <font color=green>m</font>). А именно, они ведут себя как триггеры, которые срабатывают один раз и потом выдают состояние ложь (false), пока их не взведут снова, вызвав функцию reset (она очищает статус блокировки сразу всех конструкций <font color=green>?...?</font>, локальных для данного пакета). Например, следующий фрагмент сценария проверяет, есть ли в файле пустые строки:
<pre>
<font color=green>while (&lt;&gt;)
if (?^$?) {print ."There is an empty line nere.\n";} continue {
reset if eof;   #очистить для следующего файла
}</pre>
</font>
<p align=justify>
Диагностическое сообщение будет напечатано только один раз, даже если в файле присутствует несколько пустых строк. Команда поиска с вопросительным знаком относится к подозрительным командам, а потому может не войти в новые версии perl.                      1
В качестве ограничителей можно также использовать различные (парные) койструкции скобок:
<pre>
<font color=green>while (&lt;&gt;){
  if(m/^quit$/i){exit;}
  if(m(^stop$)i){exit;} 
  if(m[^end$]i) {exit;} 
  if(m{^bye$}i) {exit;}
  if (!1)&lt;^ехit$&gt;i) {exit;}
}
</pre>
</font>
В случае команды <font color=green>
<font color=green>s/.../.../</font>
</font> и использования скобок как ограничителей для первого аргумента, ограничители второго аргумента могут выбираться независимо:
<pre>
<font color=green>$text =~ "Perl is wonderful"; 
$text =~ s/is/is very/;
$text =~ s[wonderful]{beautiful};
$text =~ s(\.)/!/;
print $text;
Perl is very beautiful!
</pre>
</font>
<p align=justify>
Предварительная обработка регулярных выражений<p align=justify>
Аргументами команд <font color=green>
<font color=green>m/.../</font>
</font> и <font color=green>
<font color=green>s/.../.../</font>
</font> являются регулярные выражения, которые перед началом работы интерполируются подобно строкам, заключенным в двойные кавычки  В отличие от текстовых строк, для шаблона не выполняется интерполяция имен типа <font color=green>$)</font>, <font color=green>$|</font> и одиночного <font color=green>$</font> - perl считает, что такие конструкции соответствуют метасимволу конца строки, а не специальной переменной. Если же в результате интерполяции шаблон поиска оказался пустой строкой, perl использует последний шаблон, который применялся им для поиска или замены.
<p align=justify>
Если вы не хотите, чтобы perl выполнял интерполяцию регулярного выражения, в качестве ограничителя надо использовать апостроф (одиночную кавычку), тогда шаблон будет вести себя, как текстовая строка, заключенная в апострофы. Однако, например, в случае команды замены <font color=green>
<font color=green>s/.../.../</font>
</font> с модификатором е или ее (их работа описывается чуть дальше) для второго аргумента будет выполняться интерполяция даже в том случае, если он заключен в апострофы. 
<p align=justify>
Если вы уверены, что при любом обращениик команде поиска или замены шаблон остается неизменным (например, несмотря на интерполяцию, скалярные переменные внутри шаблона не будут менять своего значения), то можно задать модификатор <font color=green>о</font>. Тогда perl компилирует шаблон в свое внутреннее представление только при первой встрече с данной командой поиска или замены. При остальных обращениях к команде будет использовать откомпилированное значение. Однако, если внезапно изменить значение переменных, задействованных в шаблоне, perl этого даже не заметит.
<p align=justify>
Команда замены <font color=green>
<font color=green>s/.../.../</font>
</font> использует регулярное выражение, указанное в качестве второго аргумента, для замены текста. Поскольку оно обрабатывается (интерполируется) после того, как выполнена очередная операция поиска, в нем можно, в частности, использовать временные переменные, созданные на этапе поиска. В следующем примере мы последовательно заменим местами пары слов, заданных во входном тексте, оставив между ними по одному пробелу:
<pre>
<font color=green>$text = "One   Two   Three   Four  Five   Six";
$text =- s/(\w+)\s*(\w+)/$2$1/g;    
Two One Four Three Six Five
</pre>
</font>
<p align=justify>Однако perl допускает и более сложные способы определения заменяющего текста. Так, если для команды <font color=green>
<font color=green>s/.../.../</font>
</font> указать модификатор <font color=green>е</font>, то в качестве второго аргумента надо указать код, который необходимо выполнить (например, вызвать функцию). Полученное выражение будет использованокак текст для подстановки. При этом после вычисления текстового значения, но перёд его подстановкой будет выполнен процесс интерполяции, аналогичный процессу интерполяции текстовых строк, заключенных в двойные кавычки. Еще более сложная схема реализуется, если задан модификатор <font color=green>ее</font>. В этом слу-чае второй аргумент команды <font color=green>
<font color=green>s/.../.../</font>
</font> - это строковое выражение, которое сперва надо вычислить (то есть интерполировать), затем выполнить в качестве кода (вызвав встроенную функцию <font color=green>eval</font>) и только после второй интерполяции полученный результат подставляется вместо найденного текста.<p align=justify>

Работа команды <font color=green>m/.../</font> в режиме однократного поиска <font color=green>
</font>

В скалярном контексте и без модификатора <font color=green>g</font> команда <font color=green>
<font color=green>m/.../</font>
</font> возвращает логическое значение - целое число <font color=green>1</font> (истина (true)), если поиск оказался успешным, и пустую строку "" (ложь (false)), если нужный фрагмент текста найти не удалось. Если внутри шаблона имеются группы элементов, заключенные в круглые скобки, то после операции поиска создаются нумерованные переменные <font color=green>$1</font>, <font color=green>$2</font>, ..., в которых содержится текст, соответствующий круглым скобкам. В частности, если весь шаблон заключить в круглые скобки, то в случае успешного поиска переменная <font color=green>$1</font> будет содержать текст, соотнесенный с шаблоном. После успешного поиска можно также использовать специальные переменные <font color=green>$&</font>, <font color=green>$'</font>, <font color=green>$'</font> и <font color=green>$+</font>

<pre>
<font color=green>$text = "---one---two---three---";
$scalar = ($text =' m/(\w+)/); 
print "Result: $scalar ($1).";
Result: 1 (one).
</pre>
</font>
<p align=justify>
Если вы используете команду <font color=green>
<font color=green>m/.../</font>
</font> в списковом контексте, то возвращаемое значение сильно зависит от того, есть ли группы из круглых скобок в вашем шаблоне. Если они есть (то есть если создаются нумерованные переменные), то после успешного поиска в качестве результата будет получен список, составленный из нумерованных переменных (<font color=green>$1</font>, <font color=green>$2</font>,...):

<pre>
<font color=green>$text = "---one,   two,   three---";
╘array = ($text ='m/(\w+),\s+(\w+),\s+(\w+)/);
print join "=", ╘array;
one=two=three.
</pre>
</font>
<p align=justify>
В отличие от ранних версий, perl 5 присваивает значения нумерованным переменным, даже если команда поиска работает в списковом контексте: 

<pre>
<font color=green>$text = "---one,   two,   three--- ";
($Fa, $Fb, $Fc) = ($text=-m/(\w+),\s+(\w+),\s+(\w+)/);
print "/$Fa/$Fb/$Fc/\n";
print "$1=$2=$3.\n";
/one/two/three/
one=two::three.
</pre>
</font>
<p align=justify>
Если же в шаблоне нет групп, выделенных круглыми скобками, то в случае успешного поиска возвращается список, состоящий из одного элемента - числа <font color=green>1</font>. При неудачном поиске независимо от того, были ли в шаблоне круглые скобки, возвращается пустой список:
<pre>
<font color=green>$text = "---one,   two,   three--- ";
@array = ($text=~ m/z\w+/);
print "Result: /", @array, "/\n"; 
print "Size: ", $#array+1, ".\n";
Result://
Size: 0. 
</pre>
</font>Обратите внимание на разницу между пустым и неопределенным списками.
<p align=justify>
Работа команды <font color=green>m/.../</font> в режиме глобального поиска<p align=justify>

Команда <font color=green>
<font color=green>m/.../</font>
</font> работает иначе, если указан модификатор <font color=green>g</font>, задающий глобальный поиск всех вхождений шаблона по всему тексту. Если оператор используется в списковом контексте и в шаблоне есть группы круглых скобок, то в случае удачного поиска возвращается список, состоящий из всех найденных групп, расположенных друг за другом:

<pre>
<font color=green>$text = "---one---two-~-three---";
@array = ($text =~m/(-(\w+))/);
print "Single: [", join(", ", ╘array),"].\n";
@array = ($text =~m/(-(\w+))/g);
print "Global: [", join(", ", ╘array),"].\n";
Single: [-one, one]. 
Global: [-one, one, -two, two, -three, three].
</pre>
</font>
<p align=justify>

Если же в шаблоне нет групп круглых скобок, то оператор поиска возвращает список всех найденных прототипов шаблона, то есть ведет себя так, как если бы весь шаблон был заключен в круглые скобки:
<pre>
<font color=green>$text = "---one---two---three--";
@array = ($text =~m/\w+/);
print "Result: (", join(", ", @array), ").\n";
Result: (one, two, three).
</pre>
</font>
В случае неудачного поиска, как и в предыдущих вариантах, возвращается пустой список.  
В скалярном контексте и с модификатором <font color=green>g</font> комaндa <font color=green>
<font color=green>m/.../</font>
</font> ведет себя сивершенно особым образом. Специальная переменная <font color=green>$_</font> или переменная, стоящая слева от оператора <font color=green>=~</font> или <font color=green>!~</font>, при поиске с модификатором <font color=green>g</font> получает дополнительные свойства - в нее записывается последнее состояние. При каждом последующем обращении к данному фрагменту кода поиск будет продолжаться с того места, на котором он остановился в последний раз. Например, следующая команда подсчитывает количество букв х в заданной строке текста:
<pre>
<font color=green>
$text = "Here is texxxxxt.";
$counter = O;
while ($text =~ m/x/g){
print "Found another x.\n";
$conter++;
print "Total amount = $counter.\n";
Found another х. 
Found another х.
Found another x.
Found another x. 
Found another x.
Total amount = 5.
</pre>
</font>
<p align=justify>
Состoяние (точнее, позиция) поиска сохраняется даже в случае перехода к следующему оператору поиска, имеющему модификатор <font color=green>g</font>. Неудачный поиск сбрасывает значение в исходное состояние, если только для команды <font color=green>
<font color=green>m/.../</font>
</font> не указан модификатор <font color=green>с</font> (то есть команда должна иметь вид <font color=green>
<font color=green>m/.../</font>gc</font>). Изменение текстового буфера, для которого выполняется поиск, также сбрасывает позицию поиска в исходное состояние. В следующем примере из текстовой строки последовательно извлекаются и выводятся пары имя/значение до тех пор, пока строка не закончится:<pre>
<font color=green>
$text = "X=5; z117e=3.14l6; temp=lQ24;";
$docycle = 1; $counter = 0;
while ($docycle) { 
  undef $name; undef $value;
  if ($text =~ m/(\w+)\s*=\s*/g) {$name = $1;} 
  if ($text =~ m/([\d\.\*\-]*)\s*;/g) {$value = $1;}
  if (defined($name) and defined($value)) { 
    print "Name=$name, Value=$value.\n";
    $counter++,
  }else{
    $docycle = 0;
  }
}
print "I have found $conter values.\n";
Name=X, Value=5.
Name=z117e, Value=3.1416. 
Name=temp, Value=1024.
I have found 3 values.</pre>
</font>

Позиция, на которой остановился поиск, может быть прочитана и даже переустановлена с помощью встроенной функции perl <font color=green>pos</font>. В шаблоне на текущую позицию поиска можно ссылаться с помощью метасимвола <font color=green>\G</font>. В следующем примере из строки последовательно извлекаются буквы <font color=green>p</font>, <font color=green>o</font> и <font color=green>q</font> и выводится текущая позиция поиска:

<pre>
<font color=green>$index = 0;
$_ = "ppooqppqq";
while ($index++ &lt; 2) {
print "1: '";
print $1 while /(o)/gc; print "', pos=", pos, "\n";
print "2: '";
print $1 if /\G(q)/gc; print "', pos=";' pos, "\n";
print "3: '";
print while /(p)/gc; print "', pos=",pos, "\n";
} 

1: 'oo', pos=4;
2: 'q', pos=7;
3: 'pp', pos=4;
1: '', pos=7;
2: 'q', pos=8;
3: '', pos=8;
</pre>
</font>
<p align=justify>
В документации perl приводится основанный на этом механизме интересный пример последовательного лексического разбора текста. В нем каждая последующая команда поиска очередной лексической единицы начинает выполнятьсяс того места, где завершила свою работу предыдущая. Советую внимательно разобраться с этим примером (страница руководства <font color=green>perlop</font>, раздел "<font color=green>Regexp Quote-Uke Operators</font>", описание команды <font color=green>m/PATTERN/</font>), если вы хотите расширить доступный вам инструментарий perl!
<p align=justify>
Замена строк с помощью команды <font color=green>
<font color=green>tr/.../.../</font>
</font>
<p align=justify>

Кроме команд <font color=green>
<font color=green>m/.../</font>
</font> и <font color=green>
<font color=green>s/.../.../</font>
</font> строки можно обрабатывать с помощью команды <font color=green>
<font color=green>tr/.../.../</font>
</font> (она же - команда <font color=green>у/.../.../</font>):

<pre>
<font color=green>
tr/список1/список2/модификаторы;
у/список1/список2/модификаторы;
</pre>
</font>
<p align=justify>
В отличие от <font color=green>
<font color=green>m/.../</font>
</font> и <font color=green>
<font color=green>s/.../.../</font>
</font>, эта команда не использует шаблоны и регулярные выражения, а выполняет посимвольную замену, подставляя в текст вместо литер из первого списка соответствующие им литеры из второго списка. Например, в следующем случае производится замена литер "<font color=green>i</font>" на "<font color=green>о</font>":
<font color=green>
$text = "My name is Tim.";
$text =~ tr/i/o/;
print $text;   
My name is Tom.
</font>
<p align=justify>
В качестве списков используются идущие друг за другом символы, не разделяемые запятыми (то есть это скорее строки, чем списки). В отличие от шаблонов команд <font color=green>m/.../</font>
</font> и <font color=green>s/.../.../</font>
</font>, аргументы команды <font color=green>
<font color=green>tr/.../.../</font>
</font> не интерполируются (то есть подстановки значений вместо имен переменных не происходит), хотя escape-последовательности, указанные внутри аргументов, обрабатываются правильно.
Подобно <font color=green>m/.../</font> и <font color=green>s/.../.../</font>, команда <font color=green>
<font color=green>tr/.../.../</font>
</font> пo умолчанию работает с переменной <font color=green>$_</font>:
<pre>
<font color=green>while (&lt;&gt;){
tr/iI/jJ/;
print;
</pre>
</font>
<p align=justify>
 В качестве списков можно указывать диапазоны символов - как, например в следующем фрагменте кода, заменяющем строчные буквы на заглавные:
<font color=green>$text = "Here is the text.";
$text =~ tr/a-z/A-Z/; 
print $text;
HERE IS THE TEXT.
</font> <p align=justify>
Как и в случае <font color=green>
<font color=green>m/.../</font>
</font> u <font color=green>s/.../.../</font>, команда <font color=green>tr/.../.../</font> не требует использовать именно знаки косой черты в качестве ограничителей. Можно использовать практически любой символ, отличный от "пробельных", букв и цифр, а также парные скобочные конструкции.<p align=justify>
Команда <font color=green>tr/.../.../</font> возвращает число успешных замен. В частности, если не было сделано никаких замен, она возвращает число ноль. Это позволяет, например, подсчитать с помощью команды <font color=green>tr/.../.../</font> количество вхождений буквы <font color=green>х</font> в строку <font color=green>$text</font>, не меняя содержимого этой переменной:
<font color=green>$text = "Here is the text.";
$xcount = ($text =~tr/x/x/);
print $xcount;
1 </font>
Если у команды <font color=green>tr/.../.../</font> нет модификаторов (см. далее раздел "Модификаторы команды <font color=green>tr/.../.../</font>"), то ее аргументы при обычных условиях должны быть одинаковой длины. Если второй аргумент длиннее первого, то он усекается до длины первого аргумента - так, команда <font color=green>tr/abc/0-9/</font> эквивалентна команде <font color=green>tr/abc/012/</font>. Если первый аргумент длиннее второго и второй не пуст, то для второго аргумента необходимое число раз повторяется его последний символ - так, команда <font color=green>tr/O-9/abc/</font> эквивалентна команде <font color=green>tr/0123456789/abcccccccc/</font>. Если же второй, аргумент пуст, то команда <font color=green>tr/.../.../</font> подставляет вместо него первый аргумент.
<p align=justify>
Как легко заметить, если второй аргумент пуст, то (при отсутствии модификаторов) команда <font color=green>tr/.../.../</font> не производит никаких действий, а возвращаемое ею значение равно числу совпадений между первым аргументом и обрабатываемым текстом. Например, следующая команда подсчитывает количество цифр в строке:
<pre>
<font color=green>$text = "Pi=3.1415926536, е=2.7182"; 
$digit_counter=($text =~ tr/0-9//); 
print $digit_counter;
16
</pre>
</font>
<p align=justify>Команда <font color=green>tr/.../.../</font> работает без рекурсии, просто последовательно заменяет символы входного текста. Например, для замены заглавных букв на строчные, и на-оборот, достаточно выполнить команду:
<pre>
<font color=green>$text = "MS Windows 95/98/NT";
$text =" tr/A-Za-z/a-zA-Z/;
print $text;
ms WINDOWS 95/98/nt</pre>
</font>
<p align=justify>
Если в списке, указанном в качестве первого аргумента, есть повторяющиеся символы, то для замены используется первое вхождение символа:
<pre>
<font color=green>$text = "Billy Gates";
$text =~ tr/ttt/mvd/;
print $text;
Billy Games
</pre>
</font>Модификаторы команды <font color=green>tr/.../.../</font>
<p align=justify>
Команда <font color=green>tr/.../.../</font> допускает использование следующих модификаторов: 
<ul>
	<li>
<font color=green>d</font> - удаляет непарные символы, не выравнивая аргументы по длине. </li>
	<li>
<font color=green>с</font> - в качестве первого аргумента использует полный список из 256 символов за вычетом указанных в списке символов.</li>
	<li>
<font color=green>s</font> - удаляет образовавшиеся в результате замены повторяющиеся символы. </li>
</ul>
<p align=justify>
Если указан модификатор <font color=green>d</font>, a первый аргумент команды длиннее второго, то все символы из первого списка, не имеющие соответствия со вторым списком, удаляются из обрабатываемого текста. Пример: удаляем строчные латинские буквы и заменяем пробелы на слэши:
<pre>
<font color=green>$text = "Here is the text.";
$text =~ tr[ a-z][/]d;
print $text;
H///.</pre>
</font>
<p align=justify>
 Наличие модификатора <font color=green>d</font> - единственный случай, когда первый и второй аргументы не выравниваются друг относительно друга, В остальных вариантах второй аргумент либо усекается, либо последний символ в нем повторяется до тех пор, пока аргументы не сравняются, либо, если второй аргумент пуст, вместо Второго аргумента берется копия первого.<p align=justify>
Если указан модификатор <font color=green>с</font>, то в качестве первого аргумента рассматриваются все символы, кроме указанных. Например, заменим на звездочки все символы, кроме строчных латинских букв:
<pre>
<font color=green>$text = "Here is the text,";
$text =' tr/a-z/*/c;
print $text;
*ere*is*the*text*
</pre>
</font>
<p align=justify>
Если указан модификатор <font color=green>s</font>, то в случае если замещаемые символы образуют цепочки из одинаковых символов, они сокращаются до одного. Например, заменим слова, состоящие из латинских букв, на однократные символы косой черты:
<pre>
<font color=green>$text = "Here is the text.";
$text ="tr(A-Za-z)(/)s;
print $text;
/ / / /. 
</pre>
</font>Без модификатора <font color=green>s</font> результат был бы другим:
<pre>
<font color=green>$text = "Here is the text.";
$text =' tr(A-Za-z)(/);
print $text;
//// // /// ////.</pre>
</font>

Примеры: <br>
1. Заменить множественные пробелы и нетекстовые символы на одиночные пробелы:
<pre>
<font color=green>$text = "Here   is   the   text."
$text =~ tr[\000-\040\177\377][\040]s;
print $text;
Here is the text. </pre>
</font>
2. Сократить удвоенные, утроенные и т.д. буквы;
<pre>
<font color=green>$text = "Here is the texxxxxxt.";
$text =~ tr/a-zA-Z/s;
print $text;
Here is the text.</pre>
</font>
3. Пересчитать количество небуквенных символов:
<pre>
<font color=green>$xcount=($text =~ tr/A-Za-z//c);</pre>
</font>
4. Обнулить восьмой бит символов, удалить нетекстовые символы:
<pre>
<font color=green>$text =- tr{\200-\377}{\000-\l77};
$text =~ tr[\000-\037\177][]d;</pre>
</font>
5. Заменить нетекстовые и 8-битные символы на одиночный пробел:
<pre>
<font color=green>$text =~ tr/\021-\176/ /cs;</pre>
</font>
Поиск отдельных слов<p align=justify>
Чтобы выделить слово, можно использовать метасимвол \S соответствующий символам, отличным от "пробельных":
<pre>
<font color=green>$text = "Now is the time.";
$text =- /(\S+)/;
print $1;
Now</pre>
</font>

Однако метасимвол <font color=green>\S</font> соответствует также и символам, обычно не используемым для идентификаторов. Чтобы отобрать слова, составленные из латинских букв, цифр и символов подчеркивания, нужно использовать метасимвол <font color=green>\w</font>: <pre>
<font color=green>$text = "Now is the time.";
$text =~ /(\w+)/;
print $1;
Now
</pre>
</font>
Если требуется включить в поиск только латинские буквы, надо использовать класс символов:
<pre>
<font color=green>$text = "Now is the time.";
$text =~ /([A-Za-z]+)/;
print $1;
Now
</pre>
</font>
Более безопасный метод состоит в том, чтобы включить в шаблон мнимые символы границы слова:
<pre>
<font color=green>$text = "How is the time.";
$text=~/\b([A-Za-z]+)\b/;
print $1;
Now
</pre>
</font>
Привязка к началу строки<p align=justify>

Началу строки соответствует метасимвол (мнимый символ) <font color=green>^</font>. Чтобы шаблон к началу строки, надо задать этот символ в начале регулярного выражения. Например, вот так можно проверить, что текст не начинается с точки:
<pre>
<font color=green>$line = ".Hello!";
if($line=~m/^\./){
  print "Shouldn't start a sentence with a period!\n";
}
Shouldn't start a sentence with a period!
</pre>
</font>
<p align=justify>Чтобы точка, указанная в шаблоне, не интерпретировалась как метасимвол перед ней пришлось поставить обратную косую черту.<p align=justify>
Привязка к концу строки<p align=justify>
Чтобы привязать шаблон к концу строки, используется метасимвол (мнимый символ) <font color=green>$</font>. В нашем примере мы используем привязку шаблона к началу и к концу строки, чтобы убедиться, что пользователь ввел только слово "exit":
<pre>
<font color=green>while(&lt;&gt;){
  if(m/"exlt$/) {exit;}
}</pre>
</font>
Поиск чисел<p align=justify>
Для проверки того, действительно ли пользователь ввел число, можно использо-вать метасимволы <font color=green>\d</font> и <font color=green>\D</font>. Метасимвол <font color=green>\D</font> соответствует любому символу, кроме цифр. Например, следующий код проверяет, действительно ли введенный текст представляет собой целое значение без знака и паразитных пробелов:
<pre>
<font color=green>$test = "Hello!";
if($text =~ /\D/){
print "It is not a number.\n";
}
It is not a number.
</pre>
</font>To же самое можно проделать, использовав метасимвол \d:
<pre>
<font color=green>$text = "333";
if($text =~ /^\d+$/){
print "It is a number.\n";
}
It is a number.</pre>
</font>
<p align=justify>
Вы можете потребовать, чтобы число соответствовало привычному формату. То есть число может содержать десятичную точку, перед которой стоит по краййей мере одна цифра и, возможно, какие-то цифры после нее:
<pre>
<font color=green>$text= "3,1415926";
if($text =~ /^(\d+\.\d*|\d+)$/){
print "It is a number.\n";
}
It is a number.
</pre>
</font>
<p align=justify>
Кроме того, при проверке можно учитывать тот факт, что перед числом может стоять как плюс, так и минус (или пустое место):
<pre>
<font color=green>$text = "-2.7182";
if ($text =~ /^([+-]*\d+)(\.\d*|)$/) { 
print "It is a number.\n";</pre>
</font>
<p align=justify>
Поскольку плюс является метасимволом, его надо защищать обратной косой чертой. Однако внутри квадратных скобок, то есть класса символов, он не может быть квантификаторам. Знак "минус" внутри класса символов обычно играет роль оператора диапазона и поэтому должен защищаться обратной косой чертой. Однако в начале или в конце шаблона он никак не может обозначать диапазон, и поэтому обратная косая черта необязательна. Наконец, более строгая проверка, требует, чтобы знак, если он присутствует, был только один:

<pre>
<font color=green>$text = "+0.142857142857142857"; 
if ($text =~ /^(+|-|)\d+(\.\d*\)$/) {
  print "It is a number.\n";
}
It is a number.</pre>
</font>
<p align=justify>
Альтернативные шаблоны, если они присутствуют, проверяются слева направо. Перебор вариантов обрывается, как только найдено соответствие между текстом и шаблоном. Поэтому, например, порядок альтернатив в шаблоне <font color=green>(\.\d*|)</font> мог бы стать критичным, если бы не привязка к концу строки. Наконец, вот как можно произвести проверку того, что текст является шестна-дцатеричным числом без знака и остальных атрибутов:
<pre>
<font color=green>$text = "1AO";
unless (ftext =~ m/^[a-fA-F\d]+$/) { 
print "It is not a hex number, \n";
}
</pre>
</font>
<p align=justify>
Проверка идентификаторов<p align=justify>

С помощью метасимвола <font color=green>\w</font> можно проверить, состоит ли текст только из букв, цифр и символов подчеркивания (это те символы, которые perl называет словесными (word characters)):
<pre>
<font color=green>$text="abc";
if($text=~/^\w+$/){
  print "Only word characters found. \n";
}
Only word characters found.
</pre>
</font>
<p align=justify>
Однако, если вы хотите убедиться, что текст содержит латинские буквы и несодержит цифр или символов подчеркивания, придется использовать другой шаблон:
<pre>
<font color=green>$text = "аbс";
if($text=~ /^[A-Za-z]+$/)
{ print "Only letter characters found.\n";}
Qnly letter characters found.
</pre>
</font>
<p align=justify>
Наконец, для проверки, что текст является идентификатором, то есть начинаетcя с буквы и содержит буквы, цифры и символы подчеркивания, можно испольpовать команду:                 <pre>
<font color=green>
$text = "X125c";
if($text=~ /^[A-Za-z]\w+$/)
{ print "This is identifier.\n";}
This is identifier.</pre>
</font>

Как найти множественные совпадения<p align=justify>

Для поиска нескольких вхождений шаблона можно использовать модификатор <font color=green>g</font>. Следующий пример, который мы уже видели ранее, использует команду <font color=green>m/.../</font> с модификатором <font color=green>g</font> для поиска всех входжений буквы <font color=green>x</font> в тексте:
<pre>
<font color=green>$text="Here is texxxxxt";
while($text=~m/x/g){
  print "Found another x.\n";
}
Found another x.
Found another x.
Found another x.
Found another x.
Found another x.</pre>
</font>
<p align=justify>

Модификатор <font color=green>g</font> делает поиск глобальным. В данном (скалярном) контексте perl помнит, где он остановился в строке при предыдущем поиске. Следующий поиск продолжается с отложенной точки. Без модификатора <font color=green>g</font> команда <font color=green>m/.../</font> будет упорно находить первое вхождение буквы <font color=green>х</font>, и цикл будет продолжаться бесконечно. <p align=justify>
В отличие от команды <font color=green>m/.../</font> команда <font color=green>s/.../.../</font> с модификатором <font color=green>g</font> выполняет глобальную замену за один раз, работая так, будто внутри нее уже имеется встроенный цикл поиска, подобный приведенному выше. Следующий пример за один раз заменяет все вхождения <font color=green>х</font> на <font color=green>z</font>:
<pre>
<font color=green>$text = "Here is texxxxxt."; 
$text =~ s/x/z/g;
print $text;
Here is tezzzzzt.
</pre>
</font>
<p align=justify>
Без модификатора g команда <font color=green>s/.../.../</font> заменит только первую букву <font color=green>х</font>. Команда <font color=green>s/.../.../</font> возвращает в качестве значения число сделанных подстановок, что может оказаться полезным:
<pre>
<font color=green>$text= "Here is texxxxxt.";
print (text =~ s/x/z/g)
5 
</pre>
</font>Поиск нечувствительных к регистру совпадений<p align=justify>
Вы можете использовать модификатор <font color=green>i</font>, чтобы сделать поиск нечувствительным к разнице между заглавными и строчными буквами. В следующем примере про-грамма повторяет на экране введенный пользователем текст до тех пор, пока не будет введено <font color=green>Q</font>, или <font color=green>q</font> (сокращение для QUIT или quit), после чего программа прекращает работу:
<pre>
<font color=green>while(&lt;&gt;){
  chomp;
  unless (/^q$/i){
    print
  }
  else { 
    exit; 
  }
}
</pre>
</font>Выделение подстроки <p align=justify>
Чтобы получить найденную подстроку текста, можно использовать круглые скобки в теле шаблона. Если это более удобно, можно также использовать встроенную функцию substr. В следующем примере мы вырезаем из текстовой строки нужный нам тип изделия:
<pre>
<font color=green>$record = "Product number:12345
           Product type: printer 
		   Product price: $325";
if($record=~/Product type:\s*([a-z]+)/i){
  print "The product's type Is^$1.\n";
}
product's type is printer.
</pre>
</font>
Вызов функций и вычисление выражений при подстановке текста<p align=justify>

Используя для команды <font color=green>s/.../.../</font> модификатор <font color=green>е</font>, вы тем самым показываете, что правый операнд (то есть подставляемый текст) - это то выражение perl, которое надо вычислить. Например, с помощью встроенной функции perl <font color=green>uc</font> (uppercase) можно заменить все строчные буквы слов строки на заглавные:
<pre>
<font color=green>$text = "Now is the time.";
$text=~ s/(\w+)/uc($1)/ge;
print $text; 
NOW IS THE TIME.
</pre>
</font>Вместо функции uc($l) можно поместить произвольный код, включая вызовы программ.<p align=justify>

Поиск n-го совпадения<p align=justify>
С помощью модификатора g перебираются все вхождения заданного шаблона. Но то делать, если нужна вполне определенная точка совпадения с шаблоном, например, вторая или третья? Оператор цикла while в сочетании с круглыми cкобками, выделяющими нужный образец, поможет вам:
<pre>
<font color=green>$text = "Name:Anne Nanie:Burkart Name:Glaire Name: Dan";
while ($text =~ /Name: \s*(\w+)/g){
  ++$match;
  print "Match number $match is $1.\n"; 
}

Match number 1 is Anne
Match number 2 is Burkart
Match number 3 is Claire 
Match number 4 is Dan
</pre>
</font>
Этот пример можно переписать, используя цикл for: 

<pre>
<font color=green>$text = "Name:Anne Name:Burkart Name:Ciaire Name:Dan";
for ($match = 0;
     $text =~ /Name:\s*(\w+)/g;
	 print "Match number ${\match} is $1.\n")
{}
Match nuwber 1 Is Anne
Match number 2 is Burkart 
Match number 3 is Claire
Match number 4 is Dan
</pre>
</font>
<p align=justify>
 Если же вам требуется определить нужное совпадение не по номеру, а по содержанию (например, по первой букве имени пользователя), то вместо счетчика <font color=green>$match</font> можно анализировать содержимое переменной <font color=green>$1</font>, обновляемой при каждом найденном совпадении.
Когда требуется не найти, а заменить второе или третье вхождение текста, можно применить ту же схему, использовав в качестве тела цикла выражение perl, вызываемое для вычисления заменяющей строки:
<pre>
<font color=green>$text = "Name:Anne Name:Burkart Name:Claire Name:Dan";
$match =0;
$text =~ s/(Name:\s*(\w+))/   # начинается код perl
         if (++$match == 2)   # увеличить счетчик 
		    {"Name:John ($2)"}# вернуть новое значение
         else {$1}            # оставить старое значение
         /gex;
print $text;  
Name:Anne Name:John (Burkart) Name:ClaireName:Dan
</pre>
</font>
В процессе глобального поиска при каждом найденном совпадении вычисляется выражение, указанное в качестве второго операнда. При его вычислении увеличивается значение счетчика, и в зависимости от него в качестве замены подставляется либо старое значение текста, либо новое. Модификатор <font color=green>х</font> позволяет добавить в поле шаблона комментарии, делая код более прозрачным. Обратите внимание, что нам пришлось заключить весь шаблон в круглые скобки, чтобы получить значение найденного текста и подставить его на прежнее место полностью.
<p align=justify>
Как ограничить "жадность" квантификаторов
<p align=justify>
По умолчанию квантификаторы ведут себя как "жадные" объекты. Начиная с текущей позиции поиска, они захватывают самую длинную строку, которой может соответствовать регулярное выражение, стоящее перед квантификатором. Алгоритм перебора с возвратами, используемый perl, способен ограничивать аппетит квантификаторов, возвращаясь назад и уменьшая длину захваченной строки, если не удалось найти соответствия между текстом и шаблоном. Однако этот механизм не всегда работает так, как хотелось бы. Рассмотрим следующий пример. Мы хотим заменить текст "That is" текстом "That's". Однако в силу "жадности" квантификатора регулярное выражение "<font color=green>.*is</font>" сопоставляется фрагменту текста от начала строки и до последнего найденного "is":
<pre>
<font color=green>$text = "That is some text, isn't it?";
$text =~ s/.*is/That's/;
print $texts;
That'sn't it?
</pre>
</font>
<p align=justify>
Чтобы сделать квантификаторы не столь жадными, а именно заставить их захватывать минимальную строку, с которой сопоставимо регулярное выражение, после квантификатора нужно поставить вопросительный знак. Тем самым квантификаторы принимают следующий вид:
<ul>
	<li>
<font color=green>*?</font> - ноль или несколько совпадений,</li>
	<li>
<font color=green>+?</font> - одно или несколько совпадений, </li>
	<li>
<font color=green>??</font> - ноль совпадений или одно совпадение,</li>
	<li>
<font color=green>{n}?</font> - ровно <font color=green>n</font> совпадений,</li>
	<li>
<font color=green>{n,}?</font> - по крайней мере <font color=green>n</font> совпадений,</li>
	<li>
<font color=green>{n,m}?</font> - совпадений по крайней мере <font color=green>n</font>, но не более, чем m.</li>
</ul>
Оратите внимание, что смыслквантификатора от этого не меняется; меняется только поведение алгоритма поиска. Если в процессе сопоставления шаблона и текста прототип определяется однозначно, то алгоритм поиска с возвратами увеличит "жадность" такого квантификатора точно так же, как он ограничивает аппетит собрата. Однако если выбор неоднозначен, то результат поиска будет другим:
<pre>
<font color=green>$text = "That is some text, isn't it?";
$text =~ s/.*?is/That's/;
print $texts;
That's some text, isn't it?
</pre>
</font> <p align=justify>
Как удалить ведущие и завершающие пробелы<p align=justify>

Чтобы отсечь от строки начальные "пробельные символы", можно использовать, следующую команду:
<pre>
<font color=green>
$text = "          Now is the time.";
$text =~ s/^\s+//;
print $texts;
Now is the time.
</pre>
</font>
Чтобы отсечь "хвостовые" пробелы, годится команда:
<pre>
<font color=green>
$text = "Now is the time.          ";
$text =~ s/\s+$//;
print $texts;
Now is the time.</pre>
</font>
<p align=justify>
Чтобы отсечь и начальные, и хвостовые пробелы лучше вызвать последователно эти две команды, чем использовать шаблон, делающий отсечение ненужных пробелов за один раз. Поскольку процедура сопоставления шаблона и текста достаточно сложна, на эту простую операцию 
может уйти гораздо больше времеви, чем хотелось бы.
<p align=justify>



<p align=justify>
Например в тексте нужно найти текст, находящийся между открывающим и 
закрывающим тегом:
<pre>
<font color="Green">
$text="&lt;a&gt;blah-blah&lt;/a&gt;";
if($text=~m!&lt;([a|b])&gt;(.*?)/\1!ig){
print "$2\n";
}
</pre>
</font>
найдет все слова, стоящие между тегами &lt;a&gt;&lt;/a&gt; и &lt;b&gt;&lt;/b&gt;.
<p align=justify>
В регулярных выражениях пристутствует своя семантика: быстрота, торопливость и возврат.
Если квантификатор <font color=green>*</font> совпадает во многих случаях, то в результате быдет выведен наибольший по длинне результат. Это жадность. Быстрота: поиск старается найти как можно быстрее.
<font color=green>"Text"=~/m*/</font>, по смыслу символов <font color=green>m</font> нет, но в результате будет возвращено значение <font color=green>0</font>. Т.е. формально <font color=green>0</font> и более символов.

<pre>
<font color=green>$test="aaooee ooaao";
$test=~s/o*/e/;
print $test;
eaaooee ooaao</pre>
</font>
потому что 1 элемент сторки - <font color=green>0</font> и более символов.<p align=justify>

Если добавить квантификатор <font color=green>g</font>, то результат будет таким: 

<pre>
<font color=green>eaeaeeeeee eeaeaee</pre>
</font>
т.к строка содержит 13 мест, где может встречатся <font color=green>o</font>, в том числе и пустых.
<p align=justify>
Модификаторы:

<ul>
	<li>
<font color=green>/i</font> игнорировать регистр</li>
	<li>
<font color=green>/x</font> игнорировать пропуски в шаблоне и разрешить комментарии.</li>
	<li>
<font color=green>/g</font> модификатор разрешающий выполнение поиска/замены везде, где это возможно</li>
	<li>
<font color=green>/gc</font> не сбрасывается позиция при неудачном поиске.</li>
	<li>
<font color=green>/s</font> разрешается совпрадение <font color=green>.</font> с <font color=green>\n</font>, игнорируется <font color=green>$*</font>.</li>
	<li>
<font color=green>/m</font> разрешить совпадение <font color=green>^</font> и <font color=green>$</font> для начала и конца строки во внутренних переводах строк</li>
	<li>
<font color=green>/o</font> однократная компиляция</li>
	<li>
<font color=green>/e</font> правая часть <font color=green>s///</font> представляет собой выполняемый код</li>
	<li>
<font color=green>/ee</font> правая часть <font color=green>s///</font> выполняется, после чего возвращаемое значение интерпретируется снова.</li>
</ul>
<p align=justify>
при вызове <font color=green>use locаle</font> учитываются локальные настройки. Модификатор <font color=green>/g</font> может заполнить массив значений <font color=green>@nums = m/(\d+)/g;</font> но это сработает для ненакладывающихся совпадений.
Чтобы поймать совпадения нужно воспользоваться оператором <font color=green>?=...</font> Если ширина <font color=green>= 0</font>, то механизм поиска остался на прежнем месте. Найденые данные остаются внутри скобок. Если есть модификатор <font color=green>/g</font>, то текущая позиция остается прежней, но происходит перемещение на один символ вперед.

<font color=green>$numbers="123456789";
@one=$numbers=~/(\d\d\d)/g;
@two=$numbers=~/(?=(\d\d\d))/g;
print "@one \n";
print "@two \n";</font>
<p align=justify>
Модификаторы <font color=green>m</font> и <font color=green>s</font> нужны для поиска последовательностей символов, содержащих перевод строки. При <font color=green>s</font> точка совпадает с <font color=green>\n</font> и игнорируется <font color=green>$*</font>. m делает совпадающими <font color=green>^</font> и <font color=green>$</font> до и после <font color=green>\n</font>. <font color=green>e</font> правая часть выполняется как программный код: <font color=green>perl -i -n -p -e 's/(.)/lc($1)/g' *.html</font> приводит все литеры во всех файлах <font color=green>*.html</font> текущей директории к нижнему регистру.
<p align=justify>
Встроенные переменные в regex.
<p align=justify>
<font color=green>$1, $2, $3, $4, ..., $n ...</font> содержат ссылки на найденный текст, только в том случае если regex был в круглых скобках:

<pre>
<font color=green>s%&lt;f(.*?)&gt;&lt;(.*?)"&gt;&lt;(.*?)"&gt;%$1 $2 $3%g;</pre>
</font>

внутри regex можно  использовать переменные типа <font color=green>\1, \2, \3, \4, ... \n, ...</font>

<pre>
<font color=green>s/a href=(["'])(.*?)\1&gt;/$2/g </pre>
</font>

найдет все урл, заключенные в двойные, одинарные и вообще без кавычек, находящиеся в документе.
<p align=justify>
для <font color=green>/(a.*b)|(mumu)/</font>  в переменной <font color=green>$+</font> содержится <font color=green>$1</font> или <font color=green>$2</font>.
<p align=justify>
<font color=green>$& </font> содержит полный текст совпадения при последнем поиске.
<p align=justify>
<font color=green>$'</font> и <font color=green>$`</font> содержатся строки до и после совпадения<p align=justify>

Если нужно скопировать и сделать подстановку, то нужно действовать примерно так:

<pre>
<font color=green>($at = $bt) =~ s!m(.*?)o!! #для строк
for(@mass1 = @mass2){s/umka/maugli/} #для массивов


$u = ($m=~s/a/b/g); #поменять $m и занести в $u число замен.

</pre>
</font>

Если нужно выцепить только алфавитные символы, с учетом настроек locale, то регексп примерно такой: <font color=green>/^[^\W\d_]+$/</font> в нем учитываются все не алфавитные символы, не цифры и не подчеркивания(для случая "ванька-встанька"), симвлол отрицания в группе <font color=green>[]</font> - <font color=green>^</font>, т.е. найти все, что не <font color=green>[\W\d_]</font>, можно было написать и скажем так <font color=green>!~m/^(\W|\d|_)*/</font>.
<p align=justify>
Для упрощения понимания сложных регулярных выражений можно воспользоваться их комментированием. Иногда правда можно только по виду регулярного выражения определить зачем оно предназначено: 

<pre>
<font color=green>$mmm{$1} = $2 while ($nnn =~ /^([^:]+):\s+(.*)$/m);</pre>
</font>

читаем регулярное выражение: <p align=justify>
<font color=green>нужно найти в файле все что до двоеточия не двоеточие и все что после двоеточия(включая возможные повторения после первого <b>: .*?: .*?: .*?:</b>, потому что была найдена первая позиция: выделить все что не есть двоеточие до  первого двоеточия)</font>
<p align=justify>
Что это может быть, вполне вероятно, что оно нужно для составления статистики писем, выцепление заголовка письма и его названия из mbox в хеш. По крайней мере это регулярное выражение подходит для данной задачи.
</pre>
</font>

<h3>
<a name=regex_html_exprogs>Рабочие программы, использующие регулярные выражения</a>
</h3>

В принципе регулярные выражениея это вовсе не вещь в себе, хотя иногда и может встретится задача, фактически полностью реализуемая при помощи regex. Ниже приведены программы, иллюстрирующие использование реглуярных выражений:

<h4>
<a name=regex_html_match>Выделение чисел в математической записи</a>
</h4>
<p align=justify>
Пример использования логических условий для нахождения любых чисел в том числе и в общепринятой математической записи:

<pre>
<font color=green>
#!/usr/bin/perl
$_=qq~
1234
34 -4567
 3456
-0.35e-0,2
    56grf45
-.034 E20
     -.034 e2,01   -,045 e-,23
  -,034 e201  3e-.20
-,045 e-,23 e-0.88

4 E-0.20
22 
E-21
 -0.2 w         4 3
345
2 ^-,3
~;
print "$1\n" while 
 m%(([+-]?(?=\d|[\.,]\d)\d*([\.,]\d*)?((\se|e|\s?\^)
    ([-+]?\d*[,\.]?)\d+)?)|([+-]?e[+-]?\d*[,.]?\d+))%gxi;

</pre>
</font>
программа исправно выводит все числа. Разберем регулярное выражение 

<pre>
<font color=green> 
 m%(([+-]?(?=\d|[\.,]\d)\d*([\.,]\d*)?((\se|e|\s?\^)
    ([-+]?\d*[,\.]?)\d+)?)|([+-]?e[+-]?\d*[,.]?\d+))%gxi;
</pre>
</font>
<p align=justify>
в переменной <font color=green>$1</font> содержится то, что регулярное выражение находит в результате, т.е. 
<font color=green>m%(...)%gmi. m%((что-то)|([+-]?e[+-]?\d*[,.]?\d+))%gmi</font>  нужно для
того, чтобы находить числа вида <font color=green>e-20</font> или <font color=green>E21</font>(так в математике обозначают десятку в какой-то степени, например <font color=green>e-0,20 = 10<sup>-0,20</sup>
</font> или <font color=green>E20 = 10<sup>21</sup>
</font>). Рассмотрим левое регулярное выражение "что-то" для чисел вида не <font color=green>e20</font> или <font color=green>E21</font>:

<pre>
<font color=green>([+-]?(?=\d|[\.,]\d)\d*([\.,]\d*)?((\se|e|\s?\^)([-+]?\d*[,\.]?)\d+)?)</pre>
</font>
<p align=justify>
<font color=green>[+-]?</font> - есть ли в перед числом знак <font color=green>+</font> или <font color=green>-</font>. <font color=green>?</font> - если вообще есть что-то, находящееся внутри впереди стоящего <font color=green>[...]</font>. Выкинем проверку знака, регексп сократится до

<pre>
<font color=green>(?=\d|[\.,]\d)\d*([\.,]\d*)?((\se|e|\s?\^)([-+]?\d*[,\.]?)\d+)?</pre>
</font>
<p align=justify>
рассмотрим regex <font color=green>(?=\d|[\.,]\d)\d*</font> логический оператор <font color=green>(?=B)</font> требует, чтобы перед числов было <font color=green>B</font>. В данном случае <font color=green>B</font> представляет из себя regex <font color=green>\d|[\.,]\d</font> Regex <font color=green>\d|[\.,]\d</font> значит, что 
перед каждым числом должно быть что-то либо просто число, либо число, перед которым стоит либо запятая, либо точка, т.е. находим все числа вида <font color=green>,2</font> <font color=green>.2</font> или просто числа <font color=green>2</font>(<font color=green>2</font> выбрано для примера, может быть и 3). Далее скобка закрывается и идет <font color=green>\d*</font>, т.е. число вида <font color=green>,2</font> точно пройдет(например <font color=green>,2 e-,23</font> где перед запятой забыли поставить нолики, но мало ли бывает, забыли, надо и это предусмотреть. Вообще когда пишешь программу, надо предполагать, что её использовать будет ленивый склеротический чайник, правда не всегда возможно предугадать что учудит юзер, но к этому надо стремится), а вот число вида <font color=green>,223</font> не пройдет. Да и regex <font color=green>(?=\d|[\.,]\d)</font> говорит о том, что нужно найти только одну цифру после запятой. Для остальных цифр и нужен квантификатор <font color=green>\d*</font>, который значит любое количество цифр, в том числе и ноль, т.е. оно работает и для числе вида <font color=green>.2</font> или <font color=green>,2</font> Далее идет регулярное выражение <font color=green>([\.,]\d*)?</font> которое говорит о том, есть ли вообще точка и запятая(здесь всю полную строчку в принципе можно усовершенствовать) и число <font color=green>\d*</font>(в том числе и его отсутствие, ведь квантификатор <font color=green>*</font> значит любой символ в том числе и ноль). Отбрасывая все что было выше от этого большого регулярного выражения остается строчка:

<pre>
<font color=green>((\se|e|\s?\^)([-+]?\d*[,\.]?)\d+)?</pre>
</font>
<p align=justify>
Эта строчка отвечает за поиск в строке <font color=green>$_</font> математических обозначений степеней типа <font color=green>e201</font>, <font color=green>E,20</font>(число в степени <font color=green>0,20</font> например <font color=green>a<sup>-0,20</sup>
</font>) и т.д. но только для подстрок вида <font color=green>-,034 e201</font>. Заметьте, что в конце стоит знак вопроса, т.е. если степенное обозначение вообще существует. <font color=green>(\se|e|\s?\^)</font> есть ли числа вида <font color=green>-,034 e201</font> или <font color=green>-,034e201</font> и числа в "компьютерной" записи вида <font color=green>2 ^-,3 = 2<sup>-0,3</sup>
</font>, т.е. этим регекспом мы разрешили пользователю ставить или не ставить пробел при указании степени и разрешили писать значек <font color=green>^</font> с пробелом перед ним(если есть). Далее идет выражение <font color=green>([-+]?\d*[,\.]?)</font>, которое говорит о том, что степень может быть с <font color=green>+</font> или <font color=green>-</font> (типа <font color=green>e,-23</font> где юзер забыл поставть нолик, а на самом деле хотел написать <font color=green>a<sup>-0,23</sup>
</font>). Дальше идет цифра <font color=green>\d*</font> (а может и не идет, т.к. квантификатор то <font color=green>*</font>). Потом идет либо точка либо запятая(причем тут негласно введено ограничение на использование запятой/точки, после <font color=green>e</font>, если степень дробная или вообще есть, точка или запятая должна быть, иными словами не имеет смысла написать <font color=green>-2,34e-,23</font>, хотя юзер на самом деле хотел написать число <font color=green>-2,34<sup>-0,23</sup>
</font>).  Наконец мы добрались до конца: идет <font color=green>\d+</font>, но тут уж, пользователь, будь добр напиши хотя бы одно число, т.к. квантификатор <font color=green>+</font>, а не <font color=green>*</font> после <font color=green>\d</font>. Т.е. наложили своего рода ограничения здравого смысла, можно просто написать <font color=green>2</font>, а можно написать и <font color=green>2e,-</font> что суть бессмыленно.
И еще, <font color=green>m%(что-то)%igm</font> стоит квантификатор <font color=green>i</font>, который разрешает <font color=green>e</font> быть и заглавным и квантификатор <font color=green>x</font>, который разрешает разносить регулярное выражение на несколько строк.
<p align=justify>
Прошу прошения что не ставил иногда знаки препинания, которые есть точка и запятая, тогда Вы бы подумали, что что-то лишнее написно и не подсечено как спецсимвол при помощи бэкслэша <font color=green>\</font>. 
<p align=justify>
Итак, регулярным выражением 
<pre>
<font color=green> 
 m%(([+-]?(?=\d|[\.,]\d)\d*([\.,]\d*)?((\se|e|\s?\^)
    ([-+]?\d*[,\.]?)\d+)?)|([+-]?e[+-]?\d*[,.]?\d+))%gxi;
</pre>
</font>
<p align=justify>
были предусмотрены числа степенного порядка, просто числа, числа со знаком, нецелые числа вида ,3(которое есть 0,3 или 0.3), ошибки пользователя при вводе чисел( типа <font color=green>-.034 e2,01</font> хотя надо бы писать либо <font color=green>-,034 e2,01</font> либо <font color=green>-.034 e2.01</font> хотя по смыслу перед точками и запятыми нужно ставить нули, но мы предусмотрели и это) и числа в "компьютерном" представлении.<p align=justify>
 Конечно, данное регулярное выражение не претендует на абсолютную работу, т.к. оно успешно не работает на подстроках вида <font color=green>-,045 e -,23 e-0.88</font> считая <font color=green>-,045</font> отдельным числом, а <font color=green>-,23</font>  возводит в степень <font color=green>e-0.88</font>, хотя по идее должно было бы быть два числа <font color=green>-,045 e -,23</font> и <font color=green>e-0.88</font>, в таком случае еще одно ограничение пользователю: если хочется, чтобы степенные числа понимались корректно(для этой программы), то нельзя ставить пробел перед степенью <font color=green>e</font>.  

<h4>
<a name=regex_html_work1>Облегчение поиска работы</a>
</h4>
Допустим Вы оказались без работы, развалилась ваша фирма или еще какая-нибудь причина. Вам требуется найти новую. Для упрощения этой задачи естьь следующий скрипт, который выцепливает по нужной позиции(веб программирование, зарплата от 200$ и т.д.) с www.job.ru все заявки за последние 10-15 дней, точнее емейлы, куда нужно слать резюме, что значительно убыстряет поиск работы(имея базы адресов легче разослать одно и то-же резюме, используя нехитрый список рассылки):

<pre>
<font color=green>#!/usr/bin/perl -wT
$url0="http://www.job.ru/cgi/list1.cgi?GR_NUM=";
$url1="%31&TOPICID=9&EDUC=2&TP=&Gr=&SEX=&AGEMIN=23&AGEMAX=&MONEY=200&CDT=";
$url2="&LDAY=99&ADDR=%ED%CF%D3%CB%D7%C1&KWORD=&KW_TP=AND";
use LWP::Simple;
foreach($i=1; $i<=57; $i++){#57 число листаемых страниц
$plus.="%31%2B";
$test=$url0.$plus.$url1.$url2,"\n";
@mass=grep{s/(.*) ([\w+\-\.]+\@[\w\-\.]+\.\w{2,3})(.*)/$2/ig} split /\n/, get "$test";
$test.=join "\n", @mass;
$test.=\n";
}
@un=grep{!$test{$_}++} split /\n/, $test;
print join "\n", @un;
print "\nВы можете отправлять по вашей специальности $#un резюме\n";
</pre>
</font>
<p align=justify>
Что делает эта программа, она составляет GET запрос из параметров, которые скрыты
в hidden полях навигации по результатам запроса на www.job.ru.
Программа при помощи <font color=green>Simple.pm</font> отправляет запрос на сервер и как бы листает странички с поиском. Критерий ваших профессиональных навыков составлен в GET-запросе и осталось только разослать почту(для этого можно написать список рассылки) по адресам, которые выдала программа. Разберем регулярное выражение для вытаскивания почтового адреса из текущей странички 
<font color=green>s/(.*) ([\w+\-\.]+\@[\w\-\.]+\.\w{2,3})(.*)/$2/ig</font>.
<p align=justify>
<font color=green>[\w+\-\.]\@</font> - найти все что содержит буквы, тире и точки до символа <font color=green>@</font>, ведь почтовый адрес по спецификации может быть вида a<font color=green>a.ss-ss@chto-to.ru</font>. Тоже самое после символа <font color=green>@</font> - <font color=green>[\w\-\.]+</font>
далее может быть точка <font color=green>\.</font> и любая буква от 2 до 3 символов <font color=green>\w{2,3}</font>, т.е. окончание, самый верхний домен <font color=green>.com</font>, <font color=green>.ru</font>, <font color=green>.cz</font> и т.д. Далее регулярное выражение состоит из трех классов скобок  <font color=green>(.*)</font> - переменная <font color=green>$1</font>, <font color=green>([\w+\-\.]+\@[\w\-\.]+\.\w{2,3})</font> переменная <font color=green>$2</font> и все остальное в <font color=green>(.*)</font> - <font color=green>$3</font>. Пробел перед <font color=green>$2</font> стоит потому, что так устроен html, отдаваемый пользователю поиском по базе предложений о работе www.job.ru. Нам нужно содержимое <font color=green>$2</font>, в котором находится e-mail работодателя. Пишем его во вторую часть <font color=green>s/наш regex/$2/ig</font>. Квантификатор <font color=green>i</font> нужен для того, чтобы не различать регисты <font color=green>Vasya@pupkin.ru</font> и <font color=green>vasya@pupkin.ru</font>, квантиикатор g задействова на тот случай, если работодатель указывает 2 адреса, по которым нужно высылать резюме. На 23 августа 2001 года на 20 часов 10 минут прогамма выдала 410 e-mail адресов(пролистав за 3-4 минуты 57 страниц), где вас ждут, как потенциального сотрудника.
<p align=justify>
Остается написать скрипт почтовой рассылки по e-mails, выданным данным скриптом. Но это в другой главе.
<p align=justify>
Примером выше был получен спсиок  email адресов. Теперь необходимо проверить, действительно ли существуют домены, на которых заведены такие пользщователи(примитивная - но проверка).

<pre>
<font color=green>#!/usr/bin/perl
use Socket;                      #загрузить inet_addr
s{                               #
  (                              #Сохранить имя хоста в $1
    (?:                          #Группирующие скобки
	  (?! [-_] )                 #ни подчеркивание, ни дефис
	  [\w-] +                    #кусок имени хоста
	  \.                         #и точка домена
	)+                           #повторить несколько раз
	[A-Za-z]                     #следующий символ - буква
	[\w-]+                       #домен верхнего уровня
  )                              #конец записи $1
}{                               #Заменить следующим:
  "$1" .                         #исходн часть + пробел
    (($addr = gethostbyname($1)) #Если имеется адрес
	? "[" . inet_ntoa($addr). "]"#отформатировать
	: "[???]"                    #иначе пометить как сомнительный
	)
}gex
</pre>
</font>
Переписываем исходную программу с учетом вышеприведенного кода

<pre>
<font color=green>#!/usr/bin/perl -wT
$url0="http://www.job.ru/cgi/list1.cgi?GR_NUM=";
$url1="%31&TOPICID=9&EDUC=2&TP=&Gr=&SEX=&AGEMIN=23&AGEMAX=&MONEY=200&CDT=";
$url2="&LDAY=99&ADDR=%ED%CF%D3%CB%D7%C1&KWORD=&KW_TP=AND";
use Socket;
use LWP::Simple;
foreach($i=1; $i<=57; $i++){
  $plus.="%31%2B";
  $test=$url0.$plus.$url1.$url2,"\n";
  @mass=grep{s/(.*) ([\w+\-\.]+\@[\w+\-\.]+\.\w{2,3})(.*)/$2/ig} split /\n/, get "$test";
  $test1.=join "\n", @mass;
  $test1.="\n";
}
@res=split /\n/, $test1;
@un=grep{!$test{$_}++} @res;
foreach $file(@un){
  $file=~s/(.*)\@(.*)/www\.$2/;
=pod
  $file=~s{((?:(?![-_])[\w-]+\.)+[A-Za-z][\w-]+)}
    {"$1".(($addr=gethostbyname($1))?"[".inet_ntoa($addr)."]":"[???]")}gex;
  print $file,"\n" if($file !~/\?\?\?/);
=cut
$file=~s{
  (
    (?:
      (?![-_])
      [\w-]+
      \.
    )+
    [A-Za-z]
    [\w_]+
  )
}{
  "$1".
  (($addr = gethostbyname($1))
   ? "[".inet_ntoa($addr)."]"
   : "[???]"
  ) 
}gex;
print $file,"\n" if($file !~/\?\?\?/);
}</pre>
</font>
Между строчками можно комментировать целые куски кода.
<pre>
<font color=green>=pod
  $file=~s{((?:(?![-_])[\w-]+\.)+[A-Za-z][\w-]+)}
    {"$1".(($site=gethostbyname($1))?"[".inet_ntoa($site)."]":"[???]")}gex;
  print $file,"\n" if($file !~/\?\?\?/);
=cut</pre>
</font>
<p align=justify>
Эта программа успешно удалила некторые из адресов, которые Socket.pm показались подозрительными. Все-таки какую-никакую, а проверку существования e-mail адресс окольными путями при помощи perl провести можно. Автору сего текста все-таки больше нравится вариант, заключенный в комментарии =pod(.*?)=cut. Он просто короче. Да и если научится читать сложные регулярные выражения, то можно написать полный регексп е-mail адресов, который занимается тем, что выделяет адреса в точности с соответствующим RFC(занимает это регулярное выражение несколько страгниц). Но впрочем ниже будет подглава, посвященная чтению монстрообразных, на первый взгляд, регекспов налету, со множеством примеров, выше же мы уже попытались угадать предназначение регулярного выражения только по его виду.
<p align=justify>Ключи, которые использовались в вышеприведенном регулярном выражении<p align=justify>
<font color=green>g</font> - глобальная замена<br>
<font color=green>е</font> - выполнение<br>
<font color=green>x</font> - улучшенное форматирование.<br>

Если написать это регулярное выражение в одну строчку, то оно врядли там поместится:

<pre>
<font color=green>
s{((?:(?![-_])[\w-]+\.)+[A-Za-z][\w-])}#здесь силовой перевод каретки
{"$1".(($addr=gethostbyname($1))?"[".inet_ntoa($addr)."]":"[???]")}gex
</pre>
</font>
Разберем один интересный момент в данном регекспе:

<pre>
<font color=green>s/regex/условие?да:иначе/</pre>
</font>
<p align=justify>
Тут проявляется пожалуй одна из действительно сильнейших особенностей <font color=green>regex</font>, возможность в одном регулярном выражении избежать многострочных условий с циклом. В приведенном примере работает все примерно так: Если <font color=green>$addr=gethostbyname($1)</font> - да, то ставить ip-адрес(<font color=green>inet_ntoa($addr)</font>), если нет(не откликнулся сервер, сбой на линии и пр) то метить этот урл как подозрительный <font color=green>[???]</font>. В принципе в программе ничего человеку делать не нужно, т.к. подозрительные отметаются условием <font color=green>print $file,"\n" if($file !~/\?\?\?/);</font> Общее время работы программы 10-15 минут.

<h4>
<a name=regex_html_newsline>Очень простое решение для зеркала новостной ленты</a>
</h4>
<p align=justify>
Допустим нужно сделать зеркало какой-либо зарубежной новостной ленты вместе с загрузкой картинок с удаленного сервера, чтобы не ждать по несколько минут отображения содержимого полностью загруженной большой таблицы. Приведенный скрипт запускается при помощи crontab каждые 5 часов:

<pre>
<font color=green>#!/usr/bin/perl -w
$/="\001";
print "content-type: text/html\n\n";
$dir="/var/www/docs/html/news/images";
$imgurl="http://www.qwerty.ru/news/images";
use LWP::Simple;
use LWP::UserAgent;
$page=get "http://www.astronomynow.com";
$page=~s/face="(.*?)"//igs;
&getimg($page);
$page=~s!/images/grafix/listdot.gif!../../listdot.gif!igs;
$page=~s!/images/grafix/spacer.gif!../../spacer.gif!igs;
$page=~s!images/grafix/spacer.gif!../../spacer.gif!igs;
if($page=~m!&lt;TABLE WIDTH="400" BORDER="0" CELLPADDING="0" CELLSPACING="0"&gt;(.*?)&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;!igsm){
  $file=$1; 
  &getlink($page);
  foreach $names(@res){
    $names=~s|.*/||ig;
    $file=~s|src="http://(.*?)$names"|src=$imgurl/$names|igs;
  }
  $html=qq~
  &lt;TABLE BORDER="0" CELLPADDING="0"
  CELLSPACING="0"&gt;
  $file
  &lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;~;
}
open F, "&gt;$dir/news.txt"; 
print F $html or die "\n\n\n ERROR: $!\n\n\n";
close F;
sub getimg{
  &getlink($_[0]);
  foreach $img(@res){
    my $res = LWP::UserAgent-&gt;new-&gt;request(new HTTP::Request GET => $img);
    if ($res-&gt;is_success) {
      $img=~s|.*/||;
      open (ABC, "&gt;$dir/$img") or die "\n\n\nERROR: $!\n\n\n";
      binmode(ABC);
      print ABC $res-&gt;content; close ABC or die "\n\n\nERROR: $!\n\n\n";
    } else {
      print $res-&gt;status_line;
    }
  }
  return @res;
}
sub getlink{
  local $_=$_[0];
  push(@res, "http://$2")
    while m{SRC\s*=\s*(["'])http://(.*?)\1\s*(.*?)WIDTH="100" HEIGHT="100"(.*?)&gt;}igs;
  return @res;
}</pre>
</font>

<h4>
<a name=regex_html_findres>Вывод результатов поиска</a>
</h4>
<p align=justify>
Предположим есть необходимость подсветить результаты поиска в файлах,
подобно тому как это делает поисковик aport. Данное регулярное выражение
позволяет влоб реализовать эту красивую функцию для поисковика. но оно имеет
очень большой минус, при обработке текста машина начинает неимоверно
подтормаживать, но мы рассмотрим этот регексп из общих соображений:

<pre>
<font color=green>
$sn=4;
{
  local $_=$description1;
  print "...$1&lt;font color=red&gt;$3&lt;/font&gt;$4..."
    while(m/(([\s,\.\n^]*\w*){$sn})(\s*$query\s*)(([\s,\.\n^]*\w+){$sn})/ig);
}
$_="";
</pre>
</font>
<p align=justify>Исходная задача состоит в следующем: вывести по 4 слова
спереди и сзади результата поиска, причем так, чтобы если слово находится
первым, то будет видно 4 слова позади него. В точности такое-же условие и
для последнего слова.<p>
Соответственно из вида регекспа понятно, что разделителями слов могут
быть символы <font color=green>[\s,\.\n^]*</font>, в том числе и символ 
перевода каретки <font color=green>^</font>.
Комбинация <font color=green>(\d\d\d){$sn}</font>
<hr>

<a name="passwd_html"></a>

<hr>

<a name="socket_html"></a>
<h2>
<center>Сокеты</center>
</h2>
<br>
<ul>
	<li>Основные принципы</li>
	<li>
<a href="#socket_html_ex">Примеры</a>
</li>
	<ul>
	<li>
<a href="#socket_html_upload">Подгружение файла(-ов) на сервер через веб-страничку</a>
</li>
	</ul>
</ul>

<h3>
<a name="socket_html_ex">Примеры</a>
</h3>
<h4>
<a name="socket_html_upload">Подгружение файлов на несколько серверов через веб-страничку</a>
</h4>
Предположим Вы работаете менеджером по рекламе и вам необходимо подгружать один баннер в десяток другой баннерных систем. Чтобы не возится с каждым баннером, можно написать программу, автоматизирующую процесс подгрузки баннеров на несколько сайтов, защищенных паролем в хидден-поле(безопасность для данного примера работает при клиенте с аутентификацией через хидден-поля). Используя встроенную упаковку CGI.pm пакетов multipart/from можно напороться на то, что CGI.pm формируетй такой пакет, который может не разобрать программа, написанная, скажем на языке C. Т.е. CGI.pm формирует пакеты не совсем согласно rfc1867. Чтобы избежать этого неудобства, можно посылать картинки, используя Socket.pm. Т.е. нужно сформировать и отправить пакет в точности с rfc1867, который является стандартом для всех языков программирования. Ниже представлена программа, реализующая эту задачу:

<pre>
<font color=green>#!/usr/bin/perl -w
if ((!defined $ARGV[0]) || ($ARGV[0] =~ /^-h/i)) {
        print &lt;&lt; '__HELP_END__';
This script sends banners to www.kuku.ru. Usage:
./set_banner.pl &lt;image_filename&gt;
__HELP_END__
        exit(1);
}
my $filename = shift @ARGV;
my %accounts = (
        'vovka'         =&gt; ['123321', 13]
);
my ($login, $data);
while (($login,$data) = each %accounts) {
        my %params = (
                image_filename  =&gt; $filename,
                login           =&gt; $login,
                password        =&gt; $data-&gt;[0],
                profile         =&gt; $data-&gt;[1]
        );
        #print join ":",  %params;
        send_banner_to_kuku_ru(%params);
}
exit(0);
sub send_banner_to_kuku_ru(%)
{
        my %params = @_;
        open FILE, $params{image_filename} or die "Can't open imagefile: $!";
        binmode(FILE);
        my $image_data = &lt;FILE&gt;;
        close FILE;
        %params = (%params,  (
                host            =&gt; 'www.kuku.ru',
                script_uri      =&gt; 'account/addimage.html',
                url             =&gt; 'www.rrrr.ru',
                image_data      =&gt; $image_data,
                ratio           =&gt; '0',
                alt             =&gt; 'Новости на www.rrrr.ru'
        ));
        use IO::Socket;
        my $socket = IO::Socket::INET-&gt;new(
                PeerAddr =&gt; $params{host},
                PeerPort =&gt; 80,
                Proto    =&gt; 'tcp' 
        ) 
                or die "Can't connect: $!";
my $body = ''. &lt;&lt; "__END_OF_BODY__";
-----------------------------7d02d3301bfa0846
Content-Disposition: form-data; name="user"

$params{login}

-----------------------------7d02d3301bfa0846
Content-Disposition: form-data; name="password"

$params{password}

-----------------------------7d02d3301bfa0846
Content-Disposition: form-data; name="image"; filename="$params{image_filename}"
Content-Type: image/gif
Content-Transfer-Encoding: binary

$params{image_data}
-----------------------------7d02d3301bfa0846
Content-Disposition: form-data; name="href"

$params{url}

-----------------------------7d02d3301bfa0846
Content-Disposition: form-data; name="profile"

$params{profile}

-----------------------------7d02d3301bfa0846
Content-Disposition: form-data; name="ratio"

$params{ratio}

-----------------------------7d02d3301bfa0846
Content-Disposition: form-data; name="alt"

$params{alt}

__END_OF_BODY__

$body .= '-----------------------------7d02d3301bfa0846--';
        my $content_length = length($body);
my $header = '' . &lt;&lt; "__END_OF_HEADER__";
POST $params{script_uri} HTTP/1.1
Accept: */*
Accept-Language: ru
User-Agent: Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)
Content-Length: $content_length
Content-Type: multipart/form-data; boundary=---------------------------7d02d3301bfa0846
Host: $params{host}
__END_OF_HEADER__
        print $header . "\n" . $body;
        print $socket $header . "\n\n" . $body;
        while (&lt;$socket&gt;) {
                print;
        }
        close $socket;
}
1;
</pre>
</font>
Скрипт написан <a href="mailto:mdounin@genphys.phys.msu.su">Максимом Дуниным</a>
<hr>

<a name="sub_html"></a>
<p align=justify>
<ul>
        <li>Объявление</li>
        <li>Примеры</li>
        <ul>
          <li>
<a href=#pop_b4_smtp>pop before smtp for sendmail and popa3d(and other pop3
daemons)</a>
          </li>
        </ul>
</ul>
<a href="files/pop_b4_smtp.html">Реализация авторизации "pop перед smtp".</a>
<hr>

<a name="spisok_html"></a>
<center>
<h4>Работа со списками</h4>
</center>
Задача, есть ряд вида:
<pre>
<font color=green>
.3
.3.1
.3.1.1
.2
.2.1
.2.1.1
.2.1.1.1
.1
</font>
</pre>
<p align=justify>Найти максимальное число с максимальным вложением единичек.
Решение, если убрать точки, будет максимальным числом.
Его и надо выделить:
<pre>
<font color=green>
#!/usr/bin/perl -w
$_=qq~.3
.3.1
.3.1.1
.2
.2.1
.2.1.1
.2.1.1.1
.1
~;

print ".", join "." => split m!! =>
     @{[reverse sort {$a <=> $b} grep{s!\.!!g} split m%\n%]}[0];
print "\n";
</font>
</pre>
<p align=justify>Как это работает: конструкця <font color=green>@{[</font> тут 
действия со списками <font color=green>]}</font> возвращает массив элементов, из 
которого можно выделить нужный по номеру элемента массива 
<font color=green>@{[blah-blah]}[0]</font>. В переменной <font color=green>$_</font> 
содержится искомая "строка" из цифр, поэтому её можно разбивать по переводу 
каретки: <font color=green>split m%\n%</font>. После 
<font color=green>split m%\n%</font> для <font color=green>grep{s!\.!!g}</font> 
возвращается список, который из каждого элемента списка вырезает символ 
точки(экранированный символ, т.к. символ точки в <font color=green>regex</font> 
означает любой символ). Дальше возвращается список чисел без точки, 
которые сортируются при помощи <font color=green>sort {$a <=> $b}</font>. 
Скобки <font color=green>{$a <=> $b}</font> 
нужны для того, чтобы была произведена числовая, а не символьная сортировка.
 Т.е. в случае <font color=green>print join "\n" => sort {$a <=> $b} grep{s!\.!!g} @blah-blah</font> функция <font color=green>sort</font> вернет такой список, где максимальным будет число, содержащее в начале себя тройку как максимальное число, т.е. критическим будет "старший бит":
<pre>
<font color=green>
1
2
21
211
2111
3
31
311
</font>
</pre>
<p align=justify>далее при помощи <font color=green>reverse</font> оборачивается 
возвращаемый <font color=green>sort</font> список и берется нулевой элемент массива, 
состоящий из числа(в данном случае) <font color=green>2111</font>(что как число
<font color=green>2111</font> в целом больше, чем <font color=green>311</font>). Этот нулевой элемент затем режется по символу ноль(или по пустому символу, ведь между цифрой <font color=green>2</font> и <font color=green>1</font> не стоит ничего, вот по этому то <font color=green>ничего</font> и режется): <font color=green>split m!! => @{[blah-blah]}[0]</font>. Обычно в конструкции <font color=green>split</font> ставятся два косых слеша <font color=green>split //, $string;</font> эти два косых слеша есть не что иное как поиск по подстановке <font color=green>m//</font>. А при указании буквы <font color=green>m</font> в регулярном выражении слеши можно заменять любыми символами, например <font color=green>split mЫЫ</font>. Далее при обычном синтаксисе ставится запятая, эту запятую можно заменить на стрелочку <font color=green>=&gt;</font> без потери функциональности. Итого имеем <font color=green>split m!! => @{[blah-blah]}[0]</font>, т.е. массив,  который нужно вывести в прежнем виде, т.е. <font color=green>.2.1.1.1</font>, чего и делаем: <font color=green>print ".", join "." => split m!! => @{[blah-blah]}[0]</font>
<p align=justify>
Другое более короткое решение той-же задачи от Artem Chuprina(from fido7.ru.perl):<pre>
<font color=green>
perl -lne 'if (/(\d+)/ && ($1 > $num || ($1 == $num && length($_) > 
length($res)))) { $num = $1; $res = $_ }; END { print $res }' test.dat
</font>
</pre>
<hr>

<a name="winword_html"></a>
<a name=winword_html_winword>Чтение файлов в формате *.doc для Word 6 и Word
7(doc2txt or doc2html).</a>
</h4>
<p>
Преположим Вы владеете сайтом, на который сваливается информация
в формате *.doc. Много информации. Даже, быть может, 
структурированной. Необходимо эту информацию перевести в "божеский" вид,
т.е. выцепить из таких файлов текст. Скачиваем следующие модули:
<p>
<a href="http://search.cpan.org/search?dist=Unicode-Map" target=_new>Unicode-Map</a>
<br>
<a href="http://search.cpan.org/search?dist=Startup" target=_new>Startup</a>
<br>
<a href="http://search.cpan.org/search?dist=OLE-Storage" target=_new>OLE-Storage</a>
<br>
<p>
Устанавливаем их. 

В строке N1099 Startup нужно перед установкой внести изменения(если этот баг
еще не пофиксили на cpan), 
т.к. в этой строчке в конце не хватает <font color=green>&gt;</font>:<br>
<font color=green>I&lt;$pat&gt; = I&lt;$S&gt; -&gt; log_openpat
([I&lt;$pat])</font>
<br>
а нужно написать: <br>
<font color=green>I&lt;$pat&gt; = I&lt;$S&gt; -&gt; log_openpat
([I&lt;$pat&gt;])</font>.<p>
Далее берем файл, удовлетворяющий описанным выше условиям и 
пишем скрипт(предварительно прочитав man lhalw):
<font color=green>
<pre>
#!/usr/bin/perl
print qx[lhalw --to_stdout Label.doc]
</pre>
</font>
А можно и просто из командной строки
<font color=green>
<pre>
[ne-root@www OLE-Storage-0.386]# lhalw --to_stdout Label.doc


Кому:   "ФАМИЛИЯ" "ИМЯ" "ОТЧЕСТВО"
------------------------------ ОБРАТНЫЙ АДРЕС ------------------------------
WWW.RBC.RU, отдел "Новости экономики".

[ne-root@www OLE-Storage-0.386]#
</pre>
</font>
Так-же по <a href="http://search.cpan.org/search?mode=module&query=RTF"
target=_new>ссылке</a> можно найти список модулей для работы с *.rtf:<br>
<p>
<hr>

<a name="modules_html"></a>
<h2>
<center>Модули</center>
</h2>
 <br>
<ul>
 	<li>Концепции<br>
  </li>
 	<li>Классы<br>
  </li>
 	<li>Пакеты<br>
  </li>
 	<li>
<a href="#modules_html_ex">Примеры</a>
</li>
  <ul>
    <li>
<a href="#modules_html_upload">Подгружение файлов на сервер через веб-страничку</a>
</li>
    <li>
<a href="#modules_html_postdata">Заполнение и отправка удаленной формы методом POST с помошью сценария</a>
</li>
    <li>
<a href="#modules_html_redir">Редирект пользователя, находящегося за файрволом</a>
</li>
    <li>
<a href="#modules_html_excel">Создание файла Excel</a>
</li>
    <li>
<a href="#modules_html_rename">Переименование директорий</a>
</li>
    <li>
<a href="#modules_html_file_find">File::Find</a>, 
        <a href="#modules_html_image_size">Image::Size</a>,
        <a href="#modules_html_mime_lite">Mime::Lite</a>,
        <a href="#modules_html_image_magick">Image::Magick</a>,
        <a href="#modules_html_ole">Winword files</a>,
        <a href="#modules_html_spreadsheet_writeexcel">Spreadsheet::WriteExcel</a>,
        <a href="#modules_html_mp3_info">MP3::Info</a>,
        <a href="#modules_html_mason">Mason</a>,
        <a href="#modules_html_lwp_simple">LWP::Simple</a>,
        <a href="#modules_html_calendar">Calendar::Simple</a>
  </ul>
  <ul>
 	 	
  </ul>
 
</ul>
  
<h3>
<h3>
<a name="modules_html_ex">Примеры</a>
</h3>
</h3>
 
<h4>
<h4>
<a name="modules_html_upload">Подгружение файлов на сервер через веб-страничку</a>
</h4>
</h4>
Данная программа позволяет подгружать файлы на сервер, если apache настроен
так, что не перекодирует данные</b> <font color="green">POST</font>:  
<pre>
<font color="green">#!/usr/bin/perl -w<br>$basedir = "/usr/home/vovka/public_html/files";<br>$donepage = "http://www.myserver.ru/~vovka/files";<br>use CGI; <br>$onnum = 1;<br>while ($onnum != 9) {<br>	my $req = new CGI; <br>	my $file = $req-&gt;param("FILE$onnum"); <br>	if ($file ne "") {<br>		my $fileName = $file; <br>		$fileName =~ s!^.*(\\|\/)!!; <br>		$newmain = $fileName;<br>		open (OUTFILE, "&gt;$basedir/$fileName"); <br>		while (my $bytesread = read($file, my $buffer, 1024)) { <br>			print OUTFILE $buffer; <br>		} <br>		close (OUTFILE); <br>	}<br>	$onnum++;<br>}<br>print "Content-type: text/html\n";<br>print "Location:$donepage\n\n";<br>
</font>
</pre>
 Соответственно указывая число в цикле <font color="green">while ($onnum
!= 9)</font> можно подгружать нужное чилсо файлов при одном <font
 color="green">POST</font> запросе.   html-код формы для скрипта такой:  
<pre>
<font color="green">&lt;form method="POST" action="/cgi-bin/fup.pl"<br>ENCTYPE="multipart/form-data"&gt;<br>File 1: &lt;input type="file" name="FILE1"&gt;<br>&lt;br&gt;File 2: &lt;input type="file" name="FILE2"&gt;<br>&lt;br&gt;File 3: &lt;input type="file" name="FILE3"&gt;<br>&lt;br&gt;File 4: &lt;input type="file" name="FILE4"&gt;<br>&lt;br&gt;File 5: &lt;input type="file" name="FILE5"&gt;<br>&lt;br&gt;File 6: &lt;input type="file" name="FILE6"&gt;<br>&lt;br&gt;File 7: &lt;input type="file" name="FILE7"&gt;<br>&lt;br&gt;File 8: &lt;input type="file" name="FILE8"&gt;<br>&lt;br&gt;File 9: &lt;input type="file" name="FILE9"&gt;<br>&lt;br&gt;<br>&lt;input type="submit" value="Upload!"&gt;<br>&lt;/form&gt;<br>
</font>
</pre>
 
<p align="justify">Пакеты вида <font color="green">multipart/form-data</font> 
описываются <font color="green">rfc1867</font>, который будет описан более 
подродбно на предмет автоматической посылки изображений через формы, в которых
сказано <font color="green">ENCTYPE="multipart/form-data"</font>, помимо
простого текста(закодированного <font color="green">URI</font>). Т.е. скрипт,
посылающий картинки и текст на удаленный сервер.  </p>
<h4>
<h4>
<a name="modules_html_redir">Редирект пользователя, находящегося за файрволом</a>
</h4>
</h4>
 
<p align="justify">Программа иллюстрирует использование переменной HTTP_X_FORWARDED_FOR
из хэша %ENV, которая позволяет(если прокси не совсем прокси :), узнать о
локальном адресе машины, находящейся за брандмауэром(файрволом, он-же прокси). 
 </p>
<pre>
<font color="green">#!/usr/bin/perl<br>use LWP::UserAgent;<br>use HTTP::Request::Common;<br>
<br>print "Content-type: text/html\n";<br>print "Location: http://www.fsb.gov.ru/\n\n" if (&amp;is_proxy());<br>print "Location:http://www.udaff.com/\n\n" unless (&amp;is_proxy());<br>
<br>sub is_proxy{<br>  return 1 if ($ENV{'HTTP_X_FORWARDED_FOR'} ne "");<br>  $addr = $ENV{'REMOTE_ADDR'};<br>  $ua = new LWP::UserAgent;<br>  $ua-&gt;timeout(5);<br>  foreach(80, 8000, 8080, 3128){<br>    $ua-&gt;proxy('http', "http://$addr:$_/");<br>    $resp = $ua-&gt;request(GET "http://www.ru/");<br>    $cont = $resp-&gt;content();<br>    return 1 if ($cont =~ /Russia on the Net/)<br>  }<br>  return 0;<br>}<br>
</font>
</pre>
 скрипт написан <a href="mailto:grange@grange.ru">grange</a> 
<h4>
<h4>
<a name="modules_html_excel">Создание файла Excel</a>
</h4>
</h4>
 
<p align="justify"> Допустим нужно создать отчет в формате Excel, для этого
нужно скачать и установить модуль Spreadsheet.pm c сайта www.cpan.org. Приведенная
ниже программа позволяет генерить файлы в формате excel с нужным размером
полей, цветом букв и выравниванием содержимого ячеек по запросу пользователя. 
 </p>
<p align="justify">.  </p>
<pre>
<font color="green">#!/usr/bin/perl -w<br>use strict;<br>use Spreadsheet::WriteExcel;<br>use Lingua::RU::Charset qw (:CONVERT);<br>
<br>my $fraze="Жехжкфиео хмфктжэ";<br>my $workbook = Spreadsheet::WriteExcel-&gt;new("pr.xls");<br>my $sheet1 = $workbook-&gt;addworksheet();<br>my $sheet2 = $workbook-&gt;addworksheet();<br>my $sheet3 = $workbook-&gt;addworksheet("Example");<br>my $format = $workbook-&gt;addformat();<br>
<br>$format-&gt;set_bold();<br>$format-&gt;set_size(15);<br>$format-&gt;set_color('blue');<br>$format-&gt;set_align('center');<br>
<br>$sheet3-&gt;set_column(0, 0, 50);<br>$sheet3-&gt;activate();<br>$sheet3-&gt;write(0, 0, koi2win($fraze), $format);<br>$sheet3-&gt;write(1, 0, koi2win($fraze), $format);<br>$sheet3-&gt;write(2, 0, koi2win($fraze));<br>$sheet3-&gt;write(3, 0, koi2win("Дюв"));<br>$sheet3-&gt;write(4, 0, koi2win("Жфк"));<br>$sheet3-&gt;write(5, 0, 4.00001);<br>
<br>my $date = $workbook-&gt;addformat();<br>$date-&gt;set_num_format('mmmm d yyyy h:mm AM/PM');<br>$sheet3-&gt;write(7, 0, 36050.1875, $date);<br>
</font>
</pre>
 Cоответственно получаетcя что-то вида: 
<p align="justify"> </p>
<center>
<img src="perl.gif" width="664" height="514" border="0" alt="">
</center>
 
<p align="justify"> Далее программу можно совершенно свободно курочить как
вздумается и, допустим, переводить данные из dbt(memo-тип) в Excel. В данном
примере была применена библиотека для перекодирования от Алекса Фарбера,
т.к. скрипт отлаживался под XWindows by Linux. В принципе все то-же самое
действует и для просмотра файлов при помощи StarOffice.  </p>
<h4>
<h4>
<a name="modules_html_rename">Переименование директорий</a>
</h4>
</h4>
 
<p align="justify"> Допустим проблема, есть диск с <font color="green">ufs</font>,
на котором есть директории, названные по русски. Нужно этот диск подмонтировать
на <font color="green">ext2</font>. А директории в <font color="green">ISO</font>
кодировке <font color="green">Samba</font> не воспринимает, точнее не <font
 color="green">Samba</font>, a пользователи <font color="green">Windows</font> 
машин. Значит нужна программа, которая бы умела переделывать названия директорий
из <font color="green">iso</font> в <font color="green">win1251</font>. Приведенная
ниже программа использует ту-же самую библиотеку перекодировщик:  </p>
<pre>
<font color="green">#!/usr/bin/perl<br>print "content-type: text/html\n\n";<br>use Lingua::RU::Charset qw (:CONVERT);<br>my $di="/raznoe";<br>&amp;scan($di);<br>
<br>sub  scan {<br>  my $dir=$_[0];<br>  my (@files,$filen,$ndir,$n,$mass,@dirs);<br>  opendir D, $dir or warn "Cannot open $dir: $!" and next;<br>  @dirs=grep {!(/^\./) &amp;&amp; -d "$dir/$_"} readdir D;<br>  rewinddir D;<br>  closedir D;<br>  for $n(0..$#dirs) {<br>    my @ma=koi2win(iso2koi($dirs[$n]));<br>    print "-----begindir-----\n [ ",win2koi("$dir/$dirs[$n]")," - ",<br>          win2koi("$dir/$ma[$#ma]")," ]";<br>    print " [ ",iso2koi($dirs[$n])," - NEW DIR ] " if rename<br>"$dir/$dirs[$n]", "$dir/$ma[$#ma]";<br>    $ndir="$dir/$ma[$#ma]";<br>    print "\n [ new scan dir - ",win2koi($ndir)," ] \n-----enddir-----\n\n";<br>    &amp;scan($ndir);<br>  }<br>  return 1;<br>}<br>
</font>
</pre>
 
<p align="justify">Программа довольно проста, чтобы е&#9574; объяснять. Просто
как иллюстрация использования языка <font color="green">perl</font> для нужд 
системного администрирования в случае возникновения экстренных ситуаций. Самое
сложное здесь было определить какая кодировка на <font color="green">ufstype=44bsd.</font>
Рекомендую пользоваться этой программой, имея некоторый опыт работы хотя-бы
с <font color="green">Linux</font>(дабы не было проблем при отладке с командами
типа <font color="green">chmod -R 777 .</font>, которая просто насмерть убивает
<font color="green">sendmail</font>). Вообще <font color="green">perl</font>
для админа <font color="green">Linux/FreeBSD</font> лучшая находка. Не считая 
<font color="green">shell</font> конечно(у которого нет <font
 color="green">http://www.cpan.org</font> :). </p>
<p align="justify"> То-же самое, но для файлов(можно было бы слинковать в
одну программу, мне лень :)  </p>
<p align="justify">  </p>
<pre>
<font color="green">#!/usr/bin/perl<br>use Lingua::RU::Charset qw (:CONVERT);<br>my $di="/raznoe";<br>&amp;scan($di);<br>sub  scan {<br>  my $dir=$_[0];<br>  my (@files,$filen,$ndir,$n,$mass,@dirs);<br>  opendir D, $dir or warn "Cannot open $dir: $!" and next;<br>  @dirs=grep {!(/^\./) &amp;&amp; -d "$dir/$_"} readdir D;<br>  rewinddir D;<br>  @files=grep {!(/^\./) &amp;&amp; -f "$dir/$_"} readdir D;<br>  closedir D;<br>
<br>  for $n(0..$#dirs) {<br>    $ndir="$dir/$dirs[$n]";<br>    &amp;scan($ndir);<br>  }<br>  for $n(0..$#files) {<br>    $filen=$dir."/".$files[$n];<br>    my @mass=koi2win(iso2koi("$files[$n]"));<br>    print " [ ",iso2koi($files[$n])," =&gt; NEW FILE!!! ]\n"<br>      if rename "$dir/$files[$n]", "$dir/$mass[$#mass]"<br>      or die "Cant rename $dir/$mass[$#mass]: $!\n" and next;<br>  }<br>  return 1;<br>}</font>
</pre>
<ul>
<li><a href="files/file_find.html">File::Find</a>
<li><a href="files/image_size.html">Image::Size</a>
<li><a href="files/mime_lite.html">Mime::Lite</a>
<li><a href="files/image_magick.html">ImageMagic</a>
<li><a href="files/ole.html">OLE</a>
<li><a href="files/spreadsheet_writeexcel.html">Spreadsheet::WriteExcel</a>
<li><a href="files/mp3_info.html">MP3::Info</a>
<li><a href="files/mason.html">Mason</a>
<li><a href="files/lwp_simple.html">LWP::Simple</a>
<li><a href="files/post.html">Post</a>
</ul>
<center>
</center>
<hr>

<a name="uniqhash_html"></a>
<center>
<h4>
<a name=uniqhash_html_uniqhash>Как найти уникальные ключи в двух
хешах?</a>
</h4>
</center>

<p>
Во первых нужно извлечь ключи из хешей и затем выбирать
уникальные элементы из массива:
<font color=green>
<pre>
        %seen = ();
        for $element (keys(%foo), keys(%bar)) {
            $seen{$element}++;
        }
        @uniq = keys %seen;
</pre>
</font>
или так:
<font color=green>
<pre>
        @uniq = keys %{{%foo,%bar}};
</pre>
</font>
если необходимо использовать минимальный размер памяти:
<font color=green>
<pre>
        %seen = ();
        while (defined ($key = each %foo)) {
            $seen{$key}++;
        }
        while (defined ($key = each %bar)) {
            $seen{$key}++;
        }
        @uniq = keys %seen;
</pre>
</font>

для того, чтобы выбрать повторения из массива можно воспользоваться строчкой:
<font color=green>
<pre>
        @uniq=grep{!$hash{$_}++} @mass;
</pre>
</font>
для того, чтобы убрать строки в массиве, содержащие какие-то произвольные одинаковые данные, можно немного модифицировать приведенную строчку:
<font color=green>
<pre>
        @uniq=grep{!$hash{$1}++ if m&$name\001($value)\001$other\n&} @mass;
</pre>
</font>
<hr>

<!--#include virtual="/footer.raw"-->

</body></html>