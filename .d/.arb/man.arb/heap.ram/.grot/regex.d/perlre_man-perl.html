<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
<META NAME="Author" CONTENT="Valeriy Kravchuk">
<META NAME="Copyright" CONTENT="2000 by OpenXS Initiative">
<META NAME="Revision" CONTENT="$Revision: 1.1 $">
<title>Регулярные выражения в языке Perl: перевод man perlre</title>
</head>
<body bgcolor="#DDE1C2">
<!--#include virtual="/header.raw"-->
<h3>Версия для печати</h3>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/141.shtml">Perl</a>"
</b>
 <small>(<a href="./">Многостраничная версия</a>)</small>
<hr noshade size=1>

<a name="index_html"></a>
<p><font size = -1>OpenXS Russian Perl Docs</font></p>
<br>Оригинал: <a href="http://ln.ua/~openxs/articles/perlre.html">ln.ua/~openxs</a>
<br>Автор: Valeriy Kravchuk

<table border=0 cellspacing=0 cellpadding=0 width="100%">
<tr>
<td valign=top><h1>Perl 5.6.0</h1></td>
<td valign=top><h1 align=right>PERLRE(1)</h1></td>
</tr>
</table>

<h2><a index_html_name="name">НАЗВАНИЕ</a></h2>
<p><b>perlre</b> - регулярные выражения Perl</p>

<h2><a name="index_html_description">ОПИСАНИЕ</a></h2>

<p>В этом руководстве описан
синтаксис регулярных выражений в языке Perl. Описание того, как практически
использовать регулярные выражения в операциях сопоставления с образцом, а также
разнообразные примеры на эту тему можно найти в разделах <b>m//</b> и <b>s///</b> на странице
справочного руководства <b>perlop</b>.<br>
<br>
Операции сопоставления могут иметь различные модификаторы, в том числе, связанные с
интерпретацией используемых регулярных выражений. Вот эти модификаторы:</p>

<table border=0 cellspacing=4 cellpadding=4>
 <tr>
  <td width=158 valign=top>
  <p><b>i</b></p>
  </td>
  <td width=454 valign=top>
  <p>Игнорировать регистр символов при сопоставлении с образцом.</p>
  </td>
 </tr>
 <tr>
  <td>
  <p><b>m</b></p>
  </td>
  <td>
  <p>Обрабатывать буфер как несколько строк.</p>
  </td>
 </tr>
 <tr>
  <td>
  <p><b>s</b></p>
  </td>
  <td>
  <p>Обрабатывать буфер как одну строку.</p>
  </td>
 </tr>
 <tr>
  <td>
  <p><b>x</b></p>
  </td>
  <td>
  <p>Повысить   удобочитаемость шаблона путем включения пробелов и комментариев.</p>
  </td>
 </tr>
</table>

<p>Последний обычно называют &quot;модификатор /x&quot;, хотя рассматриваемый
разделитель может и не быть косой. Фактически, любой из этих модификаторов
может быть встроен в регулярное выражение с помощью новой конструкции <b>(?...)</b>. См. ниже.<br>
<br>
Сам
модификатор <b>/x</b> требует немного более
подробного рассмотрения. Он заставляет синтаксический анализатор регулярных
выражений игнорировать пробельные символы, не замаскированные обратной косой и
не входящие в класс символов. Это можно использовать для разбиения регулярного
выражения на (немного) более понятные части. Символ <b>#</b> также рассматривается как метасимвол начала комментария, как в
остальном коде на Perl. Взятые вместе, эти возможности делают Perl 5 намного
более удобочитаемым языком. См. пример кода для удаления комментариев в
программе на C на странице справочного руководства <b>perlop</b>.</p>

<h3>Регулярные выражения</h3>

<p>Шаблоны, используемые при сопоставлении с образцом,
являются регулярными выражениями типа используемых в версии 8 библиотеки <b>regexp</b>. (Фактически,
соответствующие функции являются производными (хотя и весьма далекими) от свободно
распространяемой реализации версии 8, которую выполнил Henry Spencer.)
Подробнее см. раздел <b>&quot;Регулярные выражения версии 8&quot;</b>.<br>
<br>
В частности, следующие метасимволы имеют стандартные, знакомые по <b>egrep</b>, значения:</p>

<table border=0 cellspacing=4 cellpadding=4>
 <tr>
  <td width=158 valign=top>
  <p><b>\</b></p>
  </td>
  <td width=454 valign=top>
  <p>Маскирует следующий метасимвол</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>^</b></p>
  </td>
  <td>
  <p>Соответствует началу строки</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>.</b></p>
  </td>
  <td>
  <p>Соответствует любому символу (кроме символа перевода строки)</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>$</b></p>
  </td>
  <td>
  <p>Соответствует концу строки (перед символом перевода строки в конце)</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>|</b></p>
  </td>
  <td>
  <p>Дизъюнкция</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>()</b></p>
  </td>
  <td>
  <p>Группировка</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>[]</b></p>
  </td>
  <td>
  <p>Класс символов</p>
  </td>
 </tr>
</table>

<p>По умолчанию, символ &quot;<b>^</b>&quot;
гарантированно соответствует только началу строки, а символ &quot;<b>$</b>&quot; - только концу строки (или
позиции перед символом перевода строки в конце), причем Perl выполняет ряд
оптимизаций исходя из предположения, что буфер содержит только одну строку.
Встроенным переводам строк не будут соответствовать метасимволы &quot;<b>^</b>&quot; или &quot;<b>$</b>&quot;. Может, однако, понадобиться рассматривать буфер как
многострочный, так чтобы &quot;<b>^</b>&quot;
соответствовал позиции после символа перевода строки в буфере, а &quot;<b>$</b>&quot; - позиции перед символом
перевода строки. За счет незначительного повышения накладных расходов это можно
сделать с помощью модификатора <b>/m</b> в
операторе сопоставления с образцом. (Старые программы для этого устанавливали <b>$*</b>, но такая практика теряет смысл в
Perl 5.)<br>
<br>
Чтобы упростить многострочные подстановки, символ &quot;<b>.</b>&quot; никогда не соответствует
символу перевода строки, если только не используется модификатор <b>/s</b>, сообщающий Perl о необходимости
рассматривать буфер как однострочный, - даже если в нем несколько строк.
Модификатор <b>/s</b> также отменяет
установку <b>$*</b>, если используется
(неудачный) старый код, устанавливающий его в другом модуле.<br>
<br>
Распознаются
следующие стандартные квантификаторы:</p>

<table border=0 cellspacing=4 cellpadding=4>
 <tr>
  <td width=158 valign=top>
  <p><b>*</b></p>
  </td>
  <td width=454 valign=top>
  <p>Соответствует 0 или более вхождений</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>+</b></p>
  </td>
  <td>
  <p>Соответствует 1 или более вхождений</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>?</b></p>
  </td>
  <td>
  <p>Соответствует 1 или 0 вхождений</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>{n}</b></p>
  </td>
  <td>
  <p>Соответствует ровно <b>n</b> вхождений</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>{n,}</b></p>
  </td>
  <td>
  <p>Соответствует не менее <b>n</b> вхождений</p>
  </td>
 </tr>
 <tr>
  <td width=158>
  <p><b>{n,m}</b></p>
  </td>
  <td>
  <p>Соответствует не менее <b>n</b> и не более <b>m</b> вхождений</p>
  </td>
 </tr>
</table>

<p>(Если фигурная скобка встречается в любом другом контексте, она
рассматривается как обычный символ.) Модификатор &quot;<b>*</b>&quot; эквивалентен <b>{0,}</b>,
модификатор &quot;<b>+</b>&quot; - <b>{1,}</b>, а модификатор &quot;<b>?</b>&quot; - <b>{0,1}</b>. <b>n</b> и <b>m</b> должны иметь целые значения, не
превышающие 65536.<br>
<br>
По умолчанию, квантифицированный подшаблон -
&quot;жадный&quot;, т.е. он будет сопоставляться с как можно большим
количеством вхождений, при котором остаток шаблона сможет сопоставиться. Все
стандартные квантификаторы &quot;жадные&quot;, т.к. сопоставляются с
максимально возможным количеством вхождений (начиная с данного места). Если
необходимо сопоставление с минимально возможным количеством вхождений, после
квантификатора необходимо указать &quot;<b>?</b>&quot;.
Учтите, что изменяется не значение квантификаторов, а &quot;вес&quot;, - они
будут сопоставляться с наименьшей возможной подстрокой:</p>

<table border=0 cellspacing=4 cellpadding=4>
 <tr>
  <td width=158 valign=top>
  <p><b>*?</b></p>
  </td>
  <td width=454 valign=top>
  <p>Соответствует 0 или более вхождений</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>+?</b></p>
  </td>
  <td>
  <p>Соответствует 1 или более вхождений</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>??</b></p>
  </td>
  <td>
  <p>Соответствует 1 или 0 вхождений</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>{n}?</b></p>
  </td>
  <td>
  <p>Соответствует ровно <b>n</b> вхождений</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>{n,}?</b></p>
  </td>
  <td>
  <p>Соответствует не менее <b>n</b> вхождений</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>{n,m}?</b></p>
  </td>
  <td>
  <p>Соответствует не менее <b>n</b> и не более <b>m</b> вхождений</p>
  </td>
 </tr>
</table>

<p>Поскольку шаблоны обрабатываются как строки в двойных кавычках, следующие
метасимволы тоже будут работать:</p>

<table border=0 cellspacing=4 cellpadding=4>
 <tr>
  <td width=158 valign=top>
  <p><b>\t</b></p>
  </td>
  <td width=454 valign=top>
  <p>табуляция</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\n</b></p>
  </td>
  <td>
  <p>перевод строки</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\r</b></p>
  </td>
  <td>
  <p>возврат каретки</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\f</b></p>
  </td>
  <td>
  <p>form feed</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\a</b></p>
  </td>
  <td>
  <p>звуковой сигнал</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\e</b></p>
  </td>
  <td>
  <p>escape (вспомните <b>troff</b>)</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\033</b></p>
  </td>
  <td>
  <p>восьмеричный символ (вспомните PDP-11)</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\x1B</b></p>
  </td>
  <td>
  <p>шестнадцатеричный символ</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\c[</b></p>
  </td>
  <td>
  <p>управляющий символ</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\l</b></p>
  </td>
  <td>
  <p>перевести следующий символ в нижний регистр (вспомните <b>vi</b>)</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\u</b></p>
  </td>
  <td>
  <p>перевести следующий символ в верхний регистр (вспомните <b>vi</b>)</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\L</b></p>
  </td>
  <td>
  <p>переводить в нижний регистр до <b>\E</b> (вспомните <b>vi</b>)</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\U</b></p>
  </td>
  <td>
  <p>переводить в верхний регистр до <b>\E</b> (вспомните <b>vi</b>)</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\E</b></p>
  </td>
  <td>
  <p>конец изменения регистра символов (вспомните <b>vi</b>)</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\Q</b></p>
  </td>
  <td>
  <p>маскировать метасимволы <b>regexp</b> до <b>\E</b></p>
  </td>
 </tr>
</table>

<p>Кроме того, Perl определяет следующие метасимволы:</p>

<table border=0 cellspacing=4 cellpadding=4>
 <tr>
  <td width=158 valign=top>
  <p><b>\w</b></p>
  </td>
  <td width=454 valign=top>
  <p>Соответствует &quot;символу слова&quot; (алфавитно-цифровые символы плюс &quot;<b>_</b>&quot;)</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\W</b></p>
  </td>
  <td>
  <p>Соответствует символу, не являющемуся &quot;символом слова&quot;</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\s</b></p>
  </td>
  <td>
  <p>Соответствует пробельному символу</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\S</b></p>
  </td>
  <td>
  <p>Соответствует не пробельному символу</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\d</b></p>
  </td>
  <td>
  <p>Соответствует цифре</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\D</b></p>
  </td>
  <td>
  <p>Соответствует не цифре</p>
  </td>
 </tr>
</table>

<p>Учтите, что <b>\w</b> соответствует
одному алфавитно-цифровому символу, а не целому слову. Чтобы указать
соответствие слову, необходимо использовать <b>\w+</b>. Метасимволы <b>\w</b>, <b>\W</b>, <b>\s</b>, <b>\S</b>, <b>\d</b> и <b>\D</b> можно использовать при задании классов символов (но не в
качестве одной из границ диапазона).<br>
<br>
Perl определяет следующие <i>утверждения нулевой длины</i> (zero-width
assertions):</p>

<table border=0 cellspacing=4 cellpadding=4>
 <tr>
  <td width=158 valign=top>
  <p><b>\b</b></p>
  </td>
  <td width=454 valign=top>
  <p>Соответствует границе слова</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\B</b></p>
  </td>
  <td>
  <p>Соответствует позиции, не являющейся границей слова</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\A</b></p>
  </td>
  <td>
  <p>Соответствует только позиции в начале строки</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\Z</b></p>
  </td>
  <td>
  <p>Соответствует
  только позиции в конце строки (или перед последним символом перевода строки)</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>\G</b></p>
  </td>
  <td>
  <p>Соответствует только позиции, в которой остановился предыдущий оператор <b>m//g</b></p>
  </td>
 </tr>
</table>

<p>Граница слова (<b>\b</b>) определяется
как точка между двумя символами, с одной стороны от которой находится <b>\w</b>, а с другой - <b>\W</b> (в любом порядке), считая воображаемые символы начала и конца
строки соответствующими <b>\W</b>. (Внутри
классов символов <b>\b</b> представляет
забой - backspace, а не границу слова.) Метасимволы <b>\A</b> и <b>\Z</b> аналогичны
&quot;<b>^</b>&quot; и &quot;<b>$</b>&quot;, но не будут сопоставляться
несколько раз при использовании модификатора <b>/m</b>, тогда как &quot;<b>^</b>&quot;
и &quot;<b>$</b>&quot; будут сопоставляться
с границей каждой внутренней строки. Чтобы указать соответствие с реальным
концом строки, не исключая символ перевода строки, можно использовать <b>\Z(?!\n)</b>.<br>
<br>
При использовании
скобочной конструкции <b>( ... )</b>, <b>\&lt;цифра&gt;</b> соответствует <b>&lt;цифра&gt;</b>-й подстроке. За пределами
шаблона всегда используйте перед цифрой &quot;<b>$</b>&quot; вместо &quot;<b>\</b>&quot;.
(Запись <b>\&lt;цифра&gt;</b> может в
редких случаях срабатывать за пределами текущего шаблона, но на это не надо
полагаться. См. <a href="#index_html_warning">ПРЕДУПРЕЖДЕНИЕ</a> ниже.) Область действия <b>$&lt;digit&gt;</b> (а также <b>$`</b>,
<b>$&amp;</b> и <b>$'</b>) распространяется до конца охватывающего блока или оцениваемой
строки, или до следующего успешного сопоставления с образцом, в зависимости от
того, что будет раньше. Если вы хотите использовать скобки для ограничения
подшаблона (например, набора альтернатив), не запоминая его как подшаблон,
укажите <b>?</b> после <b>(</b>.<br>
<br>
Можно использовать любое количество скобок. Если
имеется более 9 подстрок, переменные <b>$10</b>,
<b>$11</b>, ... будут ссылаться на
соответствующую подстроку. В шаблоне <b>\10</b>,
<b>\11</b> и т.д. ссылаются на уже
сопоставленные подстроки, если их уже было столько до этой обратной ссылки. В
противном случае (для обратной совместимости) <b>\10</b> совпадает с <b>\010</b>,
или символом забоя, а <b>\11</b> совпадает
с <b>\011</b>, символом табуляции. И так
далее. (Последовательности от <b>\1</b> до <b>\9</b> всегда рассматриваются как обратные
ссылки.)<br>
<br>
<b>$+</b> возвращает
то, с чем сопоставилась последняя конструкция в скобках. <b>$&amp;</b> возвращает всю сопоставившуюся строку. (Раньше для этого
использовался <b>$0</b>, но больше не
используется.) <b>$`</b> возвращает все,
что идет до начала сопоставившейся строки. <b>$'</b>
возвращает все, что идет после сопоставившейся строки. Примеры:</p>

<pre>
s/^([^ ]*) *([^ ]*)/$2 $1/; # поменять местами
                            # два первых слова

if (/Time: (..):(..):(..)/) {
     $hours = $1;
     $minutes = $2;
     $seconds = $3;
}
</pre>

<p>Обратите внимание, что все метасимволы, предваряемые обратной косой, в Perl -
алфавитно-цифровые, например, <b>\b</b>, <b>\w</b>, <b>\n</b>. В отличие от некоторых языков регулярных
выражений, здесь обратная косая не предваряет метасимволы, не являющиеся алфавитно-цифровыми.
Поэтому все конструкции вида <b>\\</b>, <b>\(</b>, <b>\)</b>, <b>\&lt;</b>, <b>\&gt;</b>, <b>\{</b> 
или <b>\}</b> всегда интерпретируются как литеральные символы, а не как метасимволы. Это упрощает
маскировку строки, которую необходимо использовать в качестве шаблона, но которая, как вы опасаетесь, 
может содержать метасимволы. Просто замаскируйте все не алфавитно-цифровые символы:</p>

<pre>
$pattern =~ s/(\W)/\\$1/g;
</pre>

<p>Для этого можно также использовать встроенную функцию <b>quotemeta()</b>. Еще
проще замаскировать метасимволы прямо в операторе сопоставления можно следующим
образом</p>

<pre>
/$unquoted\Q$quoted\E$unquoted/
</pre>

<p>Perl 5 определяет последовательный синтаксис расширений для
регулярных выражений. Для этого используется пара круглых скобок, первым
символом в которых указан знак вопроса (в Perl 4 это было синтаксической ошибкой).
Символ после знака вопроса задает функцию расширения. Поддерживается несколько
расширений:</p>

<table border=0 cellspacing=4 cellpadding=4>
 <tr>
  <td width=196 valign=top>
  <p><b>(?#text)</b></p>
  </td>
  <td width=435 valign=top>
  <p>Комментарий. Текст игнорируется. Если использован переключатель <b>/x</b> для вставки 
  форматирующих пробелов, достаточно указать просто <b>#</b>.</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>(?:regexp)</b></p>
  </td>
  <td>
  <p>Группирует элементы аналогично &quot;<b>()</b>&quot;, но не
  создает обратных ссылок, как &quot;<b>()</b>&quot;.
  Поэтому</p>
<pre>
split(/\b(?:a|b|c)\b/)</span></p>
</pre>
  <p>аналогично</p>
<pre>
split(/\b(a|b|c)\b/)
</pre>
<p>но не порождает дополнительные поля.</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>(?=regexp)</b></p>
  </td>
  <td>
  <p>Положительный просмотр вперед нулевой длины. Например, <b>/\w+(?=\t)/</b>
  соответствует слову, после которого идет символ табуляции, но табуляция не
  включается в <b>$&amp;</b>.</p>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>(?!regexp)</b></p>
  </td>
  <td>
  <p>Отрицательный просмотр вперед нулевой длины. Например, <b>/foo(?!bar)/</b>
  соответствует любому вхождению &quot;<b>foo</b>&quot;,
  за которым не идет &quot;<b>bar</b>&quot;.
  Учтите, однако, что просмотр вперед и просмотр назад - НЕ одно и то же.
  Нельзя использовать эту конструкцию для поиска назад: <b>/(?!foo)bar/</b> не найдет вхождение &quot;<b>bar</b>&quot;, перед которым не идет &quot;<b>foo</b>&quot;. Так происходит потому, что <b>(?!foo)</b> означает, что дальше не должна идти строка &quot;<b>foo</b>&quot; -- а она и не идет, идет
  &quot;<b>bar</b>&quot;, поэтому &quot;<b>foobar</b>&quot; будет соответствовать
  этому шаблону. Необходимо задавать что-то вроде <b>/(?foo)...bar/</b>. &quot;Вроде&quot; - потому, что перед &quot;<b>bar</b>&quot; может и не быть трех
  символов. Этот случай можно охватить следующим образом: <b>/(?:(?!foo)...|^..?)bar/</b>. Иногда все же проще написать:</p>
  <pre>
  if (/foo/ &amp;&amp; $` =~ /bar$/)
  </pre>
  </td>
 </tr>
 <tr>
  <td valign=top>
  <p><b>(?imsx)</b></p>
  </td>
  <td>
  <p>Один или несколько встроенных модификаторов сопоставления с образцом. Это
  особенно полезно для шаблонов, заданных в отдельной таблице, когда некоторые
  из них должны учитывать регистр символов, а другие - нет. Для учитывающих
  регистр символов достаточно просто включить <b>(?i)</b> перед шаблоном. Например:</p>
<pre>  
  $pattern = &quot;foobar&quot;;
  if ( /$pattern/i )

  # более гибкий способ:

  $pattern = &quot;(?i)foobar&quot;;<br>
  if ( /$pattern/ )
</pre>
  </td>
 </tr>
</table>

<p>Знак вопроса для этого и новой конструкции минимального сопоставления был
выбран потому, что 1) знак вопроса редко встречался в прежних регулярных
выражениях и 2) когда вы видите знак вопроса, надо остановиться и
&quot;спросить&quot; себя, что же на самом деле происходит. Это психология...</p>

<h3>Поиск с возвратом</h3>

<p>Фундаментальное свойство сопоставления
регулярных выражений связано с понятием, которое называется поиск с возвратом
(backtracking) и используется (при необходимости) всеми квантификаторами
регулярных выражений, а именно <b>*</b>, <b>*?</b>, <b>+</b>, <b>+?</b>, <b>{n,m}</b> и <b>{n,m}?</b>.<br>
<br>
Чтобы регулярное выражение сопоставилось с
образцом, оно должно сопоставиться целиком, а не только частично. Поэтому если
начало шаблона, содержащего квантификатор, успешно сопоставилось так, что
остаток шаблона не сопоставляется, механизм сопоставления возвращается назад и
перевычисляет начальную часть -- вот откуда и название &quot;поиск с
возвратом&quot;.<br>
<br>
Вот пример поиска с возвратом: предположим,
необходимо найти слово, идущее после &quot;<b>foo</b>&quot;
в строке &quot;<b>Food is on the foo table.</b>&quot;:</p>

<pre>
$_ = &quot;Food is on the foo table.&quot;;
if ( /\b(foo)\s+(\w+)/i ) {
     print &quot;$2 follows $1.\n&quot;;
}
</pre>

<p>При выполнении сопоставления для первой части регулярного выражения (<b>\b(foo)</b>) найдется возможное
соответствие прямо в начале строки, при этом в <b>$1</b> будет помещено значение &quot;<b>Foo</b>&quot;.
Однако, как только механизм сопоставления увидит, что
после сохраненного в <b>$1</b> значения
&quot;<b>Foo</b>&quot; нет пробела, он
поймет свою ошибку и начнет снова со следующего символа после неудавшегося
сопоставления an. В этот раз он пройдет до следующего вхождения &quot;<b>foo</b>&quot;. Все регулярное выражение в
целом теперь сопоставляется и будет получен ожидаемый результат, &quot;<b>table follows foo.</b>&quot;.<br>
<br>
Иногда минимальное сопоставление может оказаться очень полезным. Предположим,
необходимо найти все, что идет между строками &quot;<b>foo</b>&quot; и &quot;<b>bar</b>&quot;.
Сразу можно написать что-то вроде:</p>

<pre>
$_ = &quot;The food is under the bar in the barn.&quot;;
if ( /foo(.*)bar/ ) {
     print &quot;got &lt;$1&gt;\n&quot;;
}
</pre>

<p>Что, возможно, неожиданно, выдает:</p>

<pre>
got &lt;d is under the bar in the &gt;
</pre>

<p>Так произошло потому, что шаблон <b>.*</b> был жадным, вот вы и получили все от
первого &quot;<b>foo</b>&quot; до последнего &quot;<b>bar</b>&quot;. В этом
случае более эффективно использовать минимальное сопоставление, гарантирующее,
что вы получите текст между &quot;<b>foo</b>&quot; и первым же вхождением &quot;<b>bar</b>&quot;
после него.</p>

<pre>
if ( /foo(.*?)bar/ ) { 
  print &quot;got &lt;$1&gt;\n&quot;
}
got &lt;d is under the &gt;
</pre>

<p>Вот другой пример: пусть необходимо найти число в конце строки и
сохранить предыдущую сопоставившуюся часть. Вы пишете следующее:</p>

<pre>
$_ = &quot;I have 2
numbers: 53147&quot;;<br>
if ( /(.*)(\d*)/ ) {               #Ошибка!
     print &quot;Beginning is &lt;$1&gt;, number is &lt;$2&gt;.\n&quot;;
}
</pre>

<p>Это вообще не сработает, поскольку шаблон <b>.*</b>
был жадным и поглотил всю строку. Поскольку <b>\d*</b> может соответствовать пустой строке, все 
регулярное выражение в целом успешно сопоставляется.</p>

<pre>
Beginning is &lt;I have 2: 53147&gt;, number is &lt;&gt;.
</pre>

<p>Вот еще несколько вариантов, большинство из которых не сработает:</p>

<pre>
$_ = "I have 2 numbers: 53147";
@pats = qw{
     (.*)(\d*)
     (.*)(\d+)
     (.*?)(\d*)
     (.*?)(\d+)
     (.*)(\d+)$
     (.*?)(\d+)$
     (.*)\b(\d+)$
     (.*\D)(\d+)$
};
for $pat (@pats) {
     printf "%-12s ", $pat;
     if ( /$pat/ ) {
          print "&lt;$1&gt; &lt;$2&gt;\n";
     } else {
          print "FAIL\n";
     }
}
</pre>

В результате будет выдано:<br>

<pre>
(.*)(\d*)     &lt;I have 2 numbers: 53147> &lt;>
(.*)(\d+)     &lt;I have 2 numbers: 5314> &lt;7>
(.*?)(\d*)     &lt;> &lt;>
(.*?)(\d+)     &lt;I have > &lt;2>
(.*)(\d+)$     &lt;I have 2 numbers: 5314> &lt;7>
(.*?)(\d+)$     &lt;I have 2 numbers: > &lt;53147>
(.*)\b(\d+)$     &lt;I have 2 numbers: > &lt;53147>
(.*\D)(\d+)$     &lt;I have 2 numbers: > &lt;53147>
</pre>

<p>Как видите,
все это может быть немого мудрено. Важно понимать, что регулярное выражение -
это просто набор утверждений, определяющих успешный результат. Может быть 0, 1
или несколько различных способов удовлетворить определение на конкретной
строке. И если имеется несколько вариантов успешного сопоставления, необходимо
понимать принципы поиска с возвратом, чтобы понять, какой вариант успешного
сопоставления будет получен.<br>
<br>
При использовании просмотров вперед и
отрицаний, ситуация может еще более усложниться. Предположим, необходимо найти
последовательность символов, отличных от цифр, за которыми не идет &quot;<b>123</b>&quot;. 
Можно попытаться записать это следующим образом</p>

<pre>
$_ = &quot;ABC123&quot;;
if ( /^\D*(?!123)/ ) {               # Ошибка!
     print &quot;Yup, no 123 in $_\n&quot;;
}
</pre>

<p>Но результата не будет; по крайней мере, такого, как вы ожидали. Утверждается, что
в строке нет <b>123</b>. Вот более четкая картина того, почему, вопреки популярным ожиданиям, произошло
сопоставление:</p>

<pre>
$x = 'ABC123' ;
$y = 'ABC445' ;

print &quot;1: got $1\n&quot; if $x =~ /^(ABC)(?!123)/ ;
print &quot;2: got $1\n&quot; if $y =~ /^(ABC)(?!123)/ ;

print &quot;3: got $1\n&quot; if $x =~ /^(\D*)(?!123)/ ;
print &quot;4: got $1\n&quot; if $y =~ /^(\D*)(?!123)/ ;
</pre>

<p>Будет выдано</p>

<pre>
2: got ABC
3: got AB
4: got ABC
</pre>

<p>Вы могли ожидать, что проверка 3 не сработает, поскольку она кажется более
универсальной версией 1. Важное различие между ними состоит в том, что проверка
3 содержит квантификатор <b>(\D*)</b> и поэтому может использовать поиск с возвратом, тогда как проверка 1 - нет. На
самом деле вы спрашиваете: &quot;Правда ли, что в начале <b>$x</b>, после 0 или более не цифр, идет нечто, 
отличающееся от <b>123</b>?&quot;. Если механизм сопоставления
позволит <b>\D*</b> расшириться до &quot;<b>ABC</b>&quot;, весь шаблон в целом не
сопоставится. Поисковая машина первоначально сопоставит <b>\D*</b> с &quot;<b>ABC</b>&quot;.
Затем она попытается сопоставить <b>(?!123)</b>
c &quot;<b>123</b>&quot;, что, конечно,
невозможно. Но поскольку в регулярном выражении использован квантификатор <b>(\D*)</b>, поисковая машина может вернуться
и поискать другое сопоставление в надежде найти сопоставить все регулярное
выражение в целом.<br>
<br>
Теперь, поскольку сопоставление шаблона так
желанно для поисковой машины, она использует стандартный возврат и повторную
попытку <b>regexp</b> (backoff-and-retry) и
позволяет на это раз <b>\D*</b> расшириться
только до &quot;<b>AB</b>&quot;. Теперь и в
самом деле имеется нечто после &quot;<b>AB</b>&quot;,
что не совпадает с &quot;<b>123</b>&quot;.
Это &quot;<b>C123</b>&quot;, что вполне
устраивает.<br>
<br>
Справиться с эти можно, используя совместно утверждение
и отрицание. Мы скажем, что после первой части в <b>$1</b> должна идти цифра, но там должно идти нечто, отличное от &quot;<b>123</b>&quot;. Помните, что просмотры
вперед - это выражения нулевой длины -- при сопоставлении выполняется только
проверка, но не берется часть строки. После таких изменений будет получен
желаемый результат; т.е. в случае 5 - неудача, а в случае 6 - успех:</p>

<pre>
print &quot;5: got $1\n&quot; if $x =~ /^(\D*)(?=\d)(?!123)/ ;
print &quot;6: got $1\n&quot; if $y =~ /^(\D*)(?=\d)(?!123)/ ;

6: got ABC
</pre>

<p>Другими словами, два <i>утверждения нулевой длины</i> (zero-width assertions), идущие подряд,
работают так, как если бы проверялась их конъюнкция, так же, как и при
использовании любых встроенных утверждений: шаблон <b>/^$/</b> сопоставляется, только если вы находитесь в начале строки И в
конце строки одновременно. Более глубокое основание этого - в том, что
соседство в регулярных выражениях всегда означает И, кроме явного указания ИЛИ
с помощью вертикальной черты. <b>/ab/</b>
означает сопоставить &quot;<b>a</b>&quot; И
(затем) сопоставить &quot;<b>b</b>&quot;,
хотя попытки сопоставления и делаются в разных позициях, т.к. &quot;<b>a</b>&quot; - утверждение не нулевой длины,
но длины один.<br>
<br>
Одно предупреждение: особенно сложные регулярные
выражения могут потребовать экспоненциального времени сопоставления из-за
огромного количества возможных вариантов сопоставления при поиске с возвратом.
Например, следующий шаблон будет сопоставляться очень долго</p>

<pre>
/((a{0,5}){0,5}){0,5}/
</pre>

<p>А если использовать <b>*</b> вместо ограничения количества вхождений от 0 до 5, сопоставление
будет выполняться бесконечно -- или пока не исчерпается место в стеке.</p>

<h3>Регулярные выражения версии 8</h3>

<p>Если вам не знакомы &quot;стандартные&quot; функции библиотеки <b>regexp</b> версии 8, 
вот правила сопоставления с образцом, не описанные выше.<br>
<br>
Любой одиночный символ сопоставляется с сами собой, если
только это не метасимвол, имеющий специальное значение, описанное здесь или
выше. Символы, обычно работающие как метасимволы, можно потребовать
интерпретировать литерально, предваряя их символом &quot;<b>\</b>&quot; (например, &quot;<b>\.</b>&quot;
соответствует &quot;<b>.</b>&quot;, а не
любому символу; &quot;<b>\\</b>&quot;
соответствует &quot;<b>\</b>&quot;).
Последовательность символов сопоставляется с такой же последовательностью
символов в целевой строке, поэтому шаблон <b>blurfl</b>
сопоставится с &quot;<b>blurfl</b>&quot; в
целевой строке.<br>
<br>
Можно задать класс символов, включив список символов
в квадратные скобки <b>[]</b>, которые
будут сопоставляться с любым из символов в списке. Если первый символ после
&quot;<b>[</b>&quot; - &quot;<b>^</b>&quot;, класс сопоставляется с любым
символом, не указанным в списке. В списке символ &quot;<b>-</b>&quot; используется для указания диапазона, так что <b>a-z</b> представляет все символы от &quot;<b>a</b>&quot; до &quot;<b>z</b>&quot;, включительно.<br>
<br>
Символы можно задавать с
использованием синтаксиса метасимволов, во многом аналогичного используемому
в  C: &quot;<b>\n</b>&quot; соответствует переводу строки, &quot;<b>\t</b>&quot; - табуляции, &quot;<b>\r</b>&quot;
- возврату каретки, &quot;<b>\f</b>&quot; -
form feed и т.д. В общем случае, <b>\nnn</b>,
где <b>nnn</b> - это строка восьмеричных
цифр, соответствует символу, значение кода ASCII для которого - <b>nnn</b>. Аналогично, <b>\xnn</b>, где <b>nn</b> - это
шестнадцатеричные цифры, соответствует символу, значение кода ASCII для
которого - <b>nn</b>. Выражение <b>\cx</b> соответствует символу ASCII <b>control-x</b>. Наконец, метасимвол &quot;<b>.</b>&quot; соответствует любому символу,
кроме &quot;<b>\n</b>&quot; (если только не
используется <b>/s</b>).<br>
<br>
Можно
задавать набор альтернатив для шаблона, разделяя их метасимволом &quot;<b>|</b>&quot;, так что <b>fee|fie|foe</b> сопоставится с любой из подстрок &quot;<b>fee</b>&quot;, &quot;<b>fie</b>&quot; или &quot;<b>foe</b>&quot;
в целевой строке (так же, как и <b>f(e|i|o)e</b>).
Учтите, что первая альтернатива включает все от последнего разделителя шаблона
(&quot;<b>(</b>&quot;, &quot;<b>[</b>&quot; или от начала шаблона) до
первого символа &quot;<b>|</b>&quot;, а
последняя альтернатива включает все от последнего символа &quot;<b>|</b>&quot; до следующего разделителя
шаблона. Поэтому альтернативы обычно берут в круглые скобки, чтобы не
сомневаться, где они начинаются и заканчиваются. Учтите, однако, что в
квадратных скобках &quot;<b>|</b>&quot;
интерпретируется как литерал, поэтому если вы напишите <b>[fee|fie|foe]</b>, сопоставление произойдет только с <b>[feio|]</b>.<br>
<br>
В шаблоне можно
выделять подшаблоны (путем взятия их в круглые скобки) для дальнейших ссылок и
можно ссылаться обратно на <b>n</b>-й
подшаблон в дальнейшем с помощью метасимвола <b>\n</b>. Подшаблоны нумеруются слева направо по открывающим круглым
скобкам. Учтите, что обратная ссылка сопоставляется с тем, с чем сопоставился
подшаблон в рассматриваемой строке, а не с правилами, задающими этот подшаблон.
Поэтому <b>(0|0x)\d*\s\1\d*</b>
сопоставится с &quot;<b>0x1234 0x4321</b>&quot;,
но не с &quot;<b>0x1234 01234</b>&quot;,
поскольку подшаблон 1 фактически сопоставился с &quot;<b>0x</b>&quot;, хотя правило <b>0|0x</b>
потенциально могло сопоставиться с начальным 0 во втором числе.</p>

<h2><a name="index_html_warning">ПРЕДУПРЕЖДЕНИЕ о \1 и $1</a></h2>

<p>Некоторые люди слишком привыкли писать вещи типа</p>

<pre>
$pattern =~ s/(\W)/\\\1/g;<br>
</pre>

<p>Корни такой привычки восходят к правой части оператора замены в <b>sed</b>, но это
плохая привычка. Дело в том, что с точки зрения Perl правая часть <b>s///</b> - это строка в 
двойных кавычках. <b>\1</b> в обычной строке в двойных кавычках
означает <b>control-A</b>. Обычное для Unix значение \1 сохранено в <b>s///</b>.
Однако, если вы привыкните делать именно так, у вас будут проблемы при
добавлении модификатора <b>/e</b>.</p>

<pre>
s/(\d+)/ \1 + 1 /eg;
</pre>

<p>или если вы попытаетесь выполнить</p>

<pre>
s/(\d+)/\1000/;
</pre>

<p>Этой двусмысленности нельзя избежать, написав <b>\{1}000</b>, но можно, если
написать <b>${1}000</b>. Просто операцию интерполяции не надо путать с операцией сопоставления с обратной ссылкой.
Конечно, они имеют разное значение в левой части оператора <b>s///</b>.<br>&nbsp;</p>

<p align=center>
Copyleft (no c) 2000-2002 <a href="mailto:valera@openxs.kiev.ua">В. Кравчук</a>,
<a href="http://ln.com.ua/~openxs">OpenXS Initiative</a>, перевод на русский язык
</p>
<hr>

<!--#include virtual="/footer.raw"-->

</body></html>