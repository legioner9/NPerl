<!DOCTYPE html>
<html lang="en-US">
    <head>
        <title>Net::SSLeay - metacpan.org</title>
        <link rel="preload" as="fetch" href="https://metacpan.org/account/login_status" crossorigin="anonymous" />
        <link href="https://metacpan.org/_assets/b8ccceeed47a0652049703d99326a9cea4933443.css" rel="stylesheet" type="text/css">
        <script src="https://metacpan.org/_assets/6bfedafe2d7caa915b7d84f61b45936818e3242e.js" type="text/javascript" defer></script>
        <link rel="alternate" type="application/rss+xml" title="Recent CPAN Uploads of Net-SSLeay - MetaCPAN" href="https://metacpan.org/dist/Net-SSLeay/releases.rss" />
        <link rel="canonical" href="./Net::SSLeay.html" />
        <meta name="description" content="Perl bindings for OpenSSL and LibreSSL" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
        <link rel="shortcut icon" href="https://metacpan.org/static/icons/favicon.ico">
        <link rel="apple-touch-icon" sizes="152x152" href="https://metacpan.org/static/icons/apple-touch-icon.png">
        <link rel="search" href="https://metacpan.org/static/opensearch.xml" type="application/opensearchdescription+xml" title="MetaCPAN">
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          (function(skey, ga_id){
            ga('create', ga_id, {
              siteSpeedSampleRate : 100,
              storage             : 'none',
              clientId            : localStorage.getItem(skey)
            });
            ga(function(tracker) {
              localStorage.setItem(skey, tracker.get('clientId'));
            });
            ga('send', 'pageview');
          })('ga:clientId', 'UA-27829474-1');
        </script>
<meta name="twitter:card"        content="summary" />
<meta name="twitter:url"         content="https://metacpan.org/pod/Net::SSLeay" />
<meta name="twitter:title"       content="Net::SSLeay" />
<meta name="twitter:description" content="" />
<meta name="twitter:site"        content="metacpan" />
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="header-logo-large hidden-xs">
              <a href="https://metacpan.org/" tabindex="0">
                <svg class="logo" aria-label="MetaCPAN">
                  <use class="logo" href="/static/images/metacpan-logo.svg#logo" />
                </svg>
              </a>
            </div>
            <div class="header-logo-icon visible-xs">
              <a href="https://metacpan.org/">
                <svg class="logo" aria-label="MetaCPAN">
                  <use class="logo" href="/static/images/metacpan-logo.svg#dots" />
                </svg>
              </a>
            </div>
            <ul class="nav navbar-nav menu-items hidden-xs hidden-sm">
              <li><a href="https://metacpan.org/about">About</a></li>
              <li><a href="https://metacpan.org/about/sponsors">Sponsor</a></li>
              <li><a href="https://grep.metacpan.org/">grep::cpan</a></li>
              <li><a href="https://metacpan.org/recent">Recent</a></li>
              <li><a href="https://metacpan.org/about/faq">FAQ</a></li>
              <li><a href="https://metacpan.org/tools">Tools</a></li>
              <li><a href="https://fastapi.metacpan.org/">API</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <button type="button" class="searchbar-btn visible-xs visible-sm">
                    <i class="fa fa-search button-fa-icon"></i>
                </button>
                <form action="https://metacpan.org/search" class="searchbar-form visible-md visible-lg search-form form-horizontal">
                   <input type="hidden" name="size" id="metacpan_search-size" value="20">
                  <div class="form-group">
                      <div class="search-group">
                        <i class="fa fa-search"></i>
                        <input type="text" name="q" placeholder="Search the CPAN" size="41" autocorrect="off" autocapitalize="off" spellcheck="false" id="metacpan_search-input" class="form-control" value="">
                      </div>
                  </div>
                </form>
                    <li class="icon-slidepanel visible-xs visible-sm">
                      <button data-toggle="slidepanel" data-target=".slidepanel">
                        <span class="button-fa-icon">
                          <i class="fa fa-bars slidepanel-open"></i>
                          <i class="fa fa-times slidepanel-close"></i>
                        </span>
                      </button>
                    </li>
                <form action="https://metacpan.org/account/logout" method="POST" id="metacpan-logout"></form>
                <li class="dropdown logged_in" style="display: none;">
                    <button type="button" class="dropdown-toggle" data-toggle="dropdown">
                      <i class="fa fa-user button-fa-icon logged-in-icon" aria-hidden="true"></i>
                      <i class="fas fa-chevron-down"></i>
                    </button>
                    <ul class="dropdown-menu">
                        <li><a href="https://metacpan.org/account/identities">Identities</a></li>
                        <li><a href="https://metacpan.org/account/profile">Profile</a></li>
                        <li><a href="https://metacpan.org/account/favorite/list">Favorites</a></li>
                        <li>
                            <a href="./Net::SSLeay.html#" type="button" onclick="$('#metacpan-logout').submit(); return false">
                              Logout
                            </a>
                        </li>
                    </ul>
                </li>
                <li class="dropdown logged_out" style="display: none;">
                    <button type="button" class="dropdown-toggle" data-toggle="dropdown">
                      <i class="fa fa-user button-fa-icon" aria-hidden="true"></i>
                      <i class="fas fa-chevron-down"></i>
                    </button>
                    <ul class="dropdown-menu">
                        <li>
                            <a href="https://metacpan.org/login/github">
                                <i class="fab fa-github fa-fw"></i>
                                GitHub
                            </a>
                        </li>
                        <li>
                            <a href="https://metacpan.org/login/twitter">
                                <i class="fab fa-twitter fa-fw"></i>
                                Twitter
                            </a>
                        </li>
                        <li>
                            <a href="https://metacpan.org/login/google">
                                <i class="fab fa-google fa-fw"></i>
                                Google
                            </a>
                        </li>
                    </ul>
                </li>
                <li class="dropdown logged_placeholder">
                    <button>
                      <i class="fa fa-user button-fa-icon" aria-hidden="true"></i>
                    </button>
                </li>
            </ul>
        </nav>
        <div class="page-content ">
          <!--
          <div class="top-notify-banner">
            <i class="fas fa-info-circle"></i>
          </div>
          -->
          <nav class="sidebar">
            <div class="slidepanel">
              <ul class="nav-list ">
    <li class="nav-header no-margin-top">
      <div class="ttip" data-toggle="tooltip" data-placement="bottom" title="The date that this version of Net-SSLeay was released.">
      <span class="relatize">08 Jan 2024 01:22:27 UTC</span>
    </li>
  <li>
    Distribution: <a href="https://metacpan.org/dist/Net-SSLeay">Net-SSLeay</a>
  </li>
  <li>
    Module version: 1.94
  </li>
  <li>
    <a data-keyboard-shortcut="g s" href="https://metacpan.org/dist/Net-SSLeay/source/lib/Net/SSLeay.pm">Source</a>
    (<a href="https://metacpan.org/dist/Net-SSLeay/source/lib/Net/SSLeay.pm?raw=1">raw</a>)
  </li>
  <li>
    <a data-keyboard-shortcut="g p" href="https://metacpan.org/dist/Net-SSLeay/source/lib/Net/SSLeay.pod">Pod Source</a>
    (<a href="https://metacpan.org/dist/Net-SSLeay/source/lib/Net/SSLeay.pod?raw=1">raw</a>)
  </li>
  <li>
    <a data-keyboard-shortcut="g b" href="https://metacpan.org/dist/Net-SSLeay/source/lib/Net">Browse</a>
    (<a href="https://metacpan.org/dist/Net-SSLeay/source/lib/Net?raw=1">raw</a>)
  </li>
    <li>
      <a data-keyboard-shortcut="g c" href="https://metacpan.org/dist/Net-SSLeay/changes">Changes</a>
    </li>
    <li>
      <a class="nopopup" href="https://metacpan.org/dist/Net-SSLeay/contribute">How to Contribute</a>
    </li>
    <li>
        <a rel="noopener nofollow" data-keyboard-shortcut="g r" href="https://github.com/radiator-software/p5-net-ssleay">Repository</a>
    </li>
    <li>
      <a rel="noopener nofollow" data-keyboard-shortcut="g i" href="https://github.com/radiator-software/p5-net-ssleay/issues">Issues</a>
    </li>
    <li>
      <a rel="noopener nofollow" href="http://matrix.cpantesters.org/?dist=Net-SSLeay+1.94" title="Matrix">Testers</a>
    </li>
    <li>
      <a rel="noopener nofollow" href="http://cpants.cpanauthors.org/release/CHRISN/Net-SSLeay-1.94">Kwalitee</a>
    </li>
    <li>
      <div class="ttip" data-toggle="tooltip" data-placement="bottom" title="The # people with an indexing permission on Net-SSLeay who have released something to CPAN in the last 2 years (i.e. the # people likely able to release critical fixes in a timely manner)">
      Bus factor: 1
      </div>
    </li>
    <li>
      License: artistic_2
    </li>
    <li>
      Perl: v5.8.1
    </li>
    <li class="nav-header">Activity</li>
    <li>
<div class="activity-graph">
    <img src="https://metacpan.org/dist/Net-SSLeay/activity.svg?res=month" />
    <div class="comment">24 month</div>
</div>
    </li>
    <li class="nav-header">Tools</li>
    <li>
      <a itemprop="downloadUrl" href="https://cpan.metacpan.org/authors/id/C/CH/CHRISN/Net-SSLeay-1.94.tar.gz">
      Download (<span itemprop="fileSize">648.39KB</span>)</a>
    </li>
    <li>
      <a href="https://explorer.metacpan.org/?url=%2Fmodule%2FCHRISN%2FNet-SSLeay-1.94%2Flib%2FNet%2FSSLeay.pm">
        MetaCPAN Explorer
      </a>
    </li>
    <li>
      <a href="https://metacpan.org/dist/Net-SSLeay/permissions">
        Permissions
      </a>
    </li>
    <li>
      <a href="https://metacpan.org/dist/Net-SSLeay/releases.rss">
        Subscribe to distribution
      </a>
    </li>
    <li>
      <button class="btn btn-link" data-toggle="modal" data-target="#metacpan_install-instructions-dialog">
        Install Instructions
      </button>
    </li>
    <li>
      <form action="https://metacpan.org/search">
        <input type="hidden" name="q" value="dist:Net-SSLeay">
        <input type="search" name="q" placeholder="Search distribution" class="form-control tool-bar-form">
        <input type="submit" style="display: none">
      </form>
    </li>
    <li>
      <form action="https://grep.metacpan.org/search">
        <input type="hidden" name="qd" value="Net-SSLeay">
        <input type="hidden" name="source" value="metacpan">
        <input type="search" name="q" placeholder="grep distribution" class="form-control tool-bar-form">
        <input type="submit" style="display: none">
     </form>
    </li>
    <li class="version-jump">
<select onchange="document.location.href=&#39;/release/&#39;+this.value+&#39;/view/lib/Net/SSLeay.pm&#39;" class="form-control tool-bar-form">
  <option disabled selected>Jump to version</option>
<option
  disabled
  value="CHRISN/Net-SSLeay-1.94"
>1.94
  (CHRISN on 2024-01-08)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.93_05"
>1.93_05 DEV
  (CHRISN on 2024-01-06)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.93_04"
>1.93_04 DEV
  (CHRISN on 2024-01-05)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.93_03"
>1.93_03 DEV
  (RADIATOR on 2024-01-02)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.93_02"
>1.93_02 DEV
  (CHRISN on 2023-02-23)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.93_01"
>1.93_01 DEV
  (CHRISN on 2022-03-20)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.92"
>1.92
  (CHRISN on 2022-01-12)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.91_03"
>1.91_03 DEV
  (CHRISN on 2022-01-10)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.91_02"
>1.91_02 DEV
  (CHRISN on 2021-12-29)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.91_01"
>1.91_01 DEV
  (CHRISN on 2021-10-24)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.90"
>1.90
  (CHRISN on 2021-01-21)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_05"
>1.89_05 DEV
  (CHRISN on 2021-01-21)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_04"
>1.89_04 DEV
  (CHRISN on 2021-01-13)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_03"
>1.89_03 DEV
  (CHRISN on 2020-12-12)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_02"
>1.89_02 DEV
  (CHRISN on 2020-08-06)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_01"
>1.89_01 DEV
  (CHRISN on 2020-03-22)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.88"
>1.88
  (CHRISN on 2019-05-10)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_11"
>1.86_11 DEV
  (CHRISN on 2019-05-08)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_10"
>1.86_10 DEV
  (CHRISN on 2019-05-05)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_09"
>1.86_09 DEV
  (CHRISN on 2019-03-12)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_07"
>1.86_07 DEV
  (RADIATOR on 2018-12-13)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_06"
>1.86_06 DEV
  (RADIATOR on 2018-09-29)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_05"
>1.86_05 DEV
  (CHRISN on 2018-08-23)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_04"
>1.86_04 DEV
  (CHRISN on 2018-07-30)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_03"
>1.86_03 DEV
  (RADIATOR on 2018-07-19)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_02"
>1.86_02 DEV
  (RADIATOR on 2018-07-06)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_01"
>1.86_01 DEV
  (RADIATOR on 2018-07-04)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.85"
>1.85
  (MIKEM on 2018-03-13)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.84"
>1.84
  (MIKEM on 2018-01-17)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.83"
>1.83
  (MIKEM on 2018-01-16)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.82"
>1.82
  (MIKEM on 2017-10-31)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.81"
>1.81
  (MIKEM on 2017-03-27)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.80"
>1.80
  (MIKEM on 2017-01-04)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.79"
>1.79
  (MIKEM on 2017-01-03)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.78"
>1.78
  (MIKEM on 2016-08-13)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.77"
>1.77
  (MIKEM on 2016-07-31)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.76"
>1.76
  (MIKEM on 2016-07-31)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.75"
>1.75
  (MIKEM on 2016-07-31)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.74"
>1.74
  (MIKEM on 2016-04-11)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.73"
>1.73
  (MIKEM on 2016-04-11)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.72"
>1.72
  (MIKEM on 2015-09-21)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.71"
>1.71
  (MIKEM on 2015-09-18)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.70"
>1.70
  (MIKEM on 2015-06-25)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.69"
>1.69
  (MIKEM on 2015-06-03)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.68"
>1.68
  (MIKEM on 2015-01-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.67"
>1.67
  (MIKEM on 2015-01-16)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.66"
>1.66
  (MIKEM on 2014-08-21)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.65"
>1.65
  (MIKEM on 2014-07-14)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.64"
>1.64
  (MIKEM on 2014-06-11)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.63"
>1.63
  (MIKEM on 2014-05-19)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.62"
>1.62
  (MIKEM on 2014-05-18)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.61"
>1.61
  (MIKEM on 2014-05-12)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.60"
>1.60
  (MIKEM on 2014-05-10)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.59"
>1.59
  (MIKEM on 2014-05-09)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.58"
>1.58
  (MIKEM on 2014-01-14)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.57"
>1.57
  (MIKEM on 2014-01-11)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.56"
>1.56
  (MIKEM on 2014-01-07)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.55"
>1.55
  (MIKEM on 2013-06-07)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.54"
>1.54
  (MIKEM on 2013-03-22)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.53"
>1.53
  (MIKEM on 2013-03-22)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.52"
>1.52
  (MIKEM on 2013-01-08)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.51"
>1.51
  (MIKEM on 2012-12-14)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.50"
>1.50
  (MIKEM on 2012-12-12)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.49"
>1.49
  (MIKEM on 2012-09-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.48"
>1.48
  (MIKEM on 2012-04-25)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.47"
>1.47
  (MIKEM on 2012-04-04)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.46"
>1.46
  (MIKEM on 2012-04-02)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.45"
>1.45
  (MIKEM on 2012-02-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.44"
>1.44
  (MIKEM on 2012-02-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.43"
>1.43
  (MIKEM on 2012-02-23)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.42"
>1.42
  (MIKEM on 2011-10-03)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.41"
>1.41
  (MIKEM on 2011-09-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.40"
>1.40
  (MIKEM on 2011-09-23)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.39"
>1.39
  (MIKEM on 2011-09-21)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.38"
>1.38
  (MIKEM on 2011-09-16)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.37"
>1.37
  (MIKEM on 2011-09-15)</option>
<option
  
  value="FLORA/Net-SSLeay-1.36"
>1.36
  (FLORA on 2010-01-30)</option>
<option
  
  value="FLORA/Net-SSLeay-1.35"
>1.35
  (FLORA on 2008-07-24)</option>
<option
  
  value="FLORA/Net-SSLeay-1.34"
>1.34
  (FLORA on 2008-07-24)</option>
<option
  
  value="FLORA/Net-SSLeay-1.33_01"
>1.33_01 DEV
  (FLORA on 2008-02-14)</option>
<option
  
  value="FLORA/Net-SSLeay-1.32"
>1.32
  (FLORA on 2007-09-03)</option>
<option
  
  value="FLORA/Net-SSLeay-1.31_02"
>1.31_02 DEV
  (FLORA on 2007-07-14)</option>
<option
  
  value="FLORA/Net-SSLeay-1.31_01"
>1.31_01 DEV
  (FLORA on 2007-07-03)</option>
<optgroup label="BackPAN">'
<option
  
  value="CHRISN/Net-SSLeay-1.86_08"
>1.86_08 DEV
  (CHRISN on 2019-03-12)</option>
</optgroup>
</select>
    </li>
    <li class="version-diff">
<select onchange="document.location.href='/release/CHRISN/Net-SSLeay-1.94/diff/' + encodeURIComponent(this.value) + '/lib/Net/SSLeay.pm'
" class="form-control tool-bar-form">
  <option disabled selected>Diff with version</option>
<option
  disabled
  value="CHRISN/Net-SSLeay-1.94"
>1.94
  (CHRISN on 2024-01-08)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.93_05"
>1.93_05 DEV
  (CHRISN on 2024-01-06)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.93_04"
>1.93_04 DEV
  (CHRISN on 2024-01-05)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.93_03"
>1.93_03 DEV
  (RADIATOR on 2024-01-02)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.93_02"
>1.93_02 DEV
  (CHRISN on 2023-02-23)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.93_01"
>1.93_01 DEV
  (CHRISN on 2022-03-20)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.92"
>1.92
  (CHRISN on 2022-01-12)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.91_03"
>1.91_03 DEV
  (CHRISN on 2022-01-10)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.91_02"
>1.91_02 DEV
  (CHRISN on 2021-12-29)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.91_01"
>1.91_01 DEV
  (CHRISN on 2021-10-24)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.90"
>1.90
  (CHRISN on 2021-01-21)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_05"
>1.89_05 DEV
  (CHRISN on 2021-01-21)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_04"
>1.89_04 DEV
  (CHRISN on 2021-01-13)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_03"
>1.89_03 DEV
  (CHRISN on 2020-12-12)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_02"
>1.89_02 DEV
  (CHRISN on 2020-08-06)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_01"
>1.89_01 DEV
  (CHRISN on 2020-03-22)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.88"
>1.88
  (CHRISN on 2019-05-10)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_11"
>1.86_11 DEV
  (CHRISN on 2019-05-08)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_10"
>1.86_10 DEV
  (CHRISN on 2019-05-05)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_09"
>1.86_09 DEV
  (CHRISN on 2019-03-12)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_07"
>1.86_07 DEV
  (RADIATOR on 2018-12-13)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_06"
>1.86_06 DEV
  (RADIATOR on 2018-09-29)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_05"
>1.86_05 DEV
  (CHRISN on 2018-08-23)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_04"
>1.86_04 DEV
  (CHRISN on 2018-07-30)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_03"
>1.86_03 DEV
  (RADIATOR on 2018-07-19)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_02"
>1.86_02 DEV
  (RADIATOR on 2018-07-06)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_01"
>1.86_01 DEV
  (RADIATOR on 2018-07-04)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.85"
>1.85
  (MIKEM on 2018-03-13)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.84"
>1.84
  (MIKEM on 2018-01-17)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.83"
>1.83
  (MIKEM on 2018-01-16)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.82"
>1.82
  (MIKEM on 2017-10-31)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.81"
>1.81
  (MIKEM on 2017-03-27)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.80"
>1.80
  (MIKEM on 2017-01-04)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.79"
>1.79
  (MIKEM on 2017-01-03)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.78"
>1.78
  (MIKEM on 2016-08-13)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.77"
>1.77
  (MIKEM on 2016-07-31)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.76"
>1.76
  (MIKEM on 2016-07-31)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.75"
>1.75
  (MIKEM on 2016-07-31)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.74"
>1.74
  (MIKEM on 2016-04-11)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.73"
>1.73
  (MIKEM on 2016-04-11)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.72"
>1.72
  (MIKEM on 2015-09-21)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.71"
>1.71
  (MIKEM on 2015-09-18)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.70"
>1.70
  (MIKEM on 2015-06-25)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.69"
>1.69
  (MIKEM on 2015-06-03)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.68"
>1.68
  (MIKEM on 2015-01-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.67"
>1.67
  (MIKEM on 2015-01-16)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.66"
>1.66
  (MIKEM on 2014-08-21)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.65"
>1.65
  (MIKEM on 2014-07-14)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.64"
>1.64
  (MIKEM on 2014-06-11)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.63"
>1.63
  (MIKEM on 2014-05-19)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.62"
>1.62
  (MIKEM on 2014-05-18)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.61"
>1.61
  (MIKEM on 2014-05-12)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.60"
>1.60
  (MIKEM on 2014-05-10)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.59"
>1.59
  (MIKEM on 2014-05-09)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.58"
>1.58
  (MIKEM on 2014-01-14)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.57"
>1.57
  (MIKEM on 2014-01-11)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.56"
>1.56
  (MIKEM on 2014-01-07)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.55"
>1.55
  (MIKEM on 2013-06-07)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.54"
>1.54
  (MIKEM on 2013-03-22)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.53"
>1.53
  (MIKEM on 2013-03-22)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.52"
>1.52
  (MIKEM on 2013-01-08)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.51"
>1.51
  (MIKEM on 2012-12-14)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.50"
>1.50
  (MIKEM on 2012-12-12)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.49"
>1.49
  (MIKEM on 2012-09-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.48"
>1.48
  (MIKEM on 2012-04-25)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.47"
>1.47
  (MIKEM on 2012-04-04)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.46"
>1.46
  (MIKEM on 2012-04-02)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.45"
>1.45
  (MIKEM on 2012-02-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.44"
>1.44
  (MIKEM on 2012-02-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.43"
>1.43
  (MIKEM on 2012-02-23)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.42"
>1.42
  (MIKEM on 2011-10-03)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.41"
>1.41
  (MIKEM on 2011-09-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.40"
>1.40
  (MIKEM on 2011-09-23)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.39"
>1.39
  (MIKEM on 2011-09-21)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.38"
>1.38
  (MIKEM on 2011-09-16)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.37"
>1.37
  (MIKEM on 2011-09-15)</option>
<option
  
  value="FLORA/Net-SSLeay-1.36"
>1.36
  (FLORA on 2010-01-30)</option>
<option
  
  value="FLORA/Net-SSLeay-1.35"
>1.35
  (FLORA on 2008-07-24)</option>
<option
  
  value="FLORA/Net-SSLeay-1.34"
>1.34
  (FLORA on 2008-07-24)</option>
<option
  
  value="FLORA/Net-SSLeay-1.33_01"
>1.33_01 DEV
  (FLORA on 2008-02-14)</option>
<option
  
  value="FLORA/Net-SSLeay-1.32"
>1.32
  (FLORA on 2007-09-03)</option>
<option
  
  value="FLORA/Net-SSLeay-1.31_02"
>1.31_02 DEV
  (FLORA on 2007-07-14)</option>
<option
  
  value="FLORA/Net-SSLeay-1.31_01"
>1.31_01 DEV
  (FLORA on 2007-07-03)</option>
<optgroup label="BackPAN">'
<option
  
  value="CHRISN/Net-SSLeay-1.86_08"
>1.86_08 DEV
  (CHRISN on 2019-03-12)</option>
</optgroup>
</select>
    </li>

    <li>
<ul class="dependencies">
  <li class="nav-header">Dependencies</li>
  <li><a href="https://metacpan.org/pod/MIME::Base64" title="MIME::Base64" class="ellipsis">MIME::Base64</a></li>
  <li>
    <hr>
  </li>
  <li>
    <a href="https://metacpan.org/module/Net::SSLeay/requires">Reverse dependencies</a>
  </li>
  <li>
    <a href="http://deps.cpantesters.org/?module=Net%3A%3ASSLeay">CPAN Testers List</a>
  </li>
  <li>
    <a href="https://cpandeps.grinnz.com/?dist=Net-SSLeay">Dependency graph</a>
  </li>
</ul>
    </li>
    <li class="nav-header">Permalinks</li>
    <li>
      <a href="https://metacpan.org/release/CHRISN/Net-SSLeay-1.94/view/lib/Net/SSLeay.pm">This version</a>
    </li>
    <li>
      <a href="./Net::SSLeay.html">Latest version</a>
    </li>
    <li>
<div class="plussers">
<div class="nav-header">++ed by:</div>
<div>
<a class="display-all" href="https://metacpan.org/author/ETHER"><img src="https://www.gravatar.com/avatar/bdc5cd06679e732e262f6c1b450a0237?d=identicon&amp;s=20" title="ETHER" alt="ETHER"></a>
<a class="display-all" href="https://metacpan.org/author/POTATOGIM"><img src="https://www.gravatar.com/avatar/82f1c6258702415af6e26187f1e36850?d=identicon&amp;s=20" title="POTATOGIM" alt="POTATOGIM"></a>
<a class="display-all" href="https://metacpan.org/author/DAGOLDEN"><img src="https://www.gravatar.com/avatar/bb755c989fcb9897f28a2c6e00df61e2?d=identicon&amp;s=20" title="DAGOLDEN" alt="DAGOLDEN"></a>
<a class="display-all" href="https://metacpan.org/author/NQOUNET"><img src="https://www.gravatar.com/avatar/e61f06bb6e837f13f4b55d9edf0bcef7?d=identicon&amp;s=20" title="NQOUNET" alt="NQOUNET"></a>
<a class="display-all" href="https://metacpan.org/author/CRUX"><img src="https://www.gravatar.com/avatar/5f448d8ac2c78d30b3567106d269d83d?d=identicon&amp;s=20" title="CRUX" alt="CRUX"></a>
</div>
<!-- Display counts of plussers-->
<div>
    <a href="https://metacpan.org/dist/Net-SSLeay/plussers">15 PAUSE users</a>
</div>
<div>
    11 non-PAUSE users
</div>
</div>
    </li>
    <li>
<div id="metacpan_contributors">
  <div>
    <button class="btn-link"
      onclick="$(this).hide(); $('#metacpan_contributors ul').slideDown(); return false;"
    >and 5 contributors</button>
  </div>
  <ul style="display: none">
    <li class="contributor"
      data-cpan-author="SAMPO"
      data-contrib-email="sampo@iki.fi"
    >
      <a href="https://metacpan.org/author/SAMPO" class="cpan-author">
      <img class="gravatar" width="20" height="20" src="https://www.gravatar.com/avatar/059c6968c220fe1273ef8c31146d06a2?d=identicon&amp;s=20" />
      Sampo Kellomaki
      </a>
    </li>
    <li class="contributor"
      data-cpan-author="FLORA"
      data-contrib-email="rafl@debian.org"
    >
      <a href="https://metacpan.org/author/FLORA" class="cpan-author">
      <img class="gravatar" width="20" height="20" src="https://www.gravatar.com/avatar/fd2bdaaefe41908133793d1ddf38f75d?d=identicon&amp;s=20" />
      Florian Ragwitz
      </a>
    </li>
    <li class="contributor"
      data-cpan-author="MIKEM"
      data-contrib-email="mikem@airspayce.com"
    >
      <a href="https://metacpan.org/author/MIKEM" class="cpan-author">
      <img class="gravatar" width="20" height="20" src="https://www.gravatar.com/avatar/9bb03ed4704f442eb594a1a469f70b53?d=identicon&amp;s=20" />
      Mike McCauley
      </a>
    </li>
    <li class="contributor"
      data-contrib-email="vartiait@radiatorsoftware.com"
    >
      <img class="gravatar" width="20" height="20" src="https://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?d=identicon&amp;s=20" />
      Tuure Vartiainen
    </li>
    <li class="contributor"
      data-contrib-email="hvn@radiatorsoftware.com"
    >
      <img class="gravatar" width="20" height="20" src="https://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?d=identicon&amp;s=20" />
      Heikki Vatiainen
    </li>
  </ul>
</div>
    </li>
              </ul>
            </div>
          </nav>
          <div class="content-navigation">
<div class="breadcrumbs">
  <span>
    <a data-keyboard-shortcut="g a" rel="author" href="https://metacpan.org/author/CHRISN" class="author-name">Chris Novakovic</a>
  </span>
  <span>&nbsp;/&nbsp;</span>
  <div class="release dist-release status-latest maturity-released">
    <span class="dropdown"><b class="caret"></b></span>
<select onchange="document.location.href=&#39;/release/&#39;+this.value+&#39;/view/lib/Net/SSLeay.pm&#39;" class="">
<option
  selected
  value="CHRISN/Net-SSLeay-1.94"
>1.94
  (CHRISN on 2024-01-08)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.93_05"
>1.93_05 DEV
  (CHRISN on 2024-01-06)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.93_04"
>1.93_04 DEV
  (CHRISN on 2024-01-05)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.93_03"
>1.93_03 DEV
  (RADIATOR on 2024-01-02)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.93_02"
>1.93_02 DEV
  (CHRISN on 2023-02-23)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.93_01"
>1.93_01 DEV
  (CHRISN on 2022-03-20)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.92"
>1.92
  (CHRISN on 2022-01-12)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.91_03"
>1.91_03 DEV
  (CHRISN on 2022-01-10)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.91_02"
>1.91_02 DEV
  (CHRISN on 2021-12-29)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.91_01"
>1.91_01 DEV
  (CHRISN on 2021-10-24)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.90"
>1.90
  (CHRISN on 2021-01-21)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_05"
>1.89_05 DEV
  (CHRISN on 2021-01-21)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_04"
>1.89_04 DEV
  (CHRISN on 2021-01-13)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_03"
>1.89_03 DEV
  (CHRISN on 2020-12-12)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_02"
>1.89_02 DEV
  (CHRISN on 2020-08-06)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.89_01"
>1.89_01 DEV
  (CHRISN on 2020-03-22)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.88"
>1.88
  (CHRISN on 2019-05-10)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_11"
>1.86_11 DEV
  (CHRISN on 2019-05-08)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_10"
>1.86_10 DEV
  (CHRISN on 2019-05-05)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_09"
>1.86_09 DEV
  (CHRISN on 2019-03-12)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_07"
>1.86_07 DEV
  (RADIATOR on 2018-12-13)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_06"
>1.86_06 DEV
  (RADIATOR on 2018-09-29)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_05"
>1.86_05 DEV
  (CHRISN on 2018-08-23)</option>
<option
  
  value="CHRISN/Net-SSLeay-1.86_04"
>1.86_04 DEV
  (CHRISN on 2018-07-30)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_03"
>1.86_03 DEV
  (RADIATOR on 2018-07-19)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_02"
>1.86_02 DEV
  (RADIATOR on 2018-07-06)</option>
<option
  
  value="RADIATOR/Net-SSLeay-1.86_01"
>1.86_01 DEV
  (RADIATOR on 2018-07-04)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.85"
>1.85
  (MIKEM on 2018-03-13)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.84"
>1.84
  (MIKEM on 2018-01-17)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.83"
>1.83
  (MIKEM on 2018-01-16)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.82"
>1.82
  (MIKEM on 2017-10-31)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.81"
>1.81
  (MIKEM on 2017-03-27)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.80"
>1.80
  (MIKEM on 2017-01-04)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.79"
>1.79
  (MIKEM on 2017-01-03)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.78"
>1.78
  (MIKEM on 2016-08-13)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.77"
>1.77
  (MIKEM on 2016-07-31)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.76"
>1.76
  (MIKEM on 2016-07-31)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.75"
>1.75
  (MIKEM on 2016-07-31)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.74"
>1.74
  (MIKEM on 2016-04-11)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.73"
>1.73
  (MIKEM on 2016-04-11)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.72"
>1.72
  (MIKEM on 2015-09-21)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.71"
>1.71
  (MIKEM on 2015-09-18)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.70"
>1.70
  (MIKEM on 2015-06-25)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.69"
>1.69
  (MIKEM on 2015-06-03)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.68"
>1.68
  (MIKEM on 2015-01-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.67"
>1.67
  (MIKEM on 2015-01-16)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.66"
>1.66
  (MIKEM on 2014-08-21)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.65"
>1.65
  (MIKEM on 2014-07-14)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.64"
>1.64
  (MIKEM on 2014-06-11)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.63"
>1.63
  (MIKEM on 2014-05-19)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.62"
>1.62
  (MIKEM on 2014-05-18)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.61"
>1.61
  (MIKEM on 2014-05-12)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.60"
>1.60
  (MIKEM on 2014-05-10)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.59"
>1.59
  (MIKEM on 2014-05-09)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.58"
>1.58
  (MIKEM on 2014-01-14)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.57"
>1.57
  (MIKEM on 2014-01-11)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.56"
>1.56
  (MIKEM on 2014-01-07)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.55"
>1.55
  (MIKEM on 2013-06-07)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.54"
>1.54
  (MIKEM on 2013-03-22)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.53"
>1.53
  (MIKEM on 2013-03-22)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.52"
>1.52
  (MIKEM on 2013-01-08)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.51"
>1.51
  (MIKEM on 2012-12-14)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.50"
>1.50
  (MIKEM on 2012-12-12)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.49"
>1.49
  (MIKEM on 2012-09-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.48"
>1.48
  (MIKEM on 2012-04-25)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.47"
>1.47
  (MIKEM on 2012-04-04)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.46"
>1.46
  (MIKEM on 2012-04-02)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.45"
>1.45
  (MIKEM on 2012-02-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.44"
>1.44
  (MIKEM on 2012-02-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.43"
>1.43
  (MIKEM on 2012-02-23)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.42"
>1.42
  (MIKEM on 2011-10-03)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.41"
>1.41
  (MIKEM on 2011-09-24)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.40"
>1.40
  (MIKEM on 2011-09-23)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.39"
>1.39
  (MIKEM on 2011-09-21)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.38"
>1.38
  (MIKEM on 2011-09-16)</option>
<option
  
  value="MIKEM/Net-SSLeay-1.37"
>1.37
  (MIKEM on 2011-09-15)</option>
<option
  
  value="FLORA/Net-SSLeay-1.36"
>1.36
  (FLORA on 2010-01-30)</option>
<option
  
  value="FLORA/Net-SSLeay-1.35"
>1.35
  (FLORA on 2008-07-24)</option>
<option
  
  value="FLORA/Net-SSLeay-1.34"
>1.34
  (FLORA on 2008-07-24)</option>
<option
  
  value="FLORA/Net-SSLeay-1.33_01"
>1.33_01 DEV
  (FLORA on 2008-02-14)</option>
<option
  
  value="FLORA/Net-SSLeay-1.32"
>1.32
  (FLORA on 2007-09-03)</option>
<option
  
  value="FLORA/Net-SSLeay-1.31_02"
>1.31_02 DEV
  (FLORA on 2007-07-14)</option>
<option
  
  value="FLORA/Net-SSLeay-1.31_01"
>1.31_01 DEV
  (FLORA on 2007-07-03)</option>
<optgroup label="BackPAN">'
<option
  
  value="CHRISN/Net-SSLeay-1.86_08"
>1.86_08 DEV
  (CHRISN on 2019-03-12)</option>
</optgroup>
</select>
    <a data-keyboard-shortcut="g d" class="release-name" href="https://metacpan.org/dist/Net-SSLeay">Net-SSLeay-1.94</a>
  </div>
<span class="river-gauge-gauge">
  <svg width="24px"
       height="15px"
       version="1.1"
       xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink">

    <g>
      <title>        River stage four &#10;
          • 166 direct dependents &#10;          • 2151 total dependents
      </title>

      <rect x="0"  y="0" width="4" height="15" fill="#7ea3f2" />
      <rect x="5"  y="0" width="4" height="15" fill="#7ea3f2" />
      <rect x="10"  y="0" width="4" height="15" fill="#7ea3f2" />
      <rect x="15"  y="0" width="4" height="15" fill="#7ea3f2" />
      <rect x="20"  y="0" width="4" height="15" fill="#e4e2e2" />
    </g>
  </svg>

</span>
<div id="Net-SSLeay-fav" class="logged_in">
<form action="https://metacpan.org/account/favorite/add" style="display: inline" onsubmit="return favDistribution(this)">
    <input type="hidden" name="remove" value="0">
    <input type="hidden" name="release" value="Net-SSLeay-1.94">
    <input type="hidden" name="author" value="CHRISN">
    <input type="hidden" name="distribution" value="Net-SSLeay">
    <button type="submit" class="favorite highlight"><span>26</span> ++</button>
</form>
</div>
<div class="logged_out">
<a href="./Net::SSLeay.html" onclick="alert('Please sign in to add favorites'); return false" class="favorite highlight">
<span>26</span> ++</a>
</div>
   / <span>Net::SSLeay</span>
</div>
          </div>
          <main class="content">


<nav class="toc">
  <div class="toc-header"><strong>Contents</strong></div>
<ul>
  <li><a href="./Net::SSLeay.html#NAME">NAME</a></li>
  <li><a href="./Net::SSLeay.html#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="./Net::SSLeay.html#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="./Net::SSLeay.html#COMPATIBILITY">COMPATIBILITY</a></li>
  <li><a href="./Net::SSLeay.html#OVERVIEW">OVERVIEW</a>
    <ul>
      <li><a href="./Net::SSLeay.html#High-level-functions-for-accessing-web-servers">High level functions for accessing web servers</a>
        <ul>
          <li><a href="./Net::SSLeay.html#Basic-set-of-functions">Basic set of functions</a></li>
          <li><a href="./Net::SSLeay.html#Alternate-versions-of-high-level-API">Alternate versions of high-level API</a></li>
          <li><a href="./Net::SSLeay.html#Using-client-certificates">Using client certificates</a></li>
          <li><a href="./Net::SSLeay.html#Working-through-a-web-proxy">Working through a web proxy</a></li>
          <li><a href="./Net::SSLeay.html#HTTP-(without-S)-API">HTTP (without S) API</a></li>
        </ul>
      </li>
      <li><a href="./Net::SSLeay.html#Certificate-verification-and-Certificate-Revocation-Lists-(CRLs)">Certificate verification and Certificate Revocation Lists (CRLs)</a></li>
      <li><a href="./Net::SSLeay.html#Certificate-verification-and-Online-Status-Revocation-Protocol-(OCSP)">Certificate verification and Online Status Revocation Protocol (OCSP)</a></li>
      <li><a href="./Net::SSLeay.html#Using-Net::SSLeay-in-multi-threaded-applications">Using Net::SSLeay in multi-threaded applications</a>
        <ul>
          <li><a href="./Net::SSLeay.html#Initialization">Initialization</a></li>
          <li><a href="./Net::SSLeay.html#Using-callbacks">Using callbacks</a></li>
          <li><a href="./Net::SSLeay.html#Using-openssl-elements">Using openssl elements</a></li>
          <li><a href="./Net::SSLeay.html#Using-other-perl-modules-based-on-Net::SSLeay">Using other perl modules based on Net::SSLeay</a></li>
          <li><a href="./Net::SSLeay.html#Combining-Net::SSLeay-with-other-modules-linked-with-openssl">Combining Net::SSLeay with other modules linked with openssl</a></li>
          <li><a href="./Net::SSLeay.html#Threading-with-get_https-and-friends">Threading with get_https and friends</a></li>
        </ul>
      </li>
      <li><a href="./Net::SSLeay.html#Convenience-routines">Convenience routines</a></li>
      <li><a href="./Net::SSLeay.html#Initialization1">Initialization</a></li>
      <li><a href="./Net::SSLeay.html#Error-handling-functions">Error handling functions</a></li>
      <li><a href="./Net::SSLeay.html#Sockets">Sockets</a></li>
      <li><a href="./Net::SSLeay.html#Callbacks">Callbacks</a></li>
      <li><a href="./Net::SSLeay.html#Low-level-API">Low level API</a>
        <ul>
          <li><a href="./Net::SSLeay.html#Low-level-API:-Version-and-library-information-related-functions">Low level API: Version and library information related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-Initialization-related-functions">Low level API: Initialization related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-ERR_*-and-SSL_alert_*-related-functions">Low level API: ERR_* and SSL_alert_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-SSL_METHOD_*-related-functions">Low level API: SSL_METHOD_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-ENGINE_*-related-functions">Low level API: ENGINE_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-EVP_PKEY_*-related-functions">Low level API: EVP_PKEY_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-PEM_*-related-functions">Low level API: PEM_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-d2i_*-(DER-format)-related-functions">Low level API: d2i_* (DER format) related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-PKCS12-related-functions">Low level API: PKCS12 related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-SESSION_*-related-functions">Low level API: SESSION_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-SSL_CTX_*-related-functions">Low level API: SSL_CTX_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-SSL_*-related-functions">Low level API: SSL_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-RAND_*-related-functions">Low level API: RAND_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-OBJ_*-related-functions">Low level API: OBJ_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-ASN1_INTEGER_*-related-functions">Low level API: ASN1_INTEGER_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-ASN1_STRING_*-related-functions">Low level API: ASN1_STRING_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-ASN1_TIME_*-related-functions">Low level API: ASN1_TIME_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-X509_*-related-functions">Low level API: X509_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-X509_REQ_*-related-functions">Low level API: X509_REQ_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-X509_CRL_*-related-functions">Low level API: X509_CRL_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-X509_EXTENSION_*-related-functions">Low level API: X509_EXTENSION_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-X509_NAME_*-related-functions">Low level API: X509_NAME_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-X509_STORE_*-related-functions">Low level API: X509_STORE_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-Level-API:-X509_INFO-related-functions">Low Level API: X509_INFO related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-X509_VERIFY_PARAM_*-related-functions">Low level API: X509_VERIFY_PARAM_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-Cipher-(EVP_CIPHER_*)-related-functions">Low level API: Cipher (EVP_CIPHER_*) related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-Digest-(EVP_MD_*)-related-functions">Low level API: Digest (EVP_MD_*) related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-CIPHER_*-related-functions">Low level API: CIPHER_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-BN_*-related-functions">Low level API: BN_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-RSA_*-related-functions">Low level API: RSA_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-BIO_*-related-functions">Low level API: BIO_* related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-Server-side-Server-Name-Indication-(SNI)-support">Low level API: Server side Server Name Indication (SNI) support</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-NPN-(next-protocol-negotiation)-related-functions">Low level API: NPN (next protocol negotiation) related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-ALPN-(application-layer-protocol-negotiation)-related-functions">Low level API: ALPN (application layer protocol negotiation) related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-DANE-Support">Low level API: DANE Support</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-Other-functions">Low level API: Other functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-EC-related-functions">Low level API: EC related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-OSSL_LIB_CTX-and-OSSL_PROVIDER-related-functions">Low level API: OSSL_LIB_CTX and OSSL_PROVIDER related functions</a></li>
          <li><a href="./Net::SSLeay.html#Low-level-API:-TLS-PSK-related-functions">Low level API: TLS PSK related functions</a></li>
        </ul>
      </li>
      <li><a href="./Net::SSLeay.html#Constants">Constants</a></li>
      <li><a href="./Net::SSLeay.html#INTERNAL-ONLY-functions-(do-not-use-these)">INTERNAL ONLY functions (do not use these)</a></li>
    </ul>
  </li>
  <li><a href="./Net::SSLeay.html#EXAMPLES">EXAMPLES</a></li>
  <li><a href="./Net::SSLeay.html#INSTALLATION">INSTALLATION</a></li>
  <li><a href="./Net::SSLeay.html#LIMITATIONS">LIMITATIONS</a></li>
  <li><a href="./Net::SSLeay.html#KNOWN-BUGS-AND-CAVEATS">KNOWN BUGS AND CAVEATS</a></li>
  <li><a href="./Net::SSLeay.html#DIAGNOSTICS">DIAGNOSTICS</a></li>
  <li><a href="./Net::SSLeay.html#SECURITY">SECURITY</a>
    <ul>
      <li><a href="./Net::SSLeay.html#BEAST-Attack">BEAST Attack</a></li>
      <li><a href="./Net::SSLeay.html#Session-Resumption">Session Resumption</a></li>
      <li><a href="./Net::SSLeay.html#Secure-Renegotiation-and-DoS-Attack">Secure Renegotiation and DoS Attack</a></li>
    </ul>
  </li>
  <li><a href="./Net::SSLeay.html#BUGS">BUGS</a></li>
  <li><a href="./Net::SSLeay.html#AUTHOR">AUTHOR</a></li>
  <li><a href="./Net::SSLeay.html#COPYRIGHT">COPYRIGHT</a></li>
  <li><a href="./Net::SSLeay.html#LICENSE">LICENSE</a></li>
  <li><a href="./Net::SSLeay.html#SEE-ALSO">SEE ALSO</a></li>
</ul></nav>
<div class="pod anchors">
<h1 id="NAME">NAME</h1>

<p>Net::SSLeay - Perl bindings for OpenSSL and LibreSSL</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    use Net::SSLeay qw(get_https post_https sslcat make_headers make_form);

    ($page) = get_https(&#39;www.bacus.pt&#39;, 443, &#39;/&#39;);                 # Case 1

    ($page, $response, %reply_headers)
        = get_https(&#39;www.bacus.pt&#39;, 443, &#39;/&#39;,                      # Case 2
            make_headers(User-Agent =&gt; &#39;Cryptozilla/5.0b1&#39;,
                         Referer    =&gt; &#39;https://www.bacus.pt&#39;)
          );

    ($page, $result, %headers)                                     # Case 2b
        = get_https(&#39;www.bacus.pt&#39;, 443, &#39;/protected.html&#39;,
            make_headers(Authorization =&gt;
                &#39;Basic &#39; . MIME::Base64::encode(&quot;$user:$pass&quot;,&#39;&#39;))
          );

    ($page, $response, %reply_headers)
        = post_https(&#39;www.bacus.pt&#39;, 443, &#39;/foo.cgi&#39;, &#39;&#39;,          # Case 3
            make_form(OK =&gt; &#39;1&#39;, name =&gt; &#39;Sampo&#39;)
          );

    $reply = sslcat($host, $port, $request);                       # Case 4

    ($reply, $err, $server_cert) = sslcat($host, $port, $request); # Case 5

    $Net::SSLeay::trace = 2; # 0=no debugging, 1=ciphers, 2=trace, 3=dump data

    Net::SSLeay::initialize(); # Initialize ssl library once</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module provides Perl bindings for libssl (an SSL/TLS API) and libcrypto (a cryptography API).</p>

<h1 id="COMPATIBILITY">COMPATIBILITY</h1>

<p>Net::SSLeay supports the following libssl implementations:</p>

<ul>

<li><p>Any stable release of <a href="https://www.openssl.org">OpenSSL</a> in the 0.9.8 - 3.2 branches, except for OpenSSL 0.9.8 - 0.9.8b.</p>

</li>
<li><p>Any stable release of <a href="https://www.libressl.org">LibreSSL</a> in the 2.0 - 3.8 series, except for LibreSSL 3.2.2 and 3.2.3.</p>

</li>
</ul>

<p>Net::SSLeay may not function as expected with releases other than the ones listed above due to libssl API incompatibilities, or, in the case of LibreSSL, because of deviations from the libssl API.</p>

<p>Net::SSLeay is only as secure as the underlying libssl implementation you use. Although Net::SSLeay maintains compatibility with old versions of OpenSSL and LibreSSL, it is <b>strongly recommended</b> that you use a version of OpenSSL or LibreSSL that is supported by the OpenSSL/LibreSSL developers and/or your operating system vendor. Many unsupported versions of OpenSSL and LibreSSL are known to contain severe security vulnerabilities. Refer to the <a href="https://www.openssl.org/policies/releasestrat.html">OpenSSL Release Strategy</a> and <a href="https://www.libressl.org/releases.html">LibreSSL Support Schedule</a> for information on which versions are currently supported.</p>

<p>The libssl API has changed significantly since OpenSSL 0.9.8: hundreds of functions have been added, deprecated or removed in the intervening versions. Although this documentation lists all of the functions and constants that Net::SSLeay may expose, they will not be available for use if they are missing from the underlying libssl implementation. Refer to the compatibility notes in this documentation, as well as the OpenSSL/LibreSSL manual pages, for information on which OpenSSL/LibreSSL versions support each function or constant. At run-time, you can check whether a function or constant is exposed before calling it using the following convention:</p>

<pre><code>    if ( defined &amp;Net::SSLeay::libssl_function ) {
        # libssl_function() (or SSL_libssl_function()) is available
        Net::SSLeay::libssl_function(...);
    }</code></pre>

<h1 id="OVERVIEW">OVERVIEW</h1>

<p><a href="https://metacpan.org/pod/distribution/Net-SSLeay/lib/Net/SSLeay.pod">Net::SSLeay</a> module basically comprise of:</p>

<ul>

<li><p>High level functions for accessing web servers (by using HTTP/HTTPS)</p>

</li>
<li><p>Low level API (mostly mapped 1:1 to openssl&#39;s C functions)</p>

</li>
<li><p>Convenience functions (related to low level API but with more perl friendly interface)</p>

</li>
</ul>

<p>There is also a related module called <a href="https://metacpan.org/pod/Net::SSLeay::Handle">Net::SSLeay::Handle</a> included in this distribution that you might want to use instead. It has its own pod documentation.</p>

<h2 id="High-level-functions-for-accessing-web-servers"><a id="High"></a>High level functions for accessing web servers</h2>

<p>This module offers some high level convenience functions for accessing web pages on SSL servers (for symmetry, the same API is offered for accessing http servers, too), an <code>sslcat()</code> function for writing your own clients, and finally access to the SSL api of the SSLeay/OpenSSL package so you can write servers or clients for more complicated applications.</p>

<p>For high level functions it is most convenient to import them into your main namespace as indicated in the synopsis.</p>

<h3 id="Basic-set-of-functions"><a id="Basic"></a>Basic set of functions</h3>

<ul>

<li><p>get_https</p>

</li>
<li><p>post_https</p>

</li>
<li><p>put_https</p>

</li>
<li><p>head_https</p>

</li>
<li><p>do_https</p>

</li>
<li><p>sslcat</p>

</li>
<li><p>https_cat</p>

</li>
<li><p>make_form</p>

</li>
<li><p>make_headers</p>

</li>
</ul>

<p><b>Case 1 (in SYNOPSIS)</b> demonstrates the typical invocation of get_https() to fetch an HTML page from secure server. The first argument provides the hostname or IP in dotted decimal notation of the remote server to contact. The second argument is the TCP port at the remote end (your own port is picked arbitrarily from high numbered ports as usual for TCP). The third argument is the URL of the page without the host name part. If in doubt consult the HTTP specifications at <a href="https://www.w3c.org">https://www.w3c.org</a>.</p>

<p><b>Case 2 (in SYNOPSIS)</b> demonstrates full fledged use of <code>get_https()</code>. As can be seen, <code>get_https()</code> parses the response and response headers and returns them as a list, which can be captured in a hash for later reference. Also a fourth argument to <code>get_https()</code> is used to insert some additional headers in the request. <code>make_headers()</code> is a function that will convert a list or hash to such headers. By default <code>get_https()</code> supplies <code>Host</code> (to make virtual hosting easy) and <code>Accept</code> (reportedly needed by IIS) headers.</p>

<p><b>Case 2b (in SYNOPSIS)</b> demonstrates how to get a password protected page. Refer to the HTTP protocol specifications for further details (e.g. RFC-2617).</p>

<p><b>Case 3 (in SYNOPSIS)</b> invokes <code>post_https()</code> to submit a HTML/CGI form to a secure server. The first four arguments are equal to <code>get_https()</code> (note that the empty string (<code>&#39;&#39;</code>) is passed as header argument). The fifth argument is the contents of the form formatted according to CGI specification. Do not post UTF-8 data as content: use utf8::downgrade first. In this case the helper function <code>make_https()</code> is used to do the formatting, but you could pass any string. <code>post_https()</code> automatically adds <code>Content-Type</code> and <code>Content-Length</code> headers to the request.</p>

<p><b>Case 4 (in SYNOPSIS)</b> shows the fundamental <code>sslcat()</code> function (inspired in spirit by the <code>netcat</code> utility :-). It&#39;s your swiss army knife that allows you to easily contact servers, send some data, and then get the response. You are responsible for formatting the data and parsing the response - <code>sslcat()</code> is just a transport.</p>

<p><b>Case 5 (in SYNOPSIS)</b> is a full invocation of <code>sslcat()</code> which allows the return of errors as well as the server (peer) certificate.</p>

<p>The <code>$trace</code> global variable can be used to control the verbosity of the high level functions. Level 0 guarantees silence, level 1 (the default) only emits error messages.</p>

<h3 id="Alternate-versions-of-high-level-API"><a id="Alternate"></a>Alternate versions of high-level API</h3>

<ul>

<li><p>get_https3</p>

</li>
<li><p>post_https3</p>

</li>
<li><p>put_https3</p>

</li>
<li><p>get_https4</p>

</li>
<li><p>post_https4</p>

</li>
<li><p>put_https4</p>

</li>
</ul>

<p>The above mentioned functions actually return the response headers as a list, which only gets converted to hash upon assignment (this assignment looses information if the same header occurs twice, as may be the case with cookies). There are also other variants of the functions that return unprocessed headers and that return a reference to a hash.</p>

<pre><code>    ($page, $response, @headers) = get_https(&#39;www.bacus.pt&#39;, 443, &#39;/&#39;);
    for ($i = 0; $i &lt; $#headers; $i+=2) {
        print &quot;$headers[$i] = &quot; . $headers[$i+1] . &quot;\n&quot;;
    }

    ($page, $response, $headers, $server_cert)
        = get_https3(&#39;www.bacus.pt&#39;, 443, &#39;/&#39;);
    print &quot;$headers\n&quot;;

    ($page, $response, $headers_ref)
        = get_https4(&#39;www.bacus.pt&#39;, 443, &#39;/&#39;);
    for $k (sort keys %{$headers_ref}) {
        for $v (@{$$headers_ref{$k}}) {
            print &quot;$k = $v\n&quot;;
        }
    }</code></pre>

<p>All of the above code fragments accomplish the same thing: display all values of all headers. The API functions ending in &quot;3&quot; return the headers simply as a scalar string and it is up to the application to split them up. The functions ending in &quot;4&quot; return a reference to a hash of arrays (see <a href="https://metacpan.org/pod/perlref">perlref</a> and <a href="https://metacpan.org/pod/perllol">perllol</a> if you are not familiar with complex perl data structures). To access a single value of such a header hash you would do something like</p>

<pre><code>    print $$headers_ref{COOKIE}[0];</code></pre>

<p>Variants 3 and 4 also allow you to discover the server certificate in case you would like to store or display it, e.g.</p>

<pre><code>    ($p, $resp, $hdrs, $server_cert) = get_https3(&#39;www.bacus.pt&#39;, 443, &#39;/&#39;);
    if (!defined($server_cert) || ($server_cert == 0)) {
        warn &quot;Subject Name: undefined, Issuer  Name: undefined&quot;;
    } else {
        warn sprintf(&#39;Subject Name: %s Issuer  Name: %s&#39;,
            Net::SSLeay::X509_NAME_oneline(
                Net::SSLeay::X509_get_subject_name($server_cert)),
            Net::SSLeay::X509_NAME_oneline(
                Net::SSLeay::X509_get_issuer_name($server_cert))
        );
    }</code></pre>

<p>Beware that this method only allows after the fact verification of the certificate: by the time <code>get_https3()</code> has returned the https request has already been sent to the server, whether you decide to trust it or not. To do the verification correctly you must either employ the OpenSSL certificate verification framework or use the lower level API to first connect and verify the certificate and only then send the http data. See the implementation of <code>ds_https3()</code> for guidance on how to do this.</p>

<h3 id="Using-client-certificates"><a id="Using"></a>Using client certificates</h3>

<p>Secure web communications are encrypted using symmetric crypto keys exchanged using encryption based on the certificate of the server. Therefore in all SSL connections the server must have a certificate. This serves both to authenticate the server to the clients and to perform the key exchange.</p>

<p>Sometimes it is necessary to authenticate the client as well. Two options are available: HTTP basic authentication and a client side certificate. The basic authentication over HTTPS is actually quite safe because HTTPS guarantees that the password will not travel in the clear. Never-the-less, problems like easily guessable passwords remain. The client certificate method involves authentication of the client at the SSL level using a certificate. For this to work, both the client and the server have certificates (which typically are different) and private keys.</p>

<p>The API functions outlined above accept additional arguments that allow one to supply the client side certificate and key files. The format of these files is the same as used for server certificates and the caveat about encrypting private keys applies.</p>

<pre><code>    ($page, $result, %headers)                                     # 2c
        = get_https(&#39;www.bacus.pt&#39;, 443, &#39;/protected.html&#39;,
            make_headers(Authorization =&gt;
                &#39;Basic &#39; . MIME::Base64::encode(&quot;$user:$pass&quot;,&#39;&#39;)),
            &#39;&#39;, $mime_type6, $path_to_crt7, $path_to_key8
          );

    ($page, $response, %reply_headers)
        = post_https(&#39;www.bacus.pt&#39;, 443, &#39;/foo.cgi&#39;,              # 3b
            make_headers(&#39;Authorization&#39; =&gt;
                &#39;Basic &#39; . MIME::Base64::encode(&quot;$user:$pass&quot;,&#39;&#39;)),
            make_form(OK   =&gt; &#39;1&#39;, name =&gt; &#39;Sampo&#39;),
            $mime_type6, $path_to_crt7, $path_to_key8
          );</code></pre>

<p><b>Case 2c (in SYNOPSIS)</b> demonstrates getting a password protected page that also requires a client certificate, i.e. it is possible to use both authentication methods simultaneously.</p>

<p><b>Case 3b (in SYNOPSIS)</b> is a full blown POST to a secure server that requires both password authentication and a client certificate, just like in case 2c.</p>

<p>Note: The client will not send a certificate unless the server requests one. This is typically achieved by setting the verify mode to <code>VERIFY_PEER</code> on the server:</p>

<pre><code>    Net::SSLeay::set_verify($ssl, Net::SSLeay::VERIFY_PEER, 0);</code></pre>

<p>See <code>perldoc ~openssl/doc/ssl/SSL_CTX_set_verify.pod</code> for a full description.</p>

<h3 id="Working-through-a-web-proxy"><a id="Working"></a>Working through a web proxy</h3>

<ul>

<li><p>set_proxy</p>

</li>
</ul>

<p><code>Net::SSLeay</code> can use a web proxy to make its connections. You need to first set the proxy host and port using <code>set_proxy()</code> and then just use the normal API functions, e.g:</p>

<pre><code>    Net::SSLeay::set_proxy(&#39;gateway.myorg.com&#39;, 8080);
    ($page) = get_https(&#39;www.bacus.pt&#39;, 443, &#39;/&#39;);</code></pre>

<p>If your proxy requires authentication, you can supply a username and password as well</p>

<pre><code>    Net::SSLeay::set_proxy(&#39;gateway.myorg.com&#39;, 8080, &#39;joe&#39;, &#39;salainen&#39;);
    ($page, $result, %headers)
        = get_https(&#39;www.bacus.pt&#39;, 443, &#39;/protected.html&#39;,
            make_headers(Authorization =&gt;
                &#39;Basic &#39; . MIME::Base64::encode(&quot;susie:pass&quot;,&#39;&#39;))
          );</code></pre>

<p>This example demonstrates the case where we authenticate to the proxy as <code>&quot;joe&quot;</code> and to the final web server as <code>&quot;susie&quot;</code>. Proxy authentication requires the <code>MIME::Base64</code> module to work.</p>

<h3 id="HTTP-(without-S)-API"><a id="HTTP"></a><a id="HTTP--without-S--API"></a>HTTP (without S) API</h3>

<ul>

<li><p>get_http</p>

</li>
<li><p>post_http</p>

</li>
<li><p>tcpcat</p>

</li>
<li><p>get_httpx</p>

</li>
<li><p>post_httpx</p>

</li>
<li><p>tcpxcat</p>

</li>
</ul>

<p>Over the years it has become clear that it would be convenient to use the light-weight flavour API of <code>Net::SSLeay</code> for normal HTTP as well (see <code>LWP</code> for the heavy-weight object-oriented approach). In fact it would be nice to be able to flip https on and off on the fly. Thus regular HTTP support was evolved.</p>

<pre><code>    use Net::SSLeay qw(get_http post_http tcpcat
                       get_httpx post_httpx tcpxcat
                       make_headers make_form);

    ($page, $result, %headers)
        = get_http(&#39;www.bacus.pt&#39;, 443, &#39;/protected.html&#39;,
            make_headers(Authorization =&gt;
                &#39;Basic &#39; . MIME::Base64::encode(&quot;$user:$pass&quot;,&#39;&#39;))
          );

    ($page, $response, %reply_headers)
        = post_http(&#39;www.bacus.pt&#39;, 443, &#39;/foo.cgi&#39;, &#39;&#39;,
            make_form(OK =&gt; &#39;1&#39;, name =&gt; &#39;Sampo&#39;)
          );

    ($reply, $err) = tcpcat($host, $port, $request);

    ($page, $result, %headers)
        = get_httpx($usessl, &#39;www.bacus.pt&#39;, 443, &#39;/protected.html&#39;,
            make_headers(Authorization =&gt;
                &#39;Basic &#39; . MIME::Base64::encode(&quot;$user:$pass&quot;,&#39;&#39;))
          );

    ($page, $response, %reply_headers)
        = post_httpx($usessl, &#39;www.bacus.pt&#39;, 443, &#39;/foo.cgi&#39;, &#39;&#39;,
            make_form(OK =&gt; &#39;1&#39;,  name =&gt; &#39;Sampo&#39;)
          );

    ($reply, $err, $server_cert) = tcpxcat($usessl, $host, $port, $request);</code></pre>

<p>As can be seen, the <code>&quot;x&quot;</code> family of APIs takes as the first argument a flag which indicates whether SSL is used or not.</p>

<h2 id="Certificate-verification-and-Certificate-Revocation-Lists-(CRLs)"><a id="Certificate"></a><a id="Certificate-verification-and-Certificate-Revocation-Lists--CRLs"></a>Certificate verification and Certificate Revocation Lists (CRLs)</h2>

<p>OpenSSL supports the ability to verify peer certificates. It can also optionally check the peer certificate against a Certificate Revocation List (CRL) from the certificates issuer. A CRL is a file, created by the certificate issuer that lists all the certificates that it previously signed, but which it now revokes. CRLs are in PEM format.</p>

<p>You can enable <code>Net::SSLeay CRL</code> checking like this:</p>

<pre><code>    &amp;Net::SSLeay::X509_STORE_set_flags(
        &amp;Net::SSLeay::CTX_get_cert_store($ssl),
        &amp;Net::SSLeay::X509_V_FLAG_CRL_CHECK
    );</code></pre>

<p>After setting this flag, if OpenSSL checks a peer&#39;s certificate, then it will attempt to find a CRL for the issuer. It does this by looking for a specially named file in the search directory specified by CTX_load_verify_locations. CRL files are named with the hash of the issuer&#39;s subject name, followed by <code>.r0</code>, <code>.r1</code> etc. For example <code>ab1331b2.r0</code>, <code>ab1331b2.r1</code>. It will read all the .r files for the issuer, and then check for a revocation of the peer certificate in all of them. (You can also force it to look in a specific named CRL file., see below). You can find out the hash of the issuer subject name in a CRL with</p>

<pre><code>    openssl crl -in crl.pem -hash -noout</code></pre>

<p>If the peer certificate does not pass the revocation list, or if no CRL is found, then the handshaking fails with an error.</p>

<p>You can also force OpenSSL to look for CRLs in one or more arbitrarily named files.</p>

<pre><code>    my $bio = Net::SSLeay::BIO_new_file($crlfilename, &#39;r&#39;);
    my $crl = Net::SSLeay::PEM_read_bio_X509_CRL($bio);
    if ($crl) {
        Net::SSLeay::X509_STORE_add_crl(
               Net::SSLeay::CTX_get_cert_store($ssl, $crl)
        );
    } else {
        # error reading CRL....
    }</code></pre>

<p>Usually the URLs where you can download the CRLs is contained in the certificate itself and you can extract them with</p>

<pre><code>    my @url = Net::SSLeay::P_X509_get_crl_distribution_points($cert);</code></pre>

<p>But there is no automatic downloading of the CRLs and often these CRLs are too huge to just download them to verify a single certificate. Also, these CRLs are often in DER format which you need to convert to PEM before you can use it:</p>

<pre><code>    openssl crl -in crl.der -inform der -out crl.pem</code></pre>

<p>So as an alternative for faster and timely revocation checks you better use the Online Status Revocation Protocol (OCSP).</p>

<h2 id="Certificate-verification-and-Online-Status-Revocation-Protocol-(OCSP)"><a id="Certificate1"></a><a id="Certificate-verification-and-Online-Status-Revocation-Protocol--OCSP"></a>Certificate verification and Online Status Revocation Protocol (OCSP)</h2>

<p>While checking for revoked certificates is possible and fast with Certificate Revocation Lists, you need to download the complete and often huge list before you can verify a single certificate.</p>

<p>A faster way is to ask the CA to check the revocation of just a single or a few certificates using OCSP. Basically you generate for each certificate an OCSP_CERTID based on the certificate itself and its issuer, put the ids together into an OCSP_REQUEST and send the request to the URL given in the certificate.</p>

<p>As a result you get back an OCSP_RESPONSE and need to check the status of the response, check that it is valid (e.g. signed by the CA) and finally extract the information about each OCSP_CERTID to find out if the certificate is still valid or got revoked.</p>

<p>With Net::SSLeay this can be done like this:</p>

<pre><code>    # get id(s) for given certs, like from get_peer_certificate
    # or get_peer_cert_chain. This will croak if
    # - one tries to make an OCSP_CERTID for a self-signed certificate
    # - the issuer of the certificate cannot be found in the SSL objects
    #   store, nor in the current certificate chain
    my $cert = Net::SSLeay::get_peer_certificate($ssl);
    my $id = eval { Net::SSLeay::OCSP_cert2ids($ssl,$cert) };
    die &quot;failed to make OCSP_CERTID: $@&quot; if $@;

    # create OCSP_REQUEST from id(s)
    # Multiple can be put into the same request, if the same OCSP responder
    # is responsible for them.
    my $req = Net::SSLeay::OCSP_ids2req($id);

    # determine URI of OCSP responder
    my $uri = Net::SSLeay::P_X509_get_ocsp_uri($cert);

    # Send stringified OCSP_REQUEST with POST to $uri.
    # We can ignore certificate verification for https, because the OCSP
    # response itself is signed.
    my $ua = HTTP::Tiny-&gt;new(verify_SSL =&gt; 0);
    my $res = $ua-&gt;request( &#39;POST&#39;,$uri, {
        headers =&gt; { &#39;Content-type&#39; =&gt; &#39;application/ocsp-request&#39; },
        content =&gt; Net::SSLeay::i2d_OCSP_REQUEST($req)
    });
    my $content = $res &amp;&amp; $res-&gt;{success} &amp;&amp; $res-&gt;{content}
        or die &quot;query failed&quot;;

    # Extract OCSP_RESPONSE.
    # this will croak if the string is not an OCSP_RESPONSE
    my $resp = eval { Net::SSLeay::d2i_OCSP_RESPONSE($content) };

    # Check status of response.
    my $status = Net::SSLeay::OCSP_response_status($resp);
    if ($status != Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()) {
        die &quot;OCSP response failed: &quot; .
            Net::SSLeay::OCSP_response_status_str($status);
    }

    # Verify signature of response and if nonce matches request.
    # This will croak if there is a nonce in the response, but it does not match
    # the request. It will return false if the signature could not be verified,
    # in which case details can be retrieved with Net::SSLeay::ERR_get_error.
    # It will not complain if the response does not contain a nonce, which is
    # usually the case with pre-signed responses.
    if ( ! eval { Net::SSLeay::OCSP_response_verify($ssl,$resp,$req) }) {
        die &quot;OCSP response verification failed&quot;;
    }

    # Extract information from OCSP_RESPONSE for each of the ids.

    # If called in scalar context it will return the time (as time_t), when the
    # next update is due (minimum of all successful responses inside $resp). It
    # will croak on the following problems:
    # - response is expired or not yet valid
    # - no response for given OCSP_CERTID
    # - certificate status is not good (e.g. revoked or unknown)
    if ( my $nextupd = eval { Net::SSLeay::OCSP_response_results($resp,$id) }) {
        warn &quot;certificate is valid, next update in &quot; .
            ($nextupd-time()) . &quot; seconds\n&quot;;
    } else {
        die &quot;certificate is not valid: $@&quot;;
    }

    # But in array context it will return detailed information about each given
    # OCSP_CERTID instead croaking on errors:
    # if no @ids are given it will return information about all single responses
    # in the OCSP_RESPONSE
    my @results = Net::SSLeay::OCSP_response_results($resp,@ids);
    for my $r (@results) {
        print Dumper($r);
        # @results are in the same order as the @ids and contain:
        # $r-&gt;[0] - OCSP_CERTID
        # $r-&gt;[1] - undef if no error (certificate good) OR error message as string
        # $r-&gt;[2] - hash with details:
        #   thisUpdate - time_t of this single response
        #   nextUpdate - time_t when update is expected
        #   statusType - integer:
        #      V_OCSP_CERTSTATUS_GOOD(0)
        #      V_OCSP_CERTSTATUS_REVOKED(1)
        #      V_OCSP_CERTSTATUS_UNKNOWN(2)
        #   revocationTime - time_t (only if revoked)
        #   revocationReason - integer (only if revoked)
        #   revocationReason_str - reason as string (only if revoked)
    }</code></pre>

<p>To further speed up certificate revocation checking one can use a TLS extension to instruct the server to staple the OCSP response:</p>

<pre><code>    # set TLS extension before doing SSL_connect
    Net::SSLeay::set_tlsext_status_type($ssl,
        Net::SSLeay::TLSEXT_STATUSTYPE_ocsp());

    # setup callback to verify OCSP response
    my $cert_valid = undef;
    Net::SSLeay::CTX_set_tlsext_status_cb($context,sub {
        my ($ssl,$resp) = @_;
        if (!$resp) {
            # Lots of servers don&#39;t return an OCSP response.
            # In this case we must check the OCSP status outside the SSL
            # handshake.
            warn &quot;server did not return stapled OCSP response\n&quot;;
            return 1;
        }
        # verify status
        my $status = Net::SSLeay::OCSP_response_status($resp);
        if ($status != Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()) {
            warn &quot;OCSP response failure: $status\n&quot;;
            return 1;
        }
        # verify signature - we have no OCSP_REQUEST here to check nonce
        if (!eval { Net::SSLeay::OCSP_response_verify($ssl,$resp) }) {
            warn &quot;OCSP response verify failed\n&quot;;
            return 1;
        }
        # check if the certificate is valid
        # we should check here against the peer_certificate
        my $cert = Net::SSLeay::get_peer_certificate();
        my $certid = eval { Net::SSLeay::OCSP_cert2ids($ssl,$cert) } or do {
            warn &quot;cannot get certid from cert: $@&quot;;
            $cert_valid = -1;
            return 1;
        };

        if ( $nextupd = eval {
            Net::SSLeay::OCSP_response_results($resp,$certid) }) {
            warn &quot;certificate not revoked\n&quot;;
            $cert_valid = 1;
        } else {
            warn &quot;certificate not valid: $@&quot;;
            $cert_valid = 0;
        }
    });

    # do SSL handshake here
    # ....
    # check if certificate revocation was checked already
    if ( ! defined $cert_valid) {
        # check revocation outside of SSL handshake by asking OCSP responder
        ...
    } elsif ( ! $cert_valid ) {
        die &quot;certificate not valid - closing SSL connection&quot;;
    } elsif ( $cert_valid&lt;0 ) {
        die &quot;cannot verify certificate revocation - self-signed ?&quot;;
    } else {
        # everything fine
        ...
    }</code></pre>

<h2 id="Using-Net::SSLeay-in-multi-threaded-applications"><a id="Using1"></a>Using Net::SSLeay in multi-threaded applications</h2>

<p><b>IMPORTANT: versions 1.42 or earlier are not thread-safe!</b></p>

<p>Net::SSLeay module implements all necessary stuff to be ready for multi-threaded environment - it requires openssl-0.9.7 or newer. The implementation fully follows thread safety related requirements of openssl library(see <a href="https://www.openssl.org/docs/manmaster/man3/threads.html">https://www.openssl.org/docs/manmaster/man3/threads.html</a>).</p>

<p>If you are about to use Net::SSLeay (or any other module based on Net::SSLeay) in multi-threaded perl application it is recommended to follow this best-practice:</p>

<h3 id="Initialization">Initialization</h3>

<p>Load and initialize Net::SSLeay module in the main thread:</p>

<pre><code>    use threads;
    use Net::SSLeay;

    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    sub do_master_job {
        # ... call whatever from Net::SSLeay
    }

    sub do_worker_job {
        # ... call whatever from Net::SSLeay
    }

    # start threads
    my $master  = threads-&gt;new(\&amp;do_master_job, &#39;param1&#39;, &#39;param2&#39;);
    my @workers = threads-&gt;new(\&amp;do_worker_job, &#39;arg1&#39;, &#39;arg2&#39;) for (1..10);

    # waiting for all threads to finish
    $_-&gt;join() for (threads-&gt;list);</code></pre>

<p>NOTE: Openssl&#39;s <code>int SSL_library_init(void)</code> function (which is also aliased as <code>SSLeay_add_ssl_algorithms</code>, <code>OpenSSL_add_ssl_algorithms</code> and <code>add_ssl_algorithms</code>) is not re-entrant and multiple calls can cause a crash in threaded application. Net::SSLeay implements flags preventing repeated calls to this function, therefore even multiple initialization via Net::SSLeay::SSLeay_add_ssl_algorithms() should work without trouble.</p>

<h3 id="Using-callbacks"><a id="Using2"></a>Using callbacks</h3>

<p>Do not use callbacks across threads (the module blocks cross-thread callback operations and throws a warning). Always do the callback setup, callback use and callback destruction within the same thread.</p>

<h3 id="Using-openssl-elements"><a id="Using3"></a>Using openssl elements</h3>

<p>All openssl elements (X509, SSL_CTX, ...) can be directly passed between threads.</p>

<pre><code>    use threads;
    use Net::SSLeay;

    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    sub do_job {
        my $context = shift;
        Net::SSLeay::CTX_set_default_passwd_cb($context, sub { &quot;secret&quot; });
        # ...
    }

    my $c = Net::SSLeay::CTX_new();
    threads-&gt;create(\&amp;do_job, $c);</code></pre>

<p>Or:</p>

<pre><code>    use threads;
    use Net::SSLeay;

    my $context; # does not need to be &#39;shared&#39;

    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    sub do_job {
        Net::SSLeay::CTX_set_default_passwd_cb($context, sub { &quot;secret&quot; });
        # ...
    }

    $context = Net::SSLeay::CTX_new();
    threads-&gt;create(\&amp;do_job);</code></pre>

<h3 id="Using-other-perl-modules-based-on-Net::SSLeay"><a id="Using4"></a>Using other perl modules based on Net::SSLeay</h3>

<p>It should be fine to use any other module based on <a href="https://metacpan.org/pod/distribution/Net-SSLeay/lib/Net/SSLeay.pod">Net::SSLeay</a> (like <a href="./IO::Socket::SSL.html">IO::Socket::SSL</a>) in multi-threaded applications. It is generally recommended to do any global initialization of such a module in the main thread before calling <code>threads-&gt;new(..)</code> or <code>threads-&gt;create(..)</code> but it might differ module by module.</p>

<p>To be safe you can load and init Net::SSLeay explicitly in the main thread:</p>

<pre><code>    use Net::SSLeay;
    use Other::SSLeay::Based::Module;

    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();</code></pre>

<p>Or even safer:</p>

<pre><code>    use Net::SSLeay;
    use Other::SSLeay::Based::Module;

    BEGIN {
        Net::SSLeay::load_error_strings();
        Net::SSLeay::SSLeay_add_ssl_algorithms();
        Net::SSLeay::randomize();
    }</code></pre>

<h3 id="Combining-Net::SSLeay-with-other-modules-linked-with-openssl"><a id="Combining"></a>Combining Net::SSLeay with other modules linked with openssl</h3>

<p><b>BEWARE: This might be a big trouble! This is not guaranteed be thread-safe!</b></p>

<p>There are many other (XS) modules linked directly to openssl library (like <a href="https://metacpan.org/pod/Crypt::SSLeay">Crypt::SSLeay</a>).</p>

<p>As it is expected that also &quot;another&quot; module will call <code>SSLeay_add_ssl_algorithms</code> at some point we have again a trouble with multiple openssl initialization by Net::SSLeay and &quot;another&quot; module.</p>

<p>As you can expect Net::SSLeay is not able to avoid multiple initialization of openssl library called by &quot;another&quot; module, thus you have to handle this on your own (in some cases it might not be possible at all to avoid this).</p>

<h3 id="Threading-with-get_https-and-friends"><a id="Threading"></a>Threading with get_https and friends</h3>

<p>The convenience functions get_https, post_https etc all initialize the SSL library by calling Net::SSLeay::initialize which does the conventional library initialization:</p>

<pre><code>    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();</code></pre>

<p>Net::SSLeay::initialize initializes the SSL library at most once. You can override the Net::SSLeay::initialize function if you desire some other type of initialization behaviour by get_https and friends. You can call Net::SSLeay::initialize from your own code if you desire this conventional library initialization.</p>

<h2 id="Convenience-routines"><a id="Convenience"></a>Convenience routines</h2>

<p>To be used with Low level API</p>

<pre><code>    Net::SSLeay::randomize($rn_seed_file,$additional_seed);
    Net::SSLeay::set_cert_and_key($ctx, $cert_path, $key_path);
    $cert = Net::SSLeay::dump_peer_certificate($ssl);
    Net::SSLeay::ssl_write_all($ssl, $message) or die &quot;ssl write failure&quot;;
    $got = Net::SSLeay::ssl_read_all($ssl) or die &quot;ssl read failure&quot;;

    $got = Net::SSLeay::ssl_read_CRLF($ssl [, $max_length]);
    $got = Net::SSLeay::ssl_read_until($ssl [, $delimit [, $max_length]]);
    Net::SSLeay::ssl_write_CRLF($ssl, $message);</code></pre>

<ul>

<li><p>randomize</p>

<p>seeds the openssl PRNG with <code>/dev/urandom</code> (see the top of <code>SSLeay.pm</code> for how to change or configure this) and optionally with user provided data. It is very important to properly seed your random numbers, so do not forget to call this. The high level API functions automatically call <code>randomize()</code> so it is not needed with them. See also caveats.</p>

</li>
<li><p>set_cert_and_key</p>

<p>takes two file names as arguments and sets the certificate and private key to those. This can be used to set either server certificates or client certificates.</p>

</li>
<li><p>dump_peer_certificate</p>

<p>allows you to get a plaintext description of the certificate the peer (usually the server) presented to us.</p>

</li>
<li><p>ssl_read_all</p>

<p>see ssl_write_all (below)</p>

</li>
<li><p>ssl_write_all</p>

<p><code>ssl_read_all()</code> and <code>ssl_write_all()</code> provide true blocking semantics for these operations (see limitation, below, for explanation). These are much preferred to the low level API equivalents (which implement BSD blocking semantics). The message argument to <code>ssl_write_all()</code> can be a reference. This is helpful to avoid unnecessary copying when writing something big, e.g:</p>

<pre><code>    $data = &#39;A&#39; x 1000000000;
    Net::SSLeay::ssl_write_all($ssl, \$data) or die &quot;ssl write failed&quot;;</code></pre>

</li>
<li><p>ssl_read_CRLF</p>

<p>uses <code>ssl_read_all()</code> to read in a line terminated with a carriage return followed by a linefeed (CRLF). The CRLF is included in the returned scalar.</p>

</li>
<li><p>ssl_read_until</p>

<p>uses <code>ssl_read_all()</code> to read from the SSL input stream until it encounters a programmer specified delimiter. If the delimiter is undefined, <code>$/</code> is used. If <code>$/</code> is undefined, <code>\n</code> is used. One can optionally set a maximum length of bytes to read from the SSL input stream.</p>

</li>
<li><p>ssl_write_CRLF</p>

<p>writes <code>$message</code> and appends CRLF to the SSL output stream.</p>

</li>
</ul>

<h2 id="Initialization1">Initialization</h2>

<p>In order to use the low level API you should start your programs with the following incantation:</p>

<pre><code>    use Net::SSLeay qw(die_now die_if_ssl_error);
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();    # Important!
    Net::SSLeay::ENGINE_load_builtin_engines();  # If you want built-in engines
    Net::SSLeay::ENGINE_register_all_complete(); # If you want built-in engines
    Net::SSLeay::randomize();</code></pre>

<h2 id="Error-handling-functions"><a id="Error"></a>Error handling functions</h2>

<p>I can not emphasize the need to check for error enough. Use these functions even in the most simple programs, they will reduce debugging time greatly. Do not ask questions on the mailing list without having first sprinkled these in your code.</p>

<ul>

<li><p>die_now</p>

</li>
<li><p>die_if_ssl_error</p>

<p><code>die_now()</code> and <code>die_if_ssl_error()</code> are used to conveniently print the SSLeay error stack when something goes wrong:</p>

<pre><code>    Net::SSLeay::connect($ssl) or die_now(&quot;Failed SSL connect ($!)&quot;);

    Net::SSLeay::write($ssl, &quot;foo&quot;) or die_if_ssl_error(&quot;SSL write ($!)&quot;);</code></pre>

</li>
<li><p>print_errs</p>

<p>You can also use <code>Net::SSLeay::print_errs()</code> to dump the error stack without exiting the program. As can be seen, your code becomes much more readable if you import the error reporting functions into your main name space.</p>

</li>
</ul>

<h2 id="Sockets">Sockets</h2>

<p>Perl uses file handles for all I/O. While SSLeay has a quite flexible BIO mechanism and perl has an evolved PerlIO mechanism, this module still sticks to using file descriptors. Thus to attach SSLeay to a socket you should use <code>fileno()</code> to extract the underlying file descriptor:</p>

<pre><code>    Net::SSLeay::set_fd($ssl, fileno(S));   # Must use fileno</code></pre>

<p>You should also set <code>$|</code> to 1 to eliminate STDIO buffering so you do not get confused if you use perl I/O functions to manipulate your socket handle.</p>

<p>If you need to <code>select(2)</code> on the socket, go right ahead, but be warned that OpenSSL does some internal buffering so SSL_read does not always return data even if the socket selected for reading (just keep on selecting and trying to read). <code>Net::SSLeay</code> is no different from the C language OpenSSL in this respect.</p>

<h2 id="Callbacks">Callbacks</h2>

<p>You can establish a per-context verify callback function something like this:</p>

<pre><code>    sub verify {
        my ($ok, $x509_store_ctx) = @_;
        print &quot;Verifying certificate...\n&quot;;
        # ...
        return $ok;
    }</code></pre>

<p>It is used like this:</p>

<pre><code>    Net::SSLeay::set_verify ($ssl, Net::SSLeay::VERIFY_PEER, \&amp;verify);</code></pre>

<p>Per-context callbacks for decrypting private keys are implemented.</p>

<pre><code>    Net::SSLeay::CTX_set_default_passwd_cb($ctx, sub { &quot;top-secret&quot; });
    Net::SSLeay::CTX_use_PrivateKey_file($ctx, &quot;key.pem&quot;,
                                         Net::SSLeay::FILETYPE_PEM)
        or die &quot;Error reading private key&quot;;
    Net::SSLeay::CTX_set_default_passwd_cb($ctx, undef);</code></pre>

<p>If Hello Extensions are supported by your OpenSSL, a session secret callback can be set up to be called when a session secret is set by openssl.</p>

<p>Establish it like this:</p>

<pre><code>    Net::SSLeay::set_session_secret_cb($ssl, \&amp;session_secret_cb, $somedata);</code></pre>

<p>It will be called like this:</p>

<pre><code>    sub session_secret_cb {
        my ($secret, \@cipherlist, \$preferredcipher, $somedata) = @_;
    }</code></pre>

<p>No other callbacks are implemented. You do not need to use any callback for simple (i.e. normal) cases where the SSLeay built-in verify mechanism satisfies your needs.</p>

<p>It is required to reset these callbacks to undef immediately after use to prevent memory leaks, thread safety problems and crashes on exit that can occur if different threads set different callbacks.</p>

<p>If you want to use callback stuff, see examples/callback.pl! It&#39;s the only one I am able to make work reliably.</p>

<h2 id="Low-level-API"><a id="Low"></a>Low level API</h2>

<p>In addition to the high level functions outlined above, this module contains straight-forward access to CRYPTO and SSL parts of OpenSSL C API.</p>

<p>See the <code>*.h</code> headers from OpenSSL C distribution for a list of low level SSLeay functions to call (check SSLeay.xs to see if some function has been implemented). The module strips the initial <code>&quot;SSL_&quot;</code> off of the SSLeay names. Generally you should use <code>Net::SSLeay::</code> in its place.</p>

<p>Note that some functions are prefixed with <code>&quot;P_&quot;</code> - these are very close to the original API however contain some kind of a wrapper making its interface more perl friendly.</p>

<p>For example:</p>

<p>In C:</p>

<pre><code>    #include &lt;ssl.h&gt;

    err = SSL_set_verify (ssl, SSL_VERIFY_CLIENT_ONCE, &amp;your_call_back_here);</code></pre>

<p>In Perl:</p>

<pre><code>    use Net::SSLeay;

    $err = Net::SSLeay::set_verify ($ssl,
                                    Net::SSLeay::VERIFY_CLIENT_ONCE,
                                    \&amp;your_call_back_here);</code></pre>

<p>If the function does not start with <code>SSL_</code> you should use the full function name, e.g.:</p>

<pre><code>    $err = Net::SSLeay::ERR_get_error;</code></pre>

<p>The following new functions behave in perlish way:</p>

<pre><code>    $got = Net::SSLeay::read($ssl);
                                # Performs SSL_read, but returns $got
                                # resized according to data received.
                                # Returns undef on failure.

    Net::SSLeay::write($ssl, $foo) || die;
                                # Performs SSL_write, but automatically
                                # figures out the size of $foo</code></pre>

<h3 id="Low-level-API:-Version-and-library-information-related-functions"><a id="Low1"></a>Low level API: Version and library information related functions</h3>

<ul>

<li><p>OpenSSL_version_num and SSLeay</p>

<p><b>COMPATIBILITY:</b> SSLeay() is not available in Net-SSLeay-1.42 and before. SSLeay() was made an alias of OpenSSL_version_num() in OpenSSL 1.1.0 and LibreSSL 2.7.0.</p>

<p><b>COMPATIBILITY:</b> OpenSSL_version_num() requires at least Net-SSLeay-1.82 with OpenSSL 1.1.0, or Net-SSLeay-1.88 with LibreSSL 2.7.0.</p>

<p>Both functions return OPENSSL_VERSION_NUMBER constant (numeric) as defined by the underlying OpenSSL or LibreSSL library.</p>

<pre><code>    my $ver_number = Net::SSLeay::SSLeay();
    # or
    my $ver_number = Net::SSLeay::OpenSSL_version_num();
    # returns: OPENSSL_VERSION_NUMBER constant

    # OpenSSL version numbering is:
    # 0x00903100 =&gt; openssl-0.9.3
    # 0x00904100 =&gt; openssl-0.9.4
    # 0x00905100 =&gt; openssl-0.9.5
    # 0x0090600f =&gt; openssl-0.9.6
    # 0x0090601f =&gt; openssl-0.9.6a
    # ...
    # 0x009060df =&gt; openssl-0.9.6m
    # 0x0090700f =&gt; openssl-0.9.7
    # 0x0090701f =&gt; openssl-0.9.7a
    # ...
    # 0x009070df =&gt; openssl-0.9.7m
    # 0x0090800f =&gt; openssl-0.9.8
    # 0x0090801f =&gt; openssl-0.9.8a
    # ...
    # 0x0090821f =&gt; openssl-0.9.8zh
    # 0x1000000f =&gt; openssl-1.0.0
    # ...
    # 0x1000014f =&gt; openssl-1.0.0t
    # 0x1000100f =&gt; openssl-1.0.1
    # ...
    # 0x1000115f =&gt; openssl-1.0.1u
    # 0x1000200f =&gt; openssl-1.0.2
    # ...
    # 0x1000215f =&gt; openssl-1.0.2u
    # 0x1010000f =&gt; openssl-1.1.0
    # ...
    # 0x101000cf =&gt; openssl-1.1.0l
    # 0x1010100f =&gt; openssl-1.1.1
    # ...
    # 0x1010117f =&gt; openssl-1.1.1w
    # 0x30000000 =&gt; openssl-3.0.0
    # ...
    # 0x300000c0 =&gt; openssl-3.0.12
    # 0x30100000 =&gt; openssl-3.1.0
    # ...
    # 0x30100040 =&gt; openssl-3.1.4
    # 0x30200000 =&gt; openssl-3.2.0

    # Note that OpenSSL 3.0.0 and later do not set the status nibble in the
    # least significant octet to f.

    # LibreSSL returns 0x20000000 always:
    # 0x20000000 =&gt; libressl-2.2.1
    # ...
    # 0x20000000 =&gt; libressl-3.8.2</code></pre>

<p>You can use the version number like this when you know that the underlying library is OpenSSL:</p>

<pre><code>    if (Net::SSLeay::SSLeay() &lt; 0x0090800f) {
        die &quot;You need OpenSSL 0.9.8 or higher&quot;;
    }</code></pre>

<p>LibresSSL 2.2.2 and later define constant LIBRESSL_VERSION_NUMBER that gives the LibreSSL version number. The format is the same that OpenSSL uses with OPENSSL_VERSION_NUMBER. You can do this if you need to check that the underlying library is LibreSSL and it&#39;s recent enough:</p>

<pre><code>    if (Net::SSLeay::SSLeay() != 0x20000000 ||
            Net::SSLeay::LIBRESSL_VERSION_NUMBER() &lt; 0x3040200f) {
        die &quot;You need LibreSSL. Version 3.4.2 or higher&quot;;
    }</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OpenSSL_version_num.html">https://www.openssl.org/docs/manmaster/man3/OpenSSL_version_num.html</a></p>

<p>See OpenSSL 1.1.1 and earlier documentation for the details of status nibble and the format interpretation.</p>

</li>
<li><p>SSLeay_version</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<p>Returns different strings depending on $type.</p>

<pre><code>    my $ver_string = Net::SSLeay::SSLeay_version($type);
    # $type
    #   SSLEAY_VERSION  - e.g. &#39;OpenSSL 1.0.0d 8 Feb 2011&#39;
    #   SSLEAY_CFLAGS   - e.g. &#39;compiler: gcc -D_WINDLL -DOPENSSL_USE_APPLINK .....&#39;
    #   SSLEAY_BUILT_ON - e.g. &#39;built on: Fri May  6 00:00:46 GMT 2011&#39;
    #   SSLEAY_PLATFORM - e.g. &#39;platform: mingw&#39;
    #   SSLEAY_DIR      - e.g. &#39;OPENSSLDIR: &quot;z:/....&quot;&#39;
    #
    # returns: string

    Net::SSLeay::SSLeay_version();
    # is equivalent to
    Net::SSLeay::SSLeay_version(SSLEAY_VERSION);</code></pre>

<p>OpenSSL 1.1.0 changed SSLeay_version() to an alias of OpenSSL_version(). To ensure correct functionality with LibreSSL, use SSLEAY_* constants with SSLeay_version() and OPENSSL_* constants with OpenSSL_version().</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OpenSSL_version.html">https://www.openssl.org/docs/manmaster/man3/OpenSSL_version.html</a></p>

<p>OpenSSL website no longer has a manual page for SSLeay_version().</p>

</li>
<li><p>OpenSSL_version</p>

<p><b>COMPATIBILITY:</b> requires at least Net-SSLeay-1.82 with OpenSSL 1.1.0, or Net-SSLeay-1.88 with LibreSSL 2.7.0.</p>

<p>Returns different strings depending on $t. Available $t constants depend on the library version.</p>

<pre><code>    my $ver_string = Net::SSLeay::OpenSSL_version($t);
    # $t
    #   OPENSSL_VERSION     - e.g. &#39;OpenSSL 1.1.0g  2 Nov 2017&#39;
    #   OPENSSL_CFLAGS      - e.g. &#39;compiler: cc -DDSO_DLFCN -DHAVE_DLFCN_H .....&#39;
    #   OPENSSL_BUILT_ON    - e.g. &#39;built on: reproducible build, date unspecified&#39;
    #   OPENSSL_PLATFORM    - e.g. &#39;platform: darwin64-x86_64-cc&#39;
    #   OPENSSL_DIR         - e.g. &#39;OPENSSLDIR: &quot;/opt/openssl-1.1.0g&quot;&#39;
    #   OPENSSL_ENGINES_DIR - e.g. &#39;ENGINESDIR: &quot;/opt/openssl-1.1.0g/lib/engines-1.1&quot;&#39;
    #
    # returns: string

    Net::SSLeay::OpenSSL_version();
    # is equivalent to
    Net::SSLeay::OpenSSL_version(OPENSSL_VERSION);</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OpenSSL_version.html">https://www.openssl.org/docs/manmaster/man3/OpenSSL_version.html</a></p>

</li>
<li><p>OPENSSL_info</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.90 and before; requires at least OpenSSL 3.0.0-alpha1</p>

<p>Returns different strings depending on $t. Available $t constants depend on the library version.</p>

<pre><code>    my $info_string = Net::SSLeay::OPENSSL_info($t);
    # $t
    #   OPENSSL_INFO_CONFIG_DIR - e.g. &#39;/opt/openssl-3.0.1&#39;
    #   OPENSSL_INFO_...
    #
    # returns: string</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OPENSSL_info.html">https://www.openssl.org/docs/manmaster/man3/OPENSSL_info.html</a></p>

</li>
<li><p>OPENSSL_version_major, OPENSSL_version_minor and OPENSSL_version_patch</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.90 and before; requires at least OpenSSL 3.0.0-alpha1, not in LibreSSL</p>

<p>Return constants OPENSSL_VERSION_MAJOR, OPENSSL_VERSION_MINOR and OPENSSL_VERSION_PATCH, respectively.</p>

<pre><code>    my $major = Net::SSLeay::OPENSSL_version_major();
    my $minor = Net::SSLeay::OPENSSL_version_minor();
    my $patch = Net::SSLeay::OPENSSL_version_patch();
    #
    # return: integer</code></pre>

<p>For example with OpenSSL 3.0.1, $major is 3, $minor is 0 and $patch is 1.</p>

<p>Note: the constants record Net::SSLeay compile time values whereas the three functions return values from the library. Typically these are the same, but they can be different if the library version is updated but Net::SSLeay is not re-compiled. See the OpenSSL and LibreSSL API/ABI compatibility statements for more information.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OPENSSL_version_major.html">https://www.openssl.org/docs/manmaster/man3/OPENSSL_version_major.html</a></p>

</li>
<li><p>OPENSSL_version_pre_release</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.90 and before; requires at least OpenSSL 3.0.0-alpha1, not in LibreSSL</p>

<p>Return constant string defined by C macro OPENSSL_VERSION_PRE_RELEASE.</p>

<pre><code>    my $pre_release = Net::SSLeay::OPENSSL_version_pre_release();
    #
    # returns: string (For example: &quot;-alpha3&quot; or &quot;&quot; for a release version)</code></pre>

<p>When the macro is not defined, an empty string is returned instead.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OPENSSL_version_pre_release.html">https://www.openssl.org/docs/manmaster/man3/OPENSSL_version_pre_release.html</a></p>

</li>
<li><p>OPENSSL_version_build_metadata</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.90 and before; requires at least OpenSSL 3.0.0-alpha1, not in LibreSSL</p>

<p>Return constant string defined by C macro OPENSSL_VERSION_BUILD_METADATA.</p>

<pre><code>    my $metadata = Net::SSLeay::OPENSSL_version_build_metadata();
    #
    # returns: string (For example: &quot;+fips&quot; or &quot;&quot;)</code></pre>

<p>When the macro is not defined, an empty string is returned instead.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OPENSSL_version_build_metadata.html">https://www.openssl.org/docs/manmaster/man3/OPENSSL_version_build_metadata.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-Initialization-related-functions"><a id="Low2"></a>Low level API: Initialization related functions</h3>

<ul>

<li><p>library_init</p>

<p>Initialize SSL library by registering algorithms.</p>

<pre><code>    my $rv = Net::SSLeay::library_init();</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_library_init.html">https://www.openssl.org/docs/manmaster/man3/SSL_library_init.html</a></p>

<p>While the original function from OpenSSL always returns 1, Net::SSLeay adds a wrapper around it to make sure that the OpenSSL function is only called once. Thus the function will return 1 if initialization was done and 0 if not, i.e. if initialization was done already before.</p>

</li>
<li><p>add_ssl_algorithms</p>

<p>The alias for <a href="./Net::SSLeay.html#library_init">&quot;library_init&quot;</a></p>

<pre><code>    Net::SSLeay::add_ssl_algorithms();</code></pre>

</li>
<li><p>OpenSSL_add_ssl_algorithms</p>

<p>The alias for <a href="./Net::SSLeay.html#library_init">&quot;library_init&quot;</a></p>

<pre><code>    Net::SSLeay::OpenSSL_add_ssl_algorithms();</code></pre>

</li>
<li><p>SSLeay_add_ssl_algorithms</p>

<p>The alias for <a href="./Net::SSLeay.html#library_init">&quot;library_init&quot;</a></p>

<pre><code>    Net::SSLeay::SSLeay_add_ssl_algorithms();</code></pre>

</li>
<li><p>load_error_strings</p>

<p>Registers the error strings for all libcrypto + libssl related functions.</p>

<pre><code>    Net::SSLeay::load_error_strings();
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/ERR_load_crypto_strings.html">https://www.openssl.org/docs/manmaster/man3/ERR_load_crypto_strings.html</a></p>

</li>
<li><p>ERR_load_crypto_strings</p>

<p>Registers the error strings for all libcrypto functions. No need to call this function if you have already called <a href="./Net::SSLeay.html#load_error_strings">&quot;load_error_strings&quot;</a>.</p>

<pre><code>    Net::SSLeay::ERR_load_crypto_strings();
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/ERR_load_crypto_strings.html">https://www.openssl.org/docs/manmaster/man3/ERR_load_crypto_strings.html</a></p>

</li>
<li><p>ERR_load_RAND_strings</p>

<p>Registers the error strings for RAND related functions. No need to call this function if you have already called <a href="./Net::SSLeay.html#load_error_strings">&quot;load_error_strings&quot;</a>.</p>

<pre><code>    Net::SSLeay::ERR_load_RAND_strings();
    #
    # returns: no return value</code></pre>

</li>
<li><p>ERR_load_SSL_strings</p>

<p>Registers the error strings for SSL related functions. No need to call this function if you have already called <a href="./Net::SSLeay.html#load_error_strings">&quot;load_error_strings&quot;</a>.</p>

<pre><code>    Net::SSLeay::ERR_load_SSL_strings();
    #
    # returns: no return value</code></pre>

</li>
<li><p>OpenSSL_add_all_algorithms</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Add algorithms to internal table.</p>

<pre><code>    Net::SSLeay::OpenSSL_add_all_algorithms();
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OpenSSL_add_all_algorithms.html">https://www.openssl.org/docs/manmaster/man3/OpenSSL_add_all_algorithms.html</a></p>

</li>
<li><p>OPENSSL_add_all_algorithms_conf</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Similar to <a href="./Net::SSLeay.html#OpenSSL_add_all_algorithms">&quot;OpenSSL_add_all_algorithms&quot;</a> - will ALWAYS load the config file</p>

<pre><code>    Net::SSLeay::OPENSSL_add_all_algorithms_conf();
    #
    # returns: no return value</code></pre>

</li>
<li><p>OPENSSL_add_all_algorithms_noconf</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Similar to <a href="./Net::SSLeay.html#OpenSSL_add_all_algorithms">&quot;OpenSSL_add_all_algorithms&quot;</a> - will NEVER load the config file</p>

<pre><code>    Net::SSLeay::OPENSSL_add_all_algorithms_noconf();
    #
    # returns: no return value</code></pre>

</li>
<li><p>OPENSSL_cleanup</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.0-pre3 or LibreSSL 3.6.0</p>

<p>Deinitialises OpenSSL libcrypto and libssl.</p>

<pre><code>    Net::SSLeay::OPENSSL_cleanup();
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OPENSSL_cleanup">https://www.openssl.org/docs/manmaster/man3/OPENSSL_cleanup</a></p>

</li>
<li><p>OPENSSL_init_crypto</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.0-pre3 not enabled for LibreSSL. LibreSSL does not define <code>OPENSSL_INIT_SETTINGS</code>.</p>

<p>Initialises OpenSSL <code>libcrypto</code> with non-default settings.</p>

<pre><code>    my $rv = Net::SSLeay::OPENSSL_init_crypto($opts, $settings);
    # $opts - (uin64_t) flags to be set (bitmask)
    # $settings - value corresponding to OPENSSL_INIT_SETTINGS structure or undef (optional)
    #
    # returns: 1 on success or 0 on error</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OPENSSL_init_crypto">https://www.openssl.org/docs/manmaster/man3/OPENSSL_init_crypto</a></p>

</li>
<li><p>OPENSSL_init_ssl</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.0-pre3 not enabled for LibreSSL. LibreSSL does not define <code>OPENSSL_INIT_SETTINGS</code>.</p>

<p>Initialises OpenSSL <code>libssl</code> with non-default settings.</p>

<pre><code>    my $rv = Net::SSLeay::OPENSSL_init_ssl($opts, $settings);
    # $opts - (uin64_t) flags to be set (bitmask)
    # $settings - value corresponding to OPENSSL_INIT_SETTINGS structure or undef (optional)
    #
    # returns: 1 on success or 0 on error</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OPENSSL_init_ssl">https://www.openssl.org/docs/manmaster/man3/OPENSSL_init_ssl</a></p>

</li>
<li><p>OPENSSL_INIT_new</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.0-pre3, not in LibreSSL</p>

<p>Allocates an OpenSSL <code>OPENSSL_INIT_SETTINGS</code> object.</p>

<pre><code>    my $settings = Net::SSLeay::OPENSSL_init_new()
    #
    # returns: value corresponding to OPENSSL_INIT_SETTINGS structure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OPENSSL_INIT_new">https://www.openssl.org/docs/manmaster/man3/OPENSSL_INIT_new</a></p>

</li>
<li><p>OPENSSL_INIT_free</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.0-pre3, not in LibreSSL</p>

<p>Releases an OpenSSL <code>OPENSSL_INIT_SETTINGS</code> object allocated with <code>OPENSSL_INIT_new</code>.</p>

<pre><code>    Net::SSLeay::OPENSSL_init_free($settings)
    # $settings - value corresponding to OPENSSL_INIT_SETTINGS structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OPENSSL_INIT_free">https://www.openssl.org/docs/manmaster/man3/OPENSSL_INIT_free</a></p>

</li>
<li><p>OPENSSL_INIT_set_config_filename</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.0-pre3, not in LibreSSL</p>

<p>Specify a nondefault filename to load as OpenSSL configuration file.</p>

<pre><code>    my $rv = Net::SSLeay::OPENSSL_INIT_set_config_filename($settings, $filename);
    # $settings - value corresponding to OPENSSL_INIT_SETTINGS structure
    # $filename - (string) filename
    #
    # returns: 1 on success or 0 on error</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OPENSSL_INIT_set_config_filename">https://www.openssl.org/docs/manmaster/man3/OPENSSL_INIT_set_config_filename</a></p>

</li>
<li><p>OPENSSL_INIT_set_config_appname</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.0-pre3, not in LibreSSL</p>

<p>Specify a nondefault application name.</p>

<pre><code>    my $rv = Net::SSLeay::OPENSSL_INIT_set_config_appname($settings, $name);
    # $settings - value corresponding to OPENSSL_INIT_SETTINGS structure
    # $name - (string) application name
    #
    # returns: 1 on success or 0 on error</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OPENSSL_INIT_set_config_appname">https://www.openssl.org/docs/manmaster/man3/OPENSSL_INIT_set_config_appname</a></p>

</li>
<li><p>OPENSSL_INIT_set_config_file_flags</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 3.0.0-alpha1, not in LibreSSL</p>

<p>Specify nondefault flags for loading OpenSSL configuration file.</p>

<pre><code>    my $rv = Net::SSLeay::OPENSSL_INIT_set_config_file_flags($settings, $flags);
    # $settings - value corresponding to OPENSSL_INIT_SETTINGS structure
    # $flags - (unsigned long) flags to be set (bitmask)
    #
    # returns: 1 on success or 0 on error</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OPENSSL_INIT_set_config_file_flags">https://www.openssl.org/docs/manmaster/man3/OPENSSL_INIT_set_config_file_flags</a></p>

</li>
</ul>

<h3 id="Low-level-API:-ERR_*-and-SSL_alert_*-related-functions"><a id="Low3"></a><a id="Low-level-API:-ERR_--and-SSL_alert_--related-functions"></a>Low level API: ERR_* and SSL_alert_* related functions</h3>

<p><b>NOTE:</b> Please note that SSL_alert_* function have &quot;SSL_&quot; part stripped from their names.</p>

<ul>

<li><p>ERR_clear_error</p>

<p>Clear the error queue.</p>

<pre><code>    Net::SSLeay::ERR_clear_error();
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/ERR_clear_error.html">https://www.openssl.org/docs/manmaster/man3/ERR_clear_error.html</a></p>

</li>
<li><p>ERR_error_string</p>

<p>Generates a human-readable string representing the error code $error.</p>

<pre><code>    my $rv = Net::SSLeay::ERR_error_string($error);
    # $error - (unsigned integer) error code
    #
    # returns: string</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/ERR_error_string.html">https://www.openssl.org/docs/manmaster/man3/ERR_error_string.html</a></p>

</li>
<li><p>ERR_get_error</p>

<p>Returns the earliest error code from the thread&#39;s error queue and removes the entry. This function can be called repeatedly until there are no more error codes to return.</p>

<pre><code>    my $rv = Net::SSLeay::ERR_get_error();
    #
    # returns: (unsigned integer) error code</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/ERR_get_error.html">https://www.openssl.org/docs/manmaster/man3/ERR_get_error.html</a></p>

</li>
<li><p>ERR_peek_error</p>

<p>Returns the earliest error code from the thread&#39;s error queue without modifying it.</p>

<pre><code>    my $rv = Net::SSLeay::ERR_peek_error();
    #
    # returns: (unsigned integer) error code</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/ERR_get_error.html">https://www.openssl.org/docs/manmaster/man3/ERR_get_error.html</a></p>

</li>
<li><p>ERR_put_error</p>

<p>Adds an error code to the thread&#39;s error queue. It signals that the error of $reason code reason occurred in function $func of library $lib, in line number $line of $file.</p>

<pre><code>    Net::SSLeay::ERR_put_error($lib, $func, $reason, $file, $line);
    # $lib - (integer) library id (check openssl/err.h for constants e.g. ERR_LIB_SSL)
    # $func - (integer) function id (check openssl/ssl.h for constants e.g. SSL_F_SSL23_READ)
    # $reason - (integer) reason id (check openssl/ssl.h for constants e.g. SSL_R_SSL_HANDSHAKE_FAILURE)
    # $file - (string) file name
    # $line - (integer) line number in $file
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/ERR_put_error.html">https://www.openssl.org/docs/manmaster/man3/ERR_put_error.html</a> and <a href="https://www.openssl.org/docs/manmaster/man3/err.html">https://www.openssl.org/docs/manmaster/man3/err.html</a></p>

</li>
<li><p>alert_desc_string</p>

<p>Returns a two letter string as a short form describing the reason of the alert specified by value.</p>

<pre><code>    my $rv = Net::SSLeay::alert_desc_string($value);
    # $value - (integer) alert id (check openssl/ssl.h for SSL3_AD_* and TLS1_AD_* constants)
    #
    # returns: description string (2 letters)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_alert_type_string.html">https://www.openssl.org/docs/manmaster/man3/SSL_alert_type_string.html</a></p>

</li>
<li><p>alert_desc_string_long</p>

<p>Returns a string describing the reason of the alert specified by value.</p>

<pre><code>    my $rv = Net::SSLeay::alert_desc_string_long($value);
    # $value - (integer) alert id (check openssl/ssl.h for SSL3_AD_* and TLS1_AD_* constants)
    #
    # returns: description string</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_alert_type_string.html">https://www.openssl.org/docs/manmaster/man3/SSL_alert_type_string.html</a></p>

</li>
<li><p>alert_type_string</p>

<p>Returns a one letter string indicating the type of the alert specified by value.</p>

<pre><code>    my $rv = Net::SSLeay::alert_type_string($value);
    # $value - (integer) alert id (check openssl/ssl.h for SSL3_AD_* and TLS1_AD_* constants)
    #
    # returns: string (1 letter)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_alert_type_string.html">https://www.openssl.org/docs/manmaster/man3/SSL_alert_type_string.html</a></p>

</li>
<li><p>alert_type_string_long</p>

<p>Returns a string indicating the type of the alert specified by value.</p>

<pre><code>    my $rv = Net::SSLeay::alert_type_string_long($value);
    # $value - (integer) alert id (check openssl/ssl.h for SSL3_AD_* and TLS1_AD_* constants)
    #
    # returns: string</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_alert_type_string.html">https://www.openssl.org/docs/manmaster/man3/SSL_alert_type_string.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-SSL_METHOD_*-related-functions"><a id="Low4"></a><a id="Low-level-API:-SSL_METHOD_--related-functions"></a>Low level API: SSL_METHOD_* related functions</h3>

<ul>

<li><p>SSLv23_method, SSLv23_server_method and SSLv23_client_method</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before.</p>

<p>Returns SSL_METHOD structure corresponding to general-purpose version-flexible TLS method, the return value can be later used as a param of <a href="./Net::SSLeay.html#CTX_new_with_method">&quot;CTX_new_with_method&quot;</a>.</p>

<p><b>NOTE:</b> Consider using TLS_method, TLS_server_method or TLS_client_method with new code.</p>

<pre><code>    my $rv = Net::SSLeay::SSLv2_method();
    #
    # returns: value corresponding to openssl&#39;s SSL_METHOD structure (0 on failure)</code></pre>

</li>
<li><p>SSLv2_method</p>

<p>Returns SSL_METHOD structure corresponding to SSLv2 method, the return value can be later used as a param of <a href="./Net::SSLeay.html#CTX_new_with_method">&quot;CTX_new_with_method&quot;</a>. Only available where supported by the underlying openssl.</p>

<pre><code>    my $rv = Net::SSLeay::SSLv2_method();
    #
    # returns: value corresponding to openssl&#39;s SSL_METHOD structure (0 on failure)</code></pre>

</li>
<li><p>SSLv3_method</p>

<p>Returns SSL_METHOD structure corresponding to SSLv3 method, the return value can be later used as a param of <a href="./Net::SSLeay.html#CTX_new_with_method">&quot;CTX_new_with_method&quot;</a>.</p>

<pre><code>    my $rv = Net::SSLeay::SSLv3_method();
    #
    # returns: value corresponding to openssl&#39;s SSL_METHOD structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html</a></p>

</li>
<li><p>TLSv1_method, TLSv1_server_method and TLSv1_client_method</p>

<p><b>COMPATIBILITY:</b> Requires OpenSSL or LibreSSL built with support for TLSv1. Server and client methods not available in Net-SSLeay-1.82 and before.</p>

<p>Returns SSL_METHOD structure corresponding to TLSv1 method, the return value can be later used as a param of <a href="./Net::SSLeay.html#CTX_new_with_method">&quot;CTX_new_with_method&quot;</a>.</p>

<pre><code>    my $rv = Net::SSLeay::TLSv1_method();
    #
    # returns: value corresponding to openssl&#39;s SSL_METHOD structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html</a></p>

</li>
<li><p>TLSv1_1_method, TLSv1_1_server_method and TLSv1_1_client_method</p>

<p><b>COMPATIBILITY:</b> Requires OpenSSL &gt;= 1.0.1 or LibreSSL built with support for TLSv1.1. Server and client methods not available in Net-SSLeay-1.82 and before.</p>

<p>Returns SSL_METHOD structure corresponding to TLSv1_1 method, the return value can be later used as a param of <a href="./Net::SSLeay.html#CTX_new_with_method">&quot;CTX_new_with_method&quot;</a>.</p>

<pre><code>    my $rv = Net::SSLeay::TLSv1_1_method();
    #
    # returns: value corresponding to openssl&#39;s SSL_METHOD structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html</a></p>

</li>
<li><p>TLSv1_2_method, TLSv1_2_server_method and TLSv1_2_client_method</p>

<p><b>COMPATIBILITY:</b> Requires OpenSSL &gt;= 1.0.1 or LibreSSL built with support for TLSv1.2. Server and client methods not available in Net-SSLeay-1.82 and before.</p>

<p>Returns SSL_METHOD structure corresponding to TLSv1_2 method, the return value can be later used as a param of <a href="./Net::SSLeay.html#CTX_new_with_method">&quot;CTX_new_with_method&quot;</a>.</p>

<pre><code>    my $rv = Net::SSLeay::TLSv1_2_method();
    #
    # returns: value corresponding to openssl&#39;s SSL_METHOD structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html</a></p>

</li>
<li><p>TLS_method, TLS_server_method and TLS_client_method</p>

<p><b>COMPATIBILITY:</b> Not available in Net-SSLeay-1.82 and before.</p>

<p>Returns SSL_METHOD structure corresponding to general-purpose version-flexible TLS method, the return value can be later used as a param of <a href="./Net::SSLeay.html#CTX_new_with_method">&quot;CTX_new_with_method&quot;</a>. Only available where supported by the underlying openssl.</p>

<pre><code>    my $rv = Net::SSLeay::TLS_method();
    #
    # returns: value corresponding to openssl&#39;s SSL_METHOD structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-ENGINE_*-related-functions"><a id="Low5"></a><a id="Low-level-API:-ENGINE_--related-functions"></a>Low level API: ENGINE_* related functions</h3>

<ul>

<li><p>ENGINE_load_builtin_engines</p>

<p><b>COMPATIBILITY:</b> Requires an OpenSSL build with dynamic engine loading support.</p>

<p>Load all bundled ENGINEs into memory and make them visible.</p>

<pre><code>    Net::SSLeay::ENGINE_load_builtin_engines();
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/ENGINE_by_id.html">https://www.openssl.org/docs/manmaster/man3/ENGINE_by_id.html</a></p>

</li>
<li><p>ENGINE_register_all_complete</p>

<p><b>COMPATIBILITY:</b> Requires an OpenSSL build with dynamic engine loading support.</p>

<p>Register all loaded ENGINEs for every algorithm they collectively implement.</p>

<pre><code>    Net::SSLeay::ENGINE_register_all_complete();
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/ENGINE_by_id.html">https://www.openssl.org/docs/manmaster/man3/ENGINE_by_id.html</a></p>

</li>
<li><p>ENGINE_set_default</p>

<p><b>COMPATIBILITY:</b> Requires an OpenSSL build with dynamic engine loading support.</p>

<p>Set default engine to $e + set its flags to $flags.</p>

<pre><code>    my $rv = Net::SSLeay::ENGINE_set_default($e, $flags);
    # $e - value corresponding to openssl&#39;s ENGINE structure
    # $flags - (integer) engine flags
    #          flags value can be made by bitwise &quot;OR&quot;ing:
    #          0x0001 - ENGINE_METHOD_RSA
    #          0x0002 - ENGINE_METHOD_DSA
    #          0x0004 - ENGINE_METHOD_DH
    #          0x0008 - ENGINE_METHOD_RAND
    #          0x0010 - ENGINE_METHOD_ECDH
    #          0x0020 - ENGINE_METHOD_ECDSA
    #          0x0040 - ENGINE_METHOD_CIPHERS
    #          0x0080 - ENGINE_METHOD_DIGESTS
    #          0x0100 - ENGINE_METHOD_STORE
    #          0x0200 - ENGINE_METHOD_PKEY_METHS
    #          0x0400 - ENGINE_METHOD_PKEY_ASN1_METHS
    #          Obvious all-or-nothing cases:
    #          0xFFFF - ENGINE_METHOD_ALL
    #          0x0000 - ENGINE_METHOD_NONE
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/ENGINE_by_id.html">https://www.openssl.org/docs/manmaster/man3/ENGINE_by_id.html</a></p>

</li>
<li><p>ENGINE_by_id</p>

<p>Get ENGINE by its identification $id.</p>

<p><b>COMPATIBILITY:</b> Requires an OpenSSL build with dynamic engine loading support.</p>

<pre><code>    my $rv = Net::SSLeay::ENGINE_by_id($id);
    # $id - (string) engine identification e.g. &quot;dynamic&quot;
    #
    # returns: value corresponding to openssl&#39;s ENGINE structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/ENGINE_by_id.html">https://www.openssl.org/docs/manmaster/man3/ENGINE_by_id.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-EVP_PKEY_*-related-functions"><a id="Low6"></a><a id="Low-level-API:-EVP_PKEY_--related-functions"></a>Low level API: EVP_PKEY_* related functions</h3>

<ul>

<li><p>EVP_PKEY_copy_parameters</p>

<p>Copies the parameters from key $from to key $to.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_PKEY_copy_parameters($to, $from);
    # $to - value corresponding to openssl&#39;s EVP_PKEY structure
    # $from - value corresponding to openssl&#39;s EVP_PKEY structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_cmp.html">https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_cmp.html</a></p>

</li>
<li><p>EVP_PKEY_new</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Creates a new EVP_PKEY structure.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_PKEY_new();
    #
    # returns: value corresponding to openssl&#39;s EVP_PKEY structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_new.html">https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_new.html</a></p>

</li>
<li><p>EVP_PKEY_free</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Free an allocated EVP_PKEY structure.</p>

<pre><code>    Net::SSLeay::EVP_PKEY_free($pkey);
    # $pkey - value corresponding to openssl&#39;s EVP_PKEY structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_new.html">https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_new.html</a></p>

</li>
<li><p>EVP_PKEY_assign_RSA</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Set the key referenced by $pkey to $key</p>

<p><b>NOTE:</b> No reference counter will be increased, i.e. $key will be freed if $pkey is freed.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_PKEY_assign_RSA($pkey, $key);
    # $pkey - value corresponding to openssl&#39;s EVP_PKEY structure
    # $key - value corresponding to openssl&#39;s RSA structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_assign_RSA.html">https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_assign_RSA.html</a></p>

</li>
<li><p>EVP_PKEY_assign_EC_KEY</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.74 and before</p>

<p>Set the key referenced by $pkey to $key</p>

<p><b>NOTE:</b> No reference counter will be increased, i.e. $key will be freed if $pkey is freed.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_PKEY_assign_EC_KEY($pkey, $key);
    # $pkey - value corresponding to openssl&#39;s EVP_PKEY structure
    # $key - value corresponding to openssl&#39;s EC_KEY structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_assign_EC_KEY.html">https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_assign_EC_KEY.html</a></p>

</li>
<li><p>EVP_PKEY_bits</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns the size of the key $pkey in bits.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_PKEY_bits($pkey);
    # $pkey - value corresponding to openssl&#39;s EVP_PKEY structure
    #
    # returns: size in bits</code></pre>

</li>
<li><p>EVP_PKEY_security_bits</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.0 or at least LibreSSL 3.6.0 and Net-SSLeay-1.94</p>

<p>Returns the size of the key $pkey in bits.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_PKEY_security_bits($pkey);
    # $pkey - value corresponding to openssl&#39;s EVP_PKEY structure
    #
    # returns: number of bits</code></pre>

</li>
<li><p>EVP_PKEY_size</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns the maximum size of a signature in bytes. The actual signature may be smaller.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_PKEY_size($pkey);
    # $pkey - value corresponding to openssl&#39;s EVP_PKEY structure
    #
    # returns: the maximum size in bytes</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_size.html">https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_size.html</a></p>

</li>
<li><p>EVP_PKEY_id</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before; requires at least OpenSSL 1.0.0</p>

<p>Returns $pkey type (integer value of corresponding NID).</p>

<pre><code>    my $rv = Net::SSLeay::EVP_PKEY_id($pkey);
    # $pkey - value corresponding to openssl&#39;s EVP_PKEY structure
    #
    # returns: (integer) key type</code></pre>

<p>Example:</p>

<pre><code>    my $pubkey = Net::SSLeay::X509_get_pubkey($x509);
    my $type = Net::SSLeay::EVP_PKEY_id($pubkey);
    print Net::SSLeay::OBJ_nid2sn($type);             # prints e.g. &#39;rsaEncryption&#39;</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-PEM_*-related-functions"><a id="Low7"></a><a id="Low-level-API:-PEM_--related-functions"></a>Low level API: PEM_* related functions</h3>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/pem.html">https://www.openssl.org/docs/manmaster/man3/pem.html</a></p>

<ul>

<li><p>PEM_read_bio_X509</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Loads PEM formatted X509 certificate via given BIO structure.</p>

<pre><code>    my $rv = Net::SSLeay::PEM_read_bio_X509($bio);
    # $bio - value corresponding to openssl&#39;s BIO structure
    #
    # returns: value corresponding to openssl&#39;s X509 structure (0 on failure)</code></pre>

<p>Example:</p>

<pre><code>    my $bio = Net::SSLeay::BIO_new_file($filename, &#39;r&#39;);
    my $x509 = Net::SSLeay::PEM_read_bio_X509($bio);
    Net::SSLeay::BIO_free($bio);</code></pre>

</li>
<li><p>PEM_read_bio_X509_REQ</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Loads PEM formatted X509_REQ object via given BIO structure.</p>

<pre><code>    my $rv = Net::SSLeay::PEM_read_bio_X509_REQ($bio, $x=NULL, $cb=NULL, $u=NULL);
    # $bio - value corresponding to openssl&#39;s BIO structure
    #
    # returns: value corresponding to openssl&#39;s X509_REQ structure (0 on failure)</code></pre>

<p>Example:</p>

<pre><code>    my $bio = Net::SSLeay::BIO_new_file($filename, &#39;r&#39;);
    my $x509_req = Net::SSLeay::PEM_read_bio_X509_REQ($bio);
    Net::SSLeay::BIO_free($bio);</code></pre>

</li>
<li><p>PEM_read_bio_DHparams</p>

<p>Reads DH structure from BIO.</p>

<pre><code>    my $rv = Net::SSLeay::PEM_read_bio_DHparams($bio);
    # $bio - value corresponding to openssl&#39;s BIO structure
    #
    # returns: value corresponding to openssl&#39;s DH structure (0 on failure)</code></pre>

</li>
<li><p>PEM_read_bio_X509_CRL</p>

<p>Reads X509_CRL structure from BIO.</p>

<pre><code>    my $rv = Net::SSLeay::PEM_read_bio_X509_CRL($bio);
    # $bio - value corresponding to openssl&#39;s BIO structure
    #
    # returns: value corresponding to openssl&#39;s X509_CRL structure (0 on failure)</code></pre>

</li>
<li><p>PEM_read_bio_PrivateKey</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Loads PEM formatted private key via given BIO structure.</p>

<pre><code>    my $rv = Net::SSLeay::PEM_read_bio_PrivateKey($bio, $cb, $data);
    # $bio - value corresponding to openssl&#39;s BIO structure
    # $cb - reference to perl callback function
    # $data - data that will be passed to callback function (see examples below)
    #
    # returns: value corresponding to openssl&#39;s EVP_PKEY structure (0 on failure)</code></pre>

<p>Example:</p>

<pre><code>    my $bio = Net::SSLeay::BIO_new_file($filename, &#39;r&#39;);
    my $privkey = Net::SSLeay::PEM_read_bio_PrivateKey($bio); # ask for password if needed
    Net::SSLeay::BIO_free($bio);</code></pre>

<p>To use password you have the following options:</p>

<pre><code>    $privkey = Net::SSLeay::PEM_read_bio_PrivateKey($bio, \&amp;callback_func); # use callback func for getting password
    $privkey = Net::SSLeay::PEM_read_bio_PrivateKey($bio, \&amp;callback_func, $data); # use callback_func + pass $data to callback_func
    $privkey = Net::SSLeay::PEM_read_bio_PrivateKey($bio, undef, &quot;secret&quot;); # use password &quot;secret&quot;
    $privkey = Net::SSLeay::PEM_read_bio_PrivateKey($bio, undef, &quot;&quot;);       # use empty password</code></pre>

<p>Callback function signature:</p>

<pre><code>    sub callback_func {
        my ($max_passwd_size, $rwflag, $data) = @_;
        # $max_passwd_size - maximum size of returned password (longer values will be discarded)
        # $rwflag - indicates whether we are loading (0) or storing (1) - for PEM_read_bio_PrivateKey always 0
        # $data - the data passed to PEM_read_bio_PrivateKey as 3rd parameter

        return &quot;secret&quot;;
    }</code></pre>

</li>
<li><p>PEM_X509_INFO_read_bio</p>

<p>Reads a BIO containing a PEM formatted file into a STACK_OF(X509_INFO) structure.</p>

<pre><code>    my $rv = Net::SSLeay::PEM_X509_INFO_read_bio($bio);
    # $bio - value corresponding to openssl&#39;s BIO structure
    #
    # returns: value corresponding to openssl&#39;s STACK_OF(X509_INFO) structure.</code></pre>

<p>Example:</p>

<pre><code>    my $bio = Net::SSLeay::BIO_new_file($filename, &#39;r&#39;);
    my $sk_x509_info = Net::SSLeay::PEM_X509_INFO_read_bio($bio);
    Net::SSLeay::BIO_free($bio);</code></pre>

</li>
<li><p>PEM_get_string_X509</p>

<p><b>NOTE:</b> Does not exactly correspond to any low level API function</p>

<p>Converts/exports X509 certificate to string (PEM format).</p>

<pre><code>    Net::SSLeay::PEM_get_string_X509($x509);
    # $x509 - value corresponding to openssl&#39;s X509 structure
    #
    # returns: string with $x509 in PEM format</code></pre>

</li>
<li><p>PEM_get_string_PrivateKey</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before. Requires legacy provider with OpenSSL 3.0 and later if the default value of <code>$enc_alg</code> (<code>DES_CBC</code>) is used.</p>

<p>Converts public key $pk into PEM formatted string (optionally protected with password).</p>

<pre><code>    my $rv = Net::SSLeay::PEM_get_string_PrivateKey($pk, $passwd, $enc_alg);
    # $pk - value corresponding to openssl&#39;s EVP_PKEY structure
    # $passwd - [optional] (string) password to use for key encryption
    # $enc_alg - [optional] algorithm to use for key encryption (default: DES_CBC) - value corresponding to openssl&#39;s EVP_CIPHER structure
    #
    # returns: PEM formatted string</code></pre>

<p>Examples:</p>

<pre><code>    $pem_privkey = Net::SSLeay::PEM_get_string_PrivateKey($pk);
    $pem_privkey = Net::SSLeay::PEM_get_string_PrivateKey($pk, &quot;secret&quot;);
    $pem_privkey = Net::SSLeay::PEM_get_string_PrivateKey($pk, &quot;secret&quot;, Net::SSLeay::EVP_get_cipherbyname(&quot;DES-EDE3-CBC&quot;));</code></pre>

</li>
<li><p>PEM_get_string_X509_CRL</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Converts X509_CRL object $x509_crl into PEM formatted string.</p>

<pre><code>    Net::SSLeay::PEM_get_string_X509_CRL($x509_crl);
    # $x509_crl - value corresponding to openssl&#39;s X509_CRL structure
    #
    # returns: no return value</code></pre>

</li>
<li><p>PEM_get_string_X509_REQ</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Converts X509_REQ object $x509_crl into PEM formatted string.</p>

<pre><code>    Net::SSLeay::PEM_get_string_X509_REQ($x509_req);
    # $x509_req - value corresponding to openssl&#39;s X509_REQ structure
    #
    # returns: no return value</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-d2i_*-(DER-format)-related-functions"><a id="Low8"></a><a id="Low-level-API:-d2i_---DER-format--related-functions"></a>Low level API: d2i_* (DER format) related functions</h3>

<ul>

<li><p>d2i_X509_bio</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Loads DER formatted X509 certificate via given BIO structure.</p>

<pre><code>    my $rv = Net::SSLeay::d2i_X509_bio($bp);
    # $bp - value corresponding to openssl&#39;s BIO structure
    #
    # returns: value corresponding to openssl&#39;s X509 structure (0 on failure)</code></pre>

<p>Example:</p>

<pre><code>    my $bio = Net::SSLeay::BIO_new_file($filename, &#39;rb&#39;);
    my $x509 = Net::SSLeay::d2i_X509_bio($bio);
    Net::SSLeay::BIO_free($bio);</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/d2i_X509.html">https://www.openssl.org/docs/manmaster/man3/d2i_X509.html</a></p>

</li>
<li><p>d2i_X509_CRL_bio</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Loads DER formatted X509_CRL object via given BIO structure.</p>

<pre><code>    my $rv = Net::SSLeay::d2i_X509_CRL_bio($bp);
    # $bp - value corresponding to openssl&#39;s BIO structure
    #
    # returns: value corresponding to openssl&#39;s X509_CRL structure (0 on failure)</code></pre>

<p>Example:</p>

<pre><code>    my $bio = Net::SSLeay::BIO_new_file($filename, &#39;rb&#39;);
    my $x509_crl = Net::SSLeay::d2i_X509_CRL_bio($bio);
    Net::SSLeay::BIO_free($bio);</code></pre>

</li>
<li><p>d2i_X509_REQ_bio</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Loads DER formatted X509_REQ object via given BIO structure.</p>

<pre><code>    my $rv = Net::SSLeay::d2i_X509_REQ_bio($bp);
    # $bp - value corresponding to openssl&#39;s BIO structure
    #
    # returns: value corresponding to openssl&#39;s X509_REQ structure (0 on failure)</code></pre>

<p>Example:</p>

<pre><code>    my $bio = Net::SSLeay::BIO_new_file($filename, &#39;rb&#39;);
    my $x509_req = Net::SSLeay::d2i_X509_REQ_bio($bio);
    Net::SSLeay::BIO_free($bio);</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-PKCS12-related-functions"><a id="Low9"></a>Low level API: PKCS12 related functions</h3>

<ul>

<li><p>P_PKCS12_load_file</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Loads X509 certificate + private key + certificates of CA chain (if present in PKCS12 file).</p>

<pre><code>    my ($privkey, $cert, @cachain) = Net::SSLeay::P_PKCS12_load_file($filename, $load_chain, $password);
    # $filename - name of PKCS12 file
    # $load_chain - [optional] whether load (1) or not(0) CA chain (default: 0)
    # $password - [optional] password for private key
    #
    # returns: triplet ($privkey, $cert, @cachain)
    #          $privkey - value corresponding to openssl&#39;s EVP_PKEY structure
    #          $cert - value corresponding to openssl&#39;s X509 structure
    #          @cachain - array of values corresponding to openssl&#39;s X509 structure (empty if no CA chain in PKCS12)</code></pre>

<p><b>IMPORTANT NOTE:</b> after you do the job you need to call X509_free() on $privkey + all members of @cachain and EVP_PKEY_free() on $privkey.</p>

<p>Examples:</p>

<pre><code>    my ($privkey, $cert) = Net::SSLeay::P_PKCS12_load_file($filename);
    # or
    my ($privkey, $cert) = Net::SSLeay::P_PKCS12_load_file($filename, 0, $password);
    # or
    my ($privkey, $cert, @cachain) = Net::SSLeay::P_PKCS12_load_file($filename, 1);
    # or
    my ($privkey, $cert, @cachain) = Net::SSLeay::P_PKCS12_load_file($filename, 1, $password);

    # BEWARE: THIS IS WRONG - MEMORY LEAKS! (you cannot free @cachain items)
    my ($privkey, $cert) = Net::SSLeay::P_PKCS12_load_file($filename, 1, $password);</code></pre>

<p><b>NOTE</b> Net::SSLeay 1.92_01 and earlier: With some combinations of Windows, perl, compiler and compiler options, you may see a runtime error &quot;no OPENSSL_Applink&quot;, when calling Net::SSLeay::P_PKCS12_load_file. See README.Win32 for more details.</p>

</li>
</ul>

<h3 id="Low-level-API:-SESSION_*-related-functions"><a id="Low10"></a><a id="Low-level-API:-SESSION_--related-functions"></a>Low level API: SESSION_* related functions</h3>

<ul>

<li><p>d2i_SSL_SESSION</p>

<p><b>COMPATIBILITY:</b> does not work in Net-SSLeay-1.85 and before</p>

<p>Transforms the binary ASN1 representation string of an SSL/TLS session into an SSL_SESSION object.</p>

<pre><code>    my $ses = Net::SSLeay::d2i_SSL_SESSION($data);
    # $data - the session as ASN1 representation string
    #
    # returns: $ses - the new SSL_SESSION</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/i2d_SSL_SESSION.html">https://www.openssl.org/docs/manmaster/man3/i2d_SSL_SESSION.html</a></p>

</li>
<li><p>i2d_SSL_SESSION</p>

<p><b>COMPATIBILITY:</b> does not work in Net-SSLeay-1.85 and before</p>

<p>Transforms the SSL_SESSION object in into the ASN1 representation and returns it as string.</p>

<pre><code>    my $data = Net::SSLeay::i2d_SSL_SESSION($ses);
    # $ses - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: $data - session as string</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/d2i_SSL_SESSION.html">https://www.openssl.org/docs/manmaster/man3/d2i_SSL_SESSION.html</a></p>

</li>
<li><p>SESSION_new</p>

<p>Creates a new SSL_SESSION structure.</p>

<pre><code>    my $rv = Net::SSLeay::SESSION_new();
    #
    # returns: value corresponding to openssl&#39;s SSL_SESSION structure (0 on failure)</code></pre>

</li>
<li><p>SESSION_free</p>

<p>Free an allocated SSL_SESSION structure.</p>

<pre><code>    Net::SSLeay::SESSION_free($ses);
    # $ses - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_free.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_free.html</a></p>

</li>
<li><p>SESSION_up_ref</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0-pre4 or LibreSSL 2.7.0</p>

<p>Increases the reference counter on a SSL_SESSION structure.</p>

<pre><code>    Net::SSLeay::SESSION_up_ref($ses);
    # $ses - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: 1 on success else 0</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_up_ref.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_up_ref.html</a></p>

</li>
<li><p>SESSION_dup</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>

<p>Duplicates a SSL_SESSION structure.</p>

<pre><code>    Net::SSLeay::SESSION_dup($ses);
    # $ses - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: the duplicated session</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_dup.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_dup.html</a></p>

</li>
<li><p>SESSION_is_resumable</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>

<p>Determine whether an SSL_SESSION object can be used for resumption.</p>

<pre><code>    Net::SSLeay::SESSION_is_resumable($ses);
    # $ses - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: (integer) 1 if it can or 0 if not</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_is_resumable.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_is_resumable.html</a></p>

</li>
<li><p>SESSION_cmp</p>

<p>Compare two SSL_SESSION structures.</p>

<pre><code>    my $rv = Net::SSLeay::SESSION_cmp($sesa, $sesb);
    # $sesa - value corresponding to openssl&#39;s SSL_SESSION structure
    # $sesb - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: 0 if the two structures are the same</code></pre>

<p><b>NOTE:</b> Not available in openssl 1.0 or later</p>

</li>
<li><p>SESSION_get_app_data</p>

<p>Can be used to get application defined value/data.</p>

<pre><code>    my $rv = Net::SSLeay::SESSION_get_app_data($ses);
    # $ses - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: string/buffer/pointer ???</code></pre>

</li>
<li><p>SESSION_set_app_data</p>

<p>Can be used to set some application defined value/data.</p>

<pre><code>    my $rv = Net::SSLeay::SESSION_set_app_data($s, $a);
    # $s - value corresponding to openssl&#39;s SSL_SESSION structure
    # $a - (string/buffer/pointer ???) data
    #
    # returns: ???</code></pre>

</li>
<li><p>SESSION_get_ex_data</p>

<p>Is used to retrieve the information for $idx from session $ses.</p>

<pre><code>    my $rv = Net::SSLeay::SESSION_get_ex_data($ses, $idx);
    # $ses - value corresponding to openssl&#39;s SSL_SESSION structure
    # $idx - (integer) index for application specific data
    #
    # returns: pointer to ???</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_ex_new_index.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_ex_new_index.html</a></p>

</li>
<li><p>SESSION_set_ex_data</p>

<p>Is used to store application data at arg for idx into the session object.</p>

<pre><code>    my $rv = Net::SSLeay::SESSION_set_ex_data($ss, $idx, $data);
    # $ss - value corresponding to openssl&#39;s SSL_SESSION structure
    # $idx - (integer) ???
    # $data - (pointer) ???
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_ex_new_index.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_ex_new_index.html</a></p>

</li>
<li><p>SESSION_get_ex_new_index</p>

<p>Is used to register a new index for application specific data.</p>

<pre><code>    my $rv = Net::SSLeay::SESSION_get_ex_new_index($argl, $argp, $new_func, $dup_func, $free_func);
    # $argl - (long) ???
    # $argp - (pointer) ???
    # $new_func - function pointer ??? (CRYPTO_EX_new *)
    # $dup_func - function pointer ??? (CRYPTO_EX_dup *)
    # $free_func - function pointer ??? (CRYPTO_EX_free *)
    #
    # returns: (integer) ???</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_ex_new_index.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_ex_new_index.html</a></p>

</li>
<li><p>SESSION_get_master_key</p>

<p><b>NOTE:</b> Does not exactly correspond to any low level API function</p>

<p>Returns &#39;master_key&#39; value from SSL_SESSION structure $s</p>

<pre><code>    Net::SSLeay::SESSION_get_master_key($s);
    # $s - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: master key (binary data)</code></pre>

</li>
<li><p>SESSION_set1_master_key</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.1pre1, not in LibreSSL</p>

<p>Sets the master key value associated with a SSL_SESSION.</p>

<pre><code>    my $ret = Net::SSLeay::SESSION_set1_master_key($sess, $key);
    # $sess - value corresponding to OpenSSL SSL_SESSION structure
    # $key - PSK key in packed binary format
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Example:</p>

<pre><code>    my $key = pack(&#39;H*&#39;, &#39;deadbeef&#39;);
    my $ret = Net::SSLeay::SESSION_set1_master_key($sess, $key);</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_set1_master_key.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_set1_master_key.html</a></p>

</li>
<li><p>SESSION_set_master_key</p>

<p>Sets &#39;master_key&#39; value for SSL_SESSION structure $s</p>

<pre><code>    Net::SSLeay::SESSION_set_master_key($s, $key);
    # $s - value corresponding to openssl&#39;s SSL_SESSION structure
    # $key - master key (binary data)
    #
    # returns: no return value</code></pre>

<p>Not available with OpenSSL 1.1 and later. Code that previously used SESSION_set_master_key must now set $secret in the session_secret callback set with SSL_set_session_secret_cb.</p>

</li>
<li><p>SESSION_set_cipher</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.1pre1, not in LibreSSL</p>

<p>Set the ciphersuite associated with an SSL_SESSION.</p>

<pre><code>    my $ret = Net::SSLeay::SESSION_set_cipher($s, $cipher);
    # $s - value corresponding to OpenSSL SSL_SESSION structure
    # $cipher - value corresponding to OpenSSL SSL_CIPHER structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_set_cipher.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_set_cipher.html</a></p>

</li>
<li><p>SESSION_set_protocol_version</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.1pre1, not in LibreSSL</p>

<p>Sets the protocol version associated with an SSL_SESSION.</p>

<pre><code>    my $ret = Net::SSLeay::SESSION_set_protocol_version($s, $version);
    # $s - value corresponding to OpenSSL SSL_SESSION structure
    # $version - integer version constant. For example Net::SSLeay::TLS1_3_VERSION()
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_set_protocol_version.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_set_protocol_version.html</a></p>

</li>
<li><p>SESSION_get0_cipher</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.0 or LibreSSL 3.4.0</p>

<p>Returns the value corresponding to OpenSSL&#39;s SSL_CIPHER associated with an SSL_SESSION.</p>

<pre><code>    my $ret = Net::SSLeay::SESSION_get0_cipher($s);
    # $s - value corresponding to OpenSSL SSL_SESSION structure
    #
    # returns: A value corresponding to OpenSSL&#39;s SSL_CIPHER structure or undef if SSL_CIPHER can&#39;t be determined.</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get0_cipher.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get0_cipher.html</a></p>

</li>
<li><p>SESSION_get_time</p>

<p>Returns the time at which the session s was established. The time is given in seconds since 1.1.1970.</p>

<pre><code>    my $rv = Net::SSLeay::SESSION_get_time($s);
    # $s - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: timestamp (seconds since 1.1.1970)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_time.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_time.html</a></p>

</li>
<li><p>get_time</p>

<p>Technically the same functionality as <a href="./Net::SSLeay.html#SESSION_get_time">&quot;SESSION_get_time&quot;</a>.</p>

<pre><code>    my $rv = Net::SSLeay::get_time($s);</code></pre>

</li>
<li><p>SESSION_get_timeout</p>

<p>Returns the timeout value set for session $s in seconds.</p>

<pre><code>    my $rv = Net::SSLeay::SESSION_get_timeout($s);
    # $s - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: timeout (in seconds)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_time.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_time.html</a></p>

</li>
<li><p>get_timeout</p>

<p>Technically the same functionality as <a href="./Net::SSLeay.html#SESSION_get_timeout">&quot;SESSION_get_timeout&quot;</a>.</p>

<pre><code>    my $rv = Net::SSLeay::get_timeout($s);</code></pre>

</li>
<li><p>SESSION_print</p>

<p><b>NOTE:</b> Does not exactly correspond to any low level API function</p>

<p>Prints session details (e.g. protocol version, cipher, session-id ...) to BIO.</p>

<pre><code>    my $rv = Net::SSLeay::SESSION_print($fp, $ses);
    # $fp - value corresponding to openssl&#39;s BIO structure
    # $ses - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>You have to use necessary BIO functions like this:</p>

<pre><code>    # let us have $ssl corresponding to openssl&#39;s SSL structure
    my $ses = Net::SSLeay::get_session($ssl);
    my $bio = Net::SSLeay::BIO_new(&amp;Net::SSLeay::BIO_s_mem);
    Net::SSLeay::SESSION_print($bio, $ses);
    print Net::SSLeay::BIO_read($bio);</code></pre>

</li>
<li><p>SESSION_print_fp</p>

<p>Prints session details (e.g. protocol version, cipher, session-id ...) to file handle.</p>

<p><b>NOTE</b> With some combinations of Windows, perl, compiler and compiler options, you may see a runtime error &quot;no OPENSSL_Applink&quot;, when calling Net::SSLeay::SESSION_print_fp. See README.Win32 for more details.</p>

<pre><code>    my $rv = Net::SSLeay::SESSION_print_fp($fp, $ses);
    # $fp - perl file handle
    # $ses - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Example:</p>

<pre><code>    # let us have $ssl corresponding to openssl&#39;s SSL structure
    my $ses = Net::SSLeay::get_session($ssl);
    open my $fh, &quot;&gt;&quot;, &quot;output.txt&quot;;
    Net::SSLeay::SESSION_print_fp($fh,$ses);</code></pre>

<p>Similar functionality without Net::SSLeay::SESSION_print_fp</p>

<pre><code>    my $ses = Net::SSLeay::get_session($ssl);
    my $bio = Net::SSLeay::BIO_new_file(&#39;output.txt&#39;, &#39;w&#39;);
    Net::SSLeay::SESSION_print($bio, $ses);</code></pre>

</li>
<li><p>SESSION_set_time</p>

<p>Replaces the creation time of the session s with the chosen value $t (seconds since 1.1.1970).</p>

<pre><code>    my $rv = Net::SSLeay::SESSION_set_time($ses, $t);
    # $ses - value corresponding to openssl&#39;s SSL_SESSION structure
    # $t - time value
    #
    # returns: 1 on success</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_time.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_time.html</a></p>

</li>
<li><p>set_time</p>

<p>Technically the same functionality as <a href="./Net::SSLeay.html#SESSION_set_time">&quot;SESSION_set_time&quot;</a>.</p>

<pre><code>    my $rv = Net::SSLeay::set_time($ses, $t);</code></pre>

</li>
<li><p>SESSION_set_timeout</p>

<p>Sets the timeout value for session s in seconds to $t.</p>

<pre><code>    my $rv = Net::SSLeay::SESSION_set_timeout($s, $t);
    # $s - value corresponding to openssl&#39;s SSL_SESSION structure
    # $t - timeout (in seconds)
    #
    # returns: 1 on success</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_time.html">https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_get_time.html</a></p>

</li>
<li><p>set_timeout</p>

<p>Technically the same functionality as <a href="./Net::SSLeay.html#SESSION_set_timeout">&quot;SESSION_set_timeout&quot;</a>.</p>

<pre><code>    my $rv = Net::SSLeay::set_timeout($ses, $t);</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-SSL_CTX_*-related-functions"><a id="Low11"></a><a id="Low-level-API:-SSL_CTX_--related-functions"></a>Low level API: SSL_CTX_* related functions</h3>

<p><b>NOTE:</b> Please note that the function described in this chapter have &quot;SSL_&quot; part stripped from their original openssl names.</p>

<ul>

<li><p>CTX_add_client_CA</p>

<p>Adds the CA name extracted from $cacert to the list of CAs sent to the client when requesting a client certificate for $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_add_client_CA($ctx, $cacert);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $cacert - value corresponding to openssl&#39;s X509 structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_client_CA_list.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_client_CA_list.html</a></p>

</li>
<li><p>CTX_add_extra_chain_cert</p>

<p>Adds the certificate $x509 to the certificate chain presented together with the certificate. Several certificates can be added one after the other.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_add_extra_chain_cert($ctx, $x509);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $x509 - value corresponding to openssl&#39;s X509 structure
    #
    # returns: 1 on success, check out the error stack to find out the reason for failure otherwise</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_add_extra_chain_cert.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_add_extra_chain_cert.html</a></p>

</li>
<li><p>CTX_add_session</p>

<p>Adds the session $ses to the context $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_add_session($ctx, $ses);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $ses - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_add_session.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_add_session.html</a></p>

</li>
<li><p>CTX_callback_ctrl</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::CTX_callback_ctrl($ctx, $cmd, $fp);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $cmd - (integer) command id
    # $fp - (function pointer) ???
    #
    # returns: ???</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_ctrl.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_ctrl.html</a></p>

</li>
<li><p>CTX_check_private_key</p>

<p>Checks the consistency of a private key with the corresponding certificate loaded into $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_check_private_key($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>CTX_ctrl</p>

<p>Internal handling function for SSL_CTX objects.</p>

<p><b>BEWARE:</b> openssl doc says: This function should never be called directly!</p>

<pre><code>    my $rv = Net::SSLeay::CTX_ctrl($ctx, $cmd, $larg, $parg);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $cmd - (integer) command id
    # $larg - (integer) long ???
    # $parg - (string/pointer) ???
    #
    # returns: (long) result of given command ???

    # valid $cmd values
    # 1 - SSL_CTRL_NEED_TMP_RSA
    # 2 - SSL_CTRL_SET_TMP_RSA
    # 3 - SSL_CTRL_SET_TMP_DH
    # 4 - SSL_CTRL_SET_TMP_ECDH
    # 5 - SSL_CTRL_SET_TMP_RSA_CB
    # 6 - SSL_CTRL_SET_TMP_DH_CB
    # 7 - SSL_CTRL_SET_TMP_ECDH_CB
    # 8 - SSL_CTRL_GET_SESSION_REUSED
    # 9 - SSL_CTRL_GET_CLIENT_CERT_REQUEST
    # 10 - SSL_CTRL_GET_NUM_RENEGOTIATIONS
    # 11 - SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS
    # 12 - SSL_CTRL_GET_TOTAL_RENEGOTIATIONS
    # 13 - SSL_CTRL_GET_FLAGS
    # 14 - SSL_CTRL_EXTRA_CHAIN_CERT
    # 15 - SSL_CTRL_SET_MSG_CALLBACK
    # 16 - SSL_CTRL_SET_MSG_CALLBACK_ARG
    # 17 - SSL_CTRL_SET_MTU
    # 20 - SSL_CTRL_SESS_NUMBER
    # 21 - SSL_CTRL_SESS_CONNECT
    # 22 - SSL_CTRL_SESS_CONNECT_GOOD
    # 23 - SSL_CTRL_SESS_CONNECT_RENEGOTIATE
    # 24 - SSL_CTRL_SESS_ACCEPT
    # 25 - SSL_CTRL_SESS_ACCEPT_GOOD
    # 26 - SSL_CTRL_SESS_ACCEPT_RENEGOTIATE
    # 27 - SSL_CTRL_SESS_HIT
    # 28 - SSL_CTRL_SESS_CB_HIT
    # 29 - SSL_CTRL_SESS_MISSES
    # 30 - SSL_CTRL_SESS_TIMEOUTS
    # 31 - SSL_CTRL_SESS_CACHE_FULL
    # 32 - SSL_CTRL_OPTIONS
    # 33 - SSL_CTRL_MODE
    # 40 - SSL_CTRL_GET_READ_AHEAD
    # 41 - SSL_CTRL_SET_READ_AHEAD
    # 42 - SSL_CTRL_SET_SESS_CACHE_SIZE
    # 43 - SSL_CTRL_GET_SESS_CACHE_SIZE
    # 44 - SSL_CTRL_SET_SESS_CACHE_MODE
    # 45 - SSL_CTRL_GET_SESS_CACHE_MODE
    # 50 - SSL_CTRL_GET_MAX_CERT_LIST
    # 51 - SSL_CTRL_SET_MAX_CERT_LIST
    # 52 - SSL_CTRL_SET_MAX_SEND_FRAGMENT
    # 53 - SSL_CTRL_SET_TLSEXT_SERVERNAME_CB
    # 54 - SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG
    # 55 - SSL_CTRL_SET_TLSEXT_HOSTNAME
    # 56 - SSL_CTRL_SET_TLSEXT_DEBUG_CB
    # 57 - SSL_CTRL_SET_TLSEXT_DEBUG_ARG
    # 58 - SSL_CTRL_GET_TLSEXT_TICKET_KEYS
    # 59 - SSL_CTRL_SET_TLSEXT_TICKET_KEYS
    # 60 - SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT
    # 61 - SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB
    # 62 - SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB_ARG
    # 63 - SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB
    # 64 - SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG
    # 65 - SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE
    # 66 - SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS
    # 67 - SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS
    # 68 - SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS
    # 69 - SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS
    # 70 - SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP
    # 71 - SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP
    # 72 - SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB
    # 73 - DTLS_CTRL_GET_TIMEOUT
    # 74 - DTLS_CTRL_HANDLE_TIMEOUT
    # 75 - DTLS_CTRL_LISTEN
    # 76 - SSL_CTRL_GET_RI_SUPPORT
    # 77 - SSL_CTRL_CLEAR_OPTIONS
    # 78 - SSL_CTRL_CLEAR_MODE

    # 82 - SSL_CTRL_GET_EXTRA_CHAIN_CERTS
    # 83 - SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS

    # 88 - SSL_CTRL_CHAIN
    # 89 - SSL_CTRL_CHAIN_CERT

    # 90 - SSL_CTRL_GET_CURVES
    # 91 - SSL_CTRL_SET_CURVES
    # 92 - SSL_CTRL_SET_CURVES_LIST
    # 93 - SSL_CTRL_GET_SHARED_CURVE
    # 94 - SSL_CTRL_SET_ECDH_AUTO
    # 97 - SSL_CTRL_SET_SIGALGS
    # 98 - SSL_CTRL_SET_SIGALGS_LIST
    # 99 - SSL_CTRL_CERT_FLAGS
    # 100 - SSL_CTRL_CLEAR_CERT_FLAGS
    # 101 - SSL_CTRL_SET_CLIENT_SIGALGS
    # 102 - SSL_CTRL_SET_CLIENT_SIGALGS_LIST
    # 103 - SSL_CTRL_GET_CLIENT_CERT_TYPES
    # 104 - SSL_CTRL_SET_CLIENT_CERT_TYPES
    # 105 - SSL_CTRL_BUILD_CERT_CHAIN
    # 106 - SSL_CTRL_SET_VERIFY_CERT_STORE
    # 107 - SSL_CTRL_SET_CHAIN_CERT_STORE
    # 108 - SSL_CTRL_GET_PEER_SIGNATURE_NID
    # 109 - SSL_CTRL_GET_SERVER_TMP_KEY
    # 110 - SSL_CTRL_GET_RAW_CIPHERLIST
    # 111 - SSL_CTRL_GET_EC_POINT_FORMATS
    # 112 - SSL_CTRL_GET_TLSA_RECORD
    # 113 - SSL_CTRL_SET_TLSA_RECORD
    # 114 - SSL_CTRL_PULL_TLSA_RECORD</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_ctrl.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_ctrl.html</a></p>

</li>
<li><p>CTX_flush_sessions</p>

<p>Causes a run through the session cache of $ctx to remove sessions expired at time $tm.</p>

<pre><code>    Net::SSLeay::CTX_flush_sessions($ctx, $tm);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $tm - specifies the time which should be used for the expiration test (seconds since 1.1.1970)
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_flush_sessions.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_flush_sessions.html</a></p>

</li>
<li><p>CTX_free</p>

<p>Free an allocated SSL_CTX object.</p>

<pre><code>    Net::SSLeay::CTX_free($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_free.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_free.html</a></p>

</li>
<li><p>CTX_get_app_data</p>

<p>Can be used to get application defined value/data.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_get_app_data($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: string/buffer/pointer ???</code></pre>

</li>
<li><p>CTX_set_app_data</p>

<p>Can be used to set some application defined value/data.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_app_data($ctx, $arg);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $arg - (string/buffer/pointer ???) data
    #
    # returns: ???</code></pre>

</li>
<li><p>CTX_get0_param</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.0.2-beta1 or LibreSSL 2.7.0</p>

<p>Returns the current verification parameters.</p>

<pre><code>    my $vpm = Net::SSLeay::CTX_get0_param($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: value corresponding to openssl&#39;s X509_VERIFY_PARAM structure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get0_param.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get0_param.html</a></p>

</li>
<li><p>CTX_get_cert_store</p>

<p>Returns the current certificate verification storage.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_get_cert_store($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: value corresponding to openssl&#39;s X509_STORE structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_cert_store.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_cert_store.html</a></p>

</li>
<li><p>CTX_get_client_CA_list</p>

<p>Returns the list of client CAs explicitly set for $ctx using <a href="./Net::SSLeay.html#CTX_set_client_CA_list">&quot;CTX_set_client_CA_list&quot;</a>.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_get_client_CA_list($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: value corresponding to openssl&#39;s X509_NAME_STACK structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_client_CA_list.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_client_CA_list.html</a></p>

</li>
<li><p>CTX_get_ex_data</p>

<p>Is used to retrieve the information for index $idx from $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_get_ex_data($ssl, $idx);
    # $ssl - value corresponding to openssl&#39;s SSL_CTX structure
    # $idx - (integer) index for application specific data
    #
    # returns: pointer to ???</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_ex_new_index.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_ex_new_index.html</a></p>

</li>
<li><p>CTX_get_ex_new_index</p>

<p>Is used to register a new index for application specific data.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_get_ex_new_index($argl, $argp, $new_func, $dup_func, $free_func);
    # $argl - (long) ???
    # $argp - (pointer) ???
    # $new_func - function pointer ??? (CRYPTO_EX_new *)
    # $dup_func - function pointer ??? (CRYPTO_EX_dup *)
    # $free_func - function pointer ??? (CRYPTO_EX_free *)
    #
    # returns: (integer) ???</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_ex_new_index.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_ex_new_index.html</a></p>

</li>
<li><p>CTX_get_mode</p>

<p>Returns the mode set for ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_get_mode($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: mode (bitmask)

    # to decode the return value (bitmask) use:
    # 0x00000001 corresponds to SSL_MODE_ENABLE_PARTIAL_WRITE
    # 0x00000002 corresponds to SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER
    # 0x00000004 corresponds to SSL_MODE_AUTO_RETRY
    # 0x00000008 corresponds to SSL_MODE_NO_AUTO_CHAIN
    # 0x00000010 corresponds to SSL_MODE_RELEASE_BUFFERS
    # (note: some of the bits might not be supported by older openssl versions)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_mode.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_mode.html</a></p>

</li>
<li><p>CTX_set_mode</p>

<p>Adds the mode set via bitmask in $mode to $ctx. Options already set before are not cleared.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_mode($ctx, $mode);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $mode - mode bitmask
    #
    # returns: the new mode bitmask after adding $mode</code></pre>

<p>For bitmask details see <a href="./Net::SSLeay.html#CTX_get_mode">&quot;CTX_get_mode&quot;</a> (above).</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_mode.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_mode.html</a></p>

</li>
<li><p>CTX_get_options</p>

<p>Returns the options (bitmask) set for $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_get_options($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: options (bitmask)</code></pre>

<p><b>BEWARE:</b> The available constants and their values in bitmask depend on the TLS library. For example, SSL_OP_NO_TLSv1_3 became available much later than SSL_OP_NO_COMPRESS which is already deprecated by some libraries. Also, some previously used option values have been recycled and are now used for newer options. See the list of constants in this document for options Net::SSLeay currently supports.</p>

<p>You are strongly encouraged to <b>check your TLS library</b> if you need to use numeric values directly. The following is a sample of historic values. It may not be correct anymore.</p>

<pre><code>    # to decode the return value (bitmask) use:
    # 0x00000004 corresponds to SSL_OP_LEGACY_SERVER_CONNECT
    # 0x00000800 corresponds to SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
    # 0x00004000 corresponds to SSL_OP_NO_TICKET
    # 0x00010000 corresponds to SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
    # 0x00400000 corresponds to SSL_OP_CIPHER_SERVER_PREFERENCE
    # 0x04000000 corresponds to SSL_OP_NO_TLSv1</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_options.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_options.html</a></p>

</li>
<li><p>CTX_set_options</p>

<p>Adds the options set via bitmask in $options to ctx. Options already set before are not cleared.</p>

<pre><code>    Net::SSLeay::CTX_set_options($ctx, $options);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $options - options bitmask
    #
    # returns: the new options bitmask after adding $options</code></pre>

<p>For bitmask details see <a href="./Net::SSLeay.html#CTX_get_options">&quot;CTX_get_options&quot;</a> (above).</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_options.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_options.html</a></p>

</li>
<li><p>CTX_get_quiet_shutdown</p>

<p>Returns the &#39;quiet shutdown&#39; setting of $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_get_quiet_shutdown($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: (integer) the current setting</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_quiet_shutdown.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_quiet_shutdown.html</a></p>

</li>
<li><p>CTX_get_read_ahead</p>

<pre><code>    my $rv = Net::SSLeay::CTX_get_read_ahead($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: (integer) read_ahead value</code></pre>

</li>
<li><p>CTX_get_session_cache_mode</p>

<p>Returns the currently used cache mode (bitmask).</p>

<pre><code>    my $rv = Net::SSLeay::CTX_get_session_cache_mode($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: mode (bitmask)</code></pre>

<p><b>BEWARE:</b> SESS_CACHE_OFF and other constants are not available in Net-SSLeay-1.82 and before. If the constants are not available, the following values have historically been correct. You are strongly encouraged to <b>check your TLS library</b> for the current values.</p>

<pre><code>    # to decode the return value (bitmask) use:
    # 0x0000 corresponds to SSL_SESS_CACHE_OFF
    # 0x0001 corresponds to SSL_SESS_CACHE_CLIENT
    # 0x0002 corresponds to SSL_SESS_CACHE_SERVER
    # 0x0080 corresponds to SSL_SESS_CACHE_NO_AUTO_CLEAR
    # 0x0100 corresponds to SSL_SESS_CACHE_NO_INTERNAL_LOOKUP
    # 0x0200 corresponds to SSL_SESS_CACHE_NO_INTERNAL_STORE
    # (note: some of the bits might not be supported by older openssl versions)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_session_cache_mode.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_session_cache_mode.html</a></p>

</li>
<li><p>CTX_set_session_cache_mode</p>

<p>Enables/disables session caching by setting the operational mode for $ctx to $mode.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_session_cache_mode($ctx, $mode);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $mode - mode (bitmask)
    #
    # returns: previously set cache mode</code></pre>

<p>For bitmask details see <a href="./Net::SSLeay.html#CTX_get_session_cache_mode">&quot;CTX_get_session_cache_mode&quot;</a> (above).</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_session_cache_mode.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_session_cache_mode.html</a></p>

</li>
<li><p>CTX_get_timeout</p>

<p>Returns the currently set timeout value for $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_get_timeout($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: timeout in seconds</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_timeout.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_timeout.html</a></p>

</li>
<li><p>CTX_get_verify_depth</p>

<p>Returns the verification depth limit currently set in $ctx. If no limit has been explicitly set, -1 is returned and the default value will be used.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_get_verify_depth($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: depth limit currently set in $ctx, -1 if no limit has been explicitly set</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_verify_mode.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_verify_mode.html</a></p>

</li>
<li><p>CTX_get_verify_mode</p>

<p>Returns the verification mode (bitmask) currently set in $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_get_verify_mode($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: mode (bitmask)</code></pre>

<p>For bitmask details see <a href="./Net::SSLeay.html#CTX_set_verify">&quot;CTX_set_verify&quot;</a>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_verify_mode.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_verify_mode.html</a></p>

</li>
<li><p>CTX_set_verify</p>

<p>Sets the verification flags for $ctx to be $mode and specifies the verify_callback function to be used.</p>

<pre><code>    Net::SSLeay::CTX_set_verify($ctx, $mode, $callback);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $mode - mode (bitmask), see OpenSSL manual
    # $callback - [optional] reference to perl callback function
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_verify.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_verify.html</a></p>

</li>
<li><p>CTX_set_post_handshake_auth</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>

<p>Enable the Post-Handshake Authentication extension to be added to the ClientHello such that post-handshake authentication can be requested by the server.</p>

<pre><code>    Net::SSLeay::CTX_set_posthandshake_auth($ctx, $val);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $val - 0 then the extension is not sent, otherwise it is
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_post_handshake_auth.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_post_handshake_auth.html</a></p>

</li>
<li><p>CTX_load_verify_locations</p>

<p>Specifies the locations for $ctx, at which CA certificates for verification purposes are located. The certificates available via $CAfile and $CApath are trusted.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_load_verify_locations($ctx, $CAfile, $CApath);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $CAfile - (string) file of CA certificates in PEM format, the file can contain several CA certificates (or &#39;&#39;)
    # $CApath - (string) directory containing CA certificates in PEM format (or &#39;&#39;)
    #
    # returns: 1 on success, 0 on failure (check the error stack to find out the reason)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html</a></p>

</li>
<li><p>CTX_need_tmp_RSA</p>

<p>Return the result of <code>SSL_CTX_ctrl(ctx,SSL_CTRL_NEED_TMP_RSA,0,NULL)</code></p>

<pre><code>    my $rv = Net::SSLeay::CTX_need_tmp_RSA($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: result of SSL_CTRL_NEED_TMP_RSA command</code></pre>

<p>Not available with OpenSSL 1.1 and later.</p>

</li>
<li><p>CTX_new</p>

<p>The same as <a href="./Net::SSLeay.html#CTX_v23_new">&quot;CTX_v23_new&quot;</a></p>

<pre><code>    my $rv = Net::SSLeay::CTX_new();
    #
    # returns: value corresponding to openssl&#39;s SSL_CTX structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html</a></p>

<p>Not available with OpenSSL 1.1 and later.</p>

</li>
<li><p>CTX_v2_new</p>

<p>Creates a new SSL_CTX object - based on SSLv2_method() - as framework to establish TLS/SSL enabled connections.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_v2_new();
    #
    # returns: value corresponding to openssl&#39;s SSL_CTX structure (0 on failure)</code></pre>

</li>
<li><p>CTX_v23_new</p>

<p>Creates a new SSL_CTX object - based on SSLv23_method() - as framework to establish TLS/SSL enabled connections.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_v23_new();
    #
    # returns: value corresponding to openssl&#39;s SSL_CTX structure (0 on failure)</code></pre>

</li>
<li><p>CTX_v3_new</p>

<p>Creates a new SSL_CTX object - based on SSLv3_method() - as framework to establish TLS/SSL enabled connections.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_v3_new();
    #
    # returns: value corresponding to openssl&#39;s SSL_CTX structure (0 on failure)</code></pre>

</li>
<li><p>CTX_tlsv1_new</p>

<p><b>COMPATIBILITY:</b> Requires OpenSSL or LibreSSL built with support for TLSv1.</p>

<p>Creates a new SSL_CTX object - based on <code>TLSv1_method()</code> - as a framework for establishing connections using TLSv1.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_tlsv1_new();
    #
    # returns: value corresponding to openssl&#39;s SSL_CTX structure (0 on failure)</code></pre>

</li>
<li><p>CTX_tlsv1_1_new</p>

<p><b>COMPATIBILITY:</b> Requires OpenSSL &gt;= 1.0.1 or LibreSSL built with support for TLSv1.1.</p>

<p>Creates a new SSL_CTX object - based on <code>TLSv1_1_method()</code> - as a framework for establishing connections using TLSv1.1.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_tlsv1_1_new();
    #
    # returns: value corresponding to openssl&#39;s SSL_CTX structure (0 on failure)</code></pre>

</li>
<li><p>CTX_tlsv1_2_new</p>

<p><b>COMPATIBILITY:</b> Requires OpenSSL &gt;= 1.0.1 or LibreSSL built with support for TLSv1.2.</p>

<p>Creates a new SSL_CTX object - based on <code>TLSv1_2_method()</code> - as a framework for establishing connections using TLSv1.2.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_tlsv1_2_new();
    #
    # returns: value corresponding to openssl&#39;s SSL_CTX structure (0 on failure)</code></pre>

</li>
<li><p>CTX_new_with_method</p>

<p>Creates a new SSL_CTX object based on $meth method</p>

<pre><code>    my $rv = Net::SSLeay::CTX_new_with_method($meth);
    # $meth - value corresponding to openssl&#39;s SSL_METHOD structure
    #
    # returns: value corresponding to openssl&#39;s SSL_CTX structure (0 on failure)

    # example
    my $ctx = Net::SSLeay::CTX_new_with_method(&amp;Net::SSLeay::TLSv1_method);</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_new.html</a></p>

</li>
<li><p>CTX_set_min_proto_version, CTX_set_max_proto_version, set_min_proto_version and set_max_proto_version,</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.1.0-pre2 or LibreSSL 2.6.0</p>

<p>Set the minimum and maximum supported protocol for $ctx or $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_min_proto_version($ctx, $version);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $version - (integer) constant version value or 0 for automatic lowest or highest value
    #
    # returns: 1 on success, 0 on failure

    # example: allow only TLS 1.2 for a SSL_CTX
    my $rv_min = Net::SSLeay::CTX_set_min_proto_version($ctx, Net::SSLeay::TLS1_2_VERSION());
    my $rv_max = Net::SSLeay::CTX_set_max_proto_version($ctx, Net::SSLeay::TLS1_2_VERSION());

    # example: allow only TLS 1.1 for a SSL
    my $rv_min = Net::SSLeay::set_min_proto_version($ssl, Net::SSLeay::TLS1_1_VERSION());
    my $rv_max = Net::SSLeay::set_max_proto_version($ssl, Net::SSLeay::TLS1_1_VERSION());</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_min_proto_version.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_min_proto_version.html</a></p>

</li>
<li><p>CTX_get_min_proto_version, CTX_get_max_proto_version, get_min_proto_version and get_max_proto_version,</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.1.0g</p>

<p>Get the minimum and maximum supported protocol for $ctx or $ssl.</p>

<pre><code>    my $version = Net::SSLeay::CTX_get_min_proto_version($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: 0 automatic lowest or highest value, configured value otherwise</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_min_proto_version.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_min_proto_version.html</a></p>

</li>
<li><p>CTX_remove_session</p>

<p>Removes the session $ses from the context $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_remove_session($ctx, $ses);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $ses - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_add_session.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_add_session.html</a></p>

</li>
<li><p>CTX_sess_accept</p>

<pre><code>    my $rv = Net::SSLeay::CTX_sess_accept($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: number of started SSL/TLS handshakes in server mode</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html</a></p>

</li>
<li><p>CTX_sess_accept_good</p>

<pre><code>    my $rv = Net::SSLeay::CTX_sess_accept_good($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: number of successfully established SSL/TLS sessions in server mode</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html</a></p>

</li>
<li><p>CTX_sess_accept_renegotiate</p>

<pre><code>    my $rv = Net::SSLeay::CTX_sess_accept_renegotiate($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: number of start renegotiations in server mode</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html</a></p>

</li>
<li><p>CTX_sess_cache_full</p>

<pre><code>    my $rv = Net::SSLeay::CTX_sess_cache_full($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: number of sessions that were removed because the maximum session cache size was exceeded</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html</a></p>

</li>
<li><p>CTX_sess_cb_hits</p>

<pre><code>    my $rv = Net::SSLeay::CTX_sess_cb_hits($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: number of successfully retrieved sessions from the external session cache in server mode</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html</a></p>

</li>
<li><p>CTX_sess_connect</p>

<pre><code>    my $rv = Net::SSLeay::CTX_sess_connect($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: number of started SSL/TLS handshakes in client mode</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html</a></p>

</li>
<li><p>CTX_sess_connect_good</p>

<pre><code>     my $rv = Net::SSLeay::CTX_sess_connect_good($ctx);
     # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
     #
     # returns: number of successfully established SSL/TLS sessions in client mode</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html</a></p>

</li>
<li><p>CTX_sess_connect_renegotiate</p>

<pre><code>     my $rv = Net::SSLeay::CTX_sess_connect_renegotiate($ctx);
     # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
     #
     # returns: number of start renegotiations in client mode</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html</a></p>

</li>
<li><p>CTX_sess_get_cache_size</p>

<p>Returns the currently valid session cache size.</p>

<pre><code>     my $rv = Net::SSLeay::CTX_sess_get_cache_size($ctx);
     # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
     #
     # returns: current size</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_set_cache_size.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_set_cache_size.html</a></p>

</li>
<li><p>CTX_sess_hits</p>

<pre><code>     my $rv = Net::SSLeay::CTX_sess_hits($ctx);
     # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
     #
     # returns: number of successfully reused sessions</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html</a></p>

</li>
<li><p>CTX_sess_misses</p>

<pre><code>     my $rv = Net::SSLeay::CTX_sess_misses($ctx);
     # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
     #
     # returns: number of sessions proposed by clients that were not found in the internal session cache in server mode</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html</a></p>

</li>
<li><p>CTX_sess_number</p>

<pre><code>     my $rv = Net::SSLeay::CTX_sess_number($ctx);
     # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
     #
     # returns: current number of sessions in the internal session cache</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html</a></p>

</li>
<li><p>CTX_sess_set_cache_size</p>

<p>Sets the size of the internal session cache of context $ctx to $size.</p>

<pre><code>     Net::SSLeay::CTX_sess_set_cache_size($ctx, $size);
     # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
     # $size - cache size (0 = unlimited)
     #
     # returns: previously valid size</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_set_cache_size.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_set_cache_size.html</a></p>

</li>
<li><p>CTX_sess_timeouts</p>

<p>Returns the number of sessions proposed by clients and either found in the internal or external session cache in server mode, but that were invalid due to timeout. These sessions are not included in the SSL_CTX_sess_hits count.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_sess_timeouts($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: number of sessions</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_number.html</a></p>

</li>
<li><p>CTX_sess_set_new_cb</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before</p>

<p>Sets the callback function, which is automatically called whenever a new session was negotiated.</p>

<pre><code>    Net::SSLeay::CTX_sess_set_new_cb($ctx, $func);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $func - perl reference to callback function
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_set_new_cb.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_set_new_cb.html</a></p>

</li>
<li><p>CTX_sess_set_remove_cb</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before</p>

<p>Sets the callback function, which is automatically called whenever a session is removed by the SSL engine.</p>

<pre><code>    Net::SSLeay::CTX_sess_set_remove_cb($ctx, $func);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $func - perl reference to callback function
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_set_remove_cb.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_set_remove_cb.html</a></p>

</li>
<li><p>CTX_sessions</p>

<p>Returns a pointer to the lhash databases containing the internal session cache for ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_sessions($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: value corresponding to openssl&#39;s LHASH structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sessions.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sessions.html</a></p>

</li>
<li><p>CTX_set1_param</p>

<p><b>COMPATIBILITY:</b> requires at least OpenSSL 1.0.0-beta3</p>

<p>Applies X509 verification parameters $vpm on $ctx</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set1_param($ctx, $vpm);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $vpm - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get0_param.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get0_param.html</a></p>

</li>
<li><p>CTX_set_cert_store</p>

<p>Sets/replaces the certificate verification storage of $ctx to/with $store.</p>

<pre><code>    Net::SSLeay::CTX_set_cert_store($ctx, $store);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $store - value corresponding to openssl&#39;s X509_STORE structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_cert_store.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_cert_store.html</a></p>

</li>
<li><p>CTX_set_cert_verify_callback</p>

<p>Sets the verification callback function for $ctx. SSL objects that are created from $ctx inherit the setting valid at the time when <code>Net::SSLeay::new($ctx)</code> is called.</p>

<pre><code>    Net::SSLeay::CTX_set_cert_verify_callback($ctx, $func, $data);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $func - perl reference to callback function
    # $data - [optional] data that will be passed to callback function when invoked
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_cert_verify_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_cert_verify_callback.html</a></p>

</li>
<li><p>CTX_set_cipher_list</p>

<p>Sets the list of available ciphers for $ctx using the control string $str. The list of ciphers is inherited by all ssl objects created from $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_cipher_list($s, $str);
    # $s - value corresponding to openssl&#39;s SSL_CTX structure
    # $str - (string) cipher list e.g. &#39;3DES:+RSA&#39;
    #
    # returns: 1 if any cipher could be selected and 0 on complete failure</code></pre>

<p>The format of $str is described in <a href="https://www.openssl.org/docs/manmaster/man1/openssl-ciphers.html">https://www.openssl.org/docs/manmaster/man1/openssl-ciphers.html</a></p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_cipher_list.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_cipher_list.html</a></p>

</li>
<li><p>CTX_set_ciphersuites</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1 or at least LibreSSL 3.4.0 and Net-SSLeay-1.94</p>

<p>Configure the available TLSv1.3 ciphersuites.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_ciphersuites($ctx, $str);
    # $ctx  - value corresponding to openssl&#39;s SSL_CTX structure
    # $str  - colon (&quot;:&quot;) separated list of TLSv1.3 ciphersuite names in order of preference
    #
    # returns: (integer) 1 if the requested ciphersuite list was configured, and 0 otherwise</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_ciphersuites.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_ciphersuites.html</a></p>

</li>
<li><p>CTX_set_client_CA_list</p>

<p>Sets the list of CAs sent to the client when requesting a client certificate for $ctx.</p>

<pre><code>    Net::SSLeay::CTX_set_client_CA_list($ctx, $list);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $list - value corresponding to openssl&#39;s X509_NAME_STACK structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_client_CA_list.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_client_CA_list.html</a></p>

</li>
<li><p>CTX_set_default_passwd_cb</p>

<p>Sets the default password callback called when loading/storing a PEM certificate with encryption.</p>

<pre><code>    Net::SSLeay::CTX_set_default_passwd_cb($ctx, $func);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $func - perl reference to callback function
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_default_passwd_cb.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_default_passwd_cb.html</a></p>

</li>
<li><p>CTX_set_default_passwd_cb_userdata</p>

<p>Sets a pointer to userdata which will be provided to the password callback on invocation.</p>

<pre><code>    Net::SSLeay::CTX_set_default_passwd_cb_userdata($ctx, $userdata);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $userdata - data that will be passed to callback function when invoked
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_default_passwd_cb.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_default_passwd_cb.html</a></p>

</li>
<li><p>CTX_set_default_verify_paths</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_default_verify_paths($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>CTX_set_ex_data</p>

<p>Is used to store application data at $data for $idx into the $ctx object.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_ex_data($ssl, $idx, $data);
    # $ssl - value corresponding to openssl&#39;s SSL_CTX structure
    # $idx - (integer) ???
    # $data - (pointer) ???
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_ex_new_index.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_ex_new_index.html</a></p>

</li>
<li><p>CTX_set_purpose</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_purpose($s, $purpose);
    # $s - value corresponding to openssl&#39;s SSL_CTX structure
    # $purpose - (integer) purpose identifier
    #
    # returns: 1 on success, 0 on failure

    # available purpose identifier
    # 1 - X509_PURPOSE_SSL_CLIENT
    # 2 - X509_PURPOSE_SSL_SERVER
    # 3 - X509_PURPOSE_NS_SSL_SERVER
    # 4 - X509_PURPOSE_SMIME_SIGN
    # 5 - X509_PURPOSE_SMIME_ENCRYPT
    # 6 - X509_PURPOSE_CRL_SIGN
    # 7 - X509_PURPOSE_ANY
    # 8 - X509_PURPOSE_OCSP_HELPER
    # 9 - X509_PURPOSE_TIMESTAMP_SIGN

    # or use corresponding constants
    $purpose = &amp;Net::SSLeay::X509_PURPOSE_SSL_CLIENT;
    # ...
    $purpose = &amp;Net::SSLeay::X509_PURPOSE_TIMESTAMP_SIGN;</code></pre>

</li>
<li><p>CTX_set_quiet_shutdown</p>

<p>Sets the &#39;quiet shutdown&#39; flag for $ctx to be mode. SSL objects created from $ctx inherit the mode valid at the time <code>Net::SSLeay::new($ctx)</code> is called.</p>

<pre><code>    Net::SSLeay::CTX_set_quiet_shutdown($ctx, $mode);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $mode - 0 or 1
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_quiet_shutdown.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_quiet_shutdown.html</a></p>

</li>
<li><p>CTX_set_read_ahead</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_read_ahead($ctx, $val);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $val - read_ahead value to be set
    #
    # returns: the original read_ahead value</code></pre>

</li>
<li><p>CTX_set_session_id_context</p>

<p>Sets the context $sid_ctx of length $sid_ctx_len within which a session can be reused for the $ctx object.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_session_id_context($ctx, $sid_ctx, $sid_ctx_len);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $sid_ctx - data buffer
    # $sid_ctx_len - length of data in $sid_ctx
    #
    # returns: 1 on success, 0 on failure (the error is logged to the error stack)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_session_id_context.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_session_id_context.html</a></p>

</li>
<li><p>CTX_set_ssl_version</p>

<p>Sets a new default TLS/SSL method for SSL objects newly created from this $ctx. SSL objects already created with <code>Net::SSLeay::new($ctx)</code> are not affected, except when <code>Net::SSLeay:clear($ssl)</code> is being called.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_ssl_version($ctx, $meth);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $meth - value corresponding to openssl&#39;s SSL_METHOD structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_ssl_version.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_ssl_version.html</a></p>

</li>
<li><p>CTX_set_timeout</p>

<p>Sets the timeout for newly created sessions for $ctx to $t. The timeout value $t must be given in seconds.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_timeout($ctx, $t);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $t - timeout in seconds
    #
    # returns: previously set timeout value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_timeout.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_timeout.html</a></p>

</li>
<li><p>CTX_set_tmp_dh</p>

<p>Sets DH parameters to be used to be $dh. The key is inherited by all ssl objects created from $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_tmp_dh($ctx, $dh);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $dh - value corresponding to openssl&#39;s DH structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_tmp_dh_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_tmp_dh_callback.html</a></p>

</li>
<li><p>CTX_set_tmp_dh_callback</p>

<p>Sets the callback function for $ctx to be used when a DH parameters are required to $tmp_dh_callback.</p>

<pre><code>    Net::SSLeay::CTX_set_tmp_dh_callback($ctx, $tmp_dh_callback);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # tmp_dh_callback - (function pointer) ???
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_tmp_dh_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_tmp_dh_callback.html</a></p>

</li>
<li><p>CTX_set_tmp_rsa</p>

<p>Sets the temporary/ephemeral RSA key to be used to be $rsa.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_tmp_rsa($ctx, $rsa);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $rsa - value corresponding to openssl&#39;s RSA structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/man1.0.2/man3/SSL_CTX_set_tmp_rsa_callback.html">https://www.openssl.org/docs/man1.0.2/man3/SSL_CTX_set_tmp_rsa_callback.html</a></p>

<p>Not available with OpenSSL 1.1 and later.</p>

</li>
<li><p>CTX_set_tmp_rsa_callback</p>

<p>Sets the callback function for ctx to be used when a temporary/ephemeral RSA key is required to $tmp_rsa_callback.</p>

<p>??? (does this function really work?)</p>

<pre><code>    Net::SSLeay::CTX_set_tmp_rsa_callback($ctx, $tmp_rsa_callback);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $tmp_rsa_callback - (function pointer) ???
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/man1.0.2/man3/SSL_CTX_set_tmp_rsa_callback.html">https://www.openssl.org/docs/man1.0.2/man3/SSL_CTX_set_tmp_rsa_callback.html</a></p>

<p>Not available with OpenSSL 1.1 and later.</p>

</li>
<li><p>CTX_set_trust</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_trust($s, $trust);
    # $s - value corresponding to openssl&#39;s SSL_CTX structure
    # $trust - (integer) trust identifier
    #
    # returns: the original value

    # available trust identifiers
    # 1 - X509_TRUST_COMPAT
    # 2 - X509_TRUST_SSL_CLIENT
    # 3 - X509_TRUST_SSL_SERVER
    # 4 - X509_TRUST_EMAIL
    # 5 - X509_TRUST_OBJECT_SIGN
    # 6 - X509_TRUST_OCSP_SIGN
    # 7 - X509_TRUST_OCSP_REQUEST
    # 8 - X509_TRUST_TSA

    # or use corresponding constants
    $trust = &amp;Net::SSLeay::X509_TRUST_COMPAT;
    # ...
    $trust = &amp;Net::SSLeay::X509_TRUST_TSA;</code></pre>

</li>
<li><p>CTX_set_verify_depth</p>

<p>Sets the maximum depth for the certificate chain verification that shall be allowed for ctx.</p>

<pre><code>    Net::SSLeay::CTX_set_verify_depth($ctx, $depth);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $depth - max. depth
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_verify.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_verify.html</a></p>

</li>
<li><p>CTX_use_PKCS12_file</p>

<p>Adds the certificate and private key from PKCS12 file $p12filename to $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_use_PKCS12_file($ctx, $p12filename, $password);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $p12filename - (string) filename
    # $password - (string) password to decrypt private key
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p><b>NOTE</b> Net::SSLeay 1.92_01 and earlier: With some combinations of Windows, perl, compiler and compiler options, you may see a runtime error &quot;no OPENSSL_Applink&quot;, when calling Net::SSLeay::CTX_use_PKCS12_file. See README.Win32 for more details.</p>

</li>
<li><p>CTX_use_PrivateKey</p>

<p>Adds the private key $pkey to $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_use_PrivateKey($ctx, $pkey);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $pkey - value corresponding to openssl&#39;s EVP_PKEY structure
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>CTX_use_PrivateKey_file</p>

<p>Adds the first private key found in $file to $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_use_PrivateKey_file($ctx, $file, $type);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $file - (string) file name
    # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>CTX_use_RSAPrivateKey</p>

<p>Adds the RSA private key $rsa to $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_use_RSAPrivateKey($ctx, $rsa);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $rsa - value corresponding to openssl&#39;s RSA structure
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>CTX_use_RSAPrivateKey_file</p>

<p>Adds the first RSA private key found in $file to $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_use_RSAPrivateKey_file($ctx, $file, $type);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $file - (string) file name
    # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

</li>
<li><p>CTX_use_certificate</p>

<p>Loads the certificate $x into $ctx</p>

<pre><code>    my $rv = Net::SSLeay::CTX_use_certificate($ctx, $x);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>CTX_use_certificate_chain_file</p>

<p>Loads a certificate chain from $file into $ctx. The certificates must be in PEM format and must be sorted starting with the subject&#39;s certificate (actual client or server certificate), followed by intermediate CA certificates if applicable, and ending at the highest level (root) CA.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_use_certificate_chain_file($ctx, $file);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $file - (string) file name
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>CTX_use_certificate_file</p>

<p>Loads the first certificate stored in $file into $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_use_certificate_file($ctx, $file, $type);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $file - (string) file name
    # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>CTX_get_security_level</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0 or at least LibreSSL 3.6.0 and Net-SSLeay-1.94</p>

<p>Returns the security level associated with $ctx.</p>

<pre><code>    my $level = Net::SSLeay::CTX_get_security_level($ctx);
    # $ctx   - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: (integer) current security level</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_security_level.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_security_level.html</a></p>

</li>
<li><p>CTX_set_security_level</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0 or at least LibreSSL 3.6.0 and Net-SSLeay-1.94</p>

<p>Sets the security level associated with $ctx to $level.</p>

<pre><code>    Net::SSLeay::CTX_set_security_level($ctx, $level);
    # $ssl   - value corresponding to openssl&#39;s SSL_CTX structure
    # $level - new security level
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_security_level.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_security_level.html</a></p>

</li>
<li><p>CTX_set_num_tickets</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1 or at least LibreSSL 3.5.0 and Net-SSLeay-1.94</p>

<p>Set number of TLSv1.3 session tickets that will be sent to a client.</p>

<pre><code>    my $rv = Net::SSLeay::CTX_set_num_tickets($ctx, $number_of_tickets);
    # $ctx  - value corresponding to openssl&#39;s SSL_CTX structure
    # $number_of_tickets - number of tickets to send
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Set to zero if you do not no want to support a session resumption.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_num_tickets.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_num_tickets.html</a></p>

</li>
<li><p>CTX_get_num_tickets</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1 or at least LibreSSL 3.5.0 and Net-SSLeay-1.94</p>

<p>Get number of TLSv1.3 session tickets that will be sent to a client.</p>

<pre><code>    my $number_of_tickets = Net::SSLeay::CTX_get_num_tickets($ctx);
    # $ctx  - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: (integer) number of tickets to send</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_num_tickets.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_num_tickets.html</a></p>

</li>
<li><p>CTX_set_keylog_callback</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.90 and before; requires at least OpenSSL 1.1.1pre1 or at least LibreSSL 3.5.0 and Net-SSLeay-1.94</p>

<p>Set the TLS key logging callback.</p>

<pre><code>    Net::SSLeay::CTX_set_keylog_callback($ctx, $cb);
    # $ctx  - value corresponding to openssl&#39;s SSL_CTX structure
    # $cb - reference to a perl callback function
    #
    # returns: no return value</code></pre>

<p>The callback function will be called like this:</p>

<pre><code>    keylog_cb_func($ssl, $line);
    # $ssl - value corresponding to OpenSSL&#39;s SSL object associated with the connection
    # $line - a string containing the key material in the format used by NSS for its SSLKEYLOGFILE debugging output</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_keylog_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_keylog_callback.html</a></p>

</li>
<li><p>CTX_get_keylog_callback</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.90 and before; requires at least OpenSSL 1.1.1pre1 or at least LibreSSL 3.5.0 and Net-SSLeay-1.94</p>

<p>Retrieve the previously set TLS key logging callback.</p>

<pre><code>    my $cb = Net::SSLeay::CTX_get_keylog_callback($ctx);
    # $ctx  - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: a reference to a perl callback function or undef if no callback is set</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_keylog_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_keylog_callback.html</a></p>

</li>
<li><p>CTX_set_client_hello_cb</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.1pre1, not in LibreSSL</p>

<p>Set a callback function called during the early stages of ClientHello processing on the server. When callback is undef, the existing callback is disabled.</p>

<pre><code>    Net::SSLeay::CTX_set_client_hello_cb($ctx, $f, [$arg]);
    # $ctx  - value corresponding to openssl&#39;s SSL_CTX structure
    # $f - sub { my ($ssl, $arg) = @_; ...; return ($ret, $al); }
    # $arg - optional data passed to the callback function when invoked
    #
    # returns: no return value</code></pre>

<p>The callback function will be called like this:</p>

<pre><code>    client_hello_cb_func($ssl, $arg);
    # $ssl - value corresponding to OpenSSL&#39;s SSL object associated with the connection
    # $arg - data to callback
    #
    # An alert code must be returned with SSL_CLIENT_HELLO_FAILURE.
    # Return value examples:
    # ok: return Net::SSLeay::CLIENT_HELLO_SUCCESS();
    # suspend: return Net::SSLeay::CLIENT_HELLO_RETRY();
    # error: return (Net::SSLeay::CLIENT_HELLO_FAILURE(), Net::SSLeay::AD_NO_APPLICATION_PROTOCOL());</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_client_hello_cb.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_client_hello_cb.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-SSL_*-related-functions"><a id="Low12"></a><a id="Low-level-API:-SSL_--related-functions"></a>Low level API: SSL_* related functions</h3>

<p><b>NOTE:</b> Please note that the function described in this chapter have &quot;SSL_&quot; part stripped from their original openssl names.</p>

<ul>

<li><p>new</p>

<p>Creates a new SSL structure which is needed to hold the data for a TLS/SSL connection. The new structure inherits the settings of the underlying context $ctx: connection method (SSLv2/v3/TLSv1), options, verification settings, timeout settings.</p>

<pre><code>    my $rv = Net::SSLeay::new($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: value corresponding to openssl&#39;s SSL structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_new.html">https://www.openssl.org/docs/manmaster/man3/SSL_new.html</a></p>

</li>
<li><p>accept</p>

<p>Waits for a TLS/SSL client to initiate the TLS/SSL handshake. The communication channel must already have been set and assigned to the ssl by setting an underlying BIO.</p>

<pre><code>    my $rv = Net::SSLeay::accept($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: 1 = success, 0 = handshake not successful, &lt;0 = fatal error during handshake</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_accept.html">https://www.openssl.org/docs/manmaster/man3/SSL_accept.html</a></p>

</li>
<li><p>add_client_CA</p>

<p>Adds the CA name extracted from cacert to the list of CAs sent to the client when requesting a client certificate for the chosen ssl, overriding the setting valid for ssl&#39;s SSL_CTX object.</p>

<pre><code>    my $rv = Net::SSLeay::add_client_CA($ssl, $x);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_client_CA_list.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_client_CA_list.html</a></p>

</li>
<li><p>callback_ctrl</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::callback_ctrl($ssl, $cmd, $fp);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $cmd - (integer) command id
    # $fp - (function pointer) ???
    #
    # returns: ???</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_ctrl.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_ctrl.html</a></p>

</li>
<li><p>check_private_key</p>

<p>Checks the consistency of a private key with the corresponding certificate loaded into $ssl</p>

<pre><code>    my $rv = Net::SSLeay::check_private_key($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>clear</p>

<p>Reset SSL object to allow another connection.</p>

<pre><code>    Net::SSLeay::clear($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_clear.html">https://www.openssl.org/docs/manmaster/man3/SSL_clear.html</a></p>

</li>
<li><p>connect</p>

<p>Initiate the TLS/SSL handshake with an TLS/SSL server.</p>

<pre><code>    my $rv = Net::SSLeay::connect($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: 1 = success, 0 = handshake not successful, &lt;0 = fatal error during handshake</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_connect.html">https://www.openssl.org/docs/manmaster/man3/SSL_connect.html</a></p>

</li>
<li><p>copy_session_id</p>

<p>Copies the session structure fro $from to $to (+ also the private key and certificate associated with $from).</p>

<pre><code>    Net::SSLeay::copy_session_id($to, $from);
    # $to - value corresponding to openssl&#39;s SSL structure
    # $from - value corresponding to openssl&#39;s SSL structure
    #
    # returns: no return value</code></pre>

</li>
<li><p>ctrl</p>

<p>Internal handling function for SSL objects.</p>

<p><b>BEWARE:</b> openssl doc says: This function should never be called directly!</p>

<pre><code>    my $rv = Net::SSLeay::ctrl($ssl, $cmd, $larg, $parg);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $cmd - (integer) command id
    # $larg - (integer) long ???
    # $parg - (string/pointer) ???
    #
    # returns: (long) result of given command ???</code></pre>

<p>For more details about valid $cmd values check <a href="./Net::SSLeay.html#CTX_ctrl">&quot;CTX_ctrl&quot;</a>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_ctrl.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_ctrl.html</a></p>

</li>
<li><p>do_handshake</p>

<p>Will wait for a SSL/TLS handshake to take place. If the connection is in client mode, the handshake will be started. The handshake routines may have to be explicitly set in advance using either SSL_set_connect_state or SSL_set_accept_state(3).</p>

<pre><code>    my $rv = Net::SSLeay::do_handshake($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: 1 = success, 0 = handshake not successful, &lt;0 = fatal error during handshake</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_do_handshake.html">https://www.openssl.org/docs/manmaster/man3/SSL_do_handshake.html</a></p>

</li>
<li><p>dup</p>

<p>Returns a duplicate of $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::dup($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: value corresponding to openssl&#39;s SSL structure (0 on failure)</code></pre>

</li>
<li><p>free</p>

<p>Free an allocated SSL structure.</p>

<pre><code>    Net::SSLeay::free($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_free.html">https://www.openssl.org/docs/manmaster/man3/SSL_free.html</a></p>

</li>
<li><p>get0_param</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.0.2-beta1 or LibreSSL 2.7.0</p>

<p>Returns the current verification parameters.</p>

<pre><code>    my $vpm = Net::SSLeay::get0_param($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: value corresponding to openssl&#39;s X509_VERIFY_PARAM structure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get0_param.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get0_param.html</a></p>

</li>
<li><p>get_SSL_CTX</p>

<p>Returns a pointer to the SSL_CTX object, from which $ssl was created with Net::SSLeay::new.</p>

<pre><code>    my $rv = Net::SSLeay::get_SSL_CTX($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: value corresponding to openssl&#39;s SSL_CTX structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_SSL_CTX.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_SSL_CTX.html</a></p>

</li>
<li><p>set_SSL_CTX</p>

<p><b>COMPATIBILITY:</b> requires at least OpenSSL 0.9.8f</p>

<p>Sets the SSL_CTX the corresponds to an SSL session.</p>

<pre><code>    my $the_ssl_ctx = Net::SSLeay::set_SSL_CTX($ssl, $ssl_ctx);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $ssl_ctx - Change the ssl object to the given ssl_ctx
    #
    # returns - the ssl_ctx</code></pre>

</li>
<li><p>get_app_data</p>

<p>Can be used to get application defined value/data.</p>

<pre><code>    my $rv = Net::SSLeay::get_app_data($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: string/buffer/pointer ???</code></pre>

</li>
<li><p>set_app_data</p>

<p>Can be used to set some application defined value/data.</p>

<pre><code>    my $rv = Net::SSLeay::set_app_data($ssl, $arg);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $arg - (string/buffer/pointer ???) data
    #
    # returns: ???</code></pre>

</li>
<li><p>get_certificate</p>

<p>Gets X509 certificate from an established SSL connection.</p>

<pre><code>    my $rv = Net::SSLeay::get_certificate($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: value corresponding to openssl&#39;s X509 structure (0 on failure)</code></pre>

</li>
<li><p>get_cipher</p>

<p>Obtains the name of the currently used cipher.</p>

<pre><code>    my $rv = Net::SSLeay::get_cipher($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (string) cipher name e.g. &#39;DHE-RSA-AES256-SHA&#39; or &#39;&#39;, when no session has been established.</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_current_cipher.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_current_cipher.html</a></p>

</li>
<li><p>get_cipher_bits</p>

<p>Obtain the number of secret/algorithm bits used.</p>

<pre><code>    my $rv = Net::SSLeay::get_cipher_bits($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: number of secret bits used by current cipher</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_current_cipher.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_current_cipher.html</a> and <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CIPHER_get_name.html">https://www.openssl.org/docs/manmaster/man3/SSL_CIPHER_get_name.html</a></p>

</li>
<li><p>get_ciphers</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.88 and before</p>

<p>Returns a list of SSL_CIPHER structures available for $ssl sorted by preference</p>

<pre><code>    my @ciphers = Net::SSLeay::get_ciphers($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (list) SSL_CIPHER structures or nothing when $ssl is undefined or no ciphers are available</code></pre>

<p>Example:</p>

<pre><code>    my @ciphers = Net::SSLeay::get_ciphers($ssl);
    foreach my $c (@ciphers) {
        print Net::SSLeay::CIPHER_get_name($c) . &quot;\n&quot;;
    }</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_ciphers.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_ciphers.html</a></p>

</li>
<li><p>get_cipher_list</p>

<p>Returns the name (string) of the SSL_CIPHER listed for $ssl with priority $n.</p>

<pre><code>    my $rv = Net::SSLeay::get_cipher_list($ssl, $n);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $n - (integer) priority
    #
    # returns: (string) cipher name e.g. &#39;EDH-DSS-DES-CBC3-SHA&#39; or undef in case of error</code></pre>

<p>Call Net::SSLeay::get_cipher_list with priority starting from 0 to obtain the sorted list of available ciphers, until undef is returned:</p>

<pre><code>    my $priority = 0;
    while (my $c = Net::SSLeay::get_cipher_list($ssl, $priority)) {
        print &quot;cipher[$priority] = $c\n&quot;;
        $priority++;
    }</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_cipher_list.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_cipher_list.html</a></p>

</li>
<li><p>get_client_CA_list</p>

<p>Returns the list of client CAs explicitly set for $ssl using <code>Net::SSLeay::set_client_CA_list</code> or $ssl&#39;s SSL_CTX object with <code>Net::SSLeay::CTX_set_client_CA_list</code>, when in server mode.</p>

<p>In client mode, returns the list of client CAs sent from the server, if any.</p>

<pre><code>    my $rv = Net::SSLeay::get_client_CA_list($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: value corresponding to openssl&#39;s STACK_OF(X509_NAME) structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_client_CA_list.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_client_CA_list.html</a></p>

</li>
<li><p>get_current_cipher</p>

<p>Returns the cipher actually used.</p>

<pre><code>    my $rv = Net::SSLeay::get_current_cipher($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: value corresponding to openssl&#39;s SSL_CIPHER structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_current_cipher.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_current_cipher.html</a></p>

</li>
<li><p>get_default_timeout</p>

<p>Returns the default timeout value assigned to SSL_SESSION objects negotiated for the protocol valid for $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_default_timeout($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (long) timeout in seconds</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_default_timeout.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_default_timeout.html</a></p>

</li>
<li><p>get_error</p>

<p>Returns a result code for a preceding call to <code>connect</code>, <code>accept</code>, <code>do_handshake</code>, <code>read</code>, <code>peek</code> or <code>write</code> on $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_error($ssl, $ret);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $ret - return value of preceding TLS/SSL I/O operation
    #
    # returns: result code, which is one of the following values:
    #  0 - SSL_ERROR_NONE
    #  1 - SSL_ERROR_SSL
    #  2 - SSL_ERROR_WANT_READ
    #  3 - SSL_ERROR_WANT_WRITE
    #  4 - SSL_ERROR_WANT_X509_LOOKUP
    #  5 - SSL_ERROR_SYSCALL
    #  6 - SSL_ERROR_ZERO_RETURN
    #  7 - SSL_ERROR_WANT_CONNECT
    #  8 - SSL_ERROR_WANT_ACCEPT</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_error.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_error.html</a></p>

</li>
<li><p>get_ex_data</p>

<p>Is used to retrieve the information for $idx from $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_ex_data($ssl, $idx);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $idx - (integer) index for application specific data
    #
    # returns: pointer to ???</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_ex_new_index.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_ex_new_index.html</a></p>

</li>
<li><p>set_ex_data</p>

<p>Is used to store application data at $data for $idx into the $ssl object.</p>

<pre><code>    my $rv = Net::SSLeay::set_ex_data($ssl, $idx, $data);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $idx - (integer) ???
    # $data - (pointer) ???
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_ex_new_index.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_ex_new_index.html</a></p>

</li>
<li><p>get_ex_new_index</p>

<p>Is used to register a new index for application specific data.</p>

<pre><code>    my $rv = Net::SSLeay::get_ex_new_index($argl, $argp, $new_func, $dup_func, $free_func);
    # $argl - (long) ???
    # $argp - (pointer) ???
    # $new_func - function pointer ??? (CRYPTO_EX_new *)
    # $dup_func - function pointer ??? (CRYPTO_EX_dup *)
    # $free_func - function pointer ??? (CRYPTO_EX_free *)
    #
    # returns: (integer) ???</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_ex_new_index.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_ex_new_index.html</a></p>

</li>
<li><p>get_fd</p>

<p>Returns the file descriptor which is linked to $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_fd($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: file descriptor (&gt;=0) or -1 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_fd.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_fd.html</a></p>

</li>
<li><p>get_finished</p>

<p>Obtains the latest &#39;Finished&#39; message sent to the peer. Return value is zero if there&#39;s been no Finished message yet. Default count is 2*EVP_MAX_MD_SIZE that is long enough for all possible Finish messages. If you supply a non-default count, the resulting return value may be longer than returned buf&#39;s length.</p>

<pre><code>    my $rv = Net::SSLeay::get_finished($ssl, $buf, $count);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $buf - buffer where the returned data will be stored
    # $count - [optional] max size of return data - default is 2*EVP_MAX_MD_SIZE
    #
    # returns: length of latest Finished message</code></pre>

</li>
<li><p>get_peer_finished</p>

<p>Obtains the latest &#39;Finished&#39; message expected from the peer. Parameters and return value are similar to get_finished().</p>

<pre><code>    my $rv = Net::SSLeay::get_peer_finished($ssl, $buf, $count);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $buf - buffer where the returned data will be stored
    # $count - [optional] max size of return data - default is 2*EVP_MAX_MD_SIZE
    #
    # returns: length of latest Finished message</code></pre>

</li>
<li><p>get_keyblock_size</p>

<p>Gets the length of the TLS keyblock. Look for &#39;key_block&#39; in TLS 1.2 and earlier TLS RFCs. Consider using TLS exporter interface defined by RFC 5705 instead of creating your own keying material exporter.</p>

<p><b>NOTE:</b> Does not exactly correspond to any low level API function. Intended for EAP-FAST.</p>

<pre><code>    my $rv = Net::SSLeay::get_keyblock_size($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: keyblock size, -1 on error</code></pre>

</li>
<li><p>get_mode</p>

<p>Returns the mode (bitmask) set for $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_mode($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: mode (bitmask)</code></pre>

<p>To decode the return value (bitmask) see documentation for <a href="./Net::SSLeay.html#CTX_get_mode">&quot;CTX_get_mode&quot;</a>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_mode.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_mode.html</a></p>

</li>
<li><p>set_mode</p>

<p>Adds the mode set via bitmask in $mode to $ssl. Options already set before are not cleared.</p>

<pre><code>    my $rv = Net::SSLeay::set_mode($ssl, $mode);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $mode - mode (bitmask)
    #
    # returns: the new mode bitmask after adding $mode</code></pre>

<p>For $mode bitmask details see <a href="./Net::SSLeay.html#CTX_get_mode">&quot;CTX_get_mode&quot;</a>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_mode.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_mode.html</a></p>

</li>
<li><p>get_options</p>

<p>Returns the options (bitmask) set for $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_options($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: options (bitmask)</code></pre>

<p>To decode the return value (bitmask) see documentation for <a href="./Net::SSLeay.html#CTX_get_options">&quot;CTX_get_options&quot;</a>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_options.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_options.html</a></p>

</li>
<li><p>set_options</p>

<p>Adds the options set via bitmask in $options to $ssl. Options already set before are not cleared!</p>

<pre><code>    Net::SSLeay::set_options($ssl, $options);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $options - options (bitmask)
    #
    # returns: the new options bitmask after adding $options</code></pre>

<p>For $options bitmask details see <a href="./Net::SSLeay.html#CTX_get_options">&quot;CTX_get_options&quot;</a>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_options.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_options.html</a></p>

</li>
<li><p>get_peer_certificate</p>

<p>Get the X509 certificate of the peer.</p>

<pre><code>    my $rv = Net::SSLeay::get_peer_certificate($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: value corresponding to openssl&#39;s X509 structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_peer_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_peer_certificate.html</a></p>

</li>
<li><p>get_peer_cert_chain</p>

<p>Get the certificate chain of the peer as an array of X509 structures.</p>

<pre><code>    my @chain = Net::SSLeay::get_peer_cert_chain($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: list of X509 structures</code></pre>

<p>Example:</p>

<pre><code>    my @chain = Net::SSLeay::get_peer_cert_chain($ssl);
    foreach my $x509 (@chain) {
        print Net::SSLeay::X509_NAME_oneline(Net::SSLeay::X509_get_subject_name($cert)) . &quot;\n&quot;;
    }</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_peer_cert_chain.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_peer_cert_chain.html</a></p>

</li>
<li><p>get_quiet_shutdown</p>

<p>Returns the &#39;quiet shutdown&#39; setting of ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_quiet_shutdown($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (integer) current &#39;quiet shutdown&#39; value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_quiet_shutdown.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_quiet_shutdown.html</a></p>

</li>
<li><p>get_rbio</p>

<p>Get &#39;read&#39; BIO linked to an SSL object $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_rbio($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: value corresponding to openssl&#39;s BIO structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_rbio.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_rbio.html</a></p>

</li>
<li><p>get_read_ahead</p>

<pre><code>    my $rv = Net::SSLeay::get_read_ahead($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (integer) read_ahead value</code></pre>

</li>
<li><p>set_read_ahead</p>

<pre><code>    Net::SSLeay::set_read_ahead($ssl, $val);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $val - read_ahead value to be set
    #
    # returns: the original read_ahead value</code></pre>

</li>
<li><p>get_security_level</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0 or at least LibreSSL 3.6.0 and Net-SSLeay-1.94</p>

<p>Returns the security level associated with $ssl.</p>

<pre><code>    my $level = Net::SSLeay::get_security_level($ssl);
    # $ssl   - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (integer) current security level</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_security_level.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_security_level.html</a></p>

</li>
<li><p>set_security_level</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0 or at least LibreSSL 3.6.0 and Net-SSLeay-1.94</p>

<p>Sets the security level associated with $ssl to $level.</p>

<pre><code>    Net::SSLeay::set_security_level($ssl, $level);
    # $ssl   - value corresponding to openssl&#39;s SSL structure
    # $level - new security level
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_security_level.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_security_level.html</a></p>

</li>
<li><p>set_num_tickets</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1 or at least LibreSSL 3.5.0 and Net-SSLeay-1.94</p>

<p>Set number of TLSv1.3 session tickets that will be sent to a client.</p>

<pre><code>    my $rv = Net::SSLeay::set_num_tickets($ssl, $number_of_tickets);
    # $ssl  - value corresponding to openssl&#39;s SSL structure
    # $number_of_tickets - number of tickets to send
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Set to zero if you do not no want to support a session resumption.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_num_tickets.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_num_tickets.html</a></p>

</li>
<li><p>get_num_tickets</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1 or at least LibreSSL 3.5.0 and Net-SSLeay-1.94</p>

<p>Get number of TLSv1.3 session tickets that will be sent to a client.</p>

<pre><code>    my $number_of_tickets = Net::SSLeay::get_num_tickets($ctx);
    # $ctx  - value corresponding to openssl&#39;s SSL structure
    #
    # returns: number of tickets to send</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_num_tickets.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_num_tickets.html</a></p>

</li>
<li><p>get_server_random</p>

<p>Returns internal SSLv3 server_random value.</p>

<pre><code>    Net::SSLeay::get_server_random($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: server_random value (binary data)</code></pre>

</li>
<li><p>get_client_random</p>

<p><b>NOTE:</b> Does not exactly correspond to any low level API function</p>

<p>Returns internal SSLv3 client_random value.</p>

<pre><code>    Net::SSLeay::get_client_random($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: client_random value (binary data)</code></pre>

</li>
<li><p>export_keying_material</p>

<p>Returns keying material based on the string $label and optional $context. Note that with TLSv1.2 and lower, empty context (empty string) and undefined context (no value or &#39;undef&#39;) will return different values.</p>

<pre><code>    my $out = Net::SSLeay::export_keying_material($ssl, $olen, $label, $context);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $olen - number of bytes to return
    # $label - application specific label
    # $context - [optional] context - default is undef for no context
    #
    # returns: keying material (binary data) or undef on error</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_export_keying_material.html">https://www.openssl.org/docs/manmaster/man3/SSL_export_keying_material.html</a></p>

</li>
<li><p>get_session</p>

<p>Retrieve TLS/SSL session data used in $ssl. The reference count of the SSL_SESSION is NOT incremented.</p>

<pre><code>    my $rv = Net::SSLeay::get_session($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: value corresponding to openssl&#39;s SSL_SESSION structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_session.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_session.html</a></p>

</li>
<li><p>SSL_get0_session</p>

<p>The alias for <a href="./Net::SSLeay.html#get_session">&quot;get_session&quot;</a> (note that the name is <code>SSL_get0_session</code> NOT <code>get0_session</code>).</p>

<pre><code>    my $rv = Net::SSLeay::SSL_get0_session();</code></pre>

</li>
<li><p>get1_session</p>

<p>Returns a pointer to the SSL_SESSION actually used in $ssl. The reference count of the SSL_SESSION is incremented by 1.</p>

<pre><code>    my $rv = Net::SSLeay::get1_session($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: value corresponding to openssl&#39;s SSL_SESSION structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_session.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_session.html</a></p>

</li>
<li><p>get_shared_ciphers</p>

<p>Returns string with a list (colon &#39;:&#39; separated) of ciphers shared between client and server within SSL session $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_shared_ciphers();
    #
    # returns: string like &#39;ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES256-SHA:DHE-DSS-AES256-SHA:...&#39;</code></pre>

</li>
<li><p>get_shutdown</p>

<p>Returns the shutdown mode of $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_shutdown($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: shutdown mode (bitmask) of ssl

    # to decode the return value (bitmask) use:
    # 0 - No shutdown setting, yet
    # 1 - SSL_SENT_SHUTDOWN
    # 2 - SSL_RECEIVED_SHUTDOWN</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_shutdown.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_shutdown.html</a></p>

</li>
<li><p>get_ssl_method</p>

<p>Returns a function pointer to the TLS/SSL method set in $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_ssl_method($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: value corresponding to openssl&#39;s SSL_METHOD structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_ssl_version.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_ssl_version.html</a></p>

</li>
<li><p>in_init, in_before, is_init_finished, in_connect_init, in_accept_init</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before.</p>

<p>Retrieve information about the handshake state machine. All functions take $ssl as the only argument and return 0 or 1. These functions are recommended over get_state() and state().</p>

<pre><code>    my $rv = Net::SSLeay::is_init_finished($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: All functions return 1 or 0</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_in_init.html">https://www.openssl.org/docs/manmaster/man3/SSL_in_init.html</a></p>

</li>
<li><p>get_state</p>

<p><b>COMPATIBILITY:</b> OpenSSL 1.1.0 and later use different constants which are not made available. Use is_init_finished() and related functions instead.</p>

<p>Returns the SSL connection state.</p>

<pre><code>    my $rv = Net::SSLeay::get_state($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (integer) state value
    #          to decode the returned state check:
    #          SSL_ST_* constants in openssl/ssl.h
    #          SSL2_ST_* constants in openssl/ssl2.h
    #          SSL23_ST_* constants in openssl/ssl23.h
    #          SSL3_ST_* + DTLS1_ST_* constants in openssl/ssl3.h</code></pre>

</li>
<li><p>state</p>

<p>Exactly the same as <a href="./Net::SSLeay.html#get_state">&quot;get_state&quot;</a>.</p>

<pre><code>    my $rv = Net::SSLeay::state($ssl);</code></pre>

</li>
<li><p>set_state</p>

<p>Sets the SSL connection state.</p>

<pre><code>    Net::SSLeay::set_state($ssl,Net::SSLeay::SSL_ST_ACCEPT());</code></pre>

<p>Not available with OpenSSL 1.1 and later.</p>

</li>
<li><p>get_verify_depth</p>

<p>Returns the verification depth limit currently set in $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_verify_depth($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: current depth or -1 if no limit has been explicitly set</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_verify_mode.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_verify_mode.html</a></p>

</li>
<li><p>set_verify_depth</p>

<p>Sets the maximum depth for the certificate chain verification that shall be allowed for $ssl.</p>

<pre><code>    Net::SSLeay::set_verify_depth($ssl, $depth);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $depth - (integer) depth
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_verify.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_verify.html</a></p>

</li>
<li><p>get_verify_mode</p>

<p>Returns the verification mode (bitmask) currently set in $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_verify_mode($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: mode (bitmask)</code></pre>

<p>To decode the return value (bitmask) see documentation for <a href="./Net::SSLeay.html#CTX_get_verify_mode">&quot;CTX_get_verify_mode&quot;</a>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_verify_mode.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_verify_mode.html</a></p>

</li>
<li><p>set_verify</p>

<p>Sets the verification flags for $ssl to be $mode and specifies the $verify_callback function to be used.</p>

<pre><code>    Net::SSLeay::set_verify($ssl, $mode, $callback);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $mode - mode (bitmask)
    # $callback - [optional] reference to perl callback function
    #
    # returns: no return value</code></pre>

<p>For $mode bitmask details see <a href="./Net::SSLeay.html#CTX_get_verify_mode">&quot;CTX_get_verify_mode&quot;</a>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_verify.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_verify.html</a></p>

</li>
<li><p>set_post_handshake_auth</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>

<p>Enable the Post-Handshake Authentication extension to be added to the ClientHello such that post-handshake authentication can be requested by the server.</p>

<pre><code>    Net::SSLeay::set_posthandshake_auth($ssl, $val);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $val - 0 then the extension is not sent, otherwise it is
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_post_handshake_auth.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_post_handshake_auth.html</a></p>

</li>
<li><p>verify_client_post_handshake</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>

<p>verify_client_post_handshake causes a CertificateRequest message to be sent by a server on the given ssl connection.</p>

<pre><code>    my $rv = Net::SSLeay::verify_client_post_handshake($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: 1 if the request succeeded, and 0 if the request failed. The error stack can be examined to determine the failure reason.</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_verify_client_post_handshake.html">https://www.openssl.org/docs/manmaster/man3/SSL_verify_client_post_handshake.html</a></p>

</li>
<li><p>get_verify_result</p>

<p>Returns the result of the verification of the X509 certificate presented by the peer, if any.</p>

<pre><code>    my $rv = Net::SSLeay::get_verify_result($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (integer)
    #      0 - X509_V_OK: ok
    #      2 - X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: unable to get issuer certificate
    #      3 - X509_V_ERR_UNABLE_TO_GET_CRL: unable to get certificate CRL
    #      4 - X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE: unable to decrypt certificate&#39;s signature
    #      5 - X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE: unable to decrypt CRL&#39;s signature
    #      6 - X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY: unable to decode issuer public key
    #      7 - X509_V_ERR_CERT_SIGNATURE_FAILURE: certificate signature failure
    #      8 - X509_V_ERR_CRL_SIGNATURE_FAILURE: CRL signature failure
    #      9 - X509_V_ERR_CERT_NOT_YET_VALID: certificate is not yet valid
    #     10 - X509_V_ERR_CERT_HAS_EXPIRED: certificate has expired
    #     11 - X509_V_ERR_CRL_NOT_YET_VALID: CRL is not yet valid
    #     12 - X509_V_ERR_CRL_HAS_EXPIRED: CRL has expired
    #     13 - X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: format error in certificate&#39;s notBefore field
    #     14 - X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: format error in certificate&#39;s notAfter field
    #     15 - X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD: format error in CRL&#39;s lastUpdate field
    #     16 - X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD: format error in CRL&#39;s nextUpdate field
    #     17 - X509_V_ERR_OUT_OF_MEM: out of memory
    #     18 - X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT: self signed certificate
    #     19 - X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN: self signed certificate in certificate chain
    #     20 - X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: unable to get local issuer certificate
    #     21 - X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE: unable to verify the first certificate
    #     22 - X509_V_ERR_CERT_CHAIN_TOO_LONG: certificate chain too long
    #     23 - X509_V_ERR_CERT_REVOKED: certificate revoked
    #     24 - X509_V_ERR_INVALID_CA: invalid CA certificate
    #     25 - X509_V_ERR_PATH_LENGTH_EXCEEDED: path length constraint exceeded
    #     26 - X509_V_ERR_INVALID_PURPOSE: unsupported certificate purpose
    #     27 - X509_V_ERR_CERT_UNTRUSTED: certificate not trusted
    #     28 - X509_V_ERR_CERT_REJECTED: certificate rejected
    #     29 - X509_V_ERR_SUBJECT_ISSUER_MISMATCH: subject issuer mismatch
    #     30 - X509_V_ERR_AKID_SKID_MISMATCH: authority and subject key identifier mismatch
    #     31 - X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH: authority and issuer serial number mismatch
    #     32 - X509_V_ERR_KEYUSAGE_NO_CERTSIGN:key usage does not include certificate signing
    #     50 - X509_V_ERR_APPLICATION_VERIFICATION: application verification failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_verify_result.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_verify_result.html</a></p>

</li>
<li><p>set_verify_result</p>

<p>Override result of peer certificate verification.</p>

<pre><code>    Net::SSLeay::set_verify_result($ssl, $v);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $v - (integer) result value
    #
    # returns: no return value</code></pre>

<p>For more info about valid return values see <a href="./Net::SSLeay.html#get_verify_result">&quot;get_verify_result&quot;</a></p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_verify_result.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_verify_result.html</a></p>

</li>
<li><p>get_wbio</p>

<p>Get &#39;write&#39; BIO linked to an SSL object $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::get_wbio($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: value corresponding to openssl&#39;s BIO structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_rbio.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_rbio.html</a></p>

</li>
<li><p>load_client_CA_file</p>

<p>Load X509 certificates from file (PEM formatted).</p>

<pre><code>    my $rv = Net::SSLeay::load_client_CA_file($file);
    # $file - (string) file name
    #
    # returns: value corresponding to openssl&#39;s STACK_OF(X509_NAME) structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_load_client_CA_file.html">https://www.openssl.org/docs/manmaster/man3/SSL_load_client_CA_file.html</a></p>

</li>
<li><p>clear_num_renegotiations</p>

<p>Executes SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS command on $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::clear_num_renegotiations($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: command result</code></pre>

</li>
<li><p>need_tmp_RSA</p>

<p>Executes SSL_CTRL_NEED_TMP_RSA command on $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::need_tmp_RSA($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: command result</code></pre>

<p>Not available with OpenSSL 1.1 and later.</p>

</li>
<li><p>num_renegotiations</p>

<p>Executes SSL_CTRL_GET_NUM_RENEGOTIATIONS command on $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::num_renegotiations($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: command result</code></pre>

</li>
<li><p>total_renegotiations</p>

<p>Executes SSL_CTRL_GET_TOTAL_RENEGOTIATIONS command on $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::total_renegotiations($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: command result</code></pre>

</li>
<li><p>peek</p>

<p>Copies $max bytes from the specified $ssl into the returned value. In contrast to the <code>Net::SSLeay::read()</code> function, the data in the SSL buffer is unmodified after the SSL_peek() operation.</p>

<pre><code>    Net::SSLeay::peek($ssl, $max);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $max - [optional] max bytes to peek (integer) - default is 32768
    #
    # in scalar context: data read from the TLS/SSL connection, undef on error
    # in list context:   two-item array consisting of data read (undef on error),
    #                      and return code from SSL_peek().</code></pre>

</li>
<li><p>peek_ex</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>

<p>Copies $max bytes from the specified $ssl into the returned value. In contrast to the <code>Net::SSLeay::read_ex()</code> function, the data in the SSL buffer is unmodified after the SSL_peek_ex() operation.</p>

<pre><code>    my($got, $rv) = Net::SSLeay::peek_ex($ssl, $max);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $max - [optional] max bytes to peek (integer) - default is 32768
    #
    # returns a list: two-item list consisting of data read (undef on error),
    #                 and return code from SSL_peek_ex().</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_peek_ex.html">https://www.openssl.org/docs/manmaster/man3/SSL_peek_ex.html</a></p>

</li>
<li><p>pending</p>

<p>Obtain number of readable bytes buffered in $ssl object.</p>

<pre><code>    my $rv = Net::SSLeay::pending($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: the number of bytes pending</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_pending.html">https://www.openssl.org/docs/manmaster/man3/SSL_pending.html</a></p>

</li>
<li><p>has_pending</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0, not in LibreSSL</p>

<p>Returns 1 if $ssl has buffered data (whether processed or unprocessed) and 0 otherwise.</p>

<pre><code>    my $rv = Net::SSLeay::has_pending($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (integer) 1 or 0</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_has_pending.html">https://www.openssl.org/docs/manmaster/man3/SSL_has_pending.html</a></p>

</li>
<li><p>read</p>

<p>Tries to read $max bytes from the specified $ssl.</p>

<pre><code>    my $got = Net::SSLeay::read($ssl, $max);
    my($got, $rv) = Net::SSLeay::read($ssl, $max);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $max - [optional] max bytes to read (integer) - default is 32768
    #
    # returns:
    # in scalar context: data read from the TLS/SSL connection, undef on error
    # in list context:   two-item array consisting of data read (undef on error),
    #                      and return code from SSL_read().</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_read.html">https://www.openssl.org/docs/manmaster/man3/SSL_read.html</a></p>

</li>
<li><p>read_ex</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>

<p>Tries to read $max bytes from the specified $ssl.</p>

<pre><code>    my($got, $rv) = Net::SSLeay::read_ex($ssl, $max);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $max - [optional] max bytes to read (integer) - default is 32768
    #
    # returns a list: two-item list consisting of data read (undef on error),
    #                 and return code from SSL_read_ex().</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_read_ex.html">https://www.openssl.org/docs/manmaster/man3/SSL_read_ex.html</a></p>

</li>
<li><p>renegotiate</p>

<p>Turn on flags for renegotiation so that renegotiation will happen</p>

<pre><code>    my $rv = Net::SSLeay::renegotiate($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>rstate_string</p>

<p>Returns a 2 letter string indicating the current read state of the SSL object $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::rstate_string($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: 2-letter string</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_rstate_string.html">https://www.openssl.org/docs/manmaster/man3/SSL_rstate_string.html</a></p>

</li>
<li><p>rstate_string_long</p>

<p>Returns a string indicating the current read state of the SSL object ssl.</p>

<pre><code>    my $rv = Net::SSLeay::rstate_string_long($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: string with current state</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_rstate_string.html">https://www.openssl.org/docs/manmaster/man3/SSL_rstate_string.html</a></p>

</li>
<li><p>session_reused</p>

<p>Query whether a reused session was negotiated during handshake.</p>

<pre><code>    my $rv = Net::SSLeay::session_reused($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: 0 - new session was negotiated; 1 - session was reused.</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_session_reused.html">https://www.openssl.org/docs/manmaster/man3/SSL_session_reused.html</a></p>

</li>
<li><p>set1_param</p>

<p><b>COMPATIBILITY:</b> requires at least OpenSSL 1.0.0-beta3</p>

<p>Applies X509 verification parameters $vpm on $ssl</p>

<pre><code>    my $rv = Net::SSLeay::set1_param($ssl, $vpm);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $vpm - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>set_accept_state</p>

<p>Sets $ssl to work in server mode.</p>

<pre><code>    Net::SSLeay::set_accept_state($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_connect_state.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_connect_state.html</a></p>

</li>
<li><p>set_bio</p>

<p>Connects the BIOs $rbio and $wbio for the read and write operations of the TLS/SSL (encrypted) side of $ssl.</p>

<pre><code>    Net::SSLeay::set_bio($ssl, $rbio, $wbio);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $rbio - value corresponding to openssl&#39;s BIO structure
    # $wbio - value corresponding to openssl&#39;s BIO structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_bio.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_bio.html</a></p>

</li>
<li><p>set_cipher_list</p>

<p>Sets the list of ciphers only for ssl.</p>

<pre><code>    my $rv = Net::SSLeay::set_cipher_list($ssl, $str);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $str - (string) cipher list e.g. &#39;3DES:+RSA&#39;
    #
    # returns: 1 if any cipher could be selected and 0 on complete failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_cipher_list.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_cipher_list.html</a></p>

</li>
<li><p>set_ciphersuites</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1 or at least LibreSSL 3.4.0 and Net-SSLeay-1.94</p>

<p>Configure the available TLSv1.3 ciphersuites.</p>

<pre><code>    my $rv = Net::SSLeay::set_ciphersuites($ssl, $str);
    # $ssl  - value corresponding to openssl&#39;s SSL structure
    # $str  - colon (&quot;:&quot;) separated list of TLSv1.3 ciphersuite names in order of preference
    #
    # returns: (integer) 1 if the requested ciphersuite list was configured, and 0 otherwise</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_ciphersuites.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_ciphersuites.html</a></p>

</li>
<li><p>set_client_CA_list</p>

<p>Sets the list of CAs sent to the client when requesting a client certificate for the chosen $ssl, overriding the setting valid for $ssl&#39;s SSL_CTX object.</p>

<pre><code>    my $rv = Net::SSLeay::set_client_CA_list($ssl, $list);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $list - value corresponding to openssl&#39;s STACK_OF(X509_NAME) structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_client_CA_list.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_client_CA_list.html</a></p>

</li>
<li><p>set_connect_state</p>

<p>Sets $ssl to work in client mode.</p>

<pre><code>    Net::SSLeay::set_connect_state($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_connect_state.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_connect_state.html</a></p>

</li>
<li><p>set_fd</p>

<p>Sets the file descriptor $fd as the input/output facility for the TLS/SSL (encrypted) side of $ssl, $fd will typically be the socket file descriptor of a network connection.</p>

<pre><code>    my $rv = Net::SSLeay::set_fd($ssl, $fd);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $fd - (integer) file handle (got via perl&#39;s fileno)
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_fd.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_fd.html</a></p>

</li>
<li><p>set_psk_client_callback</p>

<p>Sets the psk client callback.</p>

<pre><code>    Net::SSLeay::set_psk_client_callback($ssl, sub { my $hint = shift; return ($identity, $key) } );
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $hint - PSK identity hint send by the server
    # $identity - PSK identity
    # $key - PSK key, hex string without the leading &#39;0x&#39;, e.g. &#39;deadbeef&#39;
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_psk_client_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_psk_client_callback.html</a></p>

</li>
<li><p>set_rfd</p>

<p>Sets the file descriptor $fd as the input (read) facility for the TLS/SSL (encrypted) side of $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::set_rfd($ssl, $fd);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $fd - (integer) file handle (got via perl&#39;s fileno)
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_fd.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_fd.html</a></p>

</li>
<li><p>set_wfd</p>

<pre><code>    my $rv = Net::SSLeay::set_wfd($ssl, $fd);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $fd - (integer) file handle (got via perl&#39;s fileno)
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_fd.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_fd.html</a></p>

</li>
<li><p>set_info_callback</p>

<p>Sets the callback function, that can be used to obtain state information for $ssl during connection setup and use. When callback is undef, the callback setting currently valid for ctx is used.</p>

<pre><code>    Net::SSLeay::set_info_callback($ssl, $cb, [$data]);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $cb - sub { my ($ssl,$where,$ret,$data) = @_; ... }
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_info_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_info_callback.html</a></p>

</li>
<li><p>CTX_set_info_callback</p>

<p>Sets the callback function on ctx, that can be used to obtain state information during ssl connection setup and use. When callback is undef, an existing callback will be disabled.</p>

<pre><code>    Net::SSLeay::CTX_set_info_callback($ssl, $cb, [$data]);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $cb - sub { my ($ssl,$where,$ret,$data) = @_; ... }
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_info_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_info_callback.html</a></p>

</li>
<li><p>set_msg_callback</p>

<p>Sets the callback function, that can be used to obtain protocol messages information for $ssl during connection setup and use. When callback is undef, the callback setting currently valid for ctx is used. Note that set_msg_callback_arg is not provided as there is no need to explicitly set $arg, this is handled by set_msg_callback.</p>

<pre><code>    Net::SSLeay::set_msg_callback($ssl, $cb, [$arg]);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $cb - sub { my ($write_p,$version,$content_type,$buf,$len,$ssl,$arg) = @_; ... }
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_msg_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_msg_callback.html</a></p>

</li>
<li><p>CTX_set_msg_callback</p>

<p>Sets the callback function on ctx, that can be used to obtain protocol messages information for ssl connection setup and use. When callback is undef, the existing callback will be disabled. Note that CTX_set_msg_callback_arg is not provided as there is no need to explicitly set $arg, this is handled by CTX_set_msg_callback.</p>

<pre><code>    Net::SSLeay::CTX_set_msg_callback($ssl, $cb, [$arg]);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $cb - sub { my ($write_p,$version,$content_type,$buf,$len,$ssl,$arg) = @_; ... }
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_msg_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_msg_callback.html</a></p>

</li>
<li><p>set_pref_cipher</p>

<p>Sets the list of available ciphers for $ssl using the control string $str.</p>

<pre><code>    my $rv = Net::SSLeay::set_pref_cipher($ssl, $str);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $str - (string) cipher list e.g. &#39;3DES:+RSA&#39;
    #
    # returns: 1 if any cipher could be selected and 0 on complete failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_cipher_list.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_cipher_list.html</a></p>

</li>
<li><p>CTX_set_psk_client_callback</p>

<p>Sets the psk client callback.</p>

<pre><code>    Net::SSLeay::CTX_set_psk_client_callback($ssl, sub { my $hint = shift; return ($identity, $key) } );
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $hint - PSK identity hint send by the server
    # $identity - PSK identity
    # $key - PSK key, hex string without the leading &#39;0x&#39;, e.g. &#39;deadbeef&#39;
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_client_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_client_callback.html</a></p>

</li>
<li><p>set_purpose</p>

<pre><code>    my $rv = Net::SSLeay::set_purpose($ssl, $purpose);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $purpose - (integer) purpose identifier
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>For more info about available $purpose identifiers see <a href="./Net::SSLeay.html#CTX_set_purpose">&quot;CTX_set_purpose&quot;</a>.</p>

</li>
<li><p>set_quiet_shutdown</p>

<p>Sets the &#39;quiet shutdown&#39; flag for $ssl to be $mode.</p>

<pre><code>    Net::SSLeay::set_quiet_shutdown($ssl, $mode);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $mode - 0 or 1
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_quiet_shutdown.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_quiet_shutdown.html</a></p>

</li>
<li><p>set_session</p>

<p>Set a TLS/SSL session to be used during TLS/SSL connect.</p>

<pre><code>    my $rv = Net::SSLeay::set_session($to, $ses);
    # $to - value corresponding to openssl&#39;s SSL structure
    # $ses - value corresponding to openssl&#39;s SSL_SESSION structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_session.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_session.html</a></p>

</li>
<li><p>set_session_id_context</p>

<p>Sets the context $sid_ctx of length $sid_ctx_len within which a session can be reused for the $ssl object.</p>

<pre><code>    my $rv = Net::SSLeay::set_session_id_context($ssl, $sid_ctx, $sid_ctx_len);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $sid_ctx - data buffer
    # $sid_ctx_len - length of data in $sid_ctx
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_session_id_context.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_session_id_context.html</a></p>

</li>
<li><p>set_session_secret_cb</p>

<p>Setup pre-shared secret session resumption function.</p>

<pre><code>    Net::SSLeay::set_session_secret_cb($ssl, $func, $data);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $func - perl reference to callback function
    # $data - [optional] data that will be passed to callback function when invoked
    #
    # returns: no return value</code></pre>

<p>The callback function will be called like:</p>

<pre><code>    callback_function($secret, $ciphers, $pref_cipher, $data);
    # $secret is the current master session key, usually all 0s at the beginning of a session
    # $ciphers is ref to an array of peer cipher names
    # $pref_cipher is a ref to an index into the list of cipher names of
    #  the preferred cipher. Set it if you want to specify a preferred cipher
    # $data is the data passed to set_session_secret_cb</code></pre>

<p>The callback function should return 1 if it likes the suggested cipher (or has selected an alternative by setting pref_cipher), else it should return 0 (in which case OpenSSL will select its own preferred cipher).</p>

<p>With OpenSSL 1.1 and later, callback_function can change the master key for the session by altering $secret and returning 1.</p>

</li>
<li><p>CTX_set_tlsext_ticket_getkey_cb</p>

<p>Setup encryption for TLS session tickets (stateless session reuse).</p>

<pre><code>    Net::SSLeay::CTX_set_tlsext_ticket_getkey_cb($ctx, $func, $data);
    # $ctx  - value corresponding to openssl&#39;s SSL_CTX structure
    # $func - perl reference to callback function
    # $data - [optional] data that will be passed to callback function when invoked
    #
    # returns: no return value</code></pre>

<p>The callback function will be called like:</p>

<pre><code>    getkey($data,[$key_name]) -&gt; ($key,$current_key_name)
    # $data is the data passed to set_session_secret_cb
    # $key_name is the name of the key OpenSSL has extracted from the session ticket
    # $key is the requested key for ticket encryption + HMAC
    # $current_key_name is the name for the currently valid key</code></pre>

<p>OpenSSL will call the function without a key name if it generates a new ticket. It then needs the callback to return the encryption+HMAC key and an identifier (key name) for this key.</p>

<p>When OpenSSL gets a session ticket from the client it extracts the key name and calls the callback with this name as argument. It then expects the callback to return the encryption+HMAC key matching the requested key name and and also the key name which should be used at the moment. If the requested key name and the returned key name differ it means that this session ticket was created with an expired key and need to be renewed. In this case OpenSSL will call the callback again with no key name to create a new session ticket based on the old one.</p>

<p>The key must be at least 32 byte of random data which can be created with RAND_bytes. Internally the first 16 byte are used as key in AES-128 encryption while the next 16 byte are used for the SHA-256 HMAC. The key name are binary data and must be exactly 16 byte long.</p>

<p>Example:</p>

<pre><code>    Net::SSLeay::RAND_bytes(my $oldkey,32);
    Net::SSLeay::RAND_bytes(my $newkey,32);
    my $oldkey_name = pack(&quot;a16&quot;,&#39;oldsecret&#39;);
    my $newkey_name = pack(&quot;a16&quot;,&#39;newsecret&#39;);

    my @keys = (
        [ $newkey_name, $newkey ], # current active key
        [ $oldkey_name, $oldkey ], # already expired
    );

    Net::SSLeay::CTX_set_tlsext_ticket_getkey_cb($server2-&gt;_ctx, sub {
        my ($mykeys,$name) = @_;

        # return (current_key, current_key_name) if no name given
        return ($mykeys-&gt;[0][1],$mykeys-&gt;[0][0]) if ! $name;

        # return (matching_key, current_key_name) if we find a key matching
        # the given name
        for(my $i = 0; $i&lt;@$mykeys; $i++) {
            next if $name ne $mykeys-&gt;[$i][0];
            return ($mykeys-&gt;[$i][1],$mykeys-&gt;[0][0]);
        }

        # no matching key found
        return;
    },\@keys);</code></pre>

<p>This function is based on the OpenSSL function SSL_CTX_set_tlsext_ticket_key_cb but provides a simpler to use interface. For more information see <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_tlsext_ticket_key_cb.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_tlsext_ticket_key_cb.html</a></p>

</li>
<li><p>set_session_ticket_ext_cb</p>

<p>Setup callback for TLS session tickets (stateless session reuse).</p>

<pre><code>    Net::SSLeay::set_session_ticket_ext_cb($ssl, $func, $data);
    # $ssl  - value corresponding to openssl&#39;s SSL structure
    # $func - perl reference to callback function
    # $data - [optional] data that will be passed to callback function when invoked
    #
    # returns: no return value</code></pre>

<p>The callback function will be called like:</p>

<pre><code>    getticket($ssl,$ticket,$data) -&gt; $return_value
    # $ssl is a value corresponding to openssl&#39;s SSL structure
    # $ticket is a value of received TLS session ticket (can also be empty)
    # $data is the data passed to set_session_ticket_ext_cb
    # $return_value is either 0 (failure) or 1 (success)</code></pre>

<p>This function is based on the OpenSSL function SSL_set_session_ticket_ext_cb.</p>

</li>
<li><p>set_session_ticket_ext</p>

<p>Set TLS session ticket (stateless session reuse).</p>

<pre><code>    Net::SSLeay::set_session_ticket_ext($ssl, $ticket);
    # $ssl    - value corresponding to openssl&#39;s SSL structure
    # $ticket - is a value of TLS session ticket which client will send (can also be empty string)
    #
    # returns: no return value</code></pre>

<p>The callback function will be called like:</p>

<pre><code>    getticket($ssl,$ticket,$data) -&gt; $return_value
    # $ssl is a value corresponding to openssl&#39;s SSL structure
    # $ticket is a value of received TLS session ticket (can also be empty)
    # $data is the data passed to set_session_ticket_ext_cb
    # $return_value is either 0 (failure) or 1 (success)</code></pre>

<p>This function is based on the OpenSSL function SSL_set_session_ticket_ext_cb.</p>

</li>
<li><p>set_shutdown</p>

<p>Sets the shutdown state of $ssl to $mode.</p>

<pre><code>    Net::SSLeay::set_shutdown($ssl, $mode);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $mode - (integer) shutdown mode:
    #         0 - No shutdown
    #         1 - SSL_SENT_SHUTDOWN
    #         2 - SSL_RECEIVED_SHUTDOWN
    #         3 - SSL_RECEIVED_SHUTDOWN+SSL_SENT_SHUTDOWN
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_shutdown.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_shutdown.html</a></p>

</li>
<li><p>set_ssl_method</p>

<p>Sets a new TLS/SSL method for a particular $ssl object.</p>

<pre><code>    my $rv = Net::SSLeay::set_ssl_method($ssl, $method);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $method - value corresponding to openssl&#39;s SSL_METHOD structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_ssl_version.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_ssl_version.html</a></p>

</li>
<li><p>set_tmp_dh</p>

<p>Sets DH parameters to be used to be $dh.</p>

<pre><code>    my $rv = Net::SSLeay::set_tmp_dh($ssl, $dh);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $dh - value corresponding to openssl&#39;s DH structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_tmp_dh_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_tmp_dh_callback.html</a></p>

</li>
<li><p>set_tmp_dh_callback</p>

<p>Sets the callback function for $ssl to be used when a DH parameters are required to $dh_cb.</p>

<p>??? (does this function really work?)</p>

<pre><code>    Net::SSLeay::set_tmp_dh_callback($ssl, $dh);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $dh_cb - pointer to function ???
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_tmp_dh_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_tmp_dh_callback.html</a></p>

</li>
<li><p>set_tmp_rsa</p>

<p>Sets the temporary/ephemeral RSA key to be used in $ssl to be $rsa.</p>

<pre><code>    my $rv = Net::SSLeay::set_tmp_rsa($ssl, $rsa);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $rsa - value corresponding to openssl&#39;s RSA structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Example:</p>

<pre><code>    $rsakey = Net::SSLeay::RSA_generate_key();
    Net::SSLeay::set_tmp_rsa($ssl, $rsakey);
    Net::SSLeay::RSA_free($rsakey);</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/man1.0.2/man3/SSL_CTX_set_tmp_rsa_callback.html">https://www.openssl.org/docs/man1.0.2/man3/SSL_CTX_set_tmp_rsa_callback.html</a></p>

</li>
<li><p>set_tmp_rsa_callback</p>

<p>Sets the callback function for $ssl to be used when a temporary/ephemeral RSA key is required to $tmp_rsa_callback.</p>

<p>??? (does this function really work?)</p>

<pre><code>    Net::SSLeay::set_tmp_rsa_callback($ssl, $tmp_rsa_callback);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $tmp_rsa_callback - (function pointer) ???
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/man1.0.2/man3/SSL_CTX_set_tmp_rsa_callback.html">https://www.openssl.org/docs/man1.0.2/man3/SSL_CTX_set_tmp_rsa_callback.html</a></p>

</li>
<li><p>set_trust</p>

<pre><code>    my $rv = Net::SSLeay::set_trust($ssl, $trust);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $trust - (integer) trust identifier
    #
    # returns: the original value</code></pre>

<p>For more details about $trust values see <a href="./Net::SSLeay.html#CTX_set_trust">&quot;CTX_set_trust&quot;</a>.</p>

</li>
<li><p>shutdown</p>

<p>Shuts down an active TLS/SSL connection. It sends the &#39;close notify&#39; shutdown alert to the peer.</p>

<pre><code>    my $rv = Net::SSLeay::shutdown($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: 1 - shutdown was successfully completed
    #          0 - shutdown is not yet finished,
    #         -1 - shutdown was not successful</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_shutdown.html">https://www.openssl.org/docs/manmaster/man3/SSL_shutdown.html</a></p>

</li>
<li><p>state_string</p>

<p>Returns a 6 letter string indicating the current state of the SSL object $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::state_string($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: 6-letter string</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_state_string.html">https://www.openssl.org/docs/manmaster/man3/SSL_state_string.html</a></p>

</li>
<li><p>state_string_long</p>

<p>Returns a string indicating the current state of the SSL object $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::state_string_long($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: state strings</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_state_string.html">https://www.openssl.org/docs/manmaster/man3/SSL_state_string.html</a></p>

</li>
<li><p>set_default_passwd_cb</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.1.0f. Not needed with LibreSSL.</p>

<p>Sets the default password callback called when loading/storing a PEM certificate with encryption for $ssl.</p>

<pre><code>    Net::SSLeay::set_default_passwd_cb($ssl, $func);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $func - perl reference to callback function
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_default_passwd_cb.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_default_passwd_cb.html</a></p>

</li>
<li><p>set_default_passwd_cb_userdata</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.1.0f. Not needed with LibreSSL.</p>

<p>Sets a pointer to userdata which will be provided to the password callback of $ssl on invocation.</p>

<pre><code>    Net::SSLeay::set_default_passwd_cb_userdata($ssl, $userdata);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $userdata - data that will be passed to callback function when invoked
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_default_passwd_cb.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_default_passwd_cb.html</a></p>

</li>
<li><p>use_PrivateKey</p>

<p>Adds $pkey as private key to $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::use_PrivateKey($ssl, $pkey);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $pkey - value corresponding to openssl&#39;s EVP_PKEY structure
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>use_PrivateKey_ASN1</p>

<p>Adds the private key of type $pk stored in $data to $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::use_PrivateKey_ASN1($pk, $ssl, $d, $len);
    # $pk - (integer) key type, NID of corresponding algorithm
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $data - key data (binary)
    # $len - length of $data
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>use_PrivateKey_file</p>

<p>Adds the first private key found in $file to $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::use_PrivateKey_file($ssl, $file, $type);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $file - (string) file name
    # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>use_RSAPrivateKey</p>

<p>Adds $rsa as RSA private key to $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::use_RSAPrivateKey($ssl, $rsa);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $rsa - value corresponding to openssl&#39;s RSA structure
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>use_RSAPrivateKey_ASN1</p>

<p>Adds RSA private key stored in $data to $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::use_RSAPrivateKey_ASN1($ssl, $data, $len);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $data - key data (binary)
    # $len - length of $data
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>use_RSAPrivateKey_file</p>

<p>Adds the first RSA private key found in $file to $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::use_RSAPrivateKey_file($ssl, $file, $type);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $file - (string) file name
    # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>use_certificate</p>

<p>Loads the certificate $x into $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::use_certificate($ssl, $x);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>use_certificate_ASN1</p>

<p>Loads the ASN1 encoded certificate from $data to $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::use_certificate_ASN1($ssl, $data, $len);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $data - certificate data (binary)
    # $len - length of $data
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>use_certificate_chain_file</p>

<p><b>COMPATIBILITY</b>: not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.1.0 or at least LibreSSL 3.6.0 and Net-SSLeay-1.94</p>

<p>Loads a certificate chain from $file into $ssl. The certificates must be in PEM format and must be sorted starting with the subject&#39;s certificate (actual client or server certificate), followed by intermediate CA certificates if applicable, and ending at the highest level (root) CA.</p>

<pre><code>    my $rv = Net::SSLeay::use_certificate_chain_file($ssl, $file);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $file - (string) file name
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>use_certificate_file</p>

<p>Loads the first certificate stored in $file into $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::use_certificate_file($ssl, $file, $type);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $file - (string) file name
    # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
    #
    # returns: 1 on success, otherwise check out the error stack to find out the reason</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_certificate.html</a></p>

</li>
<li><p>get_version</p>

<p>Returns SSL/TLS protocol name</p>

<pre><code>    my $rv = Net::SSLeay::get_version($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (string) protocol name, see OpenSSL manual for the full list
    #          TLSv1
    #          TLSv1.3</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_get_version.html">https://www.openssl.org/docs/manmaster/man3/SSL_get_version.html</a></p>

</li>
<li><p>version</p>

<p>Returns SSL/TLS protocol version</p>

<pre><code>    my $rv = Net::SSLeay::version($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (integer) protocol version, see OpenSSL manual for the full list
    #          0x0301 - TLS1_VERSION  (TLSv1)
    #          0xFEFF - DTLS1_VERSION (DTLSv1)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_version.html">https://www.openssl.org/docs/manmaster/man3/SSL_version.html</a></p>

</li>
<li><p>client_version</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0, not in LibreSSL</p>

<p>Returns TLS protocol version used by the client when initiating the connection</p>

<pre><code>    my $rv = Net::SSLeay::client_version($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (integer) protocol version, see OpenSSL manual for the full list
    #          0x0301 - TLS1_VERSION  (TLSv1)
    #          0xFEFF - DTLS1_VERSION (DTLSv1)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_client_version.html">https://www.openssl.org/docs/manmaster/man3/SSL_client_version.html</a></p>

</li>
<li><p>is_dtls</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0 or at least LibreSSL 3.3.1 and Net-SSLeay-1.94</p>

<pre><code>    my $rv = Net::SSLeay::is_dtls($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (integer) zero or one
    #          0 - connection is not using DTLS
    #          1 - connection is using DTLS</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_is_dtls.html">https://www.openssl.org/docs/manmaster/man3/SSL_is_dtls.html</a></p>

</li>
<li><p>want</p>

<p>Returns state information for the SSL object $ssl.</p>

<pre><code>    my $rv = Net::SSLeay::want($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: state
    #          1 - SSL_NOTHING
    #          2 - SSL_WRITING
    #          3 - SSL_READING
    #          4 - SSL_X509_LOOKUP</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_want.html">https://www.openssl.org/docs/manmaster/man3/SSL_want.html</a></p>

</li>
<li><p>write</p>

<p>Writes data from the buffer $data into the specified $ssl connection.</p>

<pre><code>    my $rv = Net::SSLeay::write($ssl, $data);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $data - data to be written
    #
    # returns: &gt;0 - (success) number of bytes actually written to the TLS/SSL connection
    #           0 - write not successful, probably the underlying connection was closed
    #          &lt;0 - error</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_write.html">https://www.openssl.org/docs/manmaster/man3/SSL_write.html</a></p>

</li>
<li><p>write_ex</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>

<p>Writes data from the buffer $data into the specified $ssl connection.</p>

<pre><code>    my ($len, $rv) = Net::SSLeay::write_ex($ssl, $data);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $data - data to be written
    #
    # returns a list: two-item list consisting of number of bytes written,
    #                 and return code from SSL_write_ex()</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_write_ex.html">https://www.openssl.org/docs/manmaster/man3/SSL_write_ex.html</a></p>

</li>
<li><p>write_partial</p>

<p><b>NOTE:</b> Does not exactly correspond to any low level API function</p>

<p>Writes a fragment of data in $data from the buffer $data into the specified $ssl connection. This is a non-blocking function like <a href="https://metacpan.org/pod/Net::SSLeay::write()">Net::SSLeay::write()</a>.</p>

<pre><code>    my $rv = Net::SSLeay::write_partial($ssl, $from, $count, $data);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $from - (integer) offset from the beginning of $data
    # $count - (integer) length of data to be written
    # $data - data buffer
    #
    # returns: &gt;0 - (success) number of bytes actually written to the TLS/SSL connection
    #           0 - write not successful, probably the underlying connection was closed
    #          &lt;0 - error</code></pre>

</li>
<li><p>set_tlsext_host_name</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before; requires at least OpenSSL 0.9.8f</p>

<p>Sets TLS servername extension on SSL object $ssl to value $name.</p>

<pre><code>    my $rv = set_tlsext_host_name($ssl, $name);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    # $name - (string) name to be set
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>client_hello_isv2</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.1pre1, not in LibreSSL</p>

<p><b>NOTE:</b> to be used only from a callback set with <a href="https://metacpan.org/pod/CTX_set_client_hello_cb">CTX_set_client_hello_cb</a>.</p>

<p>Indicate if the ClientHello was carried in a SSLv2 record and is in the SSLv2 format.</p>

<pre><code>    my $rv = client_hello_isv2($s);
    # $s - value corresponding to openssl&#39;s SSL structure
    #
    # returns: 1 for SSLv2-format ClientHellos and 0 otherwise</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_client_hello_isv2.html">https://www.openssl.org/docs/manmaster/man3/SSL_client_hello_isv2.html</a></p>

</li>
<li><p>client_hello_get0_legacy_version</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.1pre1, not in LibreSSL</p>

<p><b>NOTE:</b> to be used only from a callback set with <a href="https://metacpan.org/pod/CTX_set_client_hello_cb">CTX_set_client_hello_cb</a>.</p>

<p>Returns legacy_version, also known as client_version, field from the ClientHello.</p>

<pre><code>    my $rv = client_hello_get0_legacy_version($s);
    # $s - value corresponding to openssl&#39;s SSL structure
    #
    # returns: unsigned integer, for example 0x0303 (TLS v1.2) with TLS 1.3</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_client_hello_get0_legacy_version.html">https://www.openssl.org/docs/manmaster/man3/SSL_client_hello_get0_legacy_version.html</a></p>

</li>
<li><p>client_hello_get0_random, client_hello_get0_session_id, client_hello_get0_ciphers and client_hello_get0_compression_methods</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.1pre1, not in LibreSSL</p>

<p><b>NOTE:</b> to be used only from a callback set with <a href="https://metacpan.org/pod/CTX_set_client_hello_cb">CTX_set_client_hello_cb</a>.</p>

<p>These functions return random, session_id, cipher_suites and compression_methods fields from the ClientHello, respectively.</p>

<pre><code>    my $random = client_hello_get0_random($s);
    my $session_id = client_hello_get0_session_id($s);
    my $ciphers = client_hello_get0_ciphers($s);
    my $compression_methods = client_hello_get0_compression_methods($s);
    # $s - value corresponding to openssl&#39;s SSL structure
    #
    # returns: raw octet data where data length, zero or more, depends on the field definition</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_client_hello_get0_random.html">https://www.openssl.org/docs/manmaster/man3/SSL_client_hello_get0_random.html</a></p>

</li>
<li><p>client_hello_get1_extensions_present and client_hello_get_extension_order</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.1pre1, not in LibreSSL</p>

<p><b>NOTE:</b> to be used only from a callback set with <a href="https://metacpan.org/pod/CTX_set_client_hello_cb">CTX_set_client_hello_cb</a>.</p>

<p>Returns a reference to an array holding the numerical value of the TLS extension types in the order they appear in the ClientHello. client_hello_get_extension_order is similar and requires at least OpenSSL 3.2.0, not in LibreSSL.</p>

<pre><code>    my $ref = client_hello_get1_extensions_present($s);
    # $s - value corresponding to openssl&#39;s SSL structure
    #
    # returns: an array reference of zero or more extension types or undef on failure</code></pre>

<p>Example from a TLS 1.3 ClientHello:</p>

<pre><code>    sub client_hello_cb {
        my ($ssl, $arg) = @_;
        my $ref = client_hello_get1_extensions_present($ssl);
        print join(&#39; &#39;, @$ref), &quot;\n&quot; if $ref;
    }</code></pre>

<p>Prints: <code>11 10 35 22 23 13 43 45 51</code></p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_client_hello_get1_extensions_present.html">https://www.openssl.org/docs/manmaster/man3/SSL_client_hello_get1_extensions_present.html</a></p>

</li>
<li><p>client_hello_get0_ext</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.1pre1, not in LibreSSL</p>

<p><b>NOTE:</b> to be used only from a callback set with <a href="https://metacpan.org/pod/CTX_set_client_hello_cb">CTX_set_client_hello_cb</a>.</p>

<p>Returns an extension by type number from the ClientHello.</p>

<pre><code>    my $ref = client_hello_get1_extensions_present($s, $type);
    # $s - value corresponding to openssl&#39;s SSL structure
    # $type - (integer) extension type number
    #
    # returns: zero or more octets of extension contents including extension length, undef if the extension is not present</code></pre>

<p>Example: Get the value of TLS extension <code>supported_versions</code>. You can use constant <code>TLSEXT_TYPE_supported_versions</code> or 43 directly.</p>

<pre><code>    sub client_hello_cb {
        my ($ssl, $arg) = @_;
        my $ext_ver = Net::SSLeay::client_hello_get0_ext($ssl, Net::SSLeay::TLSEXT_TYPE_supported_versions());
        print unpack(&#39;H*&#39;, $ext_ver), &quot;\n&quot; if defined $ext_ver;
    }</code></pre>

<p>Prints: <code>080304030303020301</code> where the first octet 0x08 is the extension length and the following four 16bit values correspond to TLS versions 1.3, 1.2, 1.1 and 1.0.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_client_hello_get0_ext.html">https://www.openssl.org/docs/manmaster/man3/SSL_client_hello_get0_ext.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-RAND_*-related-functions"><a id="Low13"></a><a id="Low-level-API:-RAND_--related-functions"></a>Low level API: RAND_* related functions</h3>

<p>Check openssl doc related to RAND stuff <a href="https://www.openssl.org/docs/manmaster/man3/rand.html">https://www.openssl.org/docs/manmaster/man3/rand.html</a></p>

<ul>

<li><p>RAND_add</p>

<p>Mixes the $num bytes at $buf into the PRNG state.</p>

<pre><code>    Net::SSLeay::RAND_add($buf, $num, $entropy);
    # $buf - buffer with data to be mixed into the PRNG state
    # $num - number of bytes in $buf
    # $entropy - estimate of how much randomness is contained in $buf (in bytes)
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RAND_add.html">https://www.openssl.org/docs/manmaster/man3/RAND_add.html</a></p>

</li>
<li><p>RAND_seed</p>

<p>Equivalent to <a href="./Net::SSLeay.html#RAND_add">&quot;RAND_add&quot;</a> when $num == $entropy.</p>

<pre><code>    Net::SSLeay::RAND_seed($buf);   # Perlishly figures out buf size
    # $buf - buffer with data to be mixed into the PRNG state
    # $num - number of bytes in $buf
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RAND_add.html">https://www.openssl.org/docs/manmaster/man3/RAND_add.html</a></p>

</li>
<li><p>RAND_status</p>

<p>Gives PRNG status (seeded enough or not).</p>

<pre><code>    my $rv = Net::SSLeay::RAND_status();
    # returns: 1 if the PRNG has been seeded with enough data, 0 otherwise</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RAND_add.html">https://www.openssl.org/docs/manmaster/man3/RAND_add.html</a></p>

</li>
<li><p>RAND_bytes</p>

<p>Puts $num cryptographically strong pseudo-random bytes into $buf.</p>

<pre><code>    my $rv = Net::SSLeay::RAND_bytes($buf, $num);
    # $buf - buffer where the random data will be stored
    # $num - the size (in bytes) of requested random data
    #
    # returns: 1 on success, -1 if not supported by the current RAND method, or 0 on other failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RAND_bytes.html">https://www.openssl.org/docs/manmaster/man3/RAND_bytes.html</a></p>

</li>
<li><p>RAND_priv_bytes</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>

<p>Puts $num cryptographically strong pseudo-random bytes into $buf.</p>

<pre><code>    my $rv = Net::SSLeay::RAND_priv_bytes($buf, $num);
    # $buf - buffer where the random data will be stored
    # $num - the size (in bytes) of requested random data
    #
    # returns: 1 on success, -1 if not supported by the current RAND method, or 0 on other failure</code></pre>

<p>RAND_priv_bytes has the same semantics as RAND_bytes, but see see the documentation for more information.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RAND_priv_bytes.html">https://www.openssl.org/docs/manmaster/man3/RAND_priv_bytes.html</a></p>

</li>
<li><p>RAND_pseudo_bytes</p>

<p>Puts $num pseudo-random (not necessarily unpredictable) bytes into $buf.</p>

<pre><code>    my $rv = Net::SSLeay::RAND_pseudo_bytes($buf, $num);
    # $buf - buffer where the random data will be stored
    # $num - the size (in bytes) of requested random data
    #
    # returns: 1 if the bytes generated are cryptographically strong, 0 otherwise</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RAND_bytes.html">https://www.openssl.org/docs/manmaster/man3/RAND_bytes.html</a></p>

</li>
<li><p>RAND_cleanup</p>

<p>Erase the PRNG state.</p>

<pre><code>    Net::SSLeay::RAND_cleanup();
    # no args, no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RAND_cleanup.html">https://www.openssl.org/docs/manmaster/man3/RAND_cleanup.html</a></p>

</li>
<li><p>RAND_egd_bytes</p>

<p>Queries the entropy gathering daemon EGD on socket $path for $bytes bytes.</p>

<pre><code>    my $rv = Net::SSLeay::RAND_egd_bytes($path, $bytes);
    # $path - path to a socket of entropy gathering daemon EGD
    # $bytes - number of bytes we want from EGD
    #
    # returns: the number of bytes read from the daemon on success, and -1 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RAND_egd.html">https://www.openssl.org/docs/manmaster/man3/RAND_egd.html</a></p>

</li>
<li><p>RAND_file_name</p>

<p>Generates a default path for the random seed file.</p>

<pre><code>    my $file = Net::SSLeay::RAND_file_name($num);
    # $num - maximum size of returned file name
    #
    # returns: string with file name on success, &#39;&#39; (empty string) or undef on failure</code></pre>

<p>LibreSSL and OpenSSL 1.1.0a and later return undef when, for example, $num is not large enough to hold the filename.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RAND_load_file.html">https://www.openssl.org/docs/manmaster/man3/RAND_load_file.html</a></p>

</li>
<li><p>RAND_load_file</p>

<p><b>COMPATIBILITY:</b> Is no longer functional on LibreSSL</p>

<p>Reads $max_bytes of bytes from $file_name and adds them to the PRNG.</p>

<pre><code>    my $rv = Net::SSLeay::RAND_load_file($file_name, $max_bytes);
    # $file_name - the name of file
    # $max_bytes - bytes to read from $file_name; -1 =&gt; the complete file is read
    #
    # returns: the number of bytes read</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RAND_load_file.html">https://www.openssl.org/docs/manmaster/man3/RAND_load_file.html</a></p>

</li>
<li><p>RAND_write_file</p>

<p>Writes 1024 random bytes to $file_name which can be used to initialize the PRNG by calling <a href="./Net::SSLeay.html#RAND_load_file">&quot;RAND_load_file&quot;</a> in a later session.</p>

<pre><code>    my $rv = Net::SSLeay::RAND_write_file($file_name);
    # $file_name - the name of file
    #
    # returns: the number of bytes written, and -1 if the bytes written were generated without appropriate seed</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RAND_load_file.html">https://www.openssl.org/docs/manmaster/man3/RAND_load_file.html</a></p>

</li>
<li><p>RAND_poll</p>

<p>Collects some entropy from operating system and adds it to the PRNG.</p>

<pre><code>    my $rv = Net::SSLeay::RAND_poll();
    # returns: 1 on success, 0 on failure (unable to gather reasonable entropy)</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-OBJ_*-related-functions"><a id="Low14"></a><a id="Low-level-API:-OBJ_--related-functions"></a>Low level API: OBJ_* related functions</h3>

<ul>

<li><p>OBJ_cmp</p>

<p>Compares ASN1_OBJECT $a to ASN1_OBJECT $b.</p>

<pre><code>    my $rv = Net::SSLeay::OBJ_cmp($a, $b);
    # $a - value corresponding to openssl&#39;s ASN1_OBJECT structure
    # $b - value corresponding to openssl&#39;s ASN1_OBJECT structure
    #
    # returns: if the two are identical 0 is returned</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html">https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html</a></p>

</li>
<li><p>OBJ_dup</p>

<p>Returns a copy/duplicate of $o.</p>

<pre><code>    my $rv = Net::SSLeay::OBJ_dup($o);
    # $o - value corresponding to openssl&#39;s ASN1_OBJECT structure
    #
    # returns: value corresponding to openssl&#39;s ASN1_OBJECT structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html">https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html</a></p>

</li>
<li><p>OBJ_nid2ln</p>

<p>Returns long name for given NID $n.</p>

<pre><code>    my $rv = Net::SSLeay::OBJ_nid2ln($n);
    # $n - (integer) NID
    #
    # returns: (string) long name e.g. &#39;commonName&#39;</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html">https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html</a></p>

</li>
<li><p>OBJ_ln2nid</p>

<p>Returns NID corresponding to given long name $n.</p>

<pre><code>    my $rv = Net::SSLeay::OBJ_ln2nid($s);
    # $s - (string) long name e.g. &#39;commonName&#39;
    #
    # returns: (integer) NID</code></pre>

</li>
<li><p>OBJ_nid2sn</p>

<p>Returns short name for given NID $n.</p>

<pre><code>    my $rv = Net::SSLeay::OBJ_nid2sn($n);
    # $n - (integer) NID
    #
    # returns: (string) short name e.g. &#39;CN&#39;</code></pre>

<p>Example:</p>

<pre><code>    print Net::SSLeay::OBJ_nid2sn(&amp;Net::SSLeay::NID_commonName);</code></pre>

</li>
<li><p>OBJ_sn2nid</p>

<p>Returns NID corresponding to given short name $s.</p>

<pre><code>    my $rv = Net::SSLeay::OBJ_sn2nid($s);
    # $s - (string) short name e.g. &#39;CN&#39;
    #
    # returns: (integer) NID</code></pre>

<p>Example:</p>

<pre><code>    print &quot;NID_commonName constant=&quot;, &amp;Net::SSLeay::NID_commonName;
    print &quot;OBJ_sn2nid(&#39;CN&#39;)=&quot;, Net::SSLeay::OBJ_sn2nid(&#39;CN&#39;);</code></pre>

</li>
<li><p>OBJ_nid2obj</p>

<p>Returns ASN1_OBJECT for given NID $n.</p>

<pre><code>    my $rv = Net::SSLeay::OBJ_nid2obj($n);
    # $n - (integer) NID
    #
    # returns: value corresponding to openssl&#39;s ASN1_OBJECT structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html">https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html</a></p>

</li>
<li><p>OBJ_obj2nid</p>

<p>Returns NID corresponding to given ASN1_OBJECT $o.</p>

<pre><code>    my $rv = Net::SSLeay::OBJ_obj2nid($o);
    # $o - value corresponding to openssl&#39;s ASN1_OBJECT structure
    #
    # returns: (integer) NID</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html">https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html</a></p>

</li>
<li><p>OBJ_txt2obj</p>

<p>Converts the text string s into an ASN1_OBJECT structure. If $no_name is 0 then long names (e.g. &#39;commonName&#39;) and short names (e.g. &#39;CN&#39;) will be interpreted as well as numerical forms (e.g. &#39;2.5.4.3&#39;). If $no_name is 1 only the numerical form is acceptable.</p>

<pre><code>    my $rv = Net::SSLeay::OBJ_txt2obj($s, $no_name);
    # $s - text string to be converted
    # $no_name - (integer) 0 or 1
    #
    # returns: value corresponding to openssl&#39;s ASN1_OBJECT structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html">https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html</a></p>

</li>
<li><p>OBJ_obj2txt</p>

<p>Converts the ASN1_OBJECT a into a textual representation.</p>

<pre><code>    Net::SSLeay::OBJ_obj2txt($a, $no_name);
    # $a - value corresponding to openssl&#39;s ASN1_OBJECT structure
    # $no_name - (integer) 0 or 1
    #
    # returns: textual representation e.g. &#39;commonName&#39; ($no_name=0), &#39;2.5.4.3&#39; ($no_name=1)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html">https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html</a></p>

</li>
<li><p>OBJ_txt2nid</p>

<p>Returns NID corresponding to text string $s which can be a long name, a short name or the numerical representation of an object.</p>

<pre><code>    my $rv = Net::SSLeay::OBJ_txt2nid($s);
    # $s - (string) e.g. &#39;commonName&#39; or &#39;CN&#39; or &#39;2.5.4.3&#39;
    #
    # returns: (integer) NID</code></pre>

<p>Example:</p>

<pre><code>    my $nid = Net::SSLeay::OBJ_txt2nid(&#39;2.5.4.3&#39;);
    Net::SSLeay::OBJ_nid2sn($n);</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html">https://www.openssl.org/docs/manmaster/man3/OBJ_nid2obj.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-ASN1_INTEGER_*-related-functions"><a id="Low15"></a><a id="Low-level-API:-ASN1_INTEGER_--related-functions"></a>Low level API: ASN1_INTEGER_* related functions</h3>

<ul>

<li><p>ASN1_INTEGER_new</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Creates a new ASN1_INTEGER structure.</p>

<pre><code>    my $rv = Net::SSLeay::ASN1_INTEGER_new();
    #
    # returns: value corresponding to openssl&#39;s ASN1_INTEGER structure (0 on failure)</code></pre>

</li>
<li><p>ASN1_INTEGER_free</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Free an allocated ASN1_INTEGER structure.</p>

<pre><code>    Net::SSLeay::ASN1_INTEGER_free($i);
    # $i - value corresponding to openssl&#39;s ASN1_INTEGER structure
    #
    # returns: no return value</code></pre>

</li>
<li><p>ASN1_INTEGER_get</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns integer value of given ASN1_INTEGER object.</p>

<p><b>BEWARE:</b> If the value stored in ASN1_INTEGER is greater than max. integer that can be stored in &#39;long&#39; type (usually 32bit but may vary according to platform) then this function will return -1. For getting large ASN1_INTEGER values consider using <a href="./Net::SSLeay.html#P_ASN1_INTEGER_get_dec">&quot;P_ASN1_INTEGER_get_dec&quot;</a> or <a href="./Net::SSLeay.html#P_ASN1_INTEGER_get_hex">&quot;P_ASN1_INTEGER_get_hex&quot;</a>.</p>

<pre><code>    my $rv = Net::SSLeay::ASN1_INTEGER_get($a);
    # $a - value corresponding to openssl&#39;s ASN1_INTEGER structure
    #
    # returns: integer value of ASN1_INTEGER object in $a</code></pre>

</li>
<li><p>ASN1_INTEGER_set</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sets value of given ASN1_INTEGER object to value $val</p>

<p><b>BEWARE:</b> $val has max. limit (= max. integer that can be stored in &#39;long&#39; type). For setting large ASN1_INTEGER values consider using <a href="./Net::SSLeay.html#P_ASN1_INTEGER_set_dec">&quot;P_ASN1_INTEGER_set_dec&quot;</a> or <a href="./Net::SSLeay.html#P_ASN1_INTEGER_set_hex">&quot;P_ASN1_INTEGER_set_hex&quot;</a>.</p>

<pre><code>    my $rv = Net::SSLeay::ASN1_INTEGER_set($i, $val);
    # $i - value corresponding to openssl&#39;s ASN1_INTEGER structure
    # $val - integer value
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>P_ASN1_INTEGER_get_dec</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns string with decimal representation of integer value of given ASN1_INTEGER object.</p>

<pre><code>    Net::SSLeay::P_ASN1_INTEGER_get_dec($i);
    # $i - value corresponding to openssl&#39;s ASN1_INTEGER structure
    #
    # returns: string with decimal representation</code></pre>

</li>
<li><p>P_ASN1_INTEGER_get_hex</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns string with hexadecimal representation of integer value of given ASN1_INTEGER object.</p>

<pre><code>    Net::SSLeay::P_ASN1_INTEGER_get_hex($i);
    # $i - value corresponding to openssl&#39;s ASN1_INTEGER structure
    #
    # returns: string with hexadecimal representation</code></pre>

</li>
<li><p>P_ASN1_INTEGER_set_dec</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sets value of given ASN1_INTEGER object to value $val (decimal string, suitable for large integers)</p>

<pre><code>    Net::SSLeay::P_ASN1_INTEGER_set_dec($i, $str);
    # $i - value corresponding to openssl&#39;s ASN1_INTEGER structure
    # $str - string with decimal representation
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>P_ASN1_INTEGER_set_hex</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sets value of given ASN1_INTEGER object to value $val (hexadecimal string, suitable for large integers)</p>

<pre><code>    Net::SSLeay::P_ASN1_INTEGER_set_hex($i, $str);
    # $i - value corresponding to openssl&#39;s ASN1_INTEGER structure
    # $str - string with hexadecimal representation
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-ASN1_STRING_*-related-functions"><a id="Low16"></a><a id="Low-level-API:-ASN1_STRING_--related-functions"></a>Low level API: ASN1_STRING_* related functions</h3>

<ul>

<li><p>P_ASN1_STRING_get</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns string value of given ASN1_STRING object.</p>

<pre><code>    Net::SSLeay::P_ASN1_STRING_get($s, $utf8_decode);
    # $s - value corresponding to openssl&#39;s ASN1_STRING structure
    # $utf8_decode - [optional] 0 or 1 whether the returned value should be utf8 decoded (default=0)
    #
    # returns: string

    $string = Net::SSLeay::P_ASN1_STRING_get($s);
    # is the same as:
    $string = Net::SSLeay::P_ASN1_STRING_get($s, 0);</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-ASN1_TIME_*-related-functions"><a id="Low17"></a><a id="Low-level-API:-ASN1_TIME_--related-functions"></a>Low level API: ASN1_TIME_* related functions</h3>

<ul>

<li><p>ASN1_TIME_new</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<pre><code>    my $time = ASN1_TIME_new();
    # returns: value corresponding to openssl&#39;s ASN1_TIME structure</code></pre>

</li>
<li><p>ASN1_TIME_free</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<pre><code>    ASN1_TIME_free($time);
    # $time - value corresponding to openssl&#39;s ASN1_TIME structure</code></pre>

</li>
<li><p>ASN1_TIME_set</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<pre><code>    ASN1_TIME_set($time, $t);
    # $time - value corresponding to openssl&#39;s ASN1_TIME structure
    # $t - time value in seconds since 1.1.1970</code></pre>

<p><b>BEWARE:</b> It is platform dependent how this function will handle dates after 2038. Although perl&#39;s integer is large enough the internal implementation of this function is dependent on the size of time_t structure (32bit time_t has problem with 2038).</p>

<p>If you want to safely set date and time after 2038 use function <a href="./Net::SSLeay.html#P_ASN1_TIME_set_isotime">&quot;P_ASN1_TIME_set_isotime&quot;</a>.</p>

</li>
<li><p>P_ASN1_TIME_get_isotime</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<p><b>NOTE:</b> Does not exactly correspond to any low level API function</p>

<p>Gives ISO-8601 string representation of ASN1_TIME structure.</p>

<pre><code>    my $datetime_string = P_ASN1_TIME_get_isotime($time);
    # $time - value corresponding to openssl&#39;s ASN1_TIME structure
    #
    # returns: datetime string like &#39;2033-05-16T20:39:37Z&#39; or &#39;&#39; on failure</code></pre>

<p>The output format is compatible with module <a href="https://metacpan.org/pod/DateTime::Format::RFC3339">DateTime::Format::RFC3339</a></p>

</li>
<li><p>P_ASN1_TIME_set_isotime</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<p><b>NOTE:</b> Does not exactly correspond to any low level API function</p>

<p>Sets time and date value of ANS1_time structure.</p>

<pre><code>    my $rv = P_ASN1_TIME_set_isotime($time, $string);
    # $time - value corresponding to openssl&#39;s ASN1_TIME structure
    # $string - ISO-8601 timedate string like &#39;2033-05-16T20:39:37Z&#39;
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>The <code>$string</code> parameter has to be in full form like <code>&quot;2012-03-22T23:55:33&quot;</code> or <code>&quot;2012-03-22T23:55:33Z&quot;</code> or <code>&quot;2012-03-22T23:55:33CET&quot;</code>. Short forms like <code>&quot;2012-03-22T23:55&quot;</code> or <code>&quot;2012-03-22&quot;</code> are not supported.</p>

</li>
<li><p>P_ASN1_TIME_put2string</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before, has bugs with OpenSSL 0.9.8i</p>

<p><b>NOTE:</b> Does not exactly correspond to any low level API function</p>

<p>Gives string representation of ASN1_TIME structure.</p>

<pre><code>    my $str = P_ASN1_TIME_put2string($time);
    # $time - value corresponding to openssl&#39;s ASN1_TIME structure
    #
    # returns: datetime string like &#39;May 16 20:39:37 2033 GMT&#39;</code></pre>

</li>
<li><p>P_ASN1_UTCTIME_put2string</p>

<p><b>NOTE:</b> deprecated function, only for backward compatibility, just an alias for <a href="./Net::SSLeay.html#P_ASN1_TIME_put2string">&quot;P_ASN1_TIME_put2string&quot;</a></p>

</li>
</ul>

<h3 id="Low-level-API:-X509_*-related-functions"><a id="Low18"></a><a id="Low-level-API:-X509_--related-functions"></a>Low level API: X509_* related functions</h3>

<ul>

<li><p>X509_new</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Allocates and initializes a X509 structure.</p>

<pre><code>    my $rv = Net::SSLeay::X509_new();
    #
    # returns: value corresponding to openssl&#39;s X509 structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_new.html">https://www.openssl.org/docs/manmaster/man3/X509_new.html</a></p>

</li>
<li><p>X509_free</p>

<p>Frees up the X509 structure.</p>

<pre><code>    Net::SSLeay::X509_free($a);
    # $a - value corresponding to openssl&#39;s X509 structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_new.html">https://www.openssl.org/docs/manmaster/man3/X509_new.html</a></p>

</li>
<li><p>X509_check_host</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.68 and before; requires at least OpenSSL 1.0.2. X509_CHECK_FLAG_NEVER_CHECK_SUBJECT requires OpenSSL 1.1.0.</p>

<p>Checks if the certificate Subject Alternative Name (SAN) or Subject CommonName (CN) matches the specified host name.</p>

<pre><code>    my $rv = Net::SSLeay::X509_check_host($cert, $name, $flags, $peername);
    # $cert - value corresponding to openssl&#39;s X509 structure
    # $name - host name to check
    # $flags (optional, default: 0) - can be the bitwise OR of:
    #   &amp;Net::SSLeay::X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT
    #   &amp;Net::SSLeay::X509_CHECK_FLAG_NO_WILDCARDS
    #   &amp;Net::SSLeay::X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS
    #   &amp;Net::SSLeay::X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS
    #   &amp;Net::SSLeay::X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS
    #   &amp;Net::SSLeay::X509_CHECK_FLAG_NEVER_CHECK_SUBJECT
    # $peername (optional) - If not omitted and $host matches $cert,
    #                        a copy of the matching SAN or CN from
    #                        the peer certificate is stored in $peername.
    #
    # returns:
    #   1 for a successful match
    #   0 for a failed match
    #  -1 for an internal error
    #  -2 if the input is malformed</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_check_host.html">https://www.openssl.org/docs/manmaster/man3/X509_check_host.html</a>.</p>

</li>
<li><p>X509_check_email</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.68 and before; requires at least OpenSSL 1.0.2.</p>

<p>Checks if the certificate matches the specified email address.</p>

<pre><code>    my $rv = Net::SSLeay::X509_check_email($cert, $address, $flags);
    # $cert - value corresponding to openssl&#39;s X509 structure
    # $address - email address to check
    # $flags (optional, default: 0) - see X509_check_host()
    #
    # returns: see X509_check_host()</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_check_email.html">https://www.openssl.org/docs/manmaster/man3/X509_check_email.html</a>.</p>

</li>
<li><p>X509_check_ip</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.68 and before; requires at least OpenSSL 1.0.2.</p>

<p>Checks if the certificate matches the specified IPv4 or IPv6 address.</p>

<pre><code>    my $rv = Net::SSLeay::X509_check_ip($cert, $address, $flags);
    # $cert - value corresponding to openssl&#39;s X509 structure
    # $address - IP address to check in binary format, in network byte order
    # $flags (optional, default: 0) - see X509_check_host()
    #
    # returns: see X509_check_host()</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_check_ip.html">https://www.openssl.org/docs/manmaster/man3/X509_check_ip.html</a>.</p>

</li>
<li><p>X509_check_ip_asc</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.68 and before; requires at least OpenSSL 1.0.2.</p>

<p>Checks if the certificate matches the specified IPv4 or IPv6 address.</p>

<pre><code>    my $rv = Net::SSLeay::X509_check_ip_asc($cert, $address, $flags);
    # $cert - value corresponding to openssl&#39;s X509 structure
    # $address - IP address to check in text representation
    # $flags (optional, default: 0) - see X509_check_host()
    #
    # returns: see X509_check_host()</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_check_ip_asc.html">https://www.openssl.org/docs/manmaster/man3/X509_check_ip_asc.html</a>.</p>

</li>
<li><p>X509_certificate_type</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns bitmask with type of certificate $x.</p>

<pre><code>    my $rv = Net::SSLeay::X509_certificate_type($x);
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: (integer) bitmask with certificate type

    # to decode bitmask returned by this function use these constants:
    # &amp;Net::SSLeay::EVP_PKS_DSA
    # &amp;Net::SSLeay::EVP_PKS_EC
    # &amp;Net::SSLeay::EVP_PKS_RSA
    # &amp;Net::SSLeay::EVP_PKT_ENC
    # &amp;Net::SSLeay::EVP_PKT_EXCH
    # &amp;Net::SSLeay::EVP_PKT_EXP
    # &amp;Net::SSLeay::EVP_PKT_SIGN
    # &amp;Net::SSLeay::EVP_PK_DH
    # &amp;Net::SSLeay::EVP_PK_DSA
    # &amp;Net::SSLeay::EVP_PK_EC
    # &amp;Net::SSLeay::EVP_PK_RSA</code></pre>

</li>
<li><p>X509_digest</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Computes digest/fingerprint of X509 $data using $type hash function.</p>

<pre><code>    my $digest_value = Net::SSLeay::X509_digest($data, $type);
    # $data - value corresponding to openssl&#39;s X509 structure
    # $type - value corresponding to openssl&#39;s EVP_MD structure - e.g. got via EVP_get_digestbyname()
    #
    # returns: hash value (binary)

    # to get printable (hex) value of digest use:
    print unpack(&#39;H*&#39;, $digest_value);</code></pre>

</li>
<li><p>X509_issuer_and_serial_hash</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sort of a checksum of issuer name and serial number of X509 certificate $x. The result is not a full hash (e.g. sha-1), it is kind-of-a-hash truncated to the size of &#39;unsigned long&#39; (32 bits). The resulting value might differ across different openssl versions for the same X509 certificate.</p>

<pre><code>    my $rv = Net::SSLeay::X509_issuer_and_serial_hash($x);
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: number representing checksum</code></pre>

</li>
<li><p>X509_issuer_name_hash</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sort of a checksum of issuer name of X509 certificate $x. The result is not a full hash (e.g. sha-1), it is kind-of-a-hash truncated to the size of &#39;unsigned long&#39; (32 bits). The resulting value might differ across different openssl versions for the same X509 certificate.</p>

<pre><code>    my $rv = Net::SSLeay::X509_issuer_name_hash($x);
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: number representing checksum</code></pre>

</li>
<li><p>X509_subject_name_hash</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sort of a checksum of subject name of X509 certificate $x. The result is not a full hash (e.g. sha-1), it is kind-of-a-hash truncated to the size of &#39;unsigned long&#39; (32 bits). The resulting value might differ across different openssl versions for the same X509 certificate.</p>

<pre><code>    my $rv = Net::SSLeay::X509_subject_name_hash($x);
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: number representing checksum</code></pre>

</li>
<li><p>X509_pubkey_digest</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Computes digest/fingerprint of public key from X509 certificate $data using $type hash function.</p>

<pre><code>    my $digest_value = Net::SSLeay::X509_pubkey_digest($data, $type);
    # $data - value corresponding to openssl&#39;s X509 structure
    # $type - value corresponding to openssl&#39;s EVP_MD structure - e.g. got via EVP_get_digestbyname()
    #
    # returns: hash value (binary)

    # to get printable (hex) value of digest use:
    print unpack(&#39;H*&#39;, $digest_value);</code></pre>

</li>
<li><p>X509_set_issuer_name</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sets issuer of X509 certificate $x to $name.</p>

<pre><code>    my $rv = Net::SSLeay::X509_set_issuer_name($x, $name);
    # $x - value corresponding to openssl&#39;s X509 structure
    # $name - value corresponding to openssl&#39;s X509_NAME structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_set_pubkey</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sets public key of X509 certificate $x to $pkey.</p>

<pre><code>    my $rv = Net::SSLeay::X509_set_pubkey($x, $pkey);
    # $x - value corresponding to openssl&#39;s X509 structure
    # $pkey - value corresponding to openssl&#39;s EVP_PKEY structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_set_serialNumber</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sets serial number of X509 certificate $x to $serial.</p>

<pre><code>    my $rv = Net::SSLeay::X509_set_serialNumber($x, $serial);
    # $x - value corresponding to openssl&#39;s X509 structure
    # $serial - value corresponding to openssl&#39;s ASN1_INTEGER structure
    #
    # returns: 1 on success, 0 on failure

    # to create $serial value use one of these:
    $serial = Net::SSLeay::P_ASN1_INTEGER_set_hex(&#39;45ad6f&#39;);
    $serial = Net::SSLeay::P_ASN1_INTEGER_set_dec(&#39;7896541238529631478&#39;);
    $serial = Net::SSLeay::ASN1_INTEGER_set(45896);</code></pre>

</li>
<li><p>X509_set_subject_name</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sets subject of X509 certificate $x to $name.</p>

<pre><code>    my $rv = Net::SSLeay::X509_set_subject_name($x, $name);
    # $x - value corresponding to openssl&#39;s X509 structure
    # $name - value corresponding to openssl&#39;s X509_NAME structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_set_version</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Set &#39;version&#39; value for X509 certificate $ to $version.</p>

<pre><code>    my $rv = Net::SSLeay::X509_set_version($x, $version);
    # $x - value corresponding to openssl&#39;s X509 structure
    # $version - (integer) version number
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_sign</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sign X509 certificate $x with private key $pkey (using digest algorithm $md).</p>

<pre><code>    my $rv = Net::SSLeay::X509_sign($x, $pkey, $md);
    # $x - value corresponding to openssl&#39;s X509 structure
    # $pkey - value corresponding to openssl&#39;s EVP_PKEY structure
    # $md - value corresponding to openssl&#39;s EVP_MD structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_verify</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Verifies X509 object $a using public key $r (pubkey of issuing CA).</p>

<pre><code>    my $rv = Net::SSLeay::X509_verify($x, $r);
    # $x - value corresponding to openssl&#39;s X509 structure
    # $r - value corresponding to openssl&#39;s EVP_PKEY structure
    #
    # returns: 0 - verify failure, 1 - verify OK, &lt;0 - error</code></pre>

</li>
<li><p>X509_get_ext_count</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns the total number of extensions in X509 object $x.</p>

<pre><code>    my $rv = Net::SSLeay::X509_get_ext_count($x);
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: count of extensions</code></pre>

</li>
<li><p>X509_get_pubkey</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns public key corresponding to given X509 object $x.</p>

<pre><code>    my $rv = Net::SSLeay::X509_get_pubkey($x);
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: value corresponding to openssl&#39;s EVP_PKEY structure (0 on failure)</code></pre>

<p><b>NOTE:</b> This method returns only the public key&#39;s key bits, without the algorithm or parameters. Use <code>X509_get_X509_PUBKEY()</code> to return the full public key (SPKI) instead.</p>

</li>
<li><p>X509_get_X509_PUBKEY</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.72 and before</p>

<p>Returns the full public key (SPKI) of given X509 certificate $x.</p>

<pre><code>    Net::SSLeay::X509_get_X509_PUBKEY($x);
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: public key data in DER format (binary)</code></pre>

</li>
<li><p>X509_get_serialNumber</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns serial number of X509 certificate $x.</p>

<pre><code>    my $rv = Net::SSLeay::X509_get_serialNumber($x);
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: value corresponding to openssl&#39;s ASN1_INTEGER structure (0 on failure)</code></pre>

<p>See <a href="./Net::SSLeay.html#P_ASN1_INTEGER_get_dec">&quot;P_ASN1_INTEGER_get_dec&quot;</a>, <a href="./Net::SSLeay.html#P_ASN1_INTEGER_get_hex">&quot;P_ASN1_INTEGER_get_hex&quot;</a> or <a href="./Net::SSLeay.html#ASN1_INTEGER_get">&quot;ASN1_INTEGER_get&quot;</a> to decode ASN1_INTEGER object.</p>

</li>
<li><p>X509_get0_serialNumber</p>

<p><b>COMPATIBILITY:</b> available in Net-SSLeay-1.86 onwards</p>

<p>X509_get0_serialNumber() is the same as X509_get_serialNumber() except it accepts a const parameter and returns a const result.</p>

</li>
<li><p>X509_get_version</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns &#39;version&#39; value of given X509 certificate $x.</p>

<pre><code>    my $rv = Net::SSLeay::X509_get_version($x);
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: (integer) version</code></pre>

</li>
<li><p>X509_get_ext</p>

<p>Returns X509_EXTENSION from $x509 based on given position/index.</p>

<pre><code>    my $rv = Net::SSLeay::X509_get_ext($x509, $index);
    # $x509 - value corresponding to openssl&#39;s X509 structure
    # $index - (integer) position/index of extension within $x509
    #
    # returns: value corresponding to openssl&#39;s X509_EXTENSION structure (0 on failure)</code></pre>

</li>
<li><p>X509_get_ext_by_NID</p>

<p>Returns X509_EXTENSION from $x509 based on given NID.</p>

<pre><code>    my $rv = Net::SSLeay::X509_get_ext_by_NID($x509, $nid, $loc);
    # $x509 - value corresponding to openssl&#39;s X509 structure
    # $nid - (integer) NID value
    # $loc - (integer) position to start lookup at
    #
    # returns: position/index of extension, negative value on error
    #          call Net::SSLeay::X509_get_ext($x509, $rv) to get the actual extension</code></pre>

</li>
<li><p>X509_get_fingerprint</p>

<p>Returns fingerprint of certificate $cert.</p>

<p><b>NOTE:</b> Does not exactly correspond to any low level API function. The implementation is based on openssl&#39;s <code>X509_digest()</code>.</p>

<pre><code>    Net::SSLeay::X509_get_fingerprint($x509, $type);
    # $x509 - value corresponding to openssl&#39;s X509 structure
    # $type - (string) digest type, currently supported values:
    #         &quot;md5&quot;
    #         &quot;sha1&quot;
    #         &quot;sha256&quot;
    #         &quot;ripemd160&quot;
    #
    # returns: certificate digest - hexadecimal string (NOT binary data!)</code></pre>

</li>
<li><p>X509_get_issuer_name</p>

<p>Return an X509_NAME object representing the issuer of the certificate $cert.</p>

<pre><code>    my $rv = Net::SSLeay::X509_get_issuer_name($cert);
    # $cert - value corresponding to openssl&#39;s X509 structure
    #
    # returns: value corresponding to openssl&#39;s X509_NAME structure (0 on failure)</code></pre>

</li>
<li><p>X509_get0_notAfter, X509_getm_notAfter and X509_get_notAfter</p>

<p><b>COMPATIBILITY:</b> X509_get0_notAfter and X509_getm_notAfter are not available in Net-SSLeay-1.92 and before</p>

<p>Return an object giving the time after which the certificate $cert is not valid.</p>

<pre><code>    my $rv  = Net::SSLeay::X509_get0_notAfter($cert);
    my $rvm = Net::SSLeay::X509_getm_notAfter($cert);
    # $cert - value corresponding to openssl&#39;s X509 structure
    #
    # returns: $rv  read-only value corresponding to openssl&#39;s ASN1_TIME structure
    #          $rvm mutable   value corresponding to openssl&#39;s ASN1_TIME structure</code></pre>

<p>To get human readable/printable form the return value you can use:</p>

<pre><code>    my $time = Net::SSLeay::X509_get_notAfter($cert);
    print &quot;notAfter=&quot;, Net::SSLeay::P_ASN1_TIME_get_isotime($time), &quot;\n&quot;;</code></pre>

<p><b>NOTE:</b> X509_get_notAfter is an alias and deprecated in OpenSSL 1.1.0 and later</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_get0_notAfter.html">https://www.openssl.org/docs/manmaster/man3/X509_get0_notAfter.html</a></p>

</li>
<li><p>X509_get0_notBefore, X509_getm_notBefore and X509_get_notBefore</p>

<p><b>COMPATIBILITY:</b> X509_get0_notBefore and X509_getm_notBefore are not available in Net-SSLeay-1.92 and before</p>

<p>Return an object giving the time before which the certificate $cert is not valid</p>

<pre><code>    my $rv  = Net::SSLeay::X509_get0_notBefore($cert);
    my $rvm = Net::SSLeay::X509_getm_notBefore($cert);
    # $cert - value corresponding to openssl&#39;s X509 structure
    #
    # returns: $rv  read-only value corresponding to openssl&#39;s ASN1_TIME structure
    #          $rvm mutable   value corresponding to openssl&#39;s ASN1_TIME structure</code></pre>

<p>To get human readable/printable form the return value you can use:</p>

<pre><code>    my $time = Net::SSLeay::X509_get_notBefore($cert);
    print &quot;notBefore=&quot;, Net::SSLeay::P_ASN1_TIME_get_isotime($time), &quot;\n&quot;;</code></pre>

<p><b>NOTE:</b> X509_get_notBefore is an alias and deprecated in OpenSSL 1.1.0 and later</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_get0_notBefore.html">https://www.openssl.org/docs/manmaster/man3/X509_get0_notBefore.html</a></p>

</li>
<li><p>X509_get_subjectAltNames</p>

<p><b>NOTE:</b> Does not exactly correspond to any low level API function.</p>

<p>Returns the list of alternative subject names from X509 certificate $cert.</p>

<pre><code>    my @rv = Net::SSLeay::X509_get_subjectAltNames($cert);
    # $cert - value corresponding to openssl&#39;s X509 structure
    #
    # returns: list containing pairs - name_type (integer), name_value (string)
    #          where name_type can be:
    #          0 - GEN_OTHERNAME
    #          1 - GEN_EMAIL
    #          2 - GEN_DNS
    #          3 - GEN_X400
    #          4 - GEN_DIRNAME
    #          5 - GEN_EDIPARTY
    #          6 - GEN_URI
    #          7 - GEN_IPADD
    #          8 - GEN_RID</code></pre>

<p>Note: type 7 - GEN_IPADD contains the IP address as a packed binary address. GEN_RID is available in Net-SSLeay-1.90 and later. Maximum length for returned RID string is currently 2500. Invalid and overly long RID values are skipped and not returned. GEN_X400 and GEN_EDIPARTY are not supported and will not be returned even when present in the certificate.</p>

</li>
<li><p>X509_get_subject_name</p>

<p>Returns the subject of the certificate $cert.</p>

<pre><code>    my $rv = Net::SSLeay::X509_get_subject_name($cert);
    # $cert - value corresponding to openssl&#39;s X509 structure
    #
    # returns: value corresponding to openssl&#39;s X509_NAME structure (0 on failure)</code></pre>

</li>
<li><p>X509_gmtime_adj</p>

<p>Adjust the ASN1_TIME object to the timestamp (in GMT).</p>

<pre><code>    my $rv = Net::SSLeay::X509_gmtime_adj($s, $adj);
    # $s - value corresponding to openssl&#39;s ASN1_TIME structure
    # $adj - timestamp (seconds since 1.1.1970)
    #
    # returns: value corresponding to openssl&#39;s ASN1_TIME structure (0 on failure)</code></pre>

<p><b>BEWARE:</b> this function may fail for dates after 2038 as it is dependent on time_t size on your system (32bit time_t does not work after 2038). Consider using <a href="./Net::SSLeay.html#P_ASN1_TIME_set_isotime">&quot;P_ASN1_TIME_set_isotime&quot;</a> instead).</p>

</li>
<li><p>X509_load_cert_crl_file</p>

<p>Takes PEM file and loads all X509 certificates and X509 CRLs from that file into X509_LOOKUP structure.</p>

<pre><code>    my $rv = Net::SSLeay::X509_load_cert_crl_file($ctx, $file, $type);
    # $ctx - value corresponding to openssl&#39;s X509_LOOKUP structure
    # $file - (string) file name
    # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
    #                          if not FILETYPE_PEM then behaves as Net::SSLeay::X509_load_cert_file()
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_load_cert_file</p>

<p>Loads/adds X509 certificate from $file to X509_LOOKUP structure</p>

<pre><code>    my $rv = Net::SSLeay::X509_load_cert_file($ctx, $file, $type);
    # $ctx - value corresponding to openssl&#39;s X509_LOOKUP structure
    # $file - (string) file name
    # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_load_crl_file</p>

<p>Loads/adds X509 CRL from $file to X509_LOOKUP structure</p>

<pre><code>    my $rv = Net::SSLeay::X509_load_crl_file($ctx, $file, $type);
    # $ctx - value corresponding to openssl&#39;s X509_LOOKUP structure
    # $file - (string) file name
    # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_policy_level_get0_node</p>

<p><b>COMPATIBILITY:</b> no longer available in LibreSSL 3.8.0 and later</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::X509_policy_level_get0_node($level, $i);
    # $level - value corresponding to openssl&#39;s X509_POLICY_LEVEL structure
    # $i - (integer) index/position
    #
    # returns: value corresponding to openssl&#39;s X509_POLICY_NODE structure (0 on failure)</code></pre>

</li>
<li><p>X509_policy_level_node_count</p>

<p><b>COMPATIBILITY:</b> no longer available in LibreSSL 3.8.0 and later</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::X509_policy_level_node_count($level);
    # $level - value corresponding to openssl&#39;s X509_POLICY_LEVEL structure
    #
    # returns: (integer) node count</code></pre>

</li>
<li><p>X509_policy_node_get0_parent</p>

<p><b>COMPATIBILITY:</b> no longer available in LibreSSL 3.8.0 and later</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::X509_policy_node_get0_parent($node);
    # $node - value corresponding to openssl&#39;s X509_POLICY_NODE structure
    #
    # returns: value corresponding to openssl&#39;s X509_POLICY_NODE structure (0 on failure)</code></pre>

</li>
<li><p>X509_policy_node_get0_policy</p>

<p><b>COMPATIBILITY:</b> no longer available in LibreSSL 3.8.0 and later</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::X509_policy_node_get0_policy($node);
    # $node - value corresponding to openssl&#39;s X509_POLICY_NODE structure
    #
    # returns: value corresponding to openssl&#39;s ASN1_OBJECT structure (0 on failure)</code></pre>

</li>
<li><p>X509_policy_node_get0_qualifiers</p>

<p><b>COMPATIBILITY:</b> no longer available in LibreSSL 3.8.0 and later</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::X509_policy_node_get0_qualifiers($node);
    # $node - value corresponding to openssl&#39;s X509_POLICY_NODE structure
    #
    # returns: value corresponding to openssl&#39;s STACK_OF(POLICYQUALINFO) structure (0 on failure)</code></pre>

</li>
<li><p>X509_policy_tree_free</p>

<p><b>COMPATIBILITY:</b> no longer available in LibreSSL 3.8.0 and later</p>

<p>??? (more info needed)</p>

<pre><code>    Net::SSLeay::X509_policy_tree_free($tree);
    # $tree - value corresponding to openssl&#39;s X509_POLICY_TREE structure
    #
    # returns: no return value</code></pre>

</li>
<li><p>X509_policy_tree_get0_level</p>

<p><b>COMPATIBILITY:</b> no longer available in LibreSSL 3.8.0 and later</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::X509_policy_tree_get0_level($tree, $i);
    # $tree - value corresponding to openssl&#39;s X509_POLICY_TREE structure
    # $i - (integer) level index
    #
    # returns: value corresponding to openssl&#39;s X509_POLICY_LEVEL structure (0 on failure)</code></pre>

</li>
<li><p>X509_policy_tree_get0_policies</p>

<p><b>COMPATIBILITY:</b> no longer available in LibreSSL 3.8.0 and later</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::X509_policy_tree_get0_policies($tree);
    # $tree - value corresponding to openssl&#39;s X509_POLICY_TREE structure
    #
    # returns: value corresponding to openssl&#39;s STACK_OF(X509_POLICY_NODE) structure (0 on failure)</code></pre>

</li>
<li><p>X509_policy_tree_get0_user_policies</p>

<p><b>COMPATIBILITY:</b> no longer available in LibreSSL 3.8.0 and later</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::X509_policy_tree_get0_user_policies($tree);
    # $tree - value corresponding to openssl&#39;s X509_POLICY_TREE structure
    #
    # returns: value corresponding to openssl&#39;s STACK_OF(X509_POLICY_NODE) structure (0 on failure)</code></pre>

</li>
<li><p>X509_policy_tree_level_count</p>

<p><b>COMPATIBILITY:</b> no longer available in LibreSSL 3.8.0 and later</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::X509_policy_tree_level_count($tree);
    # $tree - value corresponding to openssl&#39;s X509_POLICY_TREE structure
    #
    # returns: (integer) count</code></pre>

</li>
<li><p>X509_verify_cert_error_string</p>

<p>Returns a human readable error string for verification error $n.</p>

<pre><code>    my $rv = Net::SSLeay::X509_verify_cert_error_string($n);
    # $n - (long) numeric error code
    #
    # returns: error string</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get_error.html">https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get_error.html</a></p>

</li>
<li><p>P_X509_add_extensions</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Adds one or more X509 extensions to X509 object $x.</p>

<pre><code>    my $rv = Net::SSLeay::P_X509_add_extensions($x, $ca_cert, $nid, $value);
    # $x - value corresponding to openssl&#39;s X509 structure
    # $ca_cert - value corresponding to openssl&#39;s X509 structure (issuer&#39;s cert - necessary for setting NID_authority_key_identifier)
    # $nid - NID identifying extension to be set
    # $value - extension value
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>You can set more extensions at once:</p>

<pre><code>    my $rv = Net::SSLeay::P_X509_add_extensions($x509, $ca_cert,
                &amp;Net::SSLeay::NID_key_usage =&gt; &#39;digitalSignature,keyEncipherment&#39;,
                &amp;Net::SSLeay::NID_subject_key_identifier =&gt; &#39;hash&#39;,
                &amp;Net::SSLeay::NID_authority_key_identifier =&gt; &#39;keyid&#39;,
                &amp;Net::SSLeay::NID_authority_key_identifier =&gt; &#39;issuer&#39;,
                &amp;Net::SSLeay::NID_basic_constraints =&gt; &#39;CA:FALSE&#39;,
                &amp;Net::SSLeay::NID_ext_key_usage =&gt; &#39;serverAuth,clientAuth&#39;,
                &amp;Net::SSLeay::NID_netscape_cert_type =&gt; &#39;server&#39;,
                &amp;Net::SSLeay::NID_subject_alt_name =&gt; &#39;DNS:s1.dom.com,DNS:s2.dom.com,DNS:s3.dom.com&#39;,
          );</code></pre>

</li>
<li><p>P_X509_copy_extensions</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Copies X509 extensions from X509_REQ object to X509 object - handy when you need to turn X509_REQ into X509 certificate.</p>

<pre><code>    Net::SSLeay::P_X509_copy_extensions($x509_req, $x509, $override);
    # $x509_req - value corresponding to openssl&#39;s X509_REQ structure
    # $x509 - value corresponding to openssl&#39;s X509 structure
    # $override - (integer) flag indication whether to override already existing items in $x509 (default 1)
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>P_X509_get_crl_distribution_points</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Get the list of CRL distribution points from X509 certificate.</p>

<pre><code>    my @cdp = Net::SSLeay::P_X509_get_crl_distribution_points($x509);
    # $x509 - value corresponding to openssl&#39;s X509 structure
    #
    # returns: list of distribution points (usually URLs)</code></pre>

</li>
<li><p>P_X509_get_ext_key_usage</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Gets the list of extended key usage of given X509 certificate $cert.</p>

<pre><code>    my @ext_usage = Net::SSLeay::P_X509_get_ext_key_usage($cert, $format);
    # $cert - value corresponding to openssl&#39;s X509 structure
    # $format - choose type of return values: 0=OIDs, 1=NIDs, 2=shortnames, 3=longnames
    #
    # returns: list of values</code></pre>

<p>Examples:</p>

<pre><code>    my @extkeyusage_oid = Net::SSLeay::P_X509_get_ext_key_usage($x509,0);
    # returns for example: (&quot;1.3.6.1.5.5.7.3.1&quot;, &quot;1.3.6.1.5.5.7.3.2&quot;)

    my @extkeyusage_nid = Net::SSLeay::P_X509_get_ext_key_usage($x509,1);
    # returns for example: (129, 130)

    my @extkeyusage_sn  = Net::SSLeay::P_X509_get_ext_key_usage($x509,2);
    # returns for example: (&quot;serverAuth&quot;, &quot;clientAuth&quot;)

    my @extkeyusage_ln  = Net::SSLeay::P_X509_get_ext_key_usage($x509,3);
    # returns for example: (&quot;TLS Web Server Authentication&quot;,  &quot;TLS Web Client Authentication&quot;)</code></pre>

</li>
<li><p>P_X509_get_key_usage</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Gets the list of key usage of given X509 certificate $cert.</p>

<pre><code>    my @keyusage = Net::SSLeay::P_X509_get_key_usage($cert);
    # $cert - value corresponding to openssl&#39;s X509 structure
    #
    # returns: list of key usage values which can be none, one or more from the following list:
    #          &quot;digitalSignature&quot;
    #          &quot;nonRepudiation&quot;
    #          &quot;keyEncipherment&quot;
    #          &quot;dataEncipherment&quot;
    #          &quot;keyAgreement&quot;
    #          &quot;keyCertSign&quot;
    #          &quot;cRLSign&quot;
    #          &quot;encipherOnly&quot;
    #          &quot;decipherOnly&quot;</code></pre>

</li>
<li><p>P_X509_get_netscape_cert_type</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Gets the list of Netscape cert types of given X509 certificate $cert.</p>

<pre><code>    Net::SSLeay::P_X509_get_netscape_cert_type($cert);
    # $cert - value corresponding to openssl&#39;s X509 structure
    #
    # returns: list of Netscape type values which can be none, one or more from the following list:
    #          &quot;client&quot;
    #          &quot;server&quot;
    #          &quot;email&quot;
    #          &quot;objsign&quot;
    #          &quot;reserved&quot;
    #          &quot;sslCA&quot;
    #          &quot;emailCA&quot;
    #          &quot;objCA&quot;</code></pre>

</li>
<li><p>P_X509_get_pubkey_alg</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns ASN1_OBJECT corresponding to X509 certificate public key algorithm.</p>

<pre><code>    my $rv = Net::SSLeay::P_X509_get_pubkey_alg($x);
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: value corresponding to openssl&#39;s ASN1_OBJECT structure (0 on failure)</code></pre>

<p>To get textual representation use:</p>

<pre><code>    my $alg = Net::SSLeay::OBJ_obj2txt(Net::SSLeay::P_X509_get_pubkey_alg($x509));
    # returns for example: &quot;rsaEncryption&quot;</code></pre>

</li>
<li><p>P_X509_get_signature_alg</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns ASN1_OBJECT corresponding to X509 signature key algorithm.</p>

<pre><code>    my $rv = Net::SSLeay::P_X509_get_signature_alg($x);
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: value corresponding to openssl&#39;s ASN1_OBJECT structure (0 on failure)</code></pre>

<p>To get textual representation use:</p>

<pre><code>    my $alg = Net::SSLeay::OBJ_obj2txt(Net::SSLeay::P_X509_get_signature_alg($x509));
    # returns for example: &quot;sha1WithRSAEncryption&quot;</code></pre>

</li>
<li><p>sk_X509_new_null</p>

<p>Returns a new, empty, STACK_OF(X509) structure.</p>

<pre><code>    my $rv = Net::SSLeay::sk_X509_new_null();
    #
    # returns: value corresponding to openssl&#39;s STACK_OF(X509) structure</code></pre>

</li>
<li><p>sk_X509_push</p>

<p>Pushes an X509 structure onto a STACK_OF(X509) structure.</p>

<pre><code>    my $rv = Net::SSLeay::sk_X509_push($sk_x509, $x509);
    # $sk_x509 - value corresponding to openssl&#39;s STACK_OF(X509) structure
    # $x509 - value corresponding to openssl&#39;s X509 structure
    #
    # returns: total number of elements after the operation, 0 on failure</code></pre>

</li>
<li><p>sk_X509_pop</p>

<p>Pops an single X509 structure from a STACK_OF(X509) structure.</p>

<pre><code>    my $x509 = Net::SSLeay::sk_X509_pop($sk_x509);
    # $sk_x509 - value corresponding to openssl&#39;s STACK_OF(X509) structure
    #
    # returns: a pointer to an X509 structure, undef on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/sk_TYPE_pop.html">https://www.openssl.org/docs/manmaster/man3/sk_TYPE_pop.html</a></p>

</li>
<li><p>sk_X509_shift</p>

<p>Shifts an single X509 structure onto a STACK_OF(X509) structure.</p>

<pre><code>    my $x509 = Net::SSLeay::sk_X509_shift($sk_x509, $x509);
    # $sk_x509 - value corresponding to openssl&#39;s STACK_OF(X509) structure
    # $x509 - value corresponding to openssl&#39;s X509 structure
    #
    # returns: a pointer to an X509 structure, undef on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/sk_TYPE_shift.html">https://www.openssl.org/docs/manmaster/man3/sk_TYPE_shift.html</a></p>

</li>
<li><p>sk_X509_unshift</p>

<p>Unshifts an single X509 structure from a STACK_OF(X509) structure.</p>

<pre><code>    my $rv = Net::SSLeay::sk_X509_unshift($sk_x509);
    # $sk_x509 - value corresponding to openssl&#39;s STACK_OF(X509) structure
    #
    # returns: total number of elements after the operation, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/sk_TYPE_unshift.html">https://www.openssl.org/docs/manmaster/man3/sk_TYPE_unshift.html</a></p>

</li>
<li><p>sk_X509_insert</p>

<p>Inserts a single X509 structure into a STACK_OF(X509) at the specified index.</p>

<pre><code>    my $rv = Net::SSLeay::sk_X509_insert($sk_x509, $x509, $index);
    # $sk_x509 - value corresponding to openssl&#39;s STACK_OF(X509) structure
    # $x509 - value corresponding to openssl&#39;s X509 structure
    # $index - integer - 0 based index
    #
    # returns: total number of elements after the operation, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/sk_TYPE_insert.html">https://www.openssl.org/docs/manmaster/man3/sk_TYPE_insert.html</a></p>

</li>
<li><p>sk_X509_delete</p>

<p>Delete a single X509 structure from a STACK_OF(X509) at the specified index.</p>

<pre><code>    my $x509 = Net::SSLeay::sk_X509_delete($sk_x509, $index);
    # $sk_x509 - value corresponding to openssl&#39;s STACK_OF(X509) structure
    # $index - integer - 0 based index
    #
    # returns: a pointer to an X509 structure, undef on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/sk_TYPE_delete.html">https://www.openssl.org/docs/manmaster/man3/sk_TYPE_delete.html</a></p>

</li>
<li><p>sk_X509_value</p>

<p>Return a single X509 structure from a STACK_OF(X509) at the specified index.</p>

<pre><code>    my $x509 = Net::SSLeay::sk_X509_value($sk_x509, $index);
    # $sk_x509 - value corresponding to openssl&#39;s STACK_OF(X509) structure
    # $index - integer - 0 based index
    #
    # returns: a pointer to an X509 structure, undef on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/sk_TYPE_value.html">https://www.openssl.org/docs/manmaster/man3/sk_TYPE_value.html</a></p>

</li>
<li><p>sk_X509_num</p>

<p>Return the number of X509 elements in a STACK_OF(X509).</p>

<pre><code>    my $num = Net::SSLeay::sk_X509_num($sk_x509);
    # $sk_x509 - value corresponding to openssl&#39;s STACK_OF(X509) structure
    #
    # returns: the number of elements in the stack, -1 if the passed stack is NULL</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/sk_TYPE_num.html">https://www.openssl.org/docs/manmaster/man3/sk_TYPE_num.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-X509_REQ_*-related-functions"><a id="Low19"></a><a id="Low-level-API:-X509_REQ_--related-functions"></a>Low level API: X509_REQ_* related functions</h3>

<ul>

<li><p>X509_REQ_new</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Creates a new X509_REQ structure.</p>

<pre><code>    my $rv = Net::SSLeay::X509_REQ_new();
    #
    # returns: value corresponding to openssl&#39;s X509_REQ structure (0 on failure)</code></pre>

</li>
<li><p>X509_REQ_free</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Free an allocated X509_REQ structure.</p>

<pre><code>    Net::SSLeay::X509_REQ_free($x);
    # $x - value corresponding to openssl&#39;s X509_REQ structure
    #
    # returns: no return value</code></pre>

</li>
<li><p>X509_REQ_add1_attr_by_NID</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Adds an attribute whose name is defined by a NID $nid. The field value to be added is in $bytes.</p>

<pre><code>    my $rv = Net::SSLeay::X509_REQ_add1_attr_by_NID($req, $nid, $type, $bytes);
    # $req - value corresponding to openssl&#39;s X509_REQ structure
    # $nid - (integer) NID value
    # $type - (integer) type of data in $bytes (see below)
    # $bytes - data to be set
    #
    # returns: 1 on success, 0 on failure

    # values for $type - use constants:
    # &amp;Net::SSLeay::MBSTRING_UTF8     - $bytes contains utf8 encoded data
    # &amp;Net::SSLeay::MBSTRING_ASC      - $bytes contains ASCII data</code></pre>

</li>
<li><p>X509_REQ_digest</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Computes digest/fingerprint of X509_REQ $data using $type hash function.</p>

<pre><code>    my $digest_value = Net::SSLeay::X509_REQ_digest($data, $type);
    # $data - value corresponding to openssl&#39;s X509_REQ structure
    # $type - value corresponding to openssl&#39;s EVP_MD structure - e.g. got via EVP_get_digestbyname()
    #
    # returns: hash value (binary)

    # to get printable (hex) value of digest use:
    print unpack(&#39;H*&#39;, $digest_value);</code></pre>

</li>
<li><p>X509_REQ_get_attr_by_NID</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Retrieve the next index matching $nid after $lastpos ($lastpos should initially be set to -1).</p>

<pre><code>    my $rv = Net::SSLeay::X509_REQ_get_attr_by_NID($req, $nid, $lastpos=-1);
    # $req - value corresponding to openssl&#39;s X509_REQ structure
    # $nid - (integer) NID value
    # $lastpos - [optional] (integer) index where to start search (default -1)
    #
    # returns: index (-1 if there are no more entries)</code></pre>

<p>Note: use <a href="./Net::SSLeay.html#P_X509_REQ_get_attr">&quot;P_X509_REQ_get_attr&quot;</a> to get the actual attribute value - e.g.</p>

<pre><code>    my $index = Net::SSLeay::X509_REQ_get_attr_by_NID($req, $nid);
    my @attr_values = Net::SSLeay::P_X509_REQ_get_attr($req, $index);</code></pre>

</li>
<li><p>X509_REQ_get_attr_by_OBJ</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Retrieve the next index matching $obj after $lastpos ($lastpos should initially be set to -1).</p>

<pre><code>    my $rv = Net::SSLeay::X509_REQ_get_attr_by_OBJ($req, $obj, $lastpos=-1);
    # $req - value corresponding to openssl&#39;s X509_REQ structure
    # $obj - value corresponding to openssl&#39;s ASN1_OBJECT structure
    # $lastpos - [optional] (integer) index where to start search (default -1)
    #
    # returns: index (-1 if there are no more entries)</code></pre>

<p>Note: use <a href="./Net::SSLeay.html#P_X509_REQ_get_attr">&quot;P_X509_REQ_get_attr&quot;</a> to get the actual attribute value - e.g.</p>

<pre><code>    my $index = Net::SSLeay::X509_REQ_get_attr_by_NID($req, $nid);
    my @attr_values = Net::SSLeay::P_X509_REQ_get_attr($req, $index);</code></pre>

</li>
<li><p>X509_REQ_get_attr_count</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns the total number of attributes in $req.</p>

<pre><code>    my $rv = Net::SSLeay::X509_REQ_get_attr_count($req);
    # $req - value corresponding to openssl&#39;s X509_REQ structure
    #
    # returns: (integer) items count</code></pre>

</li>
<li><p>X509_REQ_get_pubkey</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns public key corresponding to given X509_REQ object $x.</p>

<pre><code>    my $rv = Net::SSLeay::X509_REQ_get_pubkey($x);
    # $x - value corresponding to openssl&#39;s X509_REQ structure
    #
    # returns: value corresponding to openssl&#39;s EVP_PKEY structure (0 on failure)</code></pre>

</li>
<li><p>X509_REQ_get_subject_name</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns X509_NAME object corresponding to subject name of given X509_REQ object $x.</p>

<pre><code>    my $rv = Net::SSLeay::X509_REQ_get_subject_name($x);
    # $x - value corresponding to openssl&#39;s X509_REQ structure
    #
    # returns: value corresponding to openssl&#39;s X509_NAME structure (0 on failure)</code></pre>

</li>
<li><p>X509_REQ_get_version</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns &#39;version&#39; value for given X509_REQ object $x.</p>

<pre><code>    my $rv = Net::SSLeay::X509_REQ_get_version($x);
    # $x - value corresponding to openssl&#39;s X509_REQ structure
    #
    # returns: (integer) version e.g. 0 = &quot;version 1&quot;</code></pre>

</li>
<li><p>X509_REQ_set_pubkey</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sets public key of given X509_REQ object $x to $pkey.</p>

<pre><code>    my $rv = Net::SSLeay::X509_REQ_set_pubkey($x, $pkey);
    # $x - value corresponding to openssl&#39;s X509_REQ structure
    # $pkey - value corresponding to openssl&#39;s EVP_PKEY structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_REQ_set_subject_name</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sets subject name of given X509_REQ object $x to X509_NAME object $name.</p>

<pre><code>    my $rv = Net::SSLeay::X509_REQ_set_subject_name($x, $name);
    # $x - value corresponding to openssl&#39;s X509_REQ structure
    # $name - value corresponding to openssl&#39;s X509_NAME structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_REQ_set_version</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sets &#39;version&#39; of given X509_REQ object $x to $version.</p>

<pre><code>    my $rv = Net::SSLeay::X509_REQ_set_version($x, $version);
    # $x - value corresponding to openssl&#39;s X509_REQ structure
    # $version - (integer) e.g. 0 = &quot;version 1&quot;
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_REQ_sign</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sign X509_REQ object $x with private key $pk (using digest algorithm $md).</p>

<pre><code>    my $rv = Net::SSLeay::X509_REQ_sign($x, $pk, $md);
    # $x - value corresponding to openssl&#39;s X509_REQ structure
    # $pk - value corresponding to openssl&#39;s EVP_PKEY structure (requestor&#39;s private key)
    # $md - value corresponding to openssl&#39;s EVP_MD structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_REQ_verify</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Verifies X509_REQ object $x using public key $r (pubkey of requesting party).</p>

<pre><code>    my $rv = Net::SSLeay::X509_REQ_verify($x, $r);
    # $x - value corresponding to openssl&#39;s X509_REQ structure
    # $r - value corresponding to openssl&#39;s EVP_PKEY structure
    #
    # returns: 0 - verify failure, 1 - verify OK, &lt;0 - error</code></pre>

</li>
<li><p>P_X509_REQ_add_extensions</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Adds one or more X509 extensions to X509_REQ object $x.</p>

<pre><code>    my $rv = Net::SSLeay::P_X509_REQ_add_extensions($x, $nid, $value);
    # $x - value corresponding to openssl&#39;s X509_REQ structure
    # $nid - NID identifying extension to be set
    # $value - extension value
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>You can set more extensions at once:</p>

<pre><code>    my $rv = Net::SSLeay::P_X509_REQ_add_extensions($x509_req,
            &amp;Net::SSLeay::NID_key_usage =&gt; &#39;digitalSignature,keyEncipherment&#39;,
            &amp;Net::SSLeay::NID_basic_constraints =&gt; &#39;CA:FALSE&#39;,
            &amp;Net::SSLeay::NID_ext_key_usage =&gt; &#39;serverAuth,clientAuth&#39;,
            &amp;Net::SSLeay::NID_netscape_cert_type =&gt; &#39;server&#39;,
            &amp;Net::SSLeay::NID_subject_alt_name =&gt; &#39;DNS:s1.com,DNS:s2.com&#39;,
            &amp;Net::SSLeay::NID_crl_distribution_points =&gt; &#39;URI:http://pki.com/crl1,URI:http://pki.com/crl2&#39;,
          );</code></pre>

</li>
<li><p>P_X509_REQ_get_attr</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns attribute value for X509_REQ&#39;s attribute at index $n.</p>

<pre><code>    Net::SSLeay::P_X509_REQ_get_attr($req, $n);
    # $req - value corresponding to openssl&#39;s X509_REQ structure
    # $n - (integer) attribute index
    #
    # returns: value corresponding to openssl&#39;s ASN1_STRING structure</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-X509_CRL_*-related-functions"><a id="Low20"></a><a id="Low-level-API:-X509_CRL_--related-functions"></a>Low level API: X509_CRL_* related functions</h3>

<ul>

<li><p>X509_CRL_new</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Creates a new X509_CRL structure.</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_new();
    #
    # returns: value corresponding to openssl&#39;s X509_CRL structure (0 on failure)</code></pre>

</li>
<li><p>X509_CRL_free</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Free an allocated X509_CRL structure.</p>

<pre><code>    Net::SSLeay::X509_CRL_free($x);
    # $x - value corresponding to openssl&#39;s X509_CRL structure
    #
    # returns: no return value</code></pre>

</li>
<li><p>X509_CRL_digest</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Computes digest/fingerprint of X509_CRL $data using $type hash function.</p>

<pre><code>    my $digest_value = Net::SSLeay::X509_CRL_digest($data, $type);
    # $data - value corresponding to openssl&#39;s X509_CRL structure
    # $type - value corresponding to openssl&#39;s EVP_MD structure - e.g. got via EVP_get_digestbyname()
    #
    # returns: hash value (binary)</code></pre>

<p>Example:</p>

<pre><code>    my $x509_crl;
    my $md = Net::SSLeay::EVP_get_digestbyname(&quot;sha1&quot;);
    my $digest_value = Net::SSLeay::X509_CRL_digest($x509_crl, $md);
    # to get printable (hex) value of digest use:
    print &quot;digest=&quot;, unpack(&#39;H*&#39;, $digest_value), &quot;\n&quot;;</code></pre>

</li>
<li><p>X509_CRL_get_ext</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.54 and before</p>

<p>Returns X509_EXTENSION from $x509 based on given position/index.</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_get_ext($x509, $index);
    # $x509 - value corresponding to openssl&#39;s X509_CRL structure
    # $index - (integer) position/index of extension within $x509
    #
    # returns: value corresponding to openssl&#39;s X509_EXTENSION structure (0 on failure)</code></pre>

</li>
<li><p>X509_CRL_get_ext_by_NID</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.54 and before</p>

<p>Returns X509_EXTENSION from $x509 based on given NID.</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_get_ext_by_NID($x509, $nid, $loc);
    # $x509 - value corresponding to openssl&#39;s X509_CRL structure
    # $nid - (integer) NID value
    # $loc - (integer) position to start lookup at
    #
    # returns: position/index of extension, negative value on error
    #          call Net::SSLeay::X509_CRL_get_ext($x509, $rv) to get the actual extension</code></pre>

</li>
<li><p>X509_CRL_get_ext_count</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.54 and before</p>

<p>Returns the total number of extensions in X509_CRL object $x.</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_get_ext_count($x);
    # $x - value corresponding to openssl&#39;s X509_CRL structure
    #
    # returns: count of extensions</code></pre>

</li>
<li><p>X509_CRL_get_issuer</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns X509_NAME object corresponding to the issuer of X509_CRL $x.</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_get_issuer($x);
    # $x - value corresponding to openssl&#39;s X509_CRL structure
    #
    # returns: value corresponding to openssl&#39;s X509_NAME structure (0 on failure)</code></pre>

<p>See other <code>X509_NAME_*</code> functions to get more info from X509_NAME structure.</p>

</li>
<li><p>X509_CRL_get0_lastUpdate and X509_CRL_get_lastUpdate</p>

<p><b>COMPATIBILITY:</b> X509_CRL_get0_lastUpdate not available in Net-SSLeay-1.92 and before, X509_CRL_get_lastUpdate not available in Net-SSLeay-1.45 and before</p>

<p>Returns &#39;lastUpdate&#39; date-time value of X509_CRL object $x.</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_get0_lastUpdate($x);
    # $x - value corresponding to openssl&#39;s X509_CRL structure
    #
    # returns: read-only value corresponding to openssl&#39;s ASN1_TIME structure</code></pre>

<p><b>NOTE:</b> X509_CRL_get_lastUpdate is an alias and deprecated in OpenSSL 1.1.0 and later</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_CRL_get0_lastUpdate.html">https://www.openssl.org/docs/manmaster/man3/X509_CRL_get0_lastUpdate.html</a></p>

</li>
<li><p>X509_CRL_get0_nextUpdate and X509_CRL_get_nextUpdate</p>

<p><b>COMPATIBILITY:</b> X509_CRL_get0_nextUpdate not available in Net-SSLeay-1.92 and before, X509_CRL_get_nextUpdate not available in Net-SSLeay-1.45 and before</p>

<p>Returns &#39;nextUpdate&#39; date-time value of X509_CRL object $x.</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_get0_nextUpdate($x);
    # $x - value corresponding to openssl&#39;s X509_CRL structure
    #
    # returns: read-only value corresponding to openssl&#39;s ASN1_TIME structure or 0 if &#39;nextUpdate&#39; is not set</code></pre>

<p><b>NOTE:</b> X509_CRL_get_nextUpdate is an alias and deprecated in OpenSSL 1.1.0 and later</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_CRL_get0_nextUpdate.html">https://www.openssl.org/docs/manmaster/man3/X509_CRL_get0_nextUpdate.html</a></p>

</li>
<li><p>X509_CRL_get_version</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns &#39;version&#39; value of given X509_CRL structure $x.</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_get_version($x);
    # $x - value corresponding to openssl&#39;s X509_CRL structure
    #
    # returns: (integer) version</code></pre>

</li>
<li><p>X509_CRL_set_issuer_name</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sets the issuer of X509_CRL object $x to X509_NAME object $name.</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_set_issuer_name($x, $name);
    # $x - value corresponding to openssl&#39;s X509_CRL structure
    # $name - value corresponding to openssl&#39;s X509_NAME structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_CRL_set1_lastUpdate and X509_CRL_set_lastUpdate</p>

<p><b>COMPATIBILITY:</b> X509_CRL_set1_lastUpdate not available in Net-SSLeay-1.92 and before, X509_CRL_set_lastUpdate not available in Net-SSLeay-1.45 and before</p>

<p>Sets &#39;lastUpdate&#39; value of X509_CRL object $x to $tm.</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_set1_lastUpdate($x, $tm);
    # $x - value corresponding to openssl&#39;s X509_CRL structure
    # $tm - value corresponding to openssl&#39;s ASN1_TIME structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p><b>NOTE:</b> X509_CRL_set_lastUpdate is an alias and deprecated in OpenSSL 1.1.0 and later</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_CRL_set1_lastUpdate.html">https://www.openssl.org/docs/manmaster/man3/X509_CRL_set1_lastUpdate.html</a></p>

</li>
<li><p>X509_CRL_set1_nextUpdate and X509_CRL_set_nextUpdate</p>

<p><b>COMPATIBILITY:</b> X509_CRL_set1_nextUpdate not available in Net-SSLeay-1.92 and before, X509_CRL_set_nextUpdate not available in Net-SSLeay-1.45 and before</p>

<p>Sets &#39;nextUpdate&#39; value of X509_CRL object $x to $tm.</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_set1_nextUpdate($x, $tm);
    # $x - value corresponding to openssl&#39;s X509_CRL structure
    # $tm - value corresponding to openssl&#39;s ASN1_TIME structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p><b>NOTE:</b> X509_CRL_set_nextUpdate is an alias and deprecated in OpenSSL 1.1.0 and later</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_CRL_set1_nextUpdate.html">https://www.openssl.org/docs/manmaster/man3/X509_CRL_set1_nextUpdate.html</a></p>

</li>
<li><p>X509_CRL_set_version</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sets &#39;version&#39; value of given X509_CRL structure $x to $version.</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_set_version($x, $version);
    # $x - value corresponding to openssl&#39;s X509_CRL structure
    # $version - (integer) version number (1 = version 2 CRL)
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Note that if you want to use any X509_CRL extension you need to set &quot;version 2 CRL&quot; - <code>Net::SSLeay::X509_CRL_set_version($x, 1)</code>.</p>

</li>
<li><p>X509_CRL_sign</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sign X509_CRL object $x with private key $pkey (using digest algorithm $md).</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_sign($x, $pkey, $md);
    # $x - value corresponding to openssl&#39;s X509_CRL structure
    # $pkey - value corresponding to openssl&#39;s EVP_PKEY structure
    # $md - value corresponding to openssl&#39;s EVP_MD structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_CRL_sort</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sorts the data of X509_CRL object so it will be written in serial number order.</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_sort($x);
    # $x - value corresponding to openssl&#39;s X509_CRL structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_CRL_verify</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Verifies X509_CRL object $a using public key $r (pubkey of issuing CA).</p>

<pre><code>    my $rv = Net::SSLeay::X509_CRL_verify($a, $r);
    # $a - value corresponding to openssl&#39;s X509_CRL structure
    # $r - value corresponding to openssl&#39;s EVP_PKEY structure
    #
    # returns: 0 - verify failure, 1 - verify OK, &lt;0 - error</code></pre>

</li>
<li><p>P_X509_CRL_add_revoked_serial_hex</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Adds given serial number $serial_hex to X509_CRL object $crl.</p>

<pre><code>    Net::SSLeay::P_X509_CRL_add_revoked_serial_hex($crl, $serial_hex, $rev_time, $reason_code, $comp_time);
    # $crl - value corresponding to openssl&#39;s X509_CRL structure
    # $serial_hex - string (hexadecimal) representation of serial number
    # $rev_time - (revocation time) value corresponding to openssl&#39;s ASN1_TIME structure
    # $reason_code - [optional] (integer) reason code (see below) - default 0
    # $comp_time - [optional] (compromise time) value corresponding to openssl&#39;s ASN1_TIME structure
    #
    # returns: no return value

    # reason codes:
    # 0 - unspecified
    # 1 - keyCompromise
    # 2 - CACompromise
    # 3 - affiliationChanged
    # 4 - superseded
    # 5 - cessationOfOperation
    # 6 - certificateHold
    # 7 - (value 7 is not used)
    # 8 - removeFromCRL
    # 9 - privilegeWithdrawn
    # 10 - aACompromise</code></pre>

</li>
<li><p>P_X509_CRL_get_serial</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns serial number of X509_CRL object.</p>

<pre><code>    my $rv = Net::SSLeay::P_X509_CRL_get_serial($crl);
    # $crl - value corresponding to openssl&#39;s X509_CRL structure
    #
    # returns: value corresponding to openssl&#39;s ASN1_INTEGER structure (0 on failure)</code></pre>

</li>
<li><p>P_X509_CRL_set_serial</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Sets serial number of X509_CRL object to $crl_number.</p>

<pre><code>    my $rv = Net::SSLeay::P_X509_CRL_set_serial($crl, $crl_number);
    # $crl - value corresponding to openssl&#39;s X509_CRL structure
    # $crl_number - value corresponding to openssl&#39;s ASN1_INTEGER structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>P_X509_CRL_add_extensions</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.88 and before</p>

<p>Adds one or more X509 extensions to X509 CRL object $x.</p>

<pre><code>    my $rv = Net::SSLeay::P_X509_CRL_add_extensions($x, $ca_cert, $nid, $value);
    # $x - value corresponding to openssl&#39;s X509 CRL structure
    # $ca_cert - value corresponding to openssl&#39;s X509 structure (issuer&#39;s cert - necessary for setting NID_authority_key_identifier)
    # $nid - NID identifying extension to be set
    # $value - extension value
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>For more details see <a href="./Net::SSLeay.html#P_X509_add_extensions">&quot;P_X509_add_extensions&quot;</a>.</p>

</li>
</ul>

<h3 id="Low-level-API:-X509_EXTENSION_*-related-functions"><a id="Low21"></a><a id="Low-level-API:-X509_EXTENSION_--related-functions"></a>Low level API: X509_EXTENSION_* related functions</h3>

<ul>

<li><p>X509_EXTENSION_get_critical</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns &#39;critical&#39; flag of given X509_EXTENSION object $ex.</p>

<pre><code>    my $rv = Net::SSLeay::X509_EXTENSION_get_critical($ex);
    # $ex - value corresponding to openssl&#39;s X509_EXTENSION structure
    #
    # returns: (integer) 1 - critical, 0 - noncritical</code></pre>

</li>
<li><p>X509_EXTENSION_get_data</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns value (raw data) of X509_EXTENSION object $ne.</p>

<pre><code>    my $rv = Net::SSLeay::X509_EXTENSION_get_data($ne);
    # $ne - value corresponding to openssl&#39;s X509_EXTENSION structure
    #
    # returns: value corresponding to openssl&#39;s ASN1_OCTET_STRING structure (0 on failure)</code></pre>

<p>Note: you can use <a href="./Net::SSLeay.html#P_ASN1_STRING_get">&quot;P_ASN1_STRING_get&quot;</a> to convert ASN1_OCTET_STRING into perl scalar variable.</p>

</li>
<li><p>X509_EXTENSION_get_object</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns OID (ASN1_OBJECT) of X509_EXTENSION object $ne.</p>

<pre><code>    my $rv = Net::SSLeay::X509_EXTENSION_get_object($ex);
    # $ex - value corresponding to openssl&#39;s X509_EXTENSION structure
    #
    # returns: value corresponding to openssl&#39;s ASN1_OBJECT structure (0 on failure)</code></pre>

</li>
<li><p>X509V3_EXT_print</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns string representation of given X509_EXTENSION object $ext.</p>

<pre><code>    Net::SSLeay::X509V3_EXT_print($ext, $flags, $utf8_decode);
    # $ext - value corresponding to openssl&#39;s X509_EXTENSION structure
    # $flags - [optional] (integer) Currently the flag argument is unused and should be set to 0
    # $utf8_decode - [optional] 0 or 1 whether the returned value should be utf8 decoded (default=0)
    #
    # returns: no return value</code></pre>

</li>
<li><p>X509V3_EXT_d2i</p>

<p>Parses an extension and returns its internal structure.</p>

<pre><code>    my $rv = Net::SSLeay::X509V3_EXT_d2i($ext);
    # $ext - value corresponding to openssl&#39;s X509_EXTENSION structure
    #
    # returns: pointer ???</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-X509_NAME_*-related-functions"><a id="Low22"></a><a id="Low-level-API:-X509_NAME_--related-functions"></a>Low level API: X509_NAME_* related functions</h3>

<ul>

<li><p>X509_NAME_ENTRY_get_data</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Retrieves the field value of $ne in and ASN1_STRING structure.</p>

<pre><code>    my $rv = Net::SSLeay::X509_NAME_ENTRY_get_data($ne);
    # $ne - value corresponding to openssl&#39;s X509_NAME_ENTRY structure
    #
    # returns: value corresponding to openssl&#39;s ASN1_STRING structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_NAME_ENTRY_get_object.html">https://www.openssl.org/docs/manmaster/man3/X509_NAME_ENTRY_get_object.html</a></p>

</li>
<li><p>X509_NAME_ENTRY_get_object</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Retrieves the field name of $ne in and ASN1_OBJECT structure.</p>

<pre><code>    my $rv = Net::SSLeay::X509_NAME_ENTRY_get_object($ne);
    # $ne - value corresponding to openssl&#39;s X509_NAME_ENTRY structure
    #
    # returns: value corresponding to openssl&#39;s ASN1_OBJECT structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_NAME_ENTRY_get_object.html">https://www.openssl.org/docs/manmaster/man3/X509_NAME_ENTRY_get_object.html</a></p>

</li>
<li><p>X509_NAME_new</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.55 and before</p>

<p>Creates a new X509_NAME structure. Adds a field whose name is defined by a string $field. The field value to be added is in $bytes.</p>

<pre><code>    my $rv = Net::SSLeay::X509_NAME_new();
    #
    # returns: value corresponding to openssl&#39;s X509_NAME structure (0 on failure)</code></pre>

</li>
<li><p>X509_NAME_hash</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.55 and before</p>

<p>Sort of a checksum of issuer name $name. The result is not a full hash (e.g. sha-1), it is kind-of-a-hash truncated to the size of &#39;unsigned long&#39; (32 bits). The resulting value might differ across different openssl versions for the same X509 certificate.</p>

<pre><code>    my $rv = Net::SSLeay::X509_NAME_hash($name);
    # $name - value corresponding to openssl&#39;s X509_NAME structure
    #
    # returns: number representing checksum</code></pre>

</li>
<li><p>X509_NAME_add_entry_by_txt</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Adds a field whose name is defined by a string $field. The field value to be added is in $bytes.</p>

<pre><code>    my $rv = Net::SSLeay::X509_NAME_add_entry_by_txt($name, $field, $type, $bytes, $len, $loc, $set);
    # $name - value corresponding to openssl&#39;s X509_NAME structure
    # $field - (string) field definition (name) - e.g. &quot;organizationName&quot;
    # $type - (integer) type of data in $bytes (see below)
    # $bytes - data to be set
    # $loc - [optional] (integer) index where the new entry is inserted: if it is -1 (default) it is appended
    # $set - [optional] (integer) determines how the new type is added. If it is 0 (default) a new RDN is created
    #
    # returns: 1 on success, 0 on failure

    # values for $type - use constants:
    # &amp;Net::SSLeay::MBSTRING_UTF8     - $bytes contains utf8 encoded data
    # &amp;Net::SSLeay::MBSTRING_ASC      - $bytes contains ASCII data</code></pre>

<p>Unicode note: when passing non-ascii (unicode) string in $bytes do not forget to set <code>$flags = &amp;Net::SSLeay::MBSTRING_UTF8</code> and encode the perl $string via <code>$bytes = encode(&#39;utf-8&#39;, $string)</code>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_NAME_add_entry_by_txt.html">https://www.openssl.org/docs/manmaster/man3/X509_NAME_add_entry_by_txt.html</a></p>

</li>
<li><p>X509_NAME_add_entry_by_NID</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Adds a field whose name is defined by a NID $nid. The field value to be added is in $bytes.</p>

<pre><code>    my $rv = Net::SSLeay::X509_NAME_add_entry_by_NID($name, $nid, $type, $bytes, $len, $loc, $set);
    # $name - value corresponding to openssl&#39;s X509_NAME structure
    # $nid - (integer) field definition - NID value
    # $type - (integer) type of data in $bytes (see below)
    # $bytes - data to be set
    # $loc - [optional] (integer) index where the new entry is inserted: if it is -1 (default) it is appended
    # $set - [optional] (integer) determines how the new type is added. If it is 0 (default) a new RDN is created
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_NAME_add_entry_by_txt.html">https://www.openssl.org/docs/manmaster/man3/X509_NAME_add_entry_by_txt.html</a></p>

</li>
<li><p>X509_NAME_add_entry_by_OBJ</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Adds a field whose name is defined by a object (OID) $obj . The field value to be added is in $bytes.</p>

<pre><code>    my $rv = Net::SSLeay::X509_NAME_add_entry_by_OBJ($name, $obj, $type, $bytes, $len, $loc, $set);
    # $name - value corresponding to openssl&#39;s X509_NAME structure
    # $obj - field definition - value corresponding to openssl&#39;s ASN1_OBJECT structure
    # $type - (integer) type of data in $bytes (see below)
    # $bytes - data to be set
    # $loc - [optional] (integer) index where the new entry is inserted: if it is -1 (default) it is appended
    # $set - [optional] (integer) determines how the new type is added. If it is 0 (default) a new RDN is created
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_NAME_add_entry_by_txt.html">https://www.openssl.org/docs/manmaster/man3/X509_NAME_add_entry_by_txt.html</a></p>

</li>
<li><p>X509_NAME_cmp</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Compares two X509_NAME objects.</p>

<pre><code>    my $rv = Net::SSLeay::X509_NAME_cmp($a, $b);
    # $a - value corresponding to openssl&#39;s X509_NAME structure
    # $b - value corresponding to openssl&#39;s X509_NAME structure
    #
    # returns: 0 if $a matches $b; non zero otherwise</code></pre>

</li>
<li><p>X509_NAME_digest</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Computes digest/fingerprint of X509_NAME $data using $type hash function.</p>

<pre><code>    my $digest_value = Net::SSLeay::X509_NAME_digest($data, $type);
    # $data - value corresponding to openssl&#39;s X509_NAME structure
    # $type - value corresponding to openssl&#39;s EVP_MD structure - e.g. got via EVP_get_digestbyname()
    #
    # returns: hash value (binary)

    # to get printable (hex) value of digest use:
    print unpack(&#39;H*&#39;, $digest_value);</code></pre>

</li>
<li><p>X509_NAME_entry_count</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns the total number of entries in $name.</p>

<pre><code>    my $rv = Net::SSLeay::X509_NAME_entry_count($name);
    # $name - value corresponding to openssl&#39;s X509_NAME structure
    #
    # returns: (integer) entries count</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_NAME_get_index_by_NID.html">https://www.openssl.org/docs/manmaster/man3/X509_NAME_get_index_by_NID.html</a></p>

</li>
<li><p>X509_NAME_get_entry</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Retrieves the X509_NAME_ENTRY from $name corresponding to index $loc. Acceptable values for $loc run from 0 to <code>Net::SSLeay::X509_NAME_entry_count($name) - 1</code>. The value returned is an internal pointer which must not be freed.</p>

<pre><code>    my $rv = Net::SSLeay::X509_NAME_get_entry($name, $loc);
    # $name - value corresponding to openssl&#39;s X509_NAME structure
    # $loc - (integer) index of wanted entry
    #
    # returns: value corresponding to openssl&#39;s X509_NAME_ENTRY structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_NAME_get_index_by_NID.html">https://www.openssl.org/docs/manmaster/man3/X509_NAME_get_index_by_NID.html</a></p>

</li>
<li><p>X509_NAME_print_ex</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns a string with human readable version of $name.</p>

<pre><code>    Net::SSLeay::X509_NAME_print_ex($name, $flags, $utf8_decode);
    # $name - value corresponding to openssl&#39;s X509_NAME structure
    # $flags - [optional] conversion flags (default XN_FLAG_RFC2253) - see below
    # $utf8_decode - [optional] 0 or 1 whether the returned value should be utf8 decoded (default=0)
    #
    # returns: string representation of $name

    # available conversion flags - use constants:
    # &amp;Net::SSLeay::XN_FLAG_COMPAT
    # &amp;Net::SSLeay::XN_FLAG_DN_REV
    # &amp;Net::SSLeay::XN_FLAG_DUMP_UNKNOWN_FIELDS
    # &amp;Net::SSLeay::XN_FLAG_FN_ALIGN
    # &amp;Net::SSLeay::XN_FLAG_FN_LN
    # &amp;Net::SSLeay::XN_FLAG_FN_MASK
    # &amp;Net::SSLeay::XN_FLAG_FN_NONE
    # &amp;Net::SSLeay::XN_FLAG_FN_OID
    # &amp;Net::SSLeay::XN_FLAG_FN_SN
    # &amp;Net::SSLeay::XN_FLAG_MULTILINE
    # &amp;Net::SSLeay::XN_FLAG_ONELINE
    # &amp;Net::SSLeay::XN_FLAG_RFC2253
    # &amp;Net::SSLeay::XN_FLAG_SEP_COMMA_PLUS
    # &amp;Net::SSLeay::XN_FLAG_SEP_CPLUS_SPC
    # &amp;Net::SSLeay::XN_FLAG_SEP_MASK
    # &amp;Net::SSLeay::XN_FLAG_SEP_MULTILINE
    # &amp;Net::SSLeay::XN_FLAG_SEP_SPLUS_SPC
    # &amp;Net::SSLeay::XN_FLAG_SPC_EQ</code></pre>

<p>Most likely you will be fine with default:</p>

<pre><code>    Net::SSLeay::X509_NAME_print_ex($name, &amp;Net::SSLeay::XN_FLAG_RFC2253);</code></pre>

<p>Or you might want RFC2253-like output without utf8 chars escaping:</p>

<pre><code>    use Net::SSLeay qw/XN_FLAG_RFC2253 ASN1_STRFLGS_ESC_MSB/;
    my $flag_rfc22536_utf8 = (XN_FLAG_RFC2253) &amp; (~ ASN1_STRFLGS_ESC_MSB);
    my $result = Net::SSLeay::X509_NAME_print_ex($name, $flag_rfc22536_utf8, 1);</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_NAME_print_ex.html">https://www.openssl.org/docs/manmaster/man3/X509_NAME_print_ex.html</a></p>

</li>
<li><p>X509_NAME_get_text_by_NID</p>

<p>Retrieves the text from the first entry in name which matches $nid, if no such entry exists -1 is returned.</p>

<p><b>openssl note:</b> this is a legacy function which has various limitations which makes it of minimal use in practice. It can only find the first matching entry and will copy the contents of the field verbatim: this can be highly confusing if the target is a multicharacter string type like a BMPString or a UTF8String.</p>

<pre><code>    Net::SSLeay::X509_NAME_get_text_by_NID($name, $nid);
    # $name - value corresponding to openssl&#39;s X509_NAME structure
    # $nid - NID value (integer)
    #
    # returns: text value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_NAME_get_index_by_NID.html">https://www.openssl.org/docs/manmaster/man3/X509_NAME_get_index_by_NID.html</a></p>

</li>
<li><p>X509_NAME_oneline</p>

<p>Return an ASCII version of $name.</p>

<pre><code>    Net::SSLeay::X509_NAME_oneline($name);
    # $name - value corresponding to openssl&#39;s X509_NAME structure
    #
    # returns: (string) ASCII version of $name</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_NAME_print_ex.html">https://www.openssl.org/docs/manmaster/man3/X509_NAME_print_ex.html</a></p>

</li>
<li><p>sk_X509_NAME_free</p>

<p>Free an allocated STACK_OF(X509_NAME) structure.</p>

<pre><code>    Net::SSLeay::sk_X509_NAME_free($sk);
    # $sk - value corresponding to openssl&#39;s STACK_OF(X509_NAME) structure
    #
    # returns: no return value</code></pre>

</li>
<li><p>sk_X509_NAME_num</p>

<p>Return number of items in STACK_OF(X509_NAME)</p>

<pre><code>    my $rv = Net::SSLeay::sk_X509_NAME_num($sk);
    # $sk - value corresponding to openssl&#39;s STACK_OF(X509_NAME) structure
    #
    # returns: number of items</code></pre>

</li>
<li><p>sk_X509_NAME_value</p>

<p>Returns X509_NAME from position $index in STACK_OF(X509_NAME)</p>

<pre><code>    my $rv = Net::SSLeay::sk_X509_NAME_value($sk, $i);
    # $sk - value corresponding to openssl&#39;s STACK_OF(X509_NAME) structure
    # $i - (integer) index/position
    #
    # returns: value corresponding to openssl&#39;s X509_NAME structure (0 on failure)</code></pre>

</li>
<li><p>add_file_cert_subjects_to_stack</p>

<p>Add a file of certs to a stack. All certs in $file that are not already in the $stackCAs will be added.</p>

<pre><code>    my $rv = Net::SSLeay::add_file_cert_subjects_to_stack($stackCAs, $file);
    # $stackCAs - value corresponding to openssl&#39;s STACK_OF(X509_NAME) structure
    # $file - (string) filename
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>add_dir_cert_subjects_to_stack</p>

<p>Add a directory of certs to a stack. All certs in $dir that are not already in the $stackCAs will be added.</p>

<pre><code>    my $rv = Net::SSLeay::add_dir_cert_subjects_to_stack($stackCAs, $dir);
    # $stackCAs - value corresponding to openssl&#39;s STACK_OF(X509_NAME) structure
    # $dir - (string) the directory to append from. All files in this directory will be examined as potential certs. Any that are acceptable to SSL_add_dir_cert_subjects_to_stack() that are not already in the stack will be included.
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-X509_STORE_*-related-functions"><a id="Low23"></a><a id="Low-level-API:-X509_STORE_--related-functions"></a>Low level API: X509_STORE_* related functions</h3>

<ul>

<li><p>X509_STORE_CTX_new</p>

<p>returns a newly initialised X509_STORE_CTX structure.</p>

</li>
<li><p>X509_STORE_CTX_init</p>

<p>X509_STORE_CTX_init() sets up an X509_STORE_CTX for a subsequent verification operation. It must be called before each call to X509_verify_cert().</p>

<pre><code>    my $rv = Net::SSLeay::X509_STORE_CTX_init($x509_store_ctx, $x509_store, $x509, $chain);
    # $x509_store_ctx - value corresponding to openssl&#39;s X509_STORE_CTX structure (required)
    # $x509_store - value corresponding to openssl&#39;s X509_STORE structure (optional)
    # $x509 - value corresponding to openssl&#39;s X509 structure (optional)
    # $chain - value corresponding to openssl&#39;s STACK_OF(X509) structure (optional)
    #
    # returns: 1 on success, 0 on failure
    #
    # Note: returns nothing with Net::SSLeay 1.90 and earlier.</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_init.html">https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_init.html</a></p>

</li>
<li><p>X509_STORE_CTX_free</p>

<p>Frees an X509_STORE_CTX structure.</p>

<pre><code>    Net::SSLeay::X509_STORE_CTX_free($x509_store_ctx);
    # $x509_store_ctx - value corresponding to openssl&#39;s X509_STORE_CTX structure</code></pre>

</li>
<li><p>X509_verify_cert</p>

<p>The X509_verify_cert() function attempts to discover and validate a certificate chain based on parameters in ctx. A complete description of the process is contained in the verify(1) manual page.</p>

<p>If this function returns 0, use X509_STORE_CTX_get_error to get additional error information.</p>

<pre><code>    my $rv = Net::SSLeay::X509_verify_cert($x509_store_ctx);
    # $x509_store_ctx - value corresponding to openssl&#39;s X509_STORE_CTX structure
    #
    # returns: 1 if a complete chain can be built and validated, otherwise 0</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_verify_cert.html">https://www.openssl.org/docs/manmaster/man3/X509_verify_cert.html</a></p>

</li>
<li><p>X509_STORE_CTX_get_current_cert</p>

<p>Returns the certificate in ctx which caused the error or 0 if no certificate is relevant.</p>

<pre><code>    my $rv = Net::SSLeay::X509_STORE_CTX_get_current_cert($x509_store_ctx);
    # $x509_store_ctx - value corresponding to openssl&#39;s X509_STORE_CTX structure
    #
    # returns: value corresponding to openssl&#39;s X509 structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get_error.html">https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get_error.html</a></p>

</li>
<li><p>X509_STORE_CTX_get0_cert</p>

<p><b>COMPATIBILITY</b>: not available in Net-SSLeay-1.88 and before; requires at least OpenSSL 1.1.0pre6 or LibreSSL 2.7.0</p>

<p>Returns an internal pointer to the certificate being verified by the ctx.</p>

<pre><code>    my $x509 = Net::SSLeay::X509_STORE_CTX_get0_cert($x509_store_ctx);
    # $x509_store_ctx - value corresponding to openssl&#39;s X509_STORE_CTX structure
    #
    # returns: value corresponding to openssl&#39;s X509 structure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get0_cert.html">https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get0_cert.html</a></p>

</li>
<li><p>X509_STORE_CTX_get1_chain</p>

<p>Returns a returns a complete validate chain if a previous call to X509_verify_cert() is successful.</p>

<pre><code>    my $rv = Net::SSLeay::X509_STORE_CTX_get1_chain($x509_store_ctx);
    # $x509_store_ctx - value corresponding to openssl&#39;s X509_STORE_CTX structure
    #
    # returns: value corresponding to openssl&#39;s STACK_OF(X509) structure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get1_chain.html">https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get1_chain.html</a></p>

</li>
<li><p>X509_STORE_CTX_get_error</p>

<p>Returns the error code of $ctx.</p>

<pre><code>    my $rv = Net::SSLeay::X509_STORE_CTX_get_error($x509_store_ctx);
    # $x509_store_ctx - value corresponding to openssl&#39;s X509_STORE_CTX structure
    #
    # returns: (integer) error code</code></pre>

<p>For more info about error code values check function <a href="./Net::SSLeay.html#get_verify_result">&quot;get_verify_result&quot;</a>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get_error.html">https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get_error.html</a></p>

</li>
<li><p>X509_STORE_CTX_get_error_depth</p>

<p>Returns the depth of the error. This is a non-negative integer representing where in the certificate chain the error occurred. If it is zero it occurred in the end entity certificate, one if it is the certificate which signed the end entity certificate and so on.</p>

<pre><code>    my $rv = Net::SSLeay::X509_STORE_CTX_get_error_depth($x509_store_ctx);
    # $x509_store_ctx - value corresponding to openssl&#39;s X509_STORE_CTX structure
    #
    # returns: (integer) depth</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get_error.html">https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get_error.html</a></p>

</li>
<li><p>X509_STORE_CTX_get_ex_data</p>

<p>Is used to retrieve the information for $idx from $x509_store_ctx.</p>

<pre><code>    my $rv = Net::SSLeay::X509_STORE_CTX_get_ex_data($x509_store_ctx, $idx);
    # $x509_store_ctx - value corresponding to openssl&#39;s X509_STORE_CTX structure
    # $idx - (integer) index for application specific data
    #
    # returns: pointer to ???</code></pre>

</li>
<li><p>X509_STORE_CTX_set_ex_data</p>

<p>Is used to store application data at arg for idx into $x509_store_ctx.</p>

<pre><code>    my $rv = Net::SSLeay::X509_STORE_CTX_set_ex_data($x509_store_ctx, $idx, $data);
    # $x509_store_ctx - value corresponding to openssl&#39;s X509_STORE_CTX structure
    # $idx - (integer) ???
    # $data - (pointer) ???
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_STORE_CTX_set_cert</p>

<p>Sets the certificate to be verified in $x509_store_ctx to $x.</p>

<pre><code>    Net::SSLeay::X509_STORE_CTX_set_cert($x509_store_ctx, $x);
    # $x509_store_ctx - value corresponding to openssl&#39;s X509_STORE_CTX structure
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_new.html">https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_new.html</a></p>

</li>
<li><p>X509_STORE_new</p>

<p>Returns a newly initialized X509_STORE structure.</p>

<pre><code>    my $rv = Net::SSLeay::X509_STORE_new();
    #
    # returns: value corresponding to openssl&#39;s X509_STORE structure (0 on failure)</code></pre>

</li>
<li><p>X509_STORE_free</p>

<p>Frees an X509_STORE structure</p>

<pre><code>    Net::SSLeay::X509_STORE_free($x509_store);
    # $x509_store - value corresponding to openssl&#39;s X509_STORE structure</code></pre>

</li>
<li><p>X509_STORE_add_lookup</p>

<p>Adds a lookup to an X509_STORE for a given lookup method.</p>

<pre><code>    my $method = &amp;Net::SSLeay::X509_LOOKUP_hash_dir;
    my $rv = Net::SSLeay::X509_STORE_add_lookup($x509_store, $method);
    # $method - value corresponding to openssl&#39;s X509_LOOKUP_METHOD structure
    # $x509_store - value corresponding to openssl&#39;s X509_STORE structure
    #
    # returns: value corresponding to openssl&#39;s X509_LOOKUP structure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_STORE_add_lookup.html">https://www.openssl.org/docs/manmaster/man3/X509_STORE_add_lookup.html</a></p>

</li>
<li><p>X509_STORE_CTX_set_error</p>

<p>Sets the error code of $ctx to $s. For example it might be used in a verification callback to set an error based on additional checks.</p>

<pre><code>    Net::SSLeay::X509_STORE_CTX_set_error($x509_store_ctx, $s);
    # $x509_store_ctx - value corresponding to openssl&#39;s X509_STORE_CTX structure
    # $s - (integer) error id
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get_error.html">https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get_error.html</a></p>

</li>
<li><p>X509_STORE_add_cert</p>

<p>Adds X509 certificate $x into the X509_STORE $store.</p>

<pre><code>    my $rv = Net::SSLeay::X509_STORE_add_cert($store, $x);
    # $store - value corresponding to openssl&#39;s X509_STORE structure
    # $x - value corresponding to openssl&#39;s X509 structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_STORE_add_crl</p>

<p>Adds X509 CRL $x into the X509_STORE $store.</p>

<pre><code>    my $rv = Net::SSLeay::X509_STORE_add_crl($store, $x);
    # $store - value corresponding to openssl&#39;s X509_STORE structure
    # $x - value corresponding to openssl&#39;s X509_CRL structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_STORE_set1_param</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::X509_STORE_set1_param($store, $pm);
    # $store - value corresponding to openssl&#39;s X509_STORE structure
    # $pm - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_LOOKUP_hash_dir</p>

<p>Returns an X509_LOOKUP structure that instructs an X509_STORE to load files from a directory containing certificates with filenames in the format <i>hash.N</i> or crls with filenames in the format <i>hash.</i><b>r</b><i>N</i></p>

<pre><code>    my $rv = Net::SSLeay::X509_LOOKUP_hash_dir();
    #
    # returns: value corresponding to openssl&#39;s X509_LOOKUP_METHOD structure, with the hashed directory method</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_load_crl_file.html">https://www.openssl.org/docs/manmaster/man3/X509_load_crl_file.html</a></p>

</li>
<li><p>X509_LOOKUP_add_dir</p>

<p>Add a directory to an X509_LOOKUP structure, usually obtained from X509_STORE_add_lookup.</p>

<pre><code>    my $method = &amp;Net::SSLeay::X509_LOOKUP_hash_dir;
    my $lookup = Net::SSLeay::X509_STORE_add_lookup($x509_store, $method);
    my $type = &amp;Net::SSLeay::X509_FILETYPE_PEM;
    Net::SSLeay::X509_LOOKUP_add_dir($lookup, $dir, $type);
    # $lookup - value corresponding to openssl&#39;s X509_LOOKUP structure
    # $dir - string path to a directory
    # $type - constant corresponding to the type of file in the directory - can be X509_FILETYPE_PEM, X509_FILETYPE_DEFAULT, or X509_FILETYPE_ASN1</code></pre>

</li>
<li><p>X509_STORE_set_flags</p>

<pre><code>    Net::SSLeay::X509_STORE_set_flags($ctx, $flags);
    # $ctx - value corresponding to openssl&#39;s X509_STORE structure
    # $flags - (unsigned long) flags to be set (bitmask)
    #
    # returns: no return value

    # to create $flags value use corresponding constants like
    $flags = Net::SSLeay::X509_V_FLAG_CRL_CHECK();</code></pre>

<p>For more details about $flags bitmask see <a href="./Net::SSLeay.html#X509_VERIFY_PARAM_set_flags">&quot;X509_VERIFY_PARAM_set_flags&quot;</a>.</p>

</li>
<li><p>X509_STORE_set_purpose</p>

<pre><code>    Net::SSLeay::X509_STORE_set_purpose($ctx, $purpose);
    # $ctx - value corresponding to openssl&#39;s X509_STORE structure
    # $purpose - (integer) purpose identifier
    #
    # returns: no return value</code></pre>

<p>For more details about $purpose identifier check <a href="./Net::SSLeay.html#CTX_set_purpose">&quot;CTX_set_purpose&quot;</a>.</p>

</li>
<li><p>X509_STORE_set_trust</p>

<pre><code>    Net::SSLeay::X509_STORE_set_trust($ctx, $trust);
    # $ctx - value corresponding to openssl&#39;s X509_STORE structure
    # $trust - (integer) trust identifier
    #
    # returns: no return value</code></pre>

<p>For more details about $trust identifier check <a href="./Net::SSLeay.html#CTX_set_trust">&quot;CTX_set_trust&quot;</a>.</p>

</li>
</ul>

<h3 id="Low-Level-API:-X509_INFO-related-functions"><a id="Low24"></a>Low Level API: X509_INFO related functions</h3>

<ul>

<li><p>sk_X509_INFO_num</p>

<p>Returns the number of values in a STACK_OF(X509_INFO) structure.</p>

<pre><code>    my $rv = Net::SSLeay::sk_X509_INFO_num($sk_x509_info);
    # $sk_x509_info - value corresponding to openssl&#39;s STACK_OF(X509_INFO) structure
    #
    # returns: number of values in $sk_X509_info</code></pre>

</li>
<li><p>sk_X509_INFO_value</p>

<p>Returns the value of a STACK_OF(X509_INFO) structure at a given index.</p>

<pre><code>    my $rv = Net::SSLeay::sk_X509_INFO_value($sk_x509_info, $index);
    # $sk_x509_info - value corresponding to openssl&#39;s STACK_OF(X509_INFO) structure
    # $index - index into the stack
    #
    # returns: value corresponding to openssl&#39;s X509_INFO structure at the given index</code></pre>

</li>
<li><p>P_X509_INFO_get_x509</p>

<p>Returns the X509 structure stored in an X509_INFO structure.</p>

<pre><code>    my $rv = Net::SSLeay::P_X509_INFO_get_x509($x509_info);
    # $x509_info - value corresponding to openssl&#39;s X509_INFO structure
    #
    # returns: value corresponding to openssl&#39;s X509 structure</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-X509_VERIFY_PARAM_*-related-functions"><a id="Low25"></a><a id="Low-level-API:-X509_VERIFY_PARAM_--related-functions"></a>Low level API: X509_VERIFY_PARAM_* related functions</h3>

<ul>

<li><p>X509_VERIFY_PARAM_add0_policy</p>

<p>Enables policy checking (it is disabled by default) and adds $policy to the acceptable policy set.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_add0_policy($param, $policy);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $policy - value corresponding to openssl&#39;s ASN1_OBJECT structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_add0_table</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_add0_table($param);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_VERIFY_PARAM_add1_host</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.0.2-beta2 or LibreSSL 2.7.0</p>

<p>Adds an additional reference identifier that can match the peer&#39;s certificate.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_add1_host($param, $name);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $name - (string) name to be set
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>See also OpenSSL docs, <a href="./Net::SSLeay.html#X509_VERIFY_PARAM_set1_host">&quot;X509_VERIFY_PARAM_set1_host&quot;</a> and <a href="./Net::SSLeay.html#X509_VERIFY_PARAM_set_hostflags">&quot;X509_VERIFY_PARAM_set_hostflags&quot;</a> for more information, including wildcard matching.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_clear_flags</p>

<p>Clears the flags $flags in param.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_clear_flags($param, $flags);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $flags - (unsigned long) flags to be set (bitmask)
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>For more details about $flags bitmask see <a href="./Net::SSLeay.html#X509_VERIFY_PARAM_set_flags">&quot;X509_VERIFY_PARAM_set_flags&quot;</a>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_free</p>

<p>Frees up the X509_VERIFY_PARAM structure.</p>

<pre><code>    Net::SSLeay::X509_VERIFY_PARAM_free($param);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    #
    # returns: no return value</code></pre>

</li>
<li><p>X509_VERIFY_PARAM_get0_peername</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.0.2-beta2 or LibreSSL 2.7.0</p>

<p>Returns the DNS hostname or subject CommonName from the peer certificate that matched one of the reference identifiers.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_get0_peername($param);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    #
    # returns: (string) name e.g. &#39;*.example.com&#39; or undef</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_get_depth</p>

<p>Returns the current verification depth.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_get_depth($param);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    #
    # returns: (integer) depth</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_get_flags</p>

<p>Returns the current verification flags.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_get_flags($param);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    #
    # returns: (unsigned long) flags to be set (bitmask)</code></pre>

<p>For more details about returned flags bitmask see <a href="./Net::SSLeay.html#X509_VERIFY_PARAM_set_flags">&quot;X509_VERIFY_PARAM_set_flags&quot;</a>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_set_flags</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_set_flags($param, $flags);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $flags - (unsigned long) flags to be set (bitmask)
    #
    # returns: 1 on success, 0 on failure

    # to create $flags value use corresponding constants like
    $flags = Net::SSLeay::X509_V_FLAG_CRL_CHECK();</code></pre>

<p>For more details about $flags bitmask, see the OpenSSL docs below.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_inherit</p>

<p>??? (more info needed)</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_inherit($to, $from);
    # $to - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $from - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_VERIFY_PARAM_lookup</p>

<p>Finds X509_VERIFY_PARAM by name.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_lookup($name);
    # $name - (string) name we want to find
    #
    # returns: value corresponding to openssl&#39;s X509_VERIFY_PARAM structure (0 on failure)</code></pre>

</li>
<li><p>X509_VERIFY_PARAM_new</p>

<p>Creates a new X509_VERIFY_PARAM structure.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_new();
    #
    # returns: value corresponding to openssl&#39;s X509_VERIFY_PARAM structure (0 on failure)</code></pre>

</li>
<li><p>X509_VERIFY_PARAM_set1</p>

<p>Sets the name of X509_VERIFY_PARAM structure $to to the same value as the name of X509_VERIFY_PARAM structure $from.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1($to, $from);
    # $to - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $from - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_VERIFY_PARAM_set1_email</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.0.2-beta1 or LibreSSL 2.7.0</p>

<p>Sets the expected RFC822 email address to email.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1_email($param, $email);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $email - (string) email to be set
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_set1_host</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.0.2-beta1 or LibreSSL 2.7.0</p>

<p>Sets the expected DNS hostname to name clearing any previously specified host name or names.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1_host($param, $name);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $name - (string) name to be set
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>See also OpenSSL docs, <a href="./Net::SSLeay.html#X509_VERIFY_PARAM_add1_host">&quot;X509_VERIFY_PARAM_add1_host&quot;</a> and <a href="./Net::SSLeay.html#X509_VERIFY_PARAM_set_hostflags">&quot;X509_VERIFY_PARAM_set_hostflags&quot;</a> for more information, including wildcard matching.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_set1_ip</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.0.2-beta1 or LibreSSL 2.7.0</p>

<p>Sets the expected IP address to ip.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1_ip($param, $ip);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $ip - (binary) 4 octet IPv4 or 16 octet IPv6 address
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_set1_ip_asc</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.0.2-beta1 or LibreSSL 2.7.0</p>

<p>Sets the expected IP address to ipasc.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1_asc($param, $ipasc);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $ip - (string) IPv4 or IPv6 address
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_set1_name</p>

<p>Sets the name of X509_VERIFY_PARAM structure $param to $name.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1_name($param, $name);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $name - (string) name to be set
    #
    # returns: 1 on success, 0 on failure</code></pre>

</li>
<li><p>X509_VERIFY_PARAM_set1_policies</p>

<p>Enables policy checking (it is disabled by default) and sets the acceptable policy set to policies. Any existing policy set is cleared. The policies parameter can be 0 to clear an existing policy set.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1_policies($param, $policies);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $policies - value corresponding to openssl&#39;s STACK_OF(ASN1_OBJECT) structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_set_depth</p>

<p>Sets the maximum verification depth to depth. That is the maximum number of untrusted CA certificates that can appear in a chain.</p>

<pre><code>    Net::SSLeay::X509_VERIFY_PARAM_set_depth($param, $depth);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $depth - (integer) depth to be set
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_set_hostflags</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.0.2-beta2 or LibreSSL 2.7.0</p>

<pre><code>    Net::SSLeay::X509_VERIFY_PARAM_set_hostflags($param, $flags);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $flags - (unsigned int) flags to be set (bitmask)
    #
    # returns: no return value</code></pre>

<p>See also OpenSSL docs, <a href="./Net::SSLeay.html#X509_VERIFY_PARAM_add1_host">&quot;X509_VERIFY_PARAM_add1_host&quot;</a> and <a href="./Net::SSLeay.html#X509_VERIFY_PARAM_set1_host">&quot;X509_VERIFY_PARAM_set1_host&quot;</a> for more information. The flags for controlling wildcard checks and other features are defined in OpenSSL docs.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_set_purpose</p>

<p>Sets the verification purpose in $param to $purpose. This determines the acceptable purpose of the certificate chain, for example SSL client or SSL server.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_set_purpose($param, $purpose);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $purpose - (integer) purpose identifier
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>For more details about $purpose identifier check <a href="./Net::SSLeay.html#CTX_set_purpose">&quot;CTX_set_purpose&quot;</a>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_set_time</p>

<p>Sets the verification time in $param to $t. Normally the current time is used.</p>

<pre><code>    Net::SSLeay::X509_VERIFY_PARAM_set_time($param, $t);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $t - (time_t) time in seconds since 1.1.1970
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_set_trust</p>

<p>Sets the trust setting in $param to $trust.</p>

<pre><code>    my $rv = Net::SSLeay::X509_VERIFY_PARAM_set_trust($param, $trust);
    # $param - value corresponding to openssl&#39;s X509_VERIFY_PARAM structure
    # $trust - (integer) trust identifier
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>For more details about $trust identifier check <a href="./Net::SSLeay.html#CTX_set_trust">&quot;CTX_set_trust&quot;</a>.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html">https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html</a></p>

</li>
<li><p>X509_VERIFY_PARAM_table_cleanup</p>

<p>??? (more info needed)</p>

<pre><code>    Net::SSLeay::X509_VERIFY_PARAM_table_cleanup();
    #
    # returns: no return value</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-Cipher-(EVP_CIPHER_*)-related-functions"><a id="Low26"></a><a id="Low-level-API:-Cipher--EVP_CIPHER_--related-functions"></a>Low level API: Cipher (EVP_CIPHER_*) related functions</h3>

<ul>

<li><p>EVP_get_cipherbyname</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before</p>

<p>Returns an EVP_CIPHER structure when passed a cipher name.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_get_cipherbyname($name);
    # $name - (string) cipher name e.g. &#39;aes-128-cbc&#39;, &#39;camellia-256-ecb&#39;, &#39;des-ede&#39;, ...
    #
    # returns: value corresponding to openssl&#39;s EVP_CIPHER structure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/EVP_EncryptInit.html">https://www.openssl.org/docs/manmaster/man3/EVP_EncryptInit.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-Digest-(EVP_MD_*)-related-functions"><a id="Low27"></a><a id="Low-level-API:-Digest--EVP_MD_--related-functions"></a>Low level API: Digest (EVP_MD_*) related functions</h3>

<ul>

<li><p>OpenSSL_add_all_digests</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<pre><code>    Net::SSLeay::OpenSSL_add_all_digests();
    # no args, no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OpenSSL_add_all_algorithms.html">https://www.openssl.org/docs/manmaster/man3/OpenSSL_add_all_algorithms.html</a></p>

</li>
<li><p>P_EVP_MD_list_all</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before; requires at least OpenSSL 1.0.0</p>

<p><b>NOTE:</b> Does not exactly correspond to any low level API function</p>

<pre><code>    my $rv = Net::SSLeay::P_EVP_MD_list_all();
    #
    # returns: arrayref - list of available digest names</code></pre>

<p>The returned digest names correspond to values expected by <a href="./Net::SSLeay.html#EVP_get_digestbyname">&quot;EVP_get_digestbyname&quot;</a>.</p>

<p>Note that some of the digests are available by default and some only after calling <a href="./Net::SSLeay.html#OpenSSL_add_all_digests">&quot;OpenSSL_add_all_digests&quot;</a>.</p>

</li>
<li><p>EVP_get_digestbyname</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<pre><code>    my $rv = Net::SSLeay::EVP_get_digestbyname($name);
    # $name - string with digest name
    #
    # returns: value corresponding to openssl&#39;s EVP_MD structure

    # The $name param can be:
    # md2
    # md4
    # md5
    # mdc2
    # ripemd160
    # sha
    # sha1
    # sha224
    # sha256
    # sha512
    # whirlpool</code></pre>

<p>Or better check the supported digests by calling <a href="./Net::SSLeay.html#P_EVP_MD_list_all">&quot;P_EVP_MD_list_all&quot;</a>.</p>

</li>
<li><p>EVP_MD_type</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<pre><code>    my $rv = Net::SSLeay::EVP_MD_type($md);
    # $md - value corresponding to openssl&#39;s EVP_MD structure
    #
    # returns: the NID (integer) of the OBJECT IDENTIFIER representing the given message digest</code></pre>

<p><code>EVP_MD_type</code> is a non-deprecated alias macro of <code>EVP_MD_get_type</code> since OpenSSL 3.0.0.</p>

</li>
<li><p>EVP_MD_size</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<pre><code>    my $rv = Net::SSLeay::EVP_MD_size($md);
    # $md - value corresponding to openssl&#39;s EVP_MD structure
    #
    # returns: the size of the message digest in bytes (e.g. 20 for SHA1)</code></pre>

</li>
<li><p>EVP_MD_get0_description</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 3.0.0-beta1, not in LibreSSL</p>

<p>Return description of a message digest.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_MD_get0_description($md);
    # $md - value corresponding to openssl&#39;s EVP_MD structure
    #
    # returns: String, a freeform and digest implementation dependent description of the digest for display and human consumption. (e.g. sha256)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/EVP_MD_get0_description.html">https://www.openssl.org/docs/manmaster/man3/EVP_MD_get0_description.html</a></p>

</li>
<li><p>EVP_MD_get0_name</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 3.0.0-beta1, not in LibreSSL</p>

<p>Return one name of a message digest.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_MD_get0_description($md);
    # $md - value corresponding to openssl&#39;s EVP_MD structure
    #
    # returns: String, the name of the given message digest. For fetched message digests with multiple names, only one of them is returned; it&#39;s recommended to use EVP_MD_names_do_all() instead. (e.g. SHA2-256 or SHA256 for the same digest)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/EVP_MD_get0_name.html">https://www.openssl.org/docs/manmaster/man3/EVP_MD_get0_name.html</a></p>

</li>
<li><p>EVP_MD_get_type</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 3.0.0-beta1, not in LibreSSL</p>

<p>Return NID value of a message digest.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_MD_get_type($md);
    # $md - value corresponding to openssl&#39;s EVP_MD structure
    #
    # returns: Integer, the NID of the OBJECT IDENTIFIER representing the given message digest when passed an EVP_MD structure.</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/EVP_MD_get_type.html">https://www.openssl.org/docs/manmaster/man3/EVP_MD_get_type.html</a></p>

</li>
<li><p>EVP_MD_CTX_md</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<pre><code>    Net::SSLeay::EVP_MD_CTX_md($ctx);
    # $ctx - value corresponding to openssl&#39;s EVP_MD_CTX structure
    #
    # returns: value corresponding to openssl&#39;s EVP_MD structure</code></pre>

</li>
<li><p>EVP_MD_CTX_create</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<p>Allocates, initializes and returns a digest context.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_MD_CTX_create();
    #
    # returns: value corresponding to openssl&#39;s EVP_MD_CTX structure</code></pre>

<p>The complete idea behind EVP_MD_CTX looks like this example:</p>

<pre><code>    Net::SSLeay::OpenSSL_add_all_digests();

    my $md = Net::SSLeay::EVP_get_digestbyname(&quot;sha1&quot;);
    my $ctx = Net::SSLeay::EVP_MD_CTX_create();
    Net::SSLeay::EVP_DigestInit($ctx, $md);

    while(my $chunk = get_piece_of_data()) {
        Net::SSLeay::EVP_DigestUpdate($ctx,$chunk);
    }

    my $result = Net::SSLeay::EVP_DigestFinal($ctx);
    Net::SSLeay::EVP_MD_CTX_destroy($ctx);

    print &quot;digest=&quot;, unpack(&#39;H*&#39;, $result), &quot;\n&quot;; # print hex value</code></pre>

</li>
<li><p>EVP_DigestInit_ex</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<p>Sets up digest context $ctx to use a digest $type from ENGINE $impl, $ctx must be initialized before calling this function, type will typically be supplied by a function such as <a href="./Net::SSLeay.html#EVP_get_digestbyname">&quot;EVP_get_digestbyname&quot;</a>. If $impl is 0 then the default implementation of digest $type is used.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_DigestInit_ex($ctx, $type, $impl);
    # $ctx  - value corresponding to openssl&#39;s EVP_MD_CTX structure
    # $type - value corresponding to openssl&#39;s EVP_MD structure
    # $impl - value corresponding to openssl&#39;s ENGINE structure
    #
    # returns: 1 for success and 0 for failure</code></pre>

</li>
<li><p>EVP_DigestInit</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<p>Behaves in the same way as <a href="./Net::SSLeay.html#EVP_DigestInit_ex">&quot;EVP_DigestInit_ex&quot;</a> except the passed context $ctx does not have to be initialized, and it always uses the default digest implementation.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_DigestInit($ctx, $type);
    # $ctx - value corresponding to openssl&#39;s EVP_MD_CTX structure
    # $type - value corresponding to openssl&#39;s EVP_MD structure
    #
    # returns: 1 for success and 0 for failure</code></pre>

</li>
<li><p>EVP_MD_CTX_destroy</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<p>Cleans up digest context $ctx and frees up the space allocated to it, it should be called only on a context created using <a href="./Net::SSLeay.html#EVP_MD_CTX_create">&quot;EVP_MD_CTX_create&quot;</a>.</p>

<pre><code>    Net::SSLeay::EVP_MD_CTX_destroy($ctx);
    # $ctx - value corresponding to openssl&#39;s EVP_MD_CTX structure
    #
    # returns: no return value</code></pre>

</li>
<li><p>EVP_DigestUpdate</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<pre><code>    my $rv = Net::SSLeay::EVP_DigestUpdate($ctx, $data);
    # $ctx  - value corresponding to openssl&#39;s EVP_MD_CTX structure
    # $data - data to be hashed
    #
    # returns: 1 for success and 0 for failure</code></pre>

</li>
<li><p>EVP_DigestFinal_ex</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<p>Retrieves the digest value from $ctx. After calling <a href="./Net::SSLeay.html#EVP_DigestFinal_ex">&quot;EVP_DigestFinal_ex&quot;</a> no additional calls to <a href="./Net::SSLeay.html#EVP_DigestUpdate">&quot;EVP_DigestUpdate&quot;</a> can be made, but <a href="./Net::SSLeay.html#EVP_DigestInit_ex">&quot;EVP_DigestInit_ex&quot;</a> can be called to initialize a new digest operation.</p>

<pre><code>    my $digest_value = Net::SSLeay::EVP_DigestFinal_ex($ctx);
    # $ctx - value corresponding to openssl&#39;s EVP_MD_CTX structure
    #
    # returns: hash value (binary)

    # to get printable (hex) value of digest use:
    print unpack(&#39;H*&#39;, $digest_value);</code></pre>

</li>
<li><p>EVP_DigestFinal</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<p>Similar to <a href="./Net::SSLeay.html#EVP_DigestFinal_ex">&quot;EVP_DigestFinal_ex&quot;</a> except the digest context ctx is automatically cleaned up.</p>

<pre><code>    my $rv = Net::SSLeay::EVP_DigestFinal($ctx);
    # $ctx - value corresponding to openssl&#39;s EVP_MD_CTX structure
    #
    # returns: hash value (binary)

    # to get printable (hex) value of digest use:
    print unpack(&#39;H*&#39;, $digest_value);</code></pre>

</li>
<li><p>MD2</p>

<p><b>COMPATIBILITY:</b> not supported by default in OpenSSL 1.0.0</p>

<p>Computes MD2 from given $data (all data needs to be loaded into memory)</p>

<pre><code>    my $digest = Net::SSLeay::MD2($data);
    print &quot;digest(hexadecimal)=&quot;, unpack(&#39;H*&#39;, $digest);</code></pre>

</li>
<li><p>MD4</p>

<p>Computes MD4 from given $data (all data needs to be loaded into memory)</p>

<pre><code>    my $digest = Net::SSLeay::MD4($data);
    print &quot;digest(hexadecimal)=&quot;, unpack(&#39;H*&#39;, $digest);</code></pre>

</li>
<li><p>MD5</p>

<p>Computes MD5 from given $data (all data needs to be loaded into memory)</p>

<pre><code>    my $digest = Net::SSLeay::MD5($data);
    print &quot;digest(hexadecimal)=&quot;, unpack(&#39;H*&#39;, $digest);</code></pre>

</li>
<li><p>RIPEMD160</p>

<p>Computes RIPEMD160 from given $data (all data needs to be loaded into memory)</p>

<pre><code>    my $digest = Net::SSLeay::RIPEMD160($data);
    print &quot;digest(hexadecimal)=&quot;, unpack(&#39;H*&#39;, $digest);</code></pre>

</li>
<li><p>SHA1</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<p>Computes SHA1 from given $data (all data needs to be loaded into memory)</p>

<pre><code>    my $digest = Net::SSLeay::SHA1($data);
    print &quot;digest(hexadecimal)=&quot;, unpack(&#39;H*&#39;, $digest);</code></pre>

</li>
<li><p>SHA256</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before; requires at least OpenSSL 0.9.8</p>

<p>Computes SHA256 from given $data (all data needs to be loaded into memory)</p>

<pre><code>    my $digest = Net::SSLeay::SHA256($data);
    print &quot;digest(hexadecimal)=&quot;, unpack(&#39;H*&#39;, $digest);</code></pre>

</li>
<li><p>SHA512</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before; requires at least OpenSSL 0.9.8</p>

<p>Computes SHA512 from given $data (all data needs to be loaded into memory)</p>

<pre><code>    my $digest = Net::SSLeay::SHA512($data);
    print &quot;digest(hexadecimal)=&quot;, unpack(&#39;H*&#39;, $digest);</code></pre>

</li>
<li><p>EVP_Digest</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<p>Computes &quot;any&quot; digest from given $data (all data needs to be loaded into memory)</p>

<pre><code>    my $md = Net::SSLeay::EVP_get_digestbyname(&quot;sha1&quot;); # or any other algorithm
    my $digest = Net::SSLeay::EVP_Digest($data, $md);
    print &quot;digest(hexadecimal)=&quot;, unpack(&#39;H*&#39;, $digest);</code></pre>

</li>
<li><p>EVP_sha1</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<pre><code>    my $md = Net::SSLeay::EVP_sha1();
    #
    # returns: value corresponding to openssl&#39;s EVP_MD structure</code></pre>

</li>
<li><p>EVP_sha256</p>

<p><b>COMPATIBILITY:</b> requires at least OpenSSL 0.9.8</p>

<pre><code>    my $md = Net::SSLeay::EVP_sha256();
    #
    # returns: value corresponding to openssl&#39;s EVP_MD structure</code></pre>

</li>
<li><p>EVP_sha512</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before; requires at least OpenSSL 0.9.8</p>

<pre><code>    my $md = Net::SSLeay::EVP_sha512();
    #
    # returns: value corresponding to openssl&#39;s EVP_MD structure</code></pre>

</li>
<li><p>EVP_add_digest</p>

<pre><code>    my $rv = Net::SSLeay::EVP_add_digest($digest);
    # $digest - value corresponding to openssl&#39;s EVP_MD structure
    #
    # returns: 1 on success, 0 otherwise</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-CIPHER_*-related-functions"><a id="Low28"></a><a id="Low-level-API:-CIPHER_--related-functions"></a>Low level API: CIPHER_* related functions</h3>

<ul>

<li><p>CIPHER_get_name</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and before</p>

<p>Returns name of the cipher used.</p>

<pre><code>    my $rv = Net::SSLeay::CIPHER_get_name($cipher);
    # $cipher - value corresponding to openssl&#39;s SSL_CIPHER structure
    #
    # returns: (string) cipher name e.g. &#39;DHE-RSA-AES256-SHA&#39;, &#39;(NONE)&#39; if $cipher is undefined.</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CIPHER_get_name.html">https://www.openssl.org/docs/manmaster/man3/SSL_CIPHER_get_name.html</a></p>

<p>Example:</p>

<pre><code>    my $ssl_cipher = Net::SSLeay::get_current_cipher($ssl);
    my $cipher_name = Net::SSLeay::CIPHER_get_name($ssl_cipher);</code></pre>

</li>
<li><p>CIPHER_description</p>

<p><b>COMPATIBILITY:</b> doesn&#39;t work correctly in Net-SSLeay-1.88 and before</p>

<p>Returns a textual description of the cipher used.</p>

<pre><code>    my $rv = Net::SSLeay::CIPHER_description($cipher);
    # $cipher - value corresponding to openssl&#39;s SSL_CIPHER structure
    #
    # returns: (string) cipher description e.g. &#39;DHE-RSA-AES256-SHA SSLv3 Kx=DH Au=RSA Enc=AES(256) Mac=SHA1&#39;</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CIPHER_description.html">https://www.openssl.org/docs/manmaster/man3/SSL_CIPHER_description.html</a></p>

</li>
<li><p>CIPHER_get_bits</p>

<p><b>COMPATIBILITY:</b> $alg_bits doesn&#39;t work correctly in Net-SSLeay-1.88 and before</p>

<p>Returns the number of secret bits used for cipher.</p>

<pre><code>    my $rv = Net::SSLeay::CIPHER_get_bits($cipher, $alg_bits);
    # $cipher - value corresponding to openssl&#39;s SSL_CIPHER structure
    # $alg_bits - [optional] empty scalar for storing additional return value
    #
    # returns: (integer) number of secret bits, 0 on error
    #          (integer) in $alg_bits for bits processed by the chosen algorithm</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CIPHER_get_bits.html">https://www.openssl.org/docs/manmaster/man3/SSL_CIPHER_get_bits.html</a></p>

<p>Example:</p>

<pre><code>    # bits and alg_bits are not equal for e.g., TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
    # RFC 8422 name TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
    my $alg_bits;
    my $bits = Net::SSLeay::CIPHER_get_bits($cipher, $alg_bits);
    # my $bits = Net::SSLeay::CIPHER_get_bits($cipher);
    print &quot;bits: $bits, alg_bits: $alg_bits\n&quot;;</code></pre>

</li>
<li><p>CIPHER_get_version</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.88 and before</p>

<p>Returns version of SSL/TLS protocol that first defined the cipher</p>

<pre><code>    my $rv = Net::SSLeay::CIPHER_get_version($cipher);
    # $cipher - value corresponding to openssl&#39;s SSL_CIPHER structure
    #
    # returns: (string) cipher name e.g. &#39;TLSv1/SSLv3&#39; with some libraries, &#39;TLSv1.0&#39; or &#39;TLSv1.3&#39;, &#39;(NONE)&#39; if $cipher is undefined.</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CIPHER_get_version.html">https://www.openssl.org/docs/manmaster/man3/SSL_CIPHER_get_version.html</a></p>

</li>
<li><p>CIPHER_get_handshake_digest</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.1.1-pre1, not in LibreSSL</p>

<p>Returns version of SSL/TLS protocol that first defined the cipher</p>

<pre><code>    my $rv = Net::SSLeay::CIPHER_get_handshake_digest($cipher);
    # $cipher - value corresponding to openssl&#39;s SSL_CIPHER structure
    #
    # returns: A value corresponding to OpenSSL&#39;s EVP_MD structure for the digest used during the SSL/TLS handshake when using $cipher.</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/ssl/SSL_CIPHER_get_handshake_digest.html">https://www.openssl.org/docs/ssl/SSL_CIPHER_get_handshake_digest.html</a></p>

</li>
<li><p>CIPHER_find</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before; requires at least OpenSSL 1.0.2 or LibreSSL 3.4.0</p>

<p>Returns a SSL_CIPHER structure from the current SSL using a two octet cipher ID.</p>

<pre><code>    my $cipher = Net::SSLeay::CIPHER_find($ssl, $id);
    # $ssl - value corresponding to OpenSSL SSL structure
    # $id - two octet cipher ID.
    #
    # returns: A value corresponding to OpenSSL SSL_CIPHER structure or undef if cipher is not found or an error occurs.</code></pre>

<p>Example that prints &#39;OpenSSL name is: TLS_AES_128_GCM_SHA256&#39; with TLSv1.3 when the ciphersuite is enabled:</p>

<pre><code>    # TLS Cipher Suite 0x13, 0x01 is TLS_AES_128_GCM_SHA256
    my $id = pack(&#39;n&#39;, 0x1301);
    my $cipher =  Net::SSLeay::CIPHER_find($ssl, $id);
    printf(&quot;OpenSSL name is: &quot; . Net::SSLeay::CIPHER_get_name($cipher));</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CIPHER_find.html">https://www.openssl.org/docs/manmaster/man3/SSL_CIPHER_find.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-BN_*-related-functions"><a id="Low29"></a><a id="Low-level-API:-BN_--related-functions"></a>Low level API: BN_* related functions</h3>

<ul>

<li><p>BN_dup</p>

<p>Creates and returns a new BIGNUM from an existing BIGNUM.</p>

<pre><code>    my $bn = Net::SSLeay::BN_dup($from);
    # $from - value corresponding to BIGNUM structure
    #
    # returns: a new BIGNUM containing the value $from</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BN_dup.html">https://www.openssl.org/docs/manmaster/man3/BN_dup.html</a></p>

</li>
<li><p>BN_clear</p>

<p>Clears BIGNUM data when it is no longer needed.</p>

<pre><code>    Net::SSLeay::BN_clear($bn);
    # $bn - value corresponding to BIGNUM structure
    #
    # returns: nothing. $bn is set to 0.</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BN_clear.html">https://www.openssl.org/docs/manmaster/man3/BN_clear.html</a></p>

</li>
<li><p>BN_clear_free</p>

<p>Clears and frees a previously allocated BIGNUM.</p>

<pre><code>    Net::SSLeay::BN_clear_free($bn);
    # $bn - value corresponding to BIGNUM structure
    #
    # returns: nothing. $bn is no longer usable.</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BN_clear_free.html">https://www.openssl.org/docs/manmaster/man3/BN_clear_free.html</a></p>

</li>
<li><p>BN_free</p>

<p>Frees previously a allocated BIGNUM.</p>

<pre><code>    Net::SSLeay::BN_free($bn);
    # $bn - value corresponding to BIGNUM structure
    #
    # returns: nothing. $bn is no longer usable.</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BN_free.html">https://www.openssl.org/docs/manmaster/man3/BN_free.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-RSA_*-related-functions"><a id="Low30"></a><a id="Low-level-API:-RSA_--related-functions"></a>Low level API: RSA_* related functions</h3>

<ul>

<li><p>RSA_generate_key</p>

<p>Generates a key pair and returns it in a newly allocated RSA structure. The pseudo-random number generator must be seeded prior to calling RSA_generate_key.</p>

<pre><code>    my $rv = Net::SSLeay::RSA_generate_key($bits, $e, $perl_cb, $perl_cb_arg);
    # $bits - (integer) modulus size in bits e.g. 512, 1024, 2048
    # $e - (integer) public exponent, an odd number, typically 3, 17 or 65537
    # $perl_cb - [optional] reference to perl callback function
    # $perl_cb_arg - [optional] data that will be passed to callback function when invoked
    #
    # returns: value corresponding to openssl&#39;s RSA structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RSA_generate_key.html">https://www.openssl.org/docs/manmaster/man3/RSA_generate_key.html</a></p>

</li>
<li><p>RSA_free</p>

<p>Frees the RSA structure and its components. The key is erased before the memory is returned to the system.</p>

<pre><code>    Net::SSLeay::RSA_free($r);
    # $r - value corresponding to openssl&#39;s RSA structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RSA_new.html">https://www.openssl.org/docs/manmaster/man3/RSA_new.html</a></p>

</li>
<li><p>RSA_get_key_parameters</p>

<p><b>COMPATIBILITY</b>: not available when OpenSSL is 1.1.0 or later and Net-SSLeay is 1.92 or earlier</p>

<p>Returns a list of pointers to BIGNUMs representing the parameters of the key in this order: <code>(n, e, d, p, q, dmp1, dmq1, iqmp)</code></p>

<p><b>Caution</b>: returned list consists of direct pointers to BIGNUMs. These must not be freed by the caller. These pointers can be used to duplicate a BIGNUM, which would need to be blessed as Crypt::OpenSSL::Bignum for further use. See <a href="https://metacpan.org/pod/Crypt::OpenSSL::Bignum">Crypt::OpenSSL::Bignum</a> and OpenSSL manual for more about <code>bless_pointer</code> to why <code>BN_dup()</code> is used.</p>

<pre><code>    my (@params) = RSA_get_key_parameters($r);

    my $dup = Net::SSLeay::BN_dup($params[1]);
    my $e = Crypt::OpenSSL::Bignum-&gt;bless_pointer($dup);
    print &quot;exponent: &quot;, $e-&gt;to_decimal(), &quot;\n&quot;;</code></pre>

<p>This function has no equivalent in OpenSSL or LibreSSL but combines functions <code>RSA_get0_key</code>, <code>RSA_get0_factors</code> and <code>RSA_get0_crt_params</code> for an easier interface.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/RSA_get0_key.html">https://www.openssl.org/docs/manmaster/man3/RSA_get0_key.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-BIO_*-related-functions"><a id="Low31"></a><a id="Low-level-API:-BIO_--related-functions"></a>Low level API: BIO_* related functions</h3>

<ul>

<li><p>BIO_eof</p>

<p>Returns 1 if the BIO has read EOF, the precise meaning of &#39;EOF&#39; varies according to the BIO type.</p>

<pre><code>    my $rv = Net::SSLeay::BIO_eof($s);
    # $s - value corresponding to openssl&#39;s BIO structure
    #
    # returns: 1 if EOF has been reached 0 otherwise</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_ctrl.html">https://www.openssl.org/docs/manmaster/man3/BIO_ctrl.html</a></p>

</li>
<li><p>BIO_f_ssl</p>

<p>Returns the SSL BIO method. This is a filter BIO which is a wrapper round the OpenSSL SSL routines adding a BIO &#39;flavour&#39; to SSL I/O.</p>

<pre><code>    my $rv = Net::SSLeay::BIO_f_ssl();
    #
    # returns: value corresponding to openssl&#39;s BIO_METHOD structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_f_ssl.html">https://www.openssl.org/docs/manmaster/man3/BIO_f_ssl.html</a></p>

</li>
<li><p>BIO_free</p>

<p>Frees up a single BIO.</p>

<pre><code>    my $rv = Net::SSLeay::BIO_free($bio);
    # $bio; - value corresponding to openssl&#39;s BIO structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_new.html">https://www.openssl.org/docs/manmaster/man3/BIO_new.html</a></p>

</li>
<li><p>BIO_new</p>

<p>Returns a new BIO using method $type</p>

<pre><code>    my $rv = Net::SSLeay::BIO_new($type);
    # $type - value corresponding to openssl&#39;s BIO_METHOD structure
    #
    # returns: value corresponding to openssl&#39;s BIO structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_new.html">https://www.openssl.org/docs/manmaster/man3/BIO_new.html</a></p>

</li>
<li><p>BIO_new_buffer_ssl_connect</p>

<p>Creates a new BIO chain consisting of a buffering BIO, an SSL BIO (using ctx) and a connect BIO.</p>

<pre><code>    my $rv = Net::SSLeay::BIO_new_buffer_ssl_connect($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: value corresponding to openssl&#39;s BIO structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_f_ssl.html">https://www.openssl.org/docs/manmaster/man3/BIO_f_ssl.html</a></p>

</li>
<li><p>BIO_new_file</p>

<p>Creates a new file BIO with mode $mode the meaning of mode is the same as the stdio function fopen(). The BIO_CLOSE flag is set on the returned BIO.</p>

<pre><code>    my $rv = Net::SSLeay::BIO_new_file($filename, $mode);
    # $filename - (string) filename
    # $mode - (string) opening mode (as mode by stdio function fopen)
    #
    # returns: value corresponding to openssl&#39;s BIO structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_s_file.html">https://www.openssl.org/docs/manmaster/man3/BIO_s_file.html</a></p>

</li>
<li><p>BIO_new_ssl</p>

<p>Allocates an SSL BIO using SSL_CTX ctx and using client mode if client is non zero.</p>

<pre><code>    my $rv = Net::SSLeay::BIO_new_ssl($ctx, $client);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $client - (integer) 0 or 1 - indicates ssl client mode
    #
    # returns: value corresponding to openssl&#39;s BIO structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_f_ssl.html">https://www.openssl.org/docs/manmaster/man3/BIO_f_ssl.html</a></p>

</li>
<li><p>BIO_new_ssl_connect</p>

<p>Creates a new BIO chain consisting of an SSL BIO (using ctx) followed by a connect BIO.</p>

<pre><code>    my $rv = Net::SSLeay::BIO_new_ssl_connect($ctx);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    #
    # returns: value corresponding to openssl&#39;s BIO structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_f_ssl.html">https://www.openssl.org/docs/manmaster/man3/BIO_f_ssl.html</a></p>

</li>
<li><p>BIO_pending</p>

<p>Return the number of pending characters in the BIOs read buffers.</p>

<pre><code>    my $rv = Net::SSLeay::BIO_pending($s);
    # $s - value corresponding to openssl&#39;s BIO structure
    #
    # returns: the amount of pending data</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_ctrl.html">https://www.openssl.org/docs/manmaster/man3/BIO_ctrl.html</a></p>

</li>
<li><p>BIO_wpending</p>

<p>Return the number of pending characters in the BIOs write buffers.</p>

<pre><code>    my $rv = Net::SSLeay::BIO_wpending($s);
    # $s - value corresponding to openssl&#39;s BIO structure
    #
    # returns: the amount of pending data</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_ctrl.html">https://www.openssl.org/docs/manmaster/man3/BIO_ctrl.html</a></p>

</li>
<li><p>BIO_read</p>

<p>Read the underlying descriptor.</p>

<pre><code>    Net::SSLeay::BIO_read($s, $max);
    # $s - value corresponding to openssl&#39;s BIO structure
    # $max - [optional] max. bytes to read (if not specified, the value 32768 is used)
    #
    # returns: data</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_read.html">https://www.openssl.org/docs/manmaster/man3/BIO_read.html</a></p>

</li>
<li><p>BIO_write</p>

<p>Attempts to write data from $buffer to BIO $b.</p>

<pre><code>    my $rv = Net::SSLeay::BIO_write($b, $buffer);
    # $b - value corresponding to openssl&#39;s BIO structure
    # $buffer - data
    #
    # returns: amount of data successfully written
    #          or that no data was successfully read or written if the result is 0 or -1
    #          or -2 when the operation is not implemented in the specific BIO type</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_read.html">https://www.openssl.org/docs/manmaster/man3/BIO_read.html</a></p>

</li>
<li><p>BIO_s_mem</p>

<p>Return the memory BIO method function.</p>

<pre><code>    my $rv = Net::SSLeay::BIO_s_mem();
    #
    # returns: value corresponding to openssl&#39;s BIO_METHOD structure (0 on failure)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_s_mem.html">https://www.openssl.org/docs/manmaster/man3/BIO_s_mem.html</a></p>

</li>
<li><p>BIO_ssl_copy_session_id</p>

<p>Copies an SSL session id between BIO chains from and to. It does this by locating the SSL BIOs in each chain and calling SSL_copy_session_id() on the internal SSL pointer.</p>

<pre><code>    my $rv = Net::SSLeay::BIO_ssl_copy_session_id($to, $from);
    # $to - value corresponding to openssl&#39;s BIO structure
    # $from - value corresponding to openssl&#39;s BIO structure
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_f_ssl.html">https://www.openssl.org/docs/manmaster/man3/BIO_f_ssl.html</a></p>

</li>
<li><p>BIO_ssl_shutdown</p>

<p>Closes down an SSL connection on BIO chain bio. It does this by locating the SSL BIO in the chain and calling SSL_shutdown() on its internal SSL pointer.</p>

<pre><code>    Net::SSLeay::BIO_ssl_shutdown($ssl_bio);
    # $ssl_bio - value corresponding to openssl&#39;s BIO structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/BIO_f_ssl.html">https://www.openssl.org/docs/manmaster/man3/BIO_f_ssl.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-Server-side-Server-Name-Indication-(SNI)-support"><a id="Low32"></a><a id="Low-level-API:-Server-side-Server-Name-Indication--SNI--support"></a>Low level API: Server side Server Name Indication (SNI) support</h3>

<ul>

<li><p>set_tlsext_host_name</p>

<p>TBA</p>

</li>
<li><p>get_servername</p>

<p>TBA</p>

</li>
<li><p>get_servername_type</p>

<p>TBA</p>

</li>
<li><p>CTX_set_tlsext_servername_callback</p>

<p><b>COMPATIBILITY:</b> requires at least OpenSSL 0.9.8f</p>

<p>This function is used in a server to support Server side Server Name Indication (SNI).</p>

<pre><code>    Net::SSLeay::CTX_set_tlsext_servername_callback($ctx, $code);
    # $ctx - SSL context
    # $code - reference to a subroutine that will be called when a new connection is being initiated
    #
    # returns: no return value</code></pre>

<p>On the client side: use set_tlsext_host_name($ssl, $servername) before initiating the SSL connection.</p>

<p>On the server side: Set up an additional SSL_CTX() for each different certificate.</p>

<p>Add a servername callback to each SSL_CTX() using CTX_set_tlsext_servername_callback().</p>

<p>The callback function is required to retrieve the client-supplied servername with get_servername(ssl). Figure out the right SSL_CTX to go with that host name, then switch the SSL object to that SSL_CTX with set_SSL_CTX().</p>

<p>Example:</p>

<pre><code>    # set callback
    Net::SSLeay::CTX_set_tlsext_servername_callback($ctx,
        sub {
            my $ssl = shift;
            my $h = Net::SSLeay::get_servername($ssl);
            Net::SSLeay::set_SSL_CTX($ssl, $hostnames{$h}-&gt;{ctx}) if exists $hostnames{$h};
        } );</code></pre>

<p>More complete example:</p>

<pre><code>    # ... initialize Net::SSLeay

    my %hostnames = (
        &#39;sni1&#39; =&gt; { cert=&gt;&#39;sni1.pem&#39;, key=&gt;&#39;sni1.key&#39; },
        &#39;sni2&#39; =&gt; { cert=&gt;&#39;sni2.pem&#39;, key=&gt;&#39;sni2.key&#39; },
    );

    # create a new context for each certificate/key pair
    for my $name (keys %hostnames) {
        $hostnames{$name}-&gt;{ctx} = Net::SSLeay::CTX_new or die;
        Net::SSLeay::CTX_set_cipher_list($hostnames{$name}-&gt;{ctx}, &#39;ALL&#39;);
        Net::SSLeay::set_cert_and_key($hostnames{$name}-&gt;{ctx},
        $hostnames{$name}-&gt;{cert}, $hostnames{$name}-&gt;{key}) or die;
    }

    # create default context
    my $ctx = Net::SSLeay::CTX_new or die;
    Net::SSLeay::CTX_set_cipher_list($ctx, &#39;ALL&#39;);
    Net::SSLeay::set_cert_and_key($ctx, &#39;cert.pem&#39;,&#39;key.pem&#39;) or die;

    # set callback
    Net::SSLeay::CTX_set_tlsext_servername_callback($ctx, sub {
        my $ssl = shift;
        my $h = Net::SSLeay::get_servername($ssl);
        Net::SSLeay::set_SSL_CTX($ssl, $hostnames{$h}-&gt;{ctx}) if exists $hostnames{$h};
    } );

    # ... later

    $s = Net::SSLeay::new($ctx);
    Net::SSLeay::set_fd($s, fileno($accepted_socket));
    Net::SSLeay::accept($s);</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-NPN-(next-protocol-negotiation)-related-functions"><a id="Low33"></a><a id="Low-level-API:-NPN--next-protocol-negotiation--related-functions"></a>Low level API: NPN (next protocol negotiation) related functions</h3>

<p>NPN is being replaced with ALPN, a more recent TLS extension for application protocol negotiation that&#39;s in process of being adopted by IETF. Please look below for APLN API description.</p>

<p>Simple approach for using NPN support looks like this:</p>

<pre><code>    ### client side
    use Net::SSLeay;
    use IO::Socket::INET;

    Net::SSLeay::initialize();
    my $sock = IO::Socket::INET-&gt;new(PeerAddr=&gt;&#39;encrypted.google.com:443&#39;) or die;
    my $ctx = Net::SSLeay::CTX_tlsv1_new() or die;
    Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL);
    Net::SSLeay::CTX_set_next_proto_select_cb($ctx, [&#39;http1.1&#39;,&#39;spdy/2&#39;]);
    my $ssl = Net::SSLeay::new($ctx) or die;
    Net::SSLeay::set_fd($ssl, fileno($sock)) or die;
    Net::SSLeay::connect($ssl);

    warn &quot;client:negotiated=&quot;,Net::SSLeay::P_next_proto_negotiated($ssl), &quot;\n&quot;;
    warn &quot;client:last_status=&quot;, Net::SSLeay::P_next_proto_last_status($ssl), &quot;\n&quot;;

    ### server side
    use Net::SSLeay;
    use IO::Socket::INET;

    Net::SSLeay::initialize();
    my $ctx = Net::SSLeay::CTX_tlsv1_new() or die;
    Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL);
    Net::SSLeay::set_cert_and_key($ctx, &quot;cert.pem&quot;, &quot;key.pem&quot;);
    Net::SSLeay::CTX_set_next_protos_advertised_cb($ctx, [&#39;spdy/2&#39;,&#39;http1.1&#39;]);
    my $sock = IO::Socket::INET-&gt;new(LocalAddr=&gt;&#39;localhost&#39;, LocalPort=&gt;5443, Proto=&gt;&#39;tcp&#39;, Listen=&gt;20) or die;

    while (1) {
        my $ssl = Net::SSLeay::new($ctx);
        warn(&quot;server:waiting for incoming connection...\n&quot;);
        my $fd = $sock-&gt;accept();
        Net::SSLeay::set_fd($ssl, $fd-&gt;fileno);
        Net::SSLeay::accept($ssl);
        warn &quot;server:negotiated=&quot;,Net::SSLeay::P_next_proto_negotiated($ssl),&quot;\n&quot;;
        my $got = Net::SSLeay::read($ssl);
        Net::SSLeay::ssl_write_all($ssl, &quot;length=&quot;.length($got));
        Net::SSLeay::free($ssl);
        $fd-&gt;close();
    }
    # check with: openssl s_client -connect localhost:5443 -nextprotoneg http/1.1,spdy/2</code></pre>

<p>Please note that the selection (negotiation) is performed by client side, the server side simply advertise the list of supported protocols.</p>

<p>Advanced approach allows you to implement your own negotiation algorithm.</p>

<pre><code>    # see below documentation for:
    Net::SSLeay::CTX_set_next_proto_select_cb($ctx, $perl_callback_function, $callback_data);
    Net::SSLeay::CTX_set_next_protos_advertised_cb($ctx, $perl_callback_function, $callback_data);</code></pre>

<p>Detection of NPN support (works even in older Net::SSLeay versions):</p>

<pre><code>    use Net::SSLeay;

    if (exists &amp;Net::SSLeay::P_next_proto_negotiated) {
        # do NPN stuff
    }</code></pre>

<ul>

<li><p>CTX_set_next_proto_select_cb</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before; requires at least OpenSSL 1.0.1</p>

<p><b>NOTE:</b> You need CTX_set_next_proto_select_cb on <b>client side</b> of SSL connection.</p>

<p>Simple usage - in this case a &quot;common&quot; negotiation algorithm (as implemented by openssl&#39;s function SSL_select_next_proto) is used.</p>

<pre><code>    $rv = Net::SSLeay::CTX_set_next_proto_select_cb($ctx, $arrayref);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $arrayref - list of accepted protocols - e.g. [&#39;http1.0&#39;, &#39;http1.1&#39;]
    #
    # returns: 0 on success, 1 on failure</code></pre>

<p>Advanced usage (you probably do not need this):</p>

<pre><code>    $rv = Net::SSLeay::CTX_set_next_proto_select_cb($ctx, $perl_callback_function, $callback_data);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $perl_callback_function - reference to perl function
    # $callback_data - [optional] data to passed to callback function when invoked
    #
    # returns: 0 on success, 1 on failure

    # where callback function looks like
    sub npn_advertised_cb_invoke {
        my ($ssl, $arrayref_proto_list_advertised_by_server, $callback_data) = @_;
        my $status;
        # ...
        $status = 1;   # status can be:
                      # 0 - OPENSSL_NPN_UNSUPPORTED
                      # 1 - OPENSSL_NPN_NEGOTIATED
                      # 2 - OPENSSL_NPN_NO_OVERLAP
        return $status, [&#39;http1.1&#39;,&#39;spdy/2&#39;]; # the callback has to return 2 values
    }</code></pre>

<p>To undefine/clear this callback use:</p>

<pre><code>    Net::SSLeay::CTX_set_next_proto_select_cb($ctx, undef);</code></pre>

</li>
<li><p>CTX_set_next_protos_advertised_cb</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before; requires at least OpenSSL 1.0.1</p>

<p><b>NOTE:</b> You need CTX_set_next_proto_select_cb on <b>server side</b> of SSL connection.</p>

<p>Simple usage:</p>

<pre><code>    $rv = Net::SSLeay::CTX_set_next_protos_advertised_cb($ctx, $arrayref);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $arrayref - list of advertised protocols - e.g. [&#39;http1.0&#39;, &#39;http1.1&#39;]
    #
    # returns: 0 on success, 1 on failure</code></pre>

<p>Advanced usage (you probably do not need this):</p>

<pre><code>    $rv = Net::SSLeay::CTX_set_next_protos_advertised_cb($ctx, $perl_callback_function, $callback_data);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $perl_callback_function - reference to perl function
    # $callback_data - [optional] data to passed to callback function when invoked
    #
    # returns: 0 on success, 1 on failure

    # where callback function looks like
    sub npn_advertised_cb_invoke {
        my ($ssl, $callback_data) = @_;
        # ...
        return [&#39;http1.1&#39;,&#39;spdy/2&#39;]; # the callback has to return arrayref
    }</code></pre>

<p>To undefine/clear this callback use:</p>

<pre><code>    Net::SSLeay::CTX_set_next_protos_advertised_cb($ctx, undef);</code></pre>

</li>
<li><p>P_next_proto_negotiated</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before; requires at least OpenSSL 1.0.1</p>

<p>Returns the name of negotiated protocol for given SSL connection $ssl.</p>

<pre><code>    $rv = Net::SSLeay::P_next_proto_negotiated($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (string) negotiated protocol name (or undef if no negotiation was done or failed with fatal error)</code></pre>

</li>
<li><p>P_next_proto_last_status</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and before; requires at least OpenSSL 1.0.1</p>

<p>Returns the result of the last negotiation for given SSL connection $ssl.</p>

<pre><code>    $rv = Net::SSLeay::P_next_proto_last_status($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (integer) negotiation status
    #          0 - OPENSSL_NPN_UNSUPPORTED
    #          1 - OPENSSL_NPN_NEGOTIATED
    #          2 - OPENSSL_NPN_NO_OVERLAP</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-ALPN-(application-layer-protocol-negotiation)-related-functions"><a id="Low34"></a><a id="Low-level-API:-ALPN--application-layer-protocol-negotiation--related-functions"></a>Low level API: ALPN (application layer protocol negotiation) related functions</h3>

<p>Application protocol can be negotiated via two different mechanisms employing two different TLS extensions: NPN (obsolete) and ALPN (recommended).</p>

<p>The API is rather similar, with slight differences reflecting protocol specifics. In particular, with ALPN the protocol negotiation takes place on server, while with NPN the client implements the protocol negotiation logic.</p>

<p>With ALPN, the most basic implementation looks like this:</p>

<pre><code>    ### client side
    use Net::SSLeay;
    use IO::Socket::INET;

    Net::SSLeay::initialize();
    my $sock = IO::Socket::INET-&gt;new(PeerAddr=&gt;&#39;encrypted.google.com:443&#39;) or die;
    my $ctx = Net::SSLeay::CTX_tlsv1_new() or die;
    Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL);
    Net::SSLeay::CTX_set_alpn_protos($ctx, [&#39;http/1.1&#39;, &#39;http/2.0&#39;, &#39;spdy/3&#39;]);
    my $ssl = Net::SSLeay::new($ctx) or die;
    Net::SSLeay::set_fd($ssl, fileno($sock)) or die;
    Net::SSLeay::connect($ssl);

    warn &quot;client:selected=&quot;,Net::SSLeay::P_alpn_selected($ssl), &quot;\n&quot;;

    ### server side
    use Net::SSLeay;
    use IO::Socket::INET;

    Net::SSLeay::initialize();
    my $ctx = Net::SSLeay::CTX_tlsv1_new() or die;
    Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL);
    Net::SSLeay::set_cert_and_key($ctx, &quot;cert.pem&quot;, &quot;key.pem&quot;);
    Net::SSLeay::CTX_set_alpn_select_cb($ctx, [&#39;http/1.1&#39;, &#39;http/2.0&#39;, &#39;spdy/3&#39;]);
    my $sock = IO::Socket::INET-&gt;new(LocalAddr=&gt;&#39;localhost&#39;, LocalPort=&gt;5443, Proto=&gt;&#39;tcp&#39;, Listen=&gt;20) or die;

    while (1) {
        my $ssl = Net::SSLeay::new($ctx);
        warn(&quot;server:waiting for incoming connection...\n&quot;);
        my $fd = $sock-&gt;accept();
        Net::SSLeay::set_fd($ssl, $fd-&gt;fileno);
        Net::SSLeay::accept($ssl);
        warn &quot;server:selected=&quot;,Net::SSLeay::P_alpn_selected($ssl),&quot;\n&quot;;
        my $got = Net::SSLeay::read($ssl);
        Net::SSLeay::ssl_write_all($ssl, &quot;length=&quot;.length($got));
        Net::SSLeay::free($ssl);
        $fd-&gt;close();
    }
    # check with: openssl s_client -connect localhost:5443 -alpn spdy/3,http/1.1</code></pre>

<p>Advanced approach allows you to implement your own negotiation algorithm.</p>

<pre><code>    # see below documentation for:
    Net::SSLeay::CTX_set_alpn_select_cb($ctx, $perl_callback_function, $callback_data);</code></pre>

<p>Detection of ALPN support (works even in older Net::SSLeay versions):</p>

<pre><code>    use Net::SSLeay;

    if (exists &amp;Net::SSLeay::P_alpn_selected) {
        # do ALPN stuff
    }</code></pre>

<ul>

<li><p>CTX_set_alpn_select_cb</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.55 and before; requires at least OpenSSL 1.0.2</p>

<p><b>NOTE:</b> You need CTX_set_alpn_select_cb on <b>server side</b> of TLS connection.</p>

<p>Simple usage - in this case a &quot;common&quot; negotiation algorithm (as implemented by openssl&#39;s function SSL_select_next_proto) is used.</p>

<pre><code>    $rv = Net::SSLeay::CTX_set_alpn_select_cb($ctx, $arrayref);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $arrayref - list of accepted protocols - e.g. [&#39;http/2.0&#39;, &#39;http/1.1&#39;, &#39;spdy/3&#39;]
    #
    # returns: 0 on success, 1 on failure</code></pre>

<p>Advanced usage (you probably do not need this):</p>

<pre><code>    $rv = Net::SSLeay::CTX_set_alpn_select_cb($ctx, $perl_callback_function, $callback_data);
    # $ctx - value corresponding to openssl&#39;s SSL_CTX structure
    # $perl_callback_function - reference to perl function
    # $callback_data - [optional] data to passed to callback function when invoked
    #
    # returns: 0 on success, 1 on failure

    # where callback function looks like
    sub alpn_select_cb_invoke {
        my ($ssl, $arrayref_proto_list_advertised_by_client, $callback_data) = @_;
        # ...
        if ($negotiated) {
            return &#39;http/2.0&#39;;
        } else {
            return undef;
        }
    }</code></pre>

<p>To undefine/clear this callback use:</p>

<pre><code>    Net::SSLeay::CTX_set_alpn_select_cb($ctx, undef);</code></pre>

</li>
<li><p>set_alpn_protos</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.55 and before; requires at least OpenSSL 1.0.2</p>

<p><b>NOTE:</b> You need set_alpn_protos on <b>client side</b> of TLS connection.</p>

<p>This adds list of supported application layer protocols to ClientHello message sent by a client. It advertises the enumeration of supported protocols:</p>

<pre><code>    Net::SSLeay::set_alpn_protos($ssl, [&#39;http/1.1&#39;, &#39;http/2.0&#39;, &#39;spdy/3&#39;]);
    # returns 0 on success</code></pre>

</li>
<li><p>CTX_set_alpn_protos</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.55 and before; requires at least OpenSSL 1.0.2</p>

<p><b>NOTE:</b> You need CTX_set_alpn_protos on <b>client side</b> of TLS connection.</p>

<p>This adds list of supported application layer protocols to ClientHello message sent by a client. It advertises the enumeration of supported protocols:</p>

<pre><code>    Net::SSLeay::CTX_set_alpn_protos($ctx, [&#39;http/1.1&#39;, &#39;http/2.0&#39;, &#39;spdy/3&#39;]);
    # returns 0 on success</code></pre>

</li>
<li><p>P_alpn_selected</p>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.55 and before; requires at least OpenSSL 1.0.2</p>

<p>Returns the name of negotiated protocol for given TLS connection $ssl.</p>

<pre><code>    $rv = Net::SSLeay::P_alpn_selected($ssl);
    # $ssl - value corresponding to openssl&#39;s SSL structure
    #
    # returns: (string) negotiated protocol name (or undef if no negotiation was done or failed with fatal error)</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-DANE-Support"><a id="Low35"></a>Low level API: DANE Support</h3>

<p>OpenSSL version 1.0.2 adds preliminary support RFC6698 Domain Authentication of Named Entities (DANE) Transport Layer Association within OpenSSL</p>

<ul>

<li><p>SSL_get_tlsa_record_byname</p>

<p><b>COMPATIBILITY:</b> DELETED from net-ssleay, since it is not supported by OpenSSL</p>

<p>In order to facilitate DANE there is additional interface, SSL_get_tlsa_record_byname, accepting hostname, port and socket type that returns packed TLSA record. In order to make it even easier there is additional SSL_ctrl function that calls SSL_get_tlsa_record_byname for you. Latter is recommended for programmers that wish to maintain broader binary compatibility, e.g. make application work with both 1.0.2 and prior version (in which case call to SSL_ctrl with new code returning error would have to be ignored when running with prior version).</p>

<pre><code>    Net::SSLeay::get_tlsa_record_byname($name, $port, $type);</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-Other-functions"><a id="Low36"></a>Low level API: Other functions</h3>

<ul>

<li><p>COMP_add_compression_method</p>

<p>Adds the compression method cm with the identifier id to the list of available compression methods. This list is globally maintained for all SSL operations within this application. It cannot be set for specific SSL_CTX or SSL objects.</p>

<pre><code>    my $rv = Net::SSLeay::COMP_add_compression_method($id, $cm);
    # $id - (integer) compression method id
    #       0 to 63:    methods defined by the IETF
    #       64 to 192:  external party methods assigned by IANA
    #       193 to 255: reserved for private use
    #
    # $cm - value corresponding to openssl&#39;s COMP_METHOD structure
    #
    # returns: 0 on success, 1 on failure (check the error queue to find out the reason)</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_COMP_add_compression_method.html">https://www.openssl.org/docs/manmaster/man3/SSL_COMP_add_compression_method.html</a></p>

</li>
<li><p>DH_free</p>

<p>Frees the DH structure and its components. The values are erased before the memory is returned to the system.</p>

<pre><code>    Net::SSLeay::DH_free($dh);
    # $dh - value corresponding to openssl&#39;s DH structure
    #
    # returns: no return value</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/DH_new.html">https://www.openssl.org/docs/manmaster/man3/DH_new.html</a></p>

</li>
<li><p>FIPS_mode_set</p>

<p>Enable or disable FIPS mode in a FIPS capable OpenSSL.</p>

<pre><code>    Net::SSLeay::FIPS_mode_set($enable);
    # $enable - (integer) 1 to enable, 0 to disable</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-EC-related-functions"><a id="Low37"></a>Low level API: EC related functions</h3>

<ul>

<li><p>CTX_set_tmp_ecdh</p>

<p>TBA</p>

</li>
<li><p>EC_KEY_free</p>

<p>TBA</p>

</li>
<li><p>EC_KEY_new_by_curve_name</p>

<p>TBA</p>

</li>
<li><p>EC_KEY_generate_key</p>

<p>Generates a EC key and returns it in a newly allocated EC_KEY structure. The EC key then can be used to create a PKEY which can be used in calls like X509_set_pubkey.</p>

<pre><code>    my $key = Net::SSLeay::EVP_PKEY_new();
    my $ec  = Net::SSLeay::EC_KEY_generate_key($curve);
    Net::SSLeay::EVP_PKEY_assign_EC_KEY($key,$ec);

    # $curve - curve name like &#39;secp521r1&#39; or the matching Id (integer) of the curve
    #
    # returns: value corresponding to openssl&#39;s EC_KEY structure (0 on failure)</code></pre>

<p>This function has no equivalent in OpenSSL but combines multiple OpenSSL functions for an easier interface.</p>

</li>
<li><p>CTX_set_ecdh_auto, set_ecdh_auto</p>

<p>These functions enable or disable the automatic curve selection on the server side by calling SSL_CTX_set_ecdh_auto or SSL_set_ecdh_auto respectively. If enabled the highest preference curve is automatically used for ECDH temporary keys used during key exchange. This function is no longer available for OpenSSL 1.1.0 or higher.</p>

<pre><code>    Net::SSLeay::CTX_set_ecdh_auto($ctx,1);
    Net::SSLeay::set_ecdh_auto($ssl,1);</code></pre>

</li>
<li><p>CTX_set1_curves_list, set1_curves_list</p>

<p>These functions set the supported curves (in order of preference) by calling SSL_CTX_set1_curves_list or SSL_set1_curves_list respectively. For a TLS client these curves are offered to the server in the supported curves extension while on the server side these are used to determine the shared curve. These functions are only available since OpenSSL 1.1.0.</p>

<pre><code>    Net::SSLeay::CTX_set1_curves_list($ctx,&quot;P-521:P-384:P-256&quot;);
    Net::SSLeay::set1_curves_list($ssl,&quot;P-521:P-384:P-256&quot;);</code></pre>

</li>
<li><p>CTX_set1_groups_list, set1_groups_list</p>

<p>These functions set the supported groups (in order of preference) by calling SSL_CTX_set1_groups_list or SSL_set1_groups_list respectively. This is practically the same as CTX_set1_curves_list and set1_curves_list except that all DH groups can be given as supported by TLS 1.3. These functions are only available since OpenSSL 1.1.1.</p>

<pre><code>    Net::SSLeay::CTX_set1_groups_list($ctx,&quot;P-521:P-384:P-256&quot;);
    Net::SSLeay::set1_groups_list($ssl,&quot;P-521:P-384:P-256&quot;);</code></pre>

</li>
</ul>

<h3 id="Low-level-API:-OSSL_LIB_CTX-and-OSSL_PROVIDER-related-functions"><a id="Low38"></a>Low level API: OSSL_LIB_CTX and OSSL_PROVIDER related functions</h3>

<ul>

<li><p>OSSL_LIB_CTX_get0_global_default</p>

<p>Returns a concrete (non NULL) reference to the global default library context.</p>

<pre><code>    my $libctx = Net::SSLeay::OSSL_LIB_CTX_get0_global_default();
    # returns: a value corresponding to OSSL_LIB_CTX structure or false on failure</code></pre>

<p>Typically it&#39;s simpler to use undef with functions that take an OSSL_LIB_CTX argument when global default library context is needed.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OSSL_LIB_CTX_get0_global_default.html">https://www.openssl.org/docs/manmaster/man3/OSSL_LIB_CTX_get0_global_default.html</a></p>

</li>
<li><p>OSSL_PROVIDER_load</p>

<p>Loads and initializes a provider</p>

<pre><code>    my $provider = Net::SSLeay::OSSL_PROVIDER_load($libctx, $name);
    # $libctx - value corresponding to OSSL_LIB_CTX structure or undef
    # $name - (string) provider name, e.g., &#39;legacy&#39;
    #
    # returns: a value corresponding to OSSL_PROVIDER or false on failure</code></pre>

<p>Using undef loads the provider within the global default library context.</p>

<pre><code>    my $provider = Net::SSLeay::OSSL_PROVIDER_load(undef, &#39;legacy&#39;);</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_load.html">https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_load.html</a></p>

</li>
<li><p>OSSL_PROVIDER_try_load</p>

<p>Loads and initializes a provider similar to OSSL_PROVIDER_load with additional fallback control.</p>

<pre><code>    my $provider = Net::SSLeay::OSSL_PROVIDER_try_load($libctx, $name, $retain_fallbacks);
    # $libctx - value corresponding to OSSL_LIB_CTX structure or undef
    # $name - (string) provider name, e.g., &#39;legacy&#39;
    # $retain_fallbacks - (integer) 0 or 1
    #
    # returns: a value corresponding to OSSL_PROVIDER or false on failure</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_try_load.html">https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_try_load.html</a></p>

</li>
<li><p>OSSL_PROVIDER_unload</p>

<p>Unloads the given provider.</p>

<pre><code>    my $rv = Net::SSLeay::OSSL_PROVIDER_unload($provider);
    # $provider - a value corresponding to OSSL_PROVIDER
    #
    # returns: (integer) 1 on success, 0 on error</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_unload.html">https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_unload.html</a></p>

</li>
<li><p>OSSL_PROVIDER_available</p>

<p>Checks if a named provider is available for use.</p>

<pre><code>    my $rv = Net::SSLeay::OSSL_PROVIDER_available($libctx, $name);
    # $libctx - value corresponding to OSSL_LIB_CTX structure or undef
    # $name - (string) provider name, e.g., &#39;legacy&#39;
    #
    # returns: (integer) 1 if the named provider is available, otherwise 0.</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_available.html">https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_available.html</a></p>

</li>
<li><p>OSSL_PROVIDER_do_all</p>

<p>Iterates over all loaded providers. A callback is called for each provider.</p>

<pre><code>    my $rv = Net::SSLeay::OSSL_PROVIDER_do_all($libctx, $cb, $cbdata);
    # $libctx - value corresponding to OSSL_LIB_CTX structure or undef
    # $cb - reference to a perl callback function
    # $cbdata - data that will be passed to callback function
    #
    # returns: (integer) 1 if all callbacks returned 1, 0 the first time a callback returns 0.</code></pre>

<p>Example:</p>

<pre><code>    sub do_all_cb {
        my ($provider, $cbdata) = @_;

        my $name = Net::SSLeay::OSSL_PROVIDER_get0_name($provider);
        print &quot;Callback for provider: &#39;$name&#39;, cbdata: &#39;$cbdata&#39;\n&quot;;
        return 1;
    }
    my $data_for_cb = &#39;Hello&#39;;

    # Triggers default provider automatic loading.
    Net::SSLeay::OSSL_PROVIDER_available(undef, &#39;default&#39;) || die &#39;default provider not available&#39;;
    Net::SSLeay::OSSL_PROVIDER_load(undef, &#39;legacy&#39;) || die &#39;load legacy&#39;;
    Net::SSLeay::OSSL_PROVIDER_load(undef, &#39;null&#39;)   || die &#39;load null&#39;;
    Net::SSLeay::OSSL_PROVIDER_do_all(undef, \&amp;do_all_cb, $data_for_cb) || die &#39;a callback failed&#39;;</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_do_all.html">https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_do_all.html</a></p>

</li>
<li><p>OSSL_PROVIDER_get0_name</p>

<p>Returns the name of the given provider.</p>

<pre><code>    my $name = Net::SSLeay::OSSL_PROVIDER_get0_name($provider);
    # $provider - a value corresponding to OSSL_PROVIDER
    #
    # returns: (string) provider name, e.g., &#39;legacy&#39;</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_get0_name.html">https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_get0_name.html</a></p>

</li>
<li><p>OSSL_PROVIDER_self_test</p>

<p>Runs the provider&#39;s self tests.</p>

<pre><code>    my $rv = Net::SSLeay::OSSL_PROVIDER_self_test($provider);
    # $libctx - value corresponding to OSSL_LIB_CTX structure or undef
    # $provider - a value corresponding to OSSL_PROVIDER
    #
    # returns: (integer) returns 1 if the self tests pass, 0 on error</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_self_test.html">https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_self_test.html</a></p>

</li>
</ul>

<h3 id="Low-level-API:-TLS-PSK-related-functions"><a id="Low39"></a>Low level API: TLS PSK related functions</h3>

<p><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.92 and before. The TLSv1.3 specific functions require at least OpenSSL 1.1.1 and the others require at least OpenSSL 1.0.0. Not available in LibreSSL.</p>

<ul>

<li><p>CTX_use_psk_identity_hint</p>

<p>Set PSK identity hint for SSL_CTX on TLS server for TLSv1.2 and earlier versions.</p>

<pre><code>    my $ret = Net::SSLeay::CTX_use_psk_identity_hint($ctx, $hint);
    # $ctx - value corresponding to OpenSSL SSL_CTX structure
    # $hint - string, a hint sent to the TLS clients
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Example:</p>

<pre><code>    my $ret = Net::SSLeay::CTX_use_psk_identity_hint($ctx, &#39;ctx server identity_hint&#39;);</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_psk_identity_hint.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_psk_identity_hint.html</a></p>

</li>
<li><p>use_psk_identity_hint</p>

<p>Set PSK identity hint for SSL on TLS server for TLSv1.2 and earlier versions.</p>

<pre><code>    my $ret = Net::SSLeay::use_psk_identity_hint($ssl, $hint);
    # $ssl - value corresponding to OpenSSL SSL structure
    # $hint - string, a hint sent to the TLS clients
    #
    # returns: 1 on success, 0 on failure</code></pre>

<p>Example:</p>

<pre><code>    my $ret = Net::SSLeay::use_psk_identity_hint($ssl, &#39;ssl server identity_hint&#39;);</code></pre>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_use_psk_identity_hint.html">https://www.openssl.org/docs/manmaster/man3/SSL_use_psk_identity_hint.html</a></p>

</li>
<li><p>CTX_set_psk_server_callback</p>

<p>Set a callback for an SSL_CTX on TLS server for using PSKs with all TLS versions.</p>

<p><b>NOTE:</b> With TLSv1.3 Net::SSLeay::CTX_set_psk_find_session_callback or Net::SSLeay::set_psk_find_session_callback is recommended.</p>

<pre><code>    # First set up a callback function.
    sub tls12_psk_cb {
        my ($ssl, $identity, $max_psk_len) = @_;

        # Note: $identity is potentially hostile user supplied data

        my $psk = pack(&#39;H*&#39;, &#39;deadbeef&#39;);
        return $psk if length $psk &lt;= $max_psk_len;

        return undef;
    }

    my $cb = \&amp;tls12_psk_cb;
    Net::SSLeay::CTX_set_psk_server_callback($ctx, $cb);
    # $ctx - value corresponding to OpenSSL SSL_CTX structure
    # $cb - reference to callback function
    #
    # returns: no return value</code></pre>

<p>The callback function must return a PSK in packed binary format, or <code>undef</code> to trigger <code>unknown_psk_identity</code> alert and TLS handshake failure. If TLS handshake failure without PSK specific alert is required, return packed random data.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_server_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_server_callback.html</a></p>

</li>
<li><p>set_psk_server_callback</p>

<p>Set a callback for an SSL on TLS server for using PSKs with all TLS versions.</p>

<p><b>NOTE:</b> With TLSv1.3 Net::SSLeay::CTX_set_psk_find_session_callback or Net::SSLeay::set_psk_find_session_callback is recommended.</p>

<pre><code>    Net::SSLeay::set_psk_server_callback($ssl, $cb);
    # $ssl - value corresponding to OpenSSL SSL structure
    # $cb - reference to callback function
    #
    # returns: no return value</code></pre>

<p>See Net::SSLeay::CTX_set_psk_server_callback() documentation for a full example with a callback.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_psk_server_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_psk_server_callback.html</a></p>

</li>
<li><p>CTX_set_psk_find_session_callback</p>

<p>Set a callback for an SSL_CTX on TLS server for using TLSv1.3 PSKs.</p>

<pre><code>    # First set up a callback function.
    sub tls13_psk_cb {
        my ($ssl, $identity) = @_;

        # Note: $identity is potentially hostile user supplied data

        my $sess = Net::SSLeay::SESSION_new();
        my $cipher = Net::SSLeay::CIPHER_find($ssl, pack(&#39;n&#39;, 0x1301));
        Net::SSLeay::SESSION_set1_master_key($sess, pack(&#39;H*&#39;, &#39;deadbeef&#39;));
        Net::SSLeay::SESSION_set_cipher($sess, $cipher);
        Net::SSLeay::SESSION_set_protocol_version($sess, Net::SSLeay::version($ssl));

        return (1, $sess);
    }

    my $cb = \&amp;tls13_psk_cb;
    Net::SSLeay::CTX_set_psk_find_session_callback($ctx, $cb);
    # $ctx - value corresponding to OpenSSL SSL_CTX structure
    # $cb - reference to callback function
    #
    # returns: no return value</code></pre>

<p>The callback function must return a two value list. When the first value is 0, the connection setup fails. When the first value is 1, the second value must be a valid <code>SSL_SESSION</code> or <code>undef</code>. When the second value is a valid <code>SSL_SESSION</code>, the TLS handshake proceeds with PSK authentication. When the the second value is <code>undef</code>, PSK is not used the TLS handshake proceeds with certificate authentication.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_find_session_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_find_session_callback.html</a></p>

</li>
<li><p>set_psk_find_session_callback</p>

<p>Set a callback for an SSL on TLS server for using TLSv1.3 PSKs.</p>

<pre><code>    Net::SSLeay::set_psk_find_session_callback($ssl, $cb);
    # $ssl - value corresponding to OpenSSL SSL structure
    # $cb - reference to callback function
    #
    # returns: no return value</code></pre>

<p>See Net::SSLeay::CTX_set_psk_find_session_callback() documentation for a full example with a callback.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_psk_find_session_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_set_psk_find_session_callback.html</a></p>

</li>
<li><p>CTX_set_psk_use_session_callback</p>

<p>Set a callback for an SSL_CTX on TLS client for using TLSv1.3 PSKs.</p>

<pre><code>    # First set up a callback function.
    sub tls13_use_psk_cb {
        my ($ssl, $md) = @_;

        my $psk_identity = &quot;test-tls-psk&quot;;
        my $sess = Net::SSLeay::SESSION_new();
        my $cipher = Net::SSLeay::CIPHER_find($ssl, pack(&#39;n&#39;, 0x1301));
        Net::SSLeay::SESSION_set1_master_key($sess, pack(&#39;H*&#39;, &#39;deadbeef&#39;));
        Net::SSLeay::SESSION_set_cipher($sess, $cipher);
        Net::SSLeay::SESSION_set_protocol_version($sess, Net::SSLeay::TLS1_3_VERSION());

        # Typically not defined, see OpenSSL manual
        if ($md) {
            my $sess_md = Net::SSLeay::CIPHER_get_handshake_digest($cipher);
            my $md_type; $md_type = Net::SSLeay::EVP_MD_type($md) if $md;
            my $sess_md_type = Net::SSLeay::EVP_MD_type($sess_md);

            if ($md_type != $sess_md_type) {
                # Example only: guess and try SHA384
                my $switched_cipher = Net::SSLeay::CIPHER_find($ssl, pack(&#39;n&#39;, 0x1302));
                my $switched_md = Net::SSLeay::CIPHER_get_handshake_digest($switched_cipher);
                my $switched_md_type = Net::SSLeay::EVP_MD_type($switched_md);
                if ($md_type != $switched_md_type) {
                    # Guessed wrong, can&#39;t proceed with mismatched digest function
                    Net::SSLeay::SESSION_free($sess);
                    return (0, undef, undef);
                }
                Net::SSLeay::SESSION_set_cipher($sess, $switched_cipher);
            }
        }

        return (1, $psk_identity, $sess);
    }

    my $cb = \&amp;tls13_use_psk_cb;
    Net::SSLeay::CTX_set_psk_use_session_callback($ctx, $cb);
    # $ctx - value corresponding to OpenSSL SSL_CTX structure
    # $cb - reference to callback function
    #
    # returns: no return value</code></pre>

<p>The callback function must return a two value list. When the first value is 0, the connection setup fails. When the first value is 1, the second value must be a valid <code>SSL_SESSION</code> or <code>undef</code>. When the second value is a valid <code>SSL_SESSION</code>, the TLS handshake proceeds with PSK authentication. When the the second value is <code>undef</code>, PSK is not used the TLS handshake proceeds with certificate authentication.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_find_session_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_find_session_callback.html</a></p>

</li>
<li><p>set_psk_use_session_callback</p>

<p>Set a callback for an SSL on TLS client for using TLSv1.3 PSKs.</p>

<pre><code>    # First set up a callback function.
    sub tls13_psk_cb {
        my ($ssl, $identity) = @_;

        # Note: $identity is potentially hostile user supplied data

        my $sess = Net::SSLeay::SESSION_new();
        my $cipher = Net::SSLeay::CIPHER_find($ssl, pack(&#39;n&#39;, 0x1301));
        Net::SSLeay::SESSION_set1_master_key($sess, pack(&#39;H*&#39;, &#39;deadbeef&#39;));
        Net::SSLeay::SESSION_set_cipher($sess, $cipher);
        Net::SSLeay::SESSION_set_protocol_version($sess, Net::SSLeay::version($ssl));

        return (1, $sess);
    }

    my $cb = \&amp;tls13_psk_cb;
    Net::SSLeay::CTX_set_psk_find_session_callback($ctx, $cb);
    # $ctx - value corresponding to OpenSSL SSL_CTX structure
    # $cb - reference to callback function
    #
    # returns: no return value</code></pre>

<p>The callback function must return a two value list. When the first value is 0, the connection setup fails. When the first value is 1, the second value must be a valid <code>SSL_SESSION</code> or <code>undef</code>. When the second value is a valid <code>SSL_SESSION</code>, the TLS handshake proceeds with PSK authentication. When the the second value is <code>undef</code>, PSK is not used the TLS handshake proceeds with certificate authentication.</p>

<p>Check openssl doc <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_find_session_callback.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_find_session_callback.html</a></p>

</li>
</ul>

<h2 id="Constants">Constants</h2>

<p>There are many openssl constants available in <a href="https://metacpan.org/pod/distribution/Net-SSLeay/lib/Net/SSLeay.pod">Net::SSLeay</a>. You can use them like this:</p>

<pre><code>    use Net::SSLeay;
    print &amp;Net::SSLeay::NID_commonName;
    # or
    print Net::SSLeay::NID_commonName();</code></pre>

<p>Or you can import them and use:</p>

<pre><code>    use Net::SSLeay qw/NID_commonName/;
    print &amp;NID_commonName;
    # or
    print NID_commonName();
    # or
    print NID_commonName;</code></pre>

<p>The constants names are derived from openssl constants, however constants starting with <code>SSL_</code> prefix have name with <code>SSL_</code> part stripped - e.g. openssl&#39;s constant <code>SSL_OP_ALL</code> is available as <code>Net::SSLeay::OP_ALL</code></p>

<p>The list of all available constant names:</p>

<p>The list below is automatically generated - do not manually modify it. To add or remove a constant, edit helper_script/constants.txt, then run helper_script/update-exported-constants.</p>

<pre><code>    AD_ACCESS_DENIED                        OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS
    AD_BAD_CERTIFICATE                      OPENSSL_INIT_NO_LOAD_SSL_STRINGS
    AD_BAD_CERTIFICATE_HASH_VALUE           OPENSSL_MODULES_DIR
    AD_BAD_CERTIFICATE_STATUS_RESPONSE      OPENSSL_PLATFORM
    AD_BAD_RECORD_MAC                       OPENSSL_VERSION
    AD_CERTIFICATE_EXPIRED                  OPENSSL_VERSION_MAJOR
    AD_CERTIFICATE_REQUIRED                 OPENSSL_VERSION_MINOR
    AD_CERTIFICATE_REVOKED                  OPENSSL_VERSION_NUMBER
    AD_CERTIFICATE_UNKNOWN                  OPENSSL_VERSION_PATCH
    AD_CERTIFICATE_UNOBTAINABLE             OPENSSL_VERSION_STRING
    AD_CLOSE_NOTIFY                         OP_ALL
    AD_DECODE_ERROR                         OP_ALLOW_CLIENT_RENEGOTIATION
    AD_DECOMPRESSION_FAILURE                OP_ALLOW_NO_DHE_KEX
    AD_DECRYPTION_FAILED                    OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
    AD_DECRYPT_ERROR                        OP_CIPHER_SERVER_PREFERENCE
    AD_EXPORT_RESTRICTION                   OP_CISCO_ANYCONNECT
    AD_HANDSHAKE_FAILURE                    OP_CLEANSE_PLAINTEXT
    AD_ILLEGAL_PARAMETER                    OP_COOKIE_EXCHANGE
    AD_INAPPROPRIATE_FALLBACK               OP_CRYPTOPRO_TLSEXT_BUG
    AD_INSUFFICIENT_SECURITY                OP_DISABLE_TLSEXT_CA_NAMES
    AD_INTERNAL_ERROR                       OP_DONT_INSERT_EMPTY_FRAGMENTS
    AD_MISSING_EXTENSION                    OP_ENABLE_KTLS
    AD_NO_APPLICATION_PROTOCOL              OP_ENABLE_MIDDLEBOX_COMPAT
    AD_NO_CERTIFICATE                       OP_EPHEMERAL_RSA
    AD_NO_RENEGOTIATION                     OP_IGNORE_UNEXPECTED_EOF
    AD_PROTOCOL_VERSION                     OP_LEGACY_SERVER_CONNECT
    AD_RECORD_OVERFLOW                      OP_MICROSOFT_BIG_SSLV3_BUFFER
    AD_UNEXPECTED_MESSAGE                   OP_MICROSOFT_SESS_ID_BUG
    AD_UNKNOWN_CA                           OP_MSIE_SSLV2_RSA_PADDING
    AD_UNKNOWN_PSK_IDENTITY                 OP_NETSCAPE_CA_DN_BUG
    AD_UNRECOGNIZED_NAME                    OP_NETSCAPE_CHALLENGE_BUG
    AD_UNSUPPORTED_CERTIFICATE              OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG
    AD_UNSUPPORTED_EXTENSION                OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
    AD_USER_CANCELLED                       OP_NON_EXPORT_FIRST
    ASN1_STRFLGS_ESC_CTRL                   OP_NO_ANTI_REPLAY
    ASN1_STRFLGS_ESC_MSB                    OP_NO_CLIENT_RENEGOTIATION
    ASN1_STRFLGS_ESC_QUOTE                  OP_NO_COMPRESSION
    ASN1_STRFLGS_RFC2253                    OP_NO_ENCRYPT_THEN_MAC
    ASYNC_NO_JOBS                           OP_NO_EXTENDED_MASTER_SECRET
    ASYNC_PAUSED                            OP_NO_QUERY_MTU
    CB_ACCEPT_EXIT                          OP_NO_RENEGOTIATION
    CB_ACCEPT_LOOP                          OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
    CB_ALERT                                OP_NO_SSL_MASK
    CB_CONNECT_EXIT                         OP_NO_SSLv2
    CB_CONNECT_LOOP                         OP_NO_SSLv3
    CB_EXIT                                 OP_NO_TICKET
    CB_HANDSHAKE_DONE                       OP_NO_TLSv1
    CB_HANDSHAKE_START                      OP_NO_TLSv1_1
    CB_LOOP                                 OP_NO_TLSv1_2
    CB_READ                                 OP_NO_TLSv1_3
    CB_READ_ALERT                           OP_PKCS1_CHECK_1
    CB_WRITE                                OP_PKCS1_CHECK_2
    CB_WRITE_ALERT                          OP_PRIORITIZE_CHACHA
    CLIENT_HELLO_CB                         OP_SAFARI_ECDHE_ECDSA_BUG
    CLIENT_HELLO_ERROR                      OP_SINGLE_DH_USE
    CLIENT_HELLO_RETRY                      OP_SINGLE_ECDH_USE
    CLIENT_HELLO_SUCCESS                    OP_SSLEAY_080_CLIENT_DH_BUG
    CONF_MFLAGS_DEFAULT_SECTION             OP_SSLREF2_REUSE_CERT_TYPE_BUG
    CONF_MFLAGS_IGNORE_ERRORS               OP_TLSEXT_PADDING
    CONF_MFLAGS_IGNORE_MISSING_FILE         OP_TLS_BLOCK_PADDING_BUG
    CONF_MFLAGS_IGNORE_RETURN_CODES         OP_TLS_D5_BUG
    CONF_MFLAGS_NO_DSO                      OP_TLS_ROLLBACK_BUG
    CONF_MFLAGS_SILENT                      READING
    ERROR_NONE                              RECEIVED_SHUTDOWN
    ERROR_SSL                               RETRY_VERIFY
    ERROR_SYSCALL                           RSA_3
    ERROR_WANT_ACCEPT                       RSA_F4
    ERROR_WANT_ASYNC                        R_BAD_AUTHENTICATION_TYPE
    ERROR_WANT_ASYNC_JOB                    R_BAD_CHECKSUM
    ERROR_WANT_CLIENT_HELLO_CB              R_BAD_MAC_DECODE
    ERROR_WANT_CONNECT                      R_BAD_RESPONSE_ARGUMENT
    ERROR_WANT_READ                         R_BAD_SSL_FILETYPE
    ERROR_WANT_RETRY_VERIFY                 R_BAD_SSL_SESSION_ID_LENGTH
    ERROR_WANT_WRITE                        R_BAD_STATE
    ERROR_WANT_X509_LOOKUP                  R_BAD_WRITE_RETRY
    ERROR_ZERO_RETURN                       R_CHALLENGE_IS_DIFFERENT
    EVP_PKS_DSA                             R_CIPHER_TABLE_SRC_ERROR
    EVP_PKS_EC                              R_INVALID_CHALLENGE_LENGTH
    EVP_PKS_RSA                             R_NO_CERTIFICATE_SET
    EVP_PKT_ENC                             R_NO_CERTIFICATE_SPECIFIED
    EVP_PKT_EXCH                            R_NO_CIPHER_LIST
    EVP_PKT_EXP                             R_NO_CIPHER_MATCH
    EVP_PKT_SIGN                            R_NO_PRIVATEKEY
    EVP_PK_DH                               R_NO_PUBLICKEY
    EVP_PK_DSA                              R_NULL_SSL_CTX
    EVP_PK_EC                               R_PEER_DID_NOT_RETURN_A_CERTIFICATE
    EVP_PK_RSA                              R_PEER_ERROR
    FILETYPE_ASN1                           R_PEER_ERROR_CERTIFICATE
    FILETYPE_PEM                            R_PEER_ERROR_NO_CIPHER
    F_CLIENT_CERTIFICATE                    R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE
    F_CLIENT_HELLO                          R_PUBLIC_KEY_ENCRYPT_ERROR
    F_CLIENT_MASTER_KEY                     R_PUBLIC_KEY_IS_NOT_RSA
    F_D2I_SSL_SESSION                       R_READ_WRONG_PACKET_TYPE
    F_GET_CLIENT_FINISHED                   R_SHORT_READ
    F_GET_CLIENT_HELLO                      R_SSL_SESSION_ID_IS_DIFFERENT
    F_GET_CLIENT_MASTER_KEY                 R_UNABLE_TO_EXTRACT_PUBLIC_KEY
    F_GET_SERVER_FINISHED                   R_UNKNOWN_REMOTE_ERROR_TYPE
    F_GET_SERVER_HELLO                      R_UNKNOWN_STATE
    F_GET_SERVER_VERIFY                     R_X509_LIB
    F_I2D_SSL_SESSION                       SENT_SHUTDOWN
    F_READ_N                                SESSION_ASN1_VERSION
    F_REQUEST_CERTIFICATE                   SESS_CACHE_BOTH
    F_SERVER_HELLO                          SESS_CACHE_CLIENT
    F_SSL_CERT_NEW                          SESS_CACHE_NO_AUTO_CLEAR
    F_SSL_GET_NEW_SESSION                   SESS_CACHE_NO_INTERNAL
    F_SSL_NEW                               SESS_CACHE_NO_INTERNAL_LOOKUP
    F_SSL_READ                              SESS_CACHE_NO_INTERNAL_STORE
    F_SSL_RSA_PRIVATE_DECRYPT               SESS_CACHE_OFF
    F_SSL_RSA_PUBLIC_ENCRYPT                SESS_CACHE_SERVER
    F_SSL_SESSION_NEW                       SESS_CACHE_UPDATE_TIME
    F_SSL_SESSION_PRINT_FP                  SSL2_MT_CLIENT_CERTIFICATE
    F_SSL_SET_FD                            SSL2_MT_CLIENT_FINISHED
    F_SSL_SET_RFD                           SSL2_MT_CLIENT_HELLO
    F_SSL_SET_WFD                           SSL2_MT_CLIENT_MASTER_KEY
    F_SSL_USE_CERTIFICATE                   SSL2_MT_ERROR
    F_SSL_USE_CERTIFICATE_ASN1              SSL2_MT_REQUEST_CERTIFICATE
    F_SSL_USE_CERTIFICATE_FILE              SSL2_MT_SERVER_FINISHED
    F_SSL_USE_PRIVATEKEY                    SSL2_MT_SERVER_HELLO
    F_SSL_USE_PRIVATEKEY_ASN1               SSL2_MT_SERVER_VERIFY
    F_SSL_USE_PRIVATEKEY_FILE               SSL2_VERSION
    F_SSL_USE_RSAPRIVATEKEY                 SSL3_MT_CCS
    F_SSL_USE_RSAPRIVATEKEY_ASN1            SSL3_MT_CERTIFICATE
    F_SSL_USE_RSAPRIVATEKEY_FILE            SSL3_MT_CERTIFICATE_REQUEST
    F_WRITE_PENDING                         SSL3_MT_CERTIFICATE_STATUS
    GEN_DIRNAME                             SSL3_MT_CERTIFICATE_URL
    GEN_DNS                                 SSL3_MT_CERTIFICATE_VERIFY
    GEN_EDIPARTY                            SSL3_MT_CHANGE_CIPHER_SPEC
    GEN_EMAIL                               SSL3_MT_CLIENT_HELLO
    GEN_IPADD                               SSL3_MT_CLIENT_KEY_EXCHANGE
    GEN_OTHERNAME                           SSL3_MT_ENCRYPTED_EXTENSIONS
    GEN_RID                                 SSL3_MT_END_OF_EARLY_DATA
    GEN_URI                                 SSL3_MT_FINISHED
    GEN_X400                                SSL3_MT_HELLO_REQUEST
    LIBRESSL_VERSION_NUMBER                 SSL3_MT_KEY_UPDATE
    MBSTRING_ASC                            SSL3_MT_MESSAGE_HASH
    MBSTRING_BMP                            SSL3_MT_NEWSESSION_TICKET
    MBSTRING_FLAG                           SSL3_MT_NEXT_PROTO
    MBSTRING_UNIV                           SSL3_MT_SERVER_DONE
    MBSTRING_UTF8                           SSL3_MT_SERVER_HELLO
    MIN_RSA_MODULUS_LENGTH_IN_BYTES         SSL3_MT_SERVER_KEY_EXCHANGE
    MODE_ACCEPT_MOVING_WRITE_BUFFER         SSL3_MT_SUPPLEMENTAL_DATA
    MODE_ASYNC                              SSL3_RT_ALERT
    MODE_AUTO_RETRY                         SSL3_RT_APPLICATION_DATA
    MODE_ENABLE_PARTIAL_WRITE               SSL3_RT_CHANGE_CIPHER_SPEC
    MODE_NO_AUTO_CHAIN                      SSL3_RT_HANDSHAKE
    MODE_RELEASE_BUFFERS                    SSL3_RT_HEADER
    NID_OCSP_sign                           SSL3_RT_INNER_CONTENT_TYPE
    NID_SMIMECapabilities                   SSL3_VERSION
    NID_X500                                SSLEAY_BUILT_ON
    NID_X509                                SSLEAY_CFLAGS
    NID_ad_OCSP                             SSLEAY_DIR
    NID_ad_ca_issuers                       SSLEAY_PLATFORM
    NID_algorithm                           SSLEAY_VERSION
    NID_authority_key_identifier            ST_ACCEPT
    NID_basic_constraints                   ST_BEFORE
    NID_bf_cbc                              ST_CONNECT
    NID_bf_cfb64                            ST_INIT
    NID_bf_ecb                              ST_OK
    NID_bf_ofb64                            ST_READ_BODY
    NID_cast5_cbc                           ST_READ_HEADER
    NID_cast5_cfb64                         TLS1_1_VERSION
    NID_cast5_ecb                           TLS1_2_VERSION
    NID_cast5_ofb64                         TLS1_3_VERSION
    NID_certBag                             TLS1_VERSION
    NID_certificate_policies                TLSEXT_STATUSTYPE_ocsp
    NID_client_auth                         TLSEXT_TYPE_application_layer_protocol_negotiation
    NID_code_sign                           TLSEXT_TYPE_cert_type
    NID_commonName                          TLSEXT_TYPE_certificate_authorities
    NID_countryName                         TLSEXT_TYPE_client_authz
    NID_crlBag                              TLSEXT_TYPE_client_cert_type
    NID_crl_distribution_points             TLSEXT_TYPE_client_certificate_url
    NID_crl_number                          TLSEXT_TYPE_compress_certificate
    NID_crl_reason                          TLSEXT_TYPE_cookie
    NID_delta_crl                           TLSEXT_TYPE_early_data
    NID_des_cbc                             TLSEXT_TYPE_ec_point_formats
    NID_des_cfb64                           TLSEXT_TYPE_elliptic_curves
    NID_des_ecb                             TLSEXT_TYPE_encrypt_then_mac
    NID_des_ede                             TLSEXT_TYPE_extended_master_secret
    NID_des_ede3                            TLSEXT_TYPE_key_share
    NID_des_ede3_cbc                        TLSEXT_TYPE_max_fragment_length
    NID_des_ede3_cfb64                      TLSEXT_TYPE_next_proto_neg
    NID_des_ede3_ofb64                      TLSEXT_TYPE_padding
    NID_des_ede_cbc                         TLSEXT_TYPE_post_handshake_auth
    NID_des_ede_cfb64                       TLSEXT_TYPE_psk
    NID_des_ede_ofb64                       TLSEXT_TYPE_psk_kex_modes
    NID_des_ofb64                           TLSEXT_TYPE_quic_transport_parameters
    NID_description                         TLSEXT_TYPE_renegotiate
    NID_desx_cbc                            TLSEXT_TYPE_server_authz
    NID_dhKeyAgreement                      TLSEXT_TYPE_server_cert_type
    NID_dnQualifier                         TLSEXT_TYPE_server_name
    NID_dsa                                 TLSEXT_TYPE_session_ticket
    NID_dsaWithSHA                          TLSEXT_TYPE_signature_algorithms
    NID_dsaWithSHA1                         TLSEXT_TYPE_signature_algorithms_cert
    NID_dsaWithSHA1_2                       TLSEXT_TYPE_signed_certificate_timestamp
    NID_dsa_2                               TLSEXT_TYPE_srp
    NID_email_protect                       TLSEXT_TYPE_status_request
    NID_ext_key_usage                       TLSEXT_TYPE_supported_groups
    NID_ext_req                             TLSEXT_TYPE_supported_versions
    NID_friendlyName                        TLSEXT_TYPE_truncated_hmac
    NID_givenName                           TLSEXT_TYPE_trusted_ca_keys
    NID_hmacWithSHA1                        TLSEXT_TYPE_use_srtp
    NID_id_ad                               TLSEXT_TYPE_user_mapping
    NID_id_ce                               VERIFY_CLIENT_ONCE
    NID_id_kp                               VERIFY_FAIL_IF_NO_PEER_CERT
    NID_id_pbkdf2                           VERIFY_NONE
    NID_id_pe                               VERIFY_PEER
    NID_id_pkix                             VERIFY_POST_HANDSHAKE
    NID_id_qt_cps                           V_OCSP_CERTSTATUS_GOOD
    NID_id_qt_unotice                       V_OCSP_CERTSTATUS_REVOKED
    NID_idea_cbc                            V_OCSP_CERTSTATUS_UNKNOWN
    NID_idea_cfb64                          WRITING
    NID_idea_ecb                            X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT
    NID_idea_ofb64                          X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS
    NID_info_access                         X509_CHECK_FLAG_NEVER_CHECK_SUBJECT
    NID_initials                            X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS
    NID_invalidity_date                     X509_CHECK_FLAG_NO_WILDCARDS
    NID_issuer_alt_name                     X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS
    NID_keyBag                              X509_CRL_VERSION_1
    NID_key_usage                           X509_CRL_VERSION_2
    NID_localKeyID                          X509_FILETYPE_ASN1
    NID_localityName                        X509_FILETYPE_DEFAULT
    NID_md2                                 X509_FILETYPE_PEM
    NID_md2WithRSAEncryption                X509_LOOKUP
    NID_md5                                 X509_PURPOSE_ANY
    NID_md5WithRSA                          X509_PURPOSE_CRL_SIGN
    NID_md5WithRSAEncryption                X509_PURPOSE_NS_SSL_SERVER
    NID_md5_sha1                            X509_PURPOSE_OCSP_HELPER
    NID_mdc2                                X509_PURPOSE_SMIME_ENCRYPT
    NID_mdc2WithRSA                         X509_PURPOSE_SMIME_SIGN
    NID_ms_code_com                         X509_PURPOSE_SSL_CLIENT
    NID_ms_code_ind                         X509_PURPOSE_SSL_SERVER
    NID_ms_ctl_sign                         X509_PURPOSE_TIMESTAMP_SIGN
    NID_ms_efs                              X509_REQ_VERSION_1
    NID_ms_ext_req                          X509_REQ_VERSION_2
    NID_ms_sgc                              X509_REQ_VERSION_3
    NID_name                                X509_TRUST_COMPAT
    NID_netscape                            X509_TRUST_DEFAULT
    NID_netscape_base_url                   X509_TRUST_EMAIL
    NID_netscape_ca_policy_url              X509_TRUST_OBJECT_SIGN
    NID_netscape_ca_revocation_url          X509_TRUST_OCSP_REQUEST
    NID_netscape_cert_extension             X509_TRUST_OCSP_SIGN
    NID_netscape_cert_sequence              X509_TRUST_SSL_CLIENT
    NID_netscape_cert_type                  X509_TRUST_SSL_SERVER
    NID_netscape_comment                    X509_TRUST_TSA
    NID_netscape_data_type                  X509_VERSION_1
    NID_netscape_renewal_url                X509_VERSION_2
    NID_netscape_revocation_url             X509_VERSION_3
    NID_netscape_ssl_server_name            X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH
    NID_ns_sgc                              X509_V_ERR_AKID_SKID_MISMATCH
    NID_organizationName                    X509_V_ERR_APPLICATION_VERIFICATION
    NID_organizationalUnitName              X509_V_ERR_AUTHORITY_KEY_IDENTIFIER_CRITICAL
    NID_pbeWithMD2AndDES_CBC                X509_V_ERR_CA_BCONS_NOT_CRITICAL
    NID_pbeWithMD2AndRC2_CBC                X509_V_ERR_CA_CERT_MISSING_KEY_USAGE
    NID_pbeWithMD5AndCast5_CBC              X509_V_ERR_CA_KEY_TOO_SMALL
    NID_pbeWithMD5AndDES_CBC                X509_V_ERR_CA_MD_TOO_WEAK
    NID_pbeWithMD5AndRC2_CBC                X509_V_ERR_CERT_CHAIN_TOO_LONG
    NID_pbeWithSHA1AndDES_CBC               X509_V_ERR_CERT_HAS_EXPIRED
    NID_pbeWithSHA1AndRC2_CBC               X509_V_ERR_CERT_NOT_YET_VALID
    NID_pbe_WithSHA1And128BitRC2_CBC        X509_V_ERR_CERT_REJECTED
    NID_pbe_WithSHA1And128BitRC4            X509_V_ERR_CERT_REVOKED
    NID_pbe_WithSHA1And2_Key_TripleDES_CBC  X509_V_ERR_CERT_SIGNATURE_FAILURE
    NID_pbe_WithSHA1And3_Key_TripleDES_CBC  X509_V_ERR_CERT_UNTRUSTED
    NID_pbe_WithSHA1And40BitRC2_CBC         X509_V_ERR_CRL_HAS_EXPIRED
    NID_pbe_WithSHA1And40BitRC4             X509_V_ERR_CRL_NOT_YET_VALID
    NID_pbes2                               X509_V_ERR_CRL_PATH_VALIDATION_ERROR
    NID_pbmac1                              X509_V_ERR_CRL_SIGNATURE_FAILURE
    NID_pkcs                                X509_V_ERR_DANE_NO_MATCH
    NID_pkcs3                               X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT
    NID_pkcs7                               X509_V_ERR_DIFFERENT_CRL_SCOPE
    NID_pkcs7_data                          X509_V_ERR_EC_KEY_EXPLICIT_PARAMS
    NID_pkcs7_digest                        X509_V_ERR_EE_KEY_TOO_SMALL
    NID_pkcs7_encrypted                     X509_V_ERR_EMAIL_MISMATCH
    NID_pkcs7_enveloped                     X509_V_ERR_EMPTY_SUBJECT_ALT_NAME
    NID_pkcs7_signed                        X509_V_ERR_EMPTY_SUBJECT_SAN_NOT_CRITICAL
    NID_pkcs7_signedAndEnveloped            X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD
    NID_pkcs8ShroudedKeyBag                 X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD
    NID_pkcs9                               X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD
    NID_pkcs9_challengePassword             X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD
    NID_pkcs9_contentType                   X509_V_ERR_EXCLUDED_VIOLATION
    NID_pkcs9_countersignature              X509_V_ERR_EXTENSIONS_REQUIRE_VERSION_3
    NID_pkcs9_emailAddress                  X509_V_ERR_HOSTNAME_MISMATCH
    NID_pkcs9_extCertAttributes             X509_V_ERR_INVALID_CA
    NID_pkcs9_messageDigest                 X509_V_ERR_INVALID_CALL
    NID_pkcs9_signingTime                   X509_V_ERR_INVALID_EXTENSION
    NID_pkcs9_unstructuredAddress           X509_V_ERR_INVALID_NON_CA
    NID_pkcs9_unstructuredName              X509_V_ERR_INVALID_POLICY_EXTENSION
    NID_private_key_usage_period            X509_V_ERR_INVALID_PURPOSE
    NID_rc2_40_cbc                          X509_V_ERR_IP_ADDRESS_MISMATCH
    NID_rc2_64_cbc                          X509_V_ERR_ISSUER_NAME_EMPTY
    NID_rc2_cbc                             X509_V_ERR_KEYUSAGE_NO_CERTSIGN
    NID_rc2_cfb64                           X509_V_ERR_KEYUSAGE_NO_CRL_SIGN
    NID_rc2_ecb                             X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE
    NID_rc2_ofb64                           X509_V_ERR_KU_KEY_CERT_SIGN_INVALID_FOR_NON_CA
    NID_rc4                                 X509_V_ERR_MISSING_AUTHORITY_KEY_IDENTIFIER
    NID_rc4_40                              X509_V_ERR_MISSING_SUBJECT_KEY_IDENTIFIER
    NID_rc5_cbc                             X509_V_ERR_NO_EXPLICIT_POLICY
    NID_rc5_cfb64                           X509_V_ERR_NO_ISSUER_PUBLIC_KEY
    NID_rc5_ecb                             X509_V_ERR_NO_VALID_SCTS
    NID_rc5_ofb64                           X509_V_ERR_OCSP_CERT_UNKNOWN
    NID_ripemd160                           X509_V_ERR_OCSP_VERIFY_FAILED
    NID_ripemd160WithRSA                    X509_V_ERR_OCSP_VERIFY_NEEDED
    NID_rle_compression                     X509_V_ERR_OUT_OF_MEM
    NID_rsa                                 X509_V_ERR_PATHLEN_INVALID_FOR_NON_CA
    NID_rsaEncryption                       X509_V_ERR_PATHLEN_WITHOUT_KU_KEY_CERT_SIGN
    NID_rsadsi                              X509_V_ERR_PATH_LENGTH_EXCEEDED
    NID_safeContentsBag                     X509_V_ERR_PATH_LOOP
    NID_sdsiCertificate                     X509_V_ERR_PERMITTED_VIOLATION
    NID_secretBag                           X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED
    NID_serialNumber                        X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED
    NID_server_auth                         X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION
    NID_sha                                 X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN
    NID_sha1                                X509_V_ERR_SIGNATURE_ALGORITHM_INCONSISTENCY
    NID_sha1WithRSA                         X509_V_ERR_SIGNATURE_ALGORITHM_MISMATCH
    NID_sha1WithRSAEncryption               X509_V_ERR_STORE_LOOKUP
    NID_sha224                              X509_V_ERR_SUBJECT_ISSUER_MISMATCH
    NID_sha224WithRSAEncryption             X509_V_ERR_SUBJECT_KEY_IDENTIFIER_CRITICAL
    NID_sha256                              X509_V_ERR_SUBJECT_NAME_EMPTY
    NID_sha256WithRSAEncryption             X509_V_ERR_SUBTREE_MINMAX
    NID_sha384                              X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256
    NID_sha384WithRSAEncryption             X509_V_ERR_SUITE_B_INVALID_ALGORITHM
    NID_sha3_224                            X509_V_ERR_SUITE_B_INVALID_CURVE
    NID_sha3_256                            X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM
    NID_sha3_384                            X509_V_ERR_SUITE_B_INVALID_VERSION
    NID_sha3_512                            X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED
    NID_sha512                              X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY
    NID_sha512WithRSAEncryption             X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE
    NID_sha512_224                          X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE
    NID_sha512_224WithRSAEncryption         X509_V_ERR_UNABLE_TO_GET_CRL
    NID_sha512_256                          X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER
    NID_sha512_256WithRSAEncryption         X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT
    NID_shaWithRSAEncryption                X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY
    NID_shake128                            X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE
    NID_shake256                            X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION
    NID_stateOrProvinceName                 X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION
    NID_subject_alt_name                    X509_V_ERR_UNNESTED_RESOURCE
    NID_subject_key_identifier              X509_V_ERR_UNSPECIFIED
    NID_surname                             X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX
    NID_sxnet                               X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE
    NID_time_stamp                          X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE
    NID_title                               X509_V_ERR_UNSUPPORTED_NAME_SYNTAX
    NID_undef                               X509_V_ERR_UNSUPPORTED_SIGNATURE_ALGORITHM
    NID_uniqueIdentifier                    X509_V_FLAG_ALLOW_PROXY_CERTS
    NID_x509Certificate                     X509_V_FLAG_CB_ISSUER_CHECK
    NID_x509Crl                             X509_V_FLAG_CHECK_SS_SIGNATURE
    NID_zlib_compression                    X509_V_FLAG_CRL_CHECK
    NOTHING                                 X509_V_FLAG_CRL_CHECK_ALL
    OCSP_RESPONSE_STATUS_INTERNALERROR      X509_V_FLAG_EXPLICIT_POLICY
    OCSP_RESPONSE_STATUS_MALFORMEDREQUEST   X509_V_FLAG_EXTENDED_CRL_SUPPORT
    OCSP_RESPONSE_STATUS_SIGREQUIRED        X509_V_FLAG_IGNORE_CRITICAL
    OCSP_RESPONSE_STATUS_SUCCESSFUL         X509_V_FLAG_INHIBIT_ANY
    OCSP_RESPONSE_STATUS_TRYLATER           X509_V_FLAG_INHIBIT_MAP
    OCSP_RESPONSE_STATUS_UNAUTHORIZED       X509_V_FLAG_LEGACY_VERIFY
    OPENSSL_BUILT_ON                        X509_V_FLAG_NOTIFY_POLICY
    OPENSSL_CFLAGS                          X509_V_FLAG_NO_ALT_CHAINS
    OPENSSL_CPU_INFO                        X509_V_FLAG_NO_CHECK_TIME
    OPENSSL_DIR                             X509_V_FLAG_PARTIAL_CHAIN
    OPENSSL_ENGINES_DIR                     X509_V_FLAG_POLICY_CHECK
    OPENSSL_FULL_VERSION_STRING             X509_V_FLAG_POLICY_MASK
    OPENSSL_INFO_CONFIG_DIR                 X509_V_FLAG_SUITEB_128_LOS
    OPENSSL_INFO_CPU_SETTINGS               X509_V_FLAG_SUITEB_128_LOS_ONLY
    OPENSSL_INFO_DIR_FILENAME_SEPARATOR     X509_V_FLAG_SUITEB_192_LOS
    OPENSSL_INFO_DSO_EXTENSION              X509_V_FLAG_TRUSTED_FIRST
    OPENSSL_INFO_ENGINES_DIR                X509_V_FLAG_USE_CHECK_TIME
    OPENSSL_INFO_LIST_SEPARATOR             X509_V_FLAG_USE_DELTAS
    OPENSSL_INFO_MODULES_DIR                X509_V_FLAG_X509_STRICT
    OPENSSL_INFO_SEED_SOURCE                X509_V_OK
    OPENSSL_INIT_ADD_ALL_CIPHERS            XN_FLAG_COMPAT
    OPENSSL_INIT_ADD_ALL_DIGESTS            XN_FLAG_DN_REV
    OPENSSL_INIT_ASYNC                      XN_FLAG_DUMP_UNKNOWN_FIELDS
    OPENSSL_INIT_ATFORK                     XN_FLAG_FN_ALIGN
    OPENSSL_INIT_ENGINE_AFALG               XN_FLAG_FN_LN
    OPENSSL_INIT_ENGINE_CAPI                XN_FLAG_FN_MASK
    OPENSSL_INIT_ENGINE_CRYPTODEV           XN_FLAG_FN_NONE
    OPENSSL_INIT_ENGINE_DYNAMIC             XN_FLAG_FN_OID
    OPENSSL_INIT_ENGINE_OPENSSL             XN_FLAG_FN_SN
    OPENSSL_INIT_ENGINE_PADLOCK             XN_FLAG_MULTILINE
    OPENSSL_INIT_ENGINE_RDRAND              XN_FLAG_ONELINE
    OPENSSL_INIT_LOAD_CONFIG                XN_FLAG_RFC2253
    OPENSSL_INIT_LOAD_CRYPTO_STRINGS        XN_FLAG_SEP_COMMA_PLUS
    OPENSSL_INIT_LOAD_SSL_STRINGS           XN_FLAG_SEP_CPLUS_SPC
    OPENSSL_INIT_NO_ADD_ALL_CIPHERS         XN_FLAG_SEP_MASK
    OPENSSL_INIT_NO_ADD_ALL_DIGESTS         XN_FLAG_SEP_MULTILINE
    OPENSSL_INIT_NO_ATEXIT                  XN_FLAG_SEP_SPLUS_SPC
    OPENSSL_INIT_NO_LOAD_CONFIG             XN_FLAG_SPC_EQ</code></pre>

<h2 id="INTERNAL-ONLY-functions-(do-not-use-these)"><a id="INTERNAL"></a><a id="INTERNAL-ONLY-functions--do-not-use-these"></a>INTERNAL ONLY functions (do not use these)</h2>

<p>The following functions are not intended for use from outside of <a href="https://metacpan.org/pod/distribution/Net-SSLeay/lib/Net/SSLeay.pod">Net::SSLeay</a> module. They might be removed, renamed or changed without prior notice in future version.</p>

<p>Simply <b>DO NOT USE THEM</b>!</p>

<ul>

<li><p>hello</p>

</li>
<li><p>blength</p>

</li>
<li><p>constant</p>

</li>
</ul>

<h1 id="EXAMPLES">EXAMPLES</h1>

<p>One very good example to look at is the implementation of <code>sslcat()</code> in the <code>SSLeay.pm</code> file.</p>

<p>The following is a simple SSLeay client (with too little error checking :-(</p>

<pre><code>    #!/usr/bin/perl
    use Socket;
    use Net::SSLeay qw(die_now die_if_ssl_error) ;
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    ($dest_serv, $port, $msg) = @ARGV;      # Read command line
    $port = getservbyname ($port, &#39;tcp&#39;) unless $port =~ /^\d+$/;
    $dest_ip = gethostbyname ($dest_serv);
    $dest_serv_params  = sockaddr_in($port, $dest_ip);

    socket  (S, &amp;AF_INET, &amp;SOCK_STREAM, 0)  or die &quot;socket: $!&quot;;
    connect (S, $dest_serv_params)          or die &quot;connect: $!&quot;;
    select  (S); $| = 1; select (STDOUT);   # Eliminate STDIO buffering

    # The network connection is now open, lets fire up SSL

    $ctx = Net::SSLeay::CTX_new() or die_now(&quot;Failed to create SSL_CTX $!&quot;);
    Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL)
         or die_if_ssl_error(&quot;ssl ctx set options&quot;);
    $ssl = Net::SSLeay::new($ctx) or die_now(&quot;Failed to create SSL $!&quot;);
    Net::SSLeay::set_fd($ssl, fileno(S));   # Must use fileno
    $res = Net::SSLeay::connect($ssl) and die_if_ssl_error(&quot;ssl connect&quot;);
    print &quot;Cipher `&quot; . Net::SSLeay::get_cipher($ssl) . &quot;&#39;\n&quot;;

    # Exchange data

    $res = Net::SSLeay::write($ssl, $msg);  # Perl knows how long $msg is
    die_if_ssl_error(&quot;ssl write&quot;);
    CORE::shutdown S, 1;  # Half close --&gt; No more output, sends EOF to server
    $got = Net::SSLeay::read($ssl);         # Perl returns undef on failure
    die_if_ssl_error(&quot;ssl read&quot;);
    print $got;

    Net::SSLeay::free ($ssl);               # Tear down connection
    Net::SSLeay::CTX_free ($ctx);
    close S;</code></pre>

<p>The following is a simple SSLeay echo server (non forking):</p>

<pre><code>    #!/usr/bin/perl -w
    use Socket;
    use Net::SSLeay qw(die_now die_if_ssl_error);
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    $our_ip = &quot;\0\0\0\0&quot;; # Bind to all interfaces
    $port = 1235;
    $sockaddr_template = &#39;S n a4 x8&#39;;
    $our_serv_params = pack ($sockaddr_template, &amp;AF_INET, $port, $our_ip);

    socket (S, &amp;AF_INET, &amp;SOCK_STREAM, 0)  or die &quot;socket: $!&quot;;
    bind (S, $our_serv_params)             or die &quot;bind:   $!&quot;;
    listen (S, 5)                          or die &quot;listen: $!&quot;;
    $ctx = Net::SSLeay::CTX_new ()         or die_now(&quot;CTX_new ($ctx): $!&quot;);
    Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL)
         or die_if_ssl_error(&quot;ssl ctx set options&quot;);

    # Following will ask password unless private key is not encrypted
    Net::SSLeay::CTX_use_RSAPrivateKey_file ($ctx, &#39;plain-rsa.pem&#39;,
                                             &amp;Net::SSLeay::FILETYPE_PEM);
    die_if_ssl_error(&quot;private key&quot;);
    Net::SSLeay::CTX_use_certificate_file ($ctx, &#39;plain-cert.pem&#39;,
                                            &amp;Net::SSLeay::FILETYPE_PEM);
    die_if_ssl_error(&quot;certificate&quot;);

    while (1) {
        print &quot;Accepting connections...\n&quot;;
        ($addr = accept (NS, S))           or die &quot;accept: $!&quot;;
        select (NS); $| = 1; select (STDOUT);  # Piping hot!

        ($af,$client_port,$client_ip) = unpack($sockaddr_template,$addr);
        @inetaddr = unpack(&#39;C4&#39;,$client_ip);
        print &quot;$af connection from &quot; .
        join (&#39;.&#39;, @inetaddr) . &quot;:$client_port\n&quot;;

        # We now have a network connection, lets fire up SSLeay...

        $ssl = Net::SSLeay::new($ctx)      or die_now(&quot;SSL_new ($ssl): $!&quot;);
        Net::SSLeay::set_fd($ssl, fileno(NS));

        $err = Net::SSLeay::accept($ssl) and die_if_ssl_error(&#39;ssl accept&#39;);
        print &quot;Cipher `&quot; . Net::SSLeay::get_cipher($ssl) . &quot;&#39;\n&quot;;

        # Connected. Exchange some data.

        $got = Net::SSLeay::read($ssl);     # Returns undef on fail
        die_if_ssl_error(&quot;ssl read&quot;);
        print &quot;Got `$got&#39; (&quot; . length ($got) . &quot; chars)\n&quot;;

        Net::SSLeay::write ($ssl, uc ($got)) or die &quot;write: $!&quot;;
        die_if_ssl_error(&quot;ssl write&quot;);

        Net::SSLeay::free ($ssl);           # Tear down connection
        close NS;
    }</code></pre>

<p>Yet another echo server. This one runs from <code>/etc/inetd.conf</code> so it avoids all the socket code overhead. Only caveat is opening an rsa key file - it had better be without any encryption or else it will not know where to ask for the password. Note how <code>STDIN</code> and <code>STDOUT</code> are wired to SSL.</p>

<pre><code>    #!/usr/bin/perl
    # /etc/inetd.conf
    #    ssltst stream tcp nowait root /path/to/server.pl server.pl
    # /etc/services
    #    ssltst        1234/tcp

    use Net::SSLeay qw(die_now die_if_ssl_error);
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    chdir &#39;/key/dir&#39; or die &quot;chdir: $!&quot;;
    $| = 1;  # Piping hot!
    open LOG, &quot;&gt;&gt;/dev/console&quot; or die &quot;Can&#39;t open log file $!&quot;;
    select LOG; print &quot;server.pl started\n&quot;;

    $ctx = Net::SSLeay::CTX_new()     or die_now &quot;CTX_new ($ctx) ($!)&quot;;
    $ssl = Net::SSLeay::new($ctx)     or die_now &quot;new ($ssl) ($!)&quot;;
    Net::SSLeay::set_options($ssl, &amp;Net::SSLeay::OP_ALL)
        and die_if_ssl_error(&quot;ssl set options&quot;);

    # We get already open network connection from inetd, now we just
    # need to attach SSLeay to STDIN and STDOUT
    Net::SSLeay::set_rfd($ssl, fileno(STDIN));
    Net::SSLeay::set_wfd($ssl, fileno(STDOUT));

    Net::SSLeay::use_RSAPrivateKey_file ($ssl, &#39;plain-rsa.pem&#39;,
                                         Net::SSLeay::FILETYPE_PEM);
    die_if_ssl_error(&quot;private key&quot;);
    Net::SSLeay::use_certificate_file ($ssl, &#39;plain-cert.pem&#39;,
                                       Net::SSLeay::FILETYPE_PEM);
    die_if_ssl_error(&quot;certificate&quot;);

    Net::SSLeay::accept($ssl) and die_if_ssl_err(&quot;ssl accept: $!&quot;);
    print &quot;Cipher `&quot; . Net::SSLeay::get_cipher($ssl) . &quot;&#39;\n&quot;;

    $got = Net::SSLeay::read($ssl);
    die_if_ssl_error(&quot;ssl read&quot;);
    print &quot;Got `$got&#39; (&quot; . length ($got) . &quot; chars)\n&quot;;

    Net::SSLeay::write ($ssl, uc($got)) or die &quot;write: $!&quot;;
    die_if_ssl_error(&quot;ssl write&quot;);

    Net::SSLeay::free ($ssl);         # Tear down the connection
    Net::SSLeay::CTX_free ($ctx);
    close LOG;</code></pre>

<p>There are also a number of example/test programs in the examples directory:</p>

<pre><code>    sslecho.pl   -  A simple server, not unlike the one above
    minicli.pl   -  Implements a client using low level SSLeay routines
    sslcat.pl    -  Demonstrates using high level sslcat utility function
    get_page.pl  -  Is a utility for getting html pages from secure servers
    callback.pl  -  Demonstrates certificate verification and callback usage
    stdio_bulk.pl       - Does SSL over Unix pipes
    ssl-inetd-serv.pl   - SSL server that can be invoked from inetd.conf
    httpd-proxy-snif.pl - Utility that allows you to see how a browser
                          sends https request to given server and what reply
                          it gets back (very educative :-)
    makecert.pl  -  Creates a self signed cert (does not use this module)</code></pre>

<h1 id="INSTALLATION">INSTALLATION</h1>

<p>See README and README.* in the distribution directory for installation guidance on a variety of platforms.</p>

<h1 id="LIMITATIONS">LIMITATIONS</h1>

<p><code>Net::SSLeay::read()</code> uses an internal buffer of 32KB, thus no single read will return more. In practice one read returns much less, usually as much as fits in one network packet. To work around this, you should use a loop like this:</p>

<pre><code>    $reply = &#39;&#39;;
    while ($got = Net::SSLeay::read($ssl)) {
        last if print_errs(&#39;SSL_read&#39;);
        $reply .= $got;
    }</code></pre>

<p>Although there is no built-in limit in <code>Net::SSLeay::write()</code>, the network packet size limitation applies here as well, thus use:</p>

<pre><code>    $written = 0;

    while ($written &lt; length($message)) {
        $written += Net::SSLeay::write($ssl, substr($message, $written));
        last if print_errs(&#39;SSL_write&#39;);
    }</code></pre>

<p>Or alternatively you can just use the following convenience functions:</p>

<pre><code>    Net::SSLeay::ssl_write_all($ssl, $message) or die &quot;ssl write failure&quot;;
    $got = Net::SSLeay::ssl_read_all($ssl) or die &quot;ssl read failure&quot;;</code></pre>

<h1 id="KNOWN-BUGS-AND-CAVEATS"><a id="KNOWN"></a>KNOWN BUGS AND CAVEATS</h1>

<p>LibreSSL versions in the 3.1 - 3.3 series contain a TLS 1.3 implementation that is not fully compatible with the libssl API, but is still advertised during protocol auto-negotiation. If you encounter problems or unexpected behaviour with SSL or SSL_CTX objects whose protocol version was automatically negotiated and libssl is provided by any of these versions of LibreSSL, it could be because the peers negotiated to use TLS 1.3 - try setting the maximum protocol version to TLS 1.2 (via <code>Net::SSLeay::set_max_proto_version()</code> or <code>Net::SSLeay::CTX_set_max_proto_version()</code>) before establishing the connection. The first stable LibreSSL version with a fully libssl-compatible TLS 1.3 implementation is 3.4.1.</p>

<p>An OpenSSL bug CVE-2015-0290 &quot;OpenSSL Multiblock Corrupted Pointer Issue&quot; can cause POST requests of over 90kB to fail or crash. This bug is reported to be fixed in OpenSSL 1.0.2a.</p>

<p>Autoloader emits a</p>

<pre><code>    Argument &quot;xxx&quot; isn&#39;t numeric in entersub at blib/lib/Net/SSLeay.pm&#39;</code></pre>

<p>warning if die_if_ssl_error is made autoloadable. If you figure out why, drop me a line.</p>

<p>Callback set using <code>SSL_set_verify()</code> does not appear to work. This may well be an openssl problem (e.g. see <code>ssl/ssl_lib.c</code> line 1029). Try using <code>SSL_CTX_set_verify()</code> instead and do not be surprised if even this stops working in future versions.</p>

<p>Callback and certificate verification stuff is generally too little tested.</p>

<p>Random numbers are not initialized randomly enough, especially if you do not have <code>/dev/random</code> and/or <code>/dev/urandom</code> (such as in Solaris platforms - but it&#39;s been suggested that cryptorand daemon from the SUNski package solves this). In this case you should investigate third party software that can emulate these devices, e.g. by way of a named pipe to some program.</p>

<p>Another gotcha with random number initialization is randomness depletion. This phenomenon, which has been extensively discussed in OpenSSL, Apache-SSL, and Apache-mod_ssl forums, can cause your script to block if you use <code>/dev/random</code> or to operate insecurely if you use <code>/dev/urandom</code>. What happens is that when too much randomness is drawn from the operating system&#39;s randomness pool then randomness can temporarily be unavailable. <code>/dev/random</code> solves this problem by waiting until enough randomness can be gathered - and this can take a long time since blocking reduces activity in the machine and less activity provides less random events: a vicious circle. <code>/dev/urandom</code> solves this dilemma more pragmatically by simply returning predictable &quot;random&quot; numbers. Some <code>/dev/urandom</code> emulation software however actually seems to implement <code>/dev/random</code> semantics. Caveat emptor.</p>

<p>I&#39;ve been pointed to two such daemons by Mik Firestone &lt;mik@@speed.stdio._com&gt; who has used them on Solaris 8:</p>

<ol>

<li><p>Entropy Gathering Daemon (EGD) at <a href="https://egd.sourceforge.net/">https://egd.sourceforge.net/</a></p>

</li>
<li><p>Pseudo-random number generating daemon (PRNGD) at <a href="https://prngd.sourceforge.net/">https://prngd.sourceforge.net/</a></p>

</li>
</ol>

<p>If you are using the low level API functions to communicate with other SSL implementations, you would do well to call</p>

<pre><code>    Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL)
        or die_if_ssl_error(&quot;ssl ctx set options&quot;);</code></pre>

<p>to cope with some well know bugs in some other SSL implementations. The high level API functions always set all known compatibility options.</p>

<p>Sometimes <code>sslcat()</code> (and the high level HTTPS functions that build on it) is too fast in signaling the EOF to legacy HTTPS servers. This causes the server to return empty page. To work around this problem you can set the global variable</p>

<pre><code>    $Net::SSLeay::slowly = 1;   # Add sleep so broken servers can keep up</code></pre>

<p>HTTP/1.1 is not supported. Specifically this module does not know to issue or serve multiple http requests per connection. This is a serious shortcoming, but using the SSL session cache on your server helps to alleviate the CPU load somewhat.</p>

<p>As of version 1.09 many newer OpenSSL auxiliary functions were added (from <code>REM_AUTOMATICALLY_GENERATED_1_09</code> onwards in <code>SSLeay.xs</code>). Unfortunately I have not had any opportunity to test these. Some of them are trivial enough that I believe they &quot;just work&quot;, but others have rather complex interfaces with function pointers and all. In these cases you should proceed wit great caution.</p>

<p>This module defaults to using OpenSSL automatic protocol negotiation code for automatically detecting the version of the SSL/TLS protocol that the other end talks. With most web servers this works just fine, but once in a while I get complaints from people that the module does not work with some web servers. Usually this can be solved by explicitly setting the protocol version, e.g.</p>

<pre><code>    $Net::SSLeay::ssl_version = 2;  # Insist on SSLv2
    $Net::SSLeay::ssl_version = 3;  # Insist on SSLv3
    $Net::SSLeay::ssl_version = 10; # Insist on TLSv1
    $Net::SSLeay::ssl_version = 11; # Insist on TLSv1.1
    $Net::SSLeay::ssl_version = 12; # Insist on TLSv1.2
    $Net::SSLeay::ssl_version = 13; # Insist on TLSv1.3</code></pre>

<p>Although the autonegotiation is nice to have, the SSL standards do not formally specify any such mechanism. Most of the world has accepted the SSLeay/OpenSSL way of doing it as the de facto standard. But for the few that think differently, you have to explicitly speak the correct version. This is not really a bug, but rather a deficiency in the standards. If a site refuses to respond or sends back some nonsensical error codes (at the SSL handshake level), try this option before mailing me.</p>

<p>On some systems, OpenSSL may be compiled without support for SSLv2. If this is the case, Net::SSLeay will warn if ssl_version has been set to 2.</p>

<p>The high level API returns the certificate of the peer, thus allowing one to check what certificate was supplied. However, you will only be able to check the certificate after the fact, i.e. you already sent your form data by the time you find out that you did not trust them, oops.</p>

<p>So, while being able to know the certificate after the fact is surely useful, the security minded would still choose to do the connection and certificate verification first and only then exchange data with the site. Currently none of the high level API functions do this, thus you would have to program it using the low level API. A good place to start is to see how the <code>Net::SSLeay::http_cat()</code> function is implemented.</p>

<p>The high level API functions use a global file handle <code>SSLCAT_S</code> internally. This really should not be a problem because there is no way to interleave the high level API functions, unless you use threads (but threads are not very well supported in perl anyway). However, you may run into problems if you call undocumented internal functions in an interleaved fashion. The best solution is to &quot;require Net::SSLeay&quot; in one thread after all the threads have been created.</p>

<h1 id="DIAGNOSTICS">DIAGNOSTICS</h1>

<dl>

<dt id="Random-number-generator-not-seeded!!!"><a id="Random"></a><a id="Random-number-generator-not-seeded"></a>Random number generator not seeded!!!</dt>
<dd>

<p><b>(W)</b> This warning indicates that <code>randomize()</code> was not able to read <code>/dev/random</code> or <code>/dev/urandom</code>, possibly because your system does not have them or they are differently named. You can still use SSL, but the encryption will not be as strong.</p>

</dd>
<dt id="open_tcp_connection:-destination-host-not-found:`server&#39;-(port-123)-($!)"><a id="open_tcp_connection"></a><a id="open_tcp_connection:-destination-host-not-found:-server---port-123"></a>open_tcp_connection: destination host not found:`server&#39; (port 123) ($!)</dt>
<dd>

<p>Name lookup for host named <code>server</code> failed.</p>

</dd>
<dt id="open_tcp_connection:-failed-`server&#39;,-123-($!)"><a id="open_tcp_connection1"></a><a id="open_tcp_connection:-failed--server--123"></a>open_tcp_connection: failed `server&#39;, 123 ($!)</dt>
<dd>

<p>The name was resolved, but establishing the TCP connection failed.</p>

</dd>
<dt id="msg-123:-1-error:140770F8:SSL-routines:SSL23_GET_SERVER_HELLO:unknown-proto"><a id="msg"></a>msg 123: 1 - error:140770F8:SSL routines:SSL23_GET_SERVER_HELLO:unknown proto</dt>
<dd>

<p>SSLeay error string. The first number (123) is the PID, the second number (1) indicates the position of the error message in SSLeay error stack. You often see a pile of these messages as errors cascade.</p>

</dd>
<dt id="msg-123:-1-error:02001002::lib(2)-:func(1)-:reason(2)"><a id="msg1"></a><a id="msg-123:-1-error:02001002::lib-2--:func-1--:reason-2"></a>msg 123: 1 - error:02001002::lib(2) :func(1) :reason(2)</dt>
<dd>

<p>The same as above, but you didn&#39;t call load_error_strings() so SSLeay couldn&#39;t verbosely explain the error. You can still find out what it means with this command:</p>

<pre><code>    /usr/local/ssl/bin/ssleay errstr 02001002</code></pre>

</dd>
<dt id="Password-is-being-asked-for-private-key"><a id="Password"></a>Password is being asked for private key</dt>
<dd>

<p>This is normal behaviour if your private key is encrypted. Either you have to supply the password or you have to use an unencrypted private key. Scan OpenSSL.org for the FAQ that explains how to do this (or just study examples/makecert.pl which is used during <code>make test</code> to do just that).</p>

</dd>
</dl>

<h1 id="SECURITY">SECURITY</h1>

<p>You can mitigate some of the security vulnerabilities that might be present in your SSL/TLS application:</p>

<h2 id="BEAST-Attack"><a id="BEAST"></a>BEAST Attack</h2>

<ul>

<li><p><a href="https://web.archive.org/web/20140424022931/https://blogs.cisco.com/security/beat-the-beast-with-tls">https://web.archive.org/web/20140424022931/https://blogs.cisco.com/security/beat-the-beast-with-tls</a></p>

</li>
<li><p><a href="https://community.qualys.com/blogs/securitylabs/2011/10/17/mitigating-the-beast-attack-on-tls">https://community.qualys.com/blogs/securitylabs/2011/10/17/mitigating-the-beast-attack-on-tls</a></p>

</li>
<li><p><a href="https://blog.zoller.lu/2011/09/beast-summary-tls-cbc-countermeasures.html">https://blog.zoller.lu/2011/09/beast-summary-tls-cbc-countermeasures.html</a></p>

</li>
</ul>

<p>The BEAST attack relies on a weakness in the way CBC mode is used in SSL/TLS. In OpenSSL versions 0.9.6d and later, the protocol-level mitigation is enabled by default, thus making it not vulnerable to the BEAST attack.</p>

<p>Solutions:</p>

<ul>

<li><p>Compile with OpenSSL versions 0.9.6d or later, which enables SSL_OP_ALL by default</p>

</li>
<li><p>Ensure SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS is not enabled (its not enabled by default)</p>

</li>
<li><p>Don&#39;t support SSLv2, SSLv3</p>

</li>
<li><p>Actively control the ciphers your server supports with set_cipher_list:</p>

</li>
</ul>

<pre><code>    Net::SSLeay::set_cipher_list($ssl, &#39;RC4-SHA:HIGH:!ADH&#39;);</code></pre>

<h2 id="Session-Resumption"><a id="Session"></a>Session Resumption</h2>

<ul>

<li><p><a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_options.html">https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_options.html</a></p>

</li>
</ul>

<p>The SSL Labs vulnerability test on your SSL server might report in red:</p>

<p>Session resumption No (IDs assigned but not accepted)</p>

<p>This report is not really bug or a vulnerability, since the server will not accept session resumption requests. However, you can prevent this noise in the report by disabling the session cache altogether:</p>

<pre><code>    Net::SSLeay::CTX_set_session_cache_mode($ssl_ctx, Net::SSLeay::SESS_CACHE_OFF());
    # Use 0 if you don&#39;t have SESS_CACHE_OFF constant.</code></pre>

<h2 id="Secure-Renegotiation-and-DoS-Attack"><a id="Secure"></a>Secure Renegotiation and DoS Attack</h2>

<ul>

<li><p><a href="https://community.qualys.com/blogs/securitylabs/2011/10/31/tls-renegotiation-and-denial-of-service-attacks">https://community.qualys.com/blogs/securitylabs/2011/10/31/tls-renegotiation-and-denial-of-service-attacks</a></p>

</li>
</ul>

<p>This is not a &quot;security flaw,&quot; it is more of a DoS vulnerability.</p>

<p>Solutions:</p>

<ul>

<li><p>Do not support SSLv2</p>

</li>
<li><p>Do not set the SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION option</p>

</li>
<li><p>Compile with OpenSSL 0.9.8m or later</p>

</li>
</ul>

<h1 id="BUGS">BUGS</h1>

<p>If you encounter a problem with this module that you believe is a bug, please <a href="https://github.com/radiator-software/p5-net-ssleay/issues/new">create a new issue</a> in the Net-SSLeay GitHub repository. Please make sure your bug report includes the following information:</p>

<ul>

<li><p>the code you are trying to run;</p>

</li>
<li><p>your operating system name and version;</p>

</li>
<li><p>the output of <code>perl -V</code>;</p>

</li>
<li><p>the version of OpenSSL or LibreSSL you are using.</p>

</li>
</ul>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Originally written by Sampo Kellom&auml;ki.</p>

<p>Maintained by Florian Ragwitz between November 2005 and January 2010.</p>

<p>Maintained by Mike McCauley between November 2005 and June 2018.</p>

<p>Maintained by Tuure Vartiainen between June 2018 and July 2018.</p>

<p>Maintained by Chris Novakovic and Heikki Vatiainen since June 2018.</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright (c) 1996-2003 Sampo Kellom&auml;ki &lt;sampo@iki.fi&gt;</p>

<p>Copyright (c) 2005-2010 Florian Ragwitz &lt;rafl@debian.org&gt;</p>

<p>Copyright (c) 2005-2018 Mike McCauley &lt;mikem@airspayce.com&gt;</p>

<p>Copyright (c) 2018 Tuure Vartiainen &lt;vartiait@radiatorsoftware.com&gt;</p>

<p>Copyright (c) 2018- Chris Novakovic &lt;chris@chrisn.me.uk&gt;</p>

<p>Copyright (c) 2018- Heikki Vatiainen &lt;hvn@radiatorsoftware.com&gt;</p>

<p>All rights reserved.</p>

<h1 id="LICENSE">LICENSE</h1>

<p>This module is released under the terms of the Artistic License 2.0. For details, see the <code>LICENSE</code> file distributed with Net-SSLeay&#39;s source code.</p>

<h1 id="SEE-ALSO"><a id="SEE"></a>SEE ALSO</h1>

<pre><code>    Net::SSLeay::Handle                      - File handle interface
    ./examples                               - Example servers and a clients
    &lt;https://www.openssl.org/&gt;               - OpenSSL source, documentation, etc
    openssl-users-request@openssl.org        - General OpenSSL mailing list
    &lt;https://www.ietf.org/rfc/rfc2246.txt&gt;   - TLS 1.0 specification
    &lt;https://www.w3c.org&gt;                    - HTTP specifications
    &lt;https://www.ietf.org/rfc/rfc2617.txt&gt;   - How to send password
    &lt;https://egd.sourceforge.net/&gt;           - Entropy Gathering Daemon (EGD)
    &lt;https://prngd.sourceforge.net/&gt;         - pseudo-random number generating daemon (PRNGD)
    perl(1)
    perlref(1)
    perllol(1)
    perldoc ~openssl/doc/ssl/SSL_CTX_set_verify.pod</code></pre></div>

<div id="metacpan_install-instructions-dialog" class="modal fade">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
        <h4 class="modal-title">Module Install Instructions</h4>
      </div>
      <div class="modal-body">
        <p>To install Net::SSLeay, copy and paste the appropriate command in to your terminal.</p>
        <p><a href="https://metacpan.org/dist/App-cpanminus/view/bin/cpanm">cpanm</a></p>
        <pre><code>cpanm Net::SSLeay</code></pre>
        <p><a href="https://metacpan.org/pod/CPAN">CPAN shell</a></p>
        <pre><code>perl -MCPAN -e shell
install Net::SSLeay</code></pre>
        <p>For more information on module installation, please visit <a href="https://www.cpan.org/modules/INSTALL.html">the detailed CPAN module installation guide</a>.</p>
      </div>
      <div class="modal-footer">
        <a href="./Net::SSLeay.html#" data-dismiss="modal" class="btn">Close</a>
      </div>
    </div>
  </div>
</div>
          </main>
          <div class="content-pagination">
          </div>
        </div>
        <footer class="footer">
          <div class="footer-container">
            <div class="footer-social">
              <div class="footer-link footer-logo">
                <a href="https://metacpan.org/">
                  <img src="https://metacpan.org/static/images/metacpan-logo.svg" alt="MetaCPAN" />
                </a>
              </div>
              <a class="footer-social-link" href="https://github.com/metacpan">
                <i class="fab fa-github-square"></i>
              </a>
              <a class="footer-social-link" href="https://fosstodon.org/@metacpan">
                <i class="fab fa-mastodon"></i>
              </a>
            </div>
            <div class="footer-links">
              <div class="footer-link">
                  <a href="https://metacpan.org/about">About</a>
              </div>
              <div class="footer-link">
                  <a href="https://metacpan.org/about/sponsors">Sponsor</a>
              </div>
              <div class="footer-link">
                  <a href="https://grep.metacpan.org">grep::cpan</a>
              </div>
              <div class="footer-link">
                  <a href="https://metacpan.org/recent">Recent</a>
              </div>
              <div class="footer-link">
                  <a href="https://metacpan.org/about/faq">FAQ</a>
              </div>
              <div class="footer-link">
                  <a href="https://metacpan.org/tools">Tools</a>
              </div>
              <div class="footer-link">
                  <a href="https://fastapi.metacpan.org/">API</a>
              </div>
              <div class="footer-link">
                  <a href="https://www.perl.org/">Perl.org</a>
              </div>
            </div>
            <div class="footer-sponsors">
              <a class="footer-sponsor-link" target="_blank" href="https://www.bytemark.co.uk/" rel="noopener">
                <img class="footer-sponsor-bytemark" src="https://metacpan.org/static/images/sponsors/bytemark_logo.svg" alt="Bytemark logo">
              </a>
              <a class="footer-sponsor-link" target="_blank" href="https://www.liquidweb.com/" rel="noopener">
                <img class="footer-sponsor-liquidweb" src="https://metacpan.org/static/images/sponsors/liquidweb_logo.png" alt="liquidweb logo">
              </a>
              <a class="footer-sponsor-link" target="_blank" href="https://deriv.com/careers/" rel="noopener">
                <img class="footer-sponsor-deriv" src="https://metacpan.org/static/images/sponsors/deriv.svg" alt="Deriv logo">
              </a>
              <a class="footer-sponsor-link" target="_blank" href="https://geocode.xyz" rel="noopener">
                <img class="footer-sponsor-geocode" src="https://metacpan.org/static/images/sponsors/geocodelogo.svg" alt="Geocode logo">
              </a>
              <a class="footer-sponsor-link" target="_blank" href="https://www.fastly.com/" rel="noopener">
                <img class="footer-sponsor-fastly" src="https://metacpan.org/static/images/sponsors/fastly_logo.svg" alt="Fastly logo">
              </a>
              <a class="footer-sponsor-link" target="_blank" href="https://opencagedata.com" rel="noopener">
                <img class="footer-sponsor-opencage" src="https://metacpan.org/static/images/sponsors/open-cage.svg" alt="OpenCage logo">
              </a>
            </div>
          </div>
        </footer>
        <div class="modal fade" tabindex="-1" role="dialog" id="metacpan_keyboard-shortcuts">
          <div class="modal-dialog">
            <div class="modal-content">
              <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">&times;</button>
                <h4 class="modal-title">Keyboard Shortcuts</h4>
              </div>
              <div class="modal-body row">
<div class="col-md-6">
  <table class="table keyboard-shortcuts">
    <thead>
      <tr>
        <th></th>
        <th>Global</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="keys">
          <kbd>s</kbd>
        </td>
        <td>Focus search bar</td>
      </tr>
      <tr>
        <td class="keys">
          <kbd>?</kbd>
        </td>
        <td>Bring up this help dialog</td>
      </tr>
    </tbody>
  </table>

  <table class="table keyboard-shortcuts">
    <thead>
      <tr>
        <th></th>
        <th>GitHub</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="keys">
          <kbd>g</kbd> <kbd>p</kbd>
        </td>
        <td>Go to pull requests</td>
      </tr>
      <tr>
        <td class="keys">
          <kbd>g</kbd> <kbd>i</kbd>
        </td>
        <td>go to github issues (only if github is preferred repository)</td>
      </tr>
    </tbody>
  </table>
</div>

<div class="col-md-6">
  <table class="table keyboard-shortcuts">
    <thead>
      <tr>
        <th></th>
        <th>POD</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="keys">
          <kbd>g</kbd> <kbd>a</kbd>
        </td>
        <td>Go to author</td>
      </tr>
      <tr>
        <td class="keys">
          <kbd>g</kbd> <kbd>c</kbd>
        </td>
        <td>Go to changes</td>
      </tr>
      <tr>
        <td class="keys">
          <kbd>g</kbd> <kbd>i</kbd>
        </td>
        <td>Go to issues</td>
      </tr>
      <tr>
        <td class="keys">
          <kbd>g</kbd> <kbd>d</kbd>
        </td>
        <td>Go to dist</td>
      </tr>
      <tr>
        <td class="keys">
          <kbd>g</kbd> <kbd>r</kbd>
        </td>
        <td>Go to repository/SCM</td>
      </tr>
      <tr>
        <td class="keys">
          <kbd>g</kbd> <kbd>s</kbd>
        </td>
        <td>Go to source</td>
      </tr>
      <tr>
        <td class="keys">
          <kbd>g</kbd> <kbd>b</kbd>
        </td>
        <td>Go to file browse</td>
      </tr>

    </tbody>
  </table>
</div>

<div class="col-md-12">
  <table class="table keyboard-shortcuts">
    <thead>
      <tr>
        <th></th>
        <th>Search terms</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><em>module:</em> (e.g. <a href="https://metacpan.org/search?q=module%3APlugin">module:Plugin</a>)</td>
      </tr>
      <tr>
        <td><em>distribution:</em> (e.g. <a href="https://metacpan.org/search?q=distribution%3ADancer+auth">distribution:Dancer auth</a>)</td>
      </tr>
      <tr>
        <td><em>author:</em> (e.g. <a href="https://metacpan.org/search?q=author%3ASONGMU+Redis">author:SONGMU Redis</a>)</td>
      </tr>
      <tr>
        <td><em>version:</em> (e.g. <a href="https://metacpan.org/search?q=version%3A1.00">version:1.00</a>)</td>
      </tr>
    </tbody>
  </table>
</div>
              </div>
              <div class="modal-footer"></div>
            </div>
          </div>
        </div>
    </body>
</html>
