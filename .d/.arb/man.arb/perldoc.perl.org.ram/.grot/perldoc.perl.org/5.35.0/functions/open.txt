=over

=item open FILEHANDLE,MODE,EXPR
X<open> X<pipe> X<file, open> X<fopen>

=item open FILEHANDLE,MODE,EXPR,LIST

=item open FILEHANDLE,MODE,REFERENCE

=item open FILEHANDLE,EXPR

=item open FILEHANDLE

Associates an internal FILEHANDLE with the external file specified by
EXPR. That filehandle will subsequently allow you to perform
I/O operations on that file, such as reading from it or writing to it.

Instead of a filename, you may specify an external command
(plus an optional argument list) or a scalar reference, in order to open
filehandles on commands or in-memory scalars, respectively.

A thorough reference to C<open> follows. For a gentler introduction to
the basics of C<open>, see also the L<perlopentut> manual page.

=over

=item Working with files

Most often, C<open> gets invoked with three arguments: the required
FILEHANDLE (usually an empty scalar variable), followed by MODE (usually
a literal describing the I/O mode the filehandle will use), and then the
filename  that the new filehandle will refer to.

=over

=item Simple examples

Reading from a file:

    open(my $fh, "<", "input.txt")
        or die "Can't open < input.txt: $!";

    # Process every line in input.txt
    while (my $line = <$fh>) {
        #
        # ... do something interesting with $line here ...
        #
    }

or writing to one:

    open(my $fh, ">", "output.txt")
        or die "Can't open > output.txt: $!";

    print $fh "This line gets printed into output.txt.\n";

For a summary of common filehandle operations such as these, see
L<perlintro/Files and I/O>.

=item About filehandles

The first argument to C<open>, labeled FILEHANDLE in this reference, is
usually a scalar variable. (Exceptions exist, described in "Other
considerations", below.) If the call to C<open> succeeds, then the
expression provided as FILEHANDLE will get assigned an open
I<filehandle>. That filehandle provides an internal reference to the
specified external file, conveniently stored in a Perl variable, and
ready for I/O operations such as reading and writing.

=item About modes

When calling C<open> with three or more arguments, the second argument
-- labeled MODE here -- defines the I<open mode>. MODE is usually a
literal string comprising special characters that define the intended
I/O role of the filehandle being created: whether it's read-only, or
read-and-write, and so on.

If MODE is C<< < >>, the file is opened for input (read-only).
If MODE is C<< > >>, the file is opened for output, with existing files
first being truncated ("clobbered") and nonexisting files newly created.
If MODE is C<<< >> >>>, the file is opened for appending, again being
created if necessary.

You can put a C<+> in front of the C<< > >> or C<< < >> to
indicate that you want both read and write access to the file; thus
C<< +< >> is almost always preferred for read/write updates--the
C<< +> >> mode would clobber the file first.  You can't usually use
either read-write mode for updating textfiles, since they have
variable-length records.  See the B<-i> switch in
L<perlrun|perlrun/-i[extension]> for a better approach.  The file is
created with permissions of C<0666> modified by the process's
L<C<umask>|/umask EXPR> value.

These various prefixes correspond to the L<fopen(3)> modes of C<r>,
C<r+>, C<w>, C<w+>, C<a>, and C<a+>.

More examples of different modes in action:

 # Open a file for concatenation
 open(my $log, ">>", "/usr/spool/news/twitlog")
     or warn "Couldn't open log file; discarding input";

 # Open a file for reading and writing
 open(my $dbase, "+<", "dbase.mine")
     or die "Can't open 'dbase.mine' for update: $!";

=item Checking the return value

Open returns nonzero on success, the undefined value otherwise.  If the
C<open> involved a pipe, the return value happens to be the pid of the
subprocess.

When opening a file, it's seldom a good idea to continue if the request
failed, so C<open> is frequently used with L<C<die>|/die LIST>. Even if
you want your code to do something other than C<die> on a failed open,
you should still always check the return value from opening a file.

=back

=item Specifying I/O layers in MODE

You can use the three-argument form of open to specify
I/O layers (sometimes referred to as "disciplines") to apply to the new
filehandle. These affect how the input and output are processed (see
L<open> and
L<PerlIO> for more details).  For example:

    open(my $fh, "<:encoding(UTF-8)", $filename)
        || die "Can't open UTF-8 encoded $filename: $!";

This opens the UTF8-encoded file containing Unicode characters;
see L<perluniintro>.  Note that if layers are specified in the
three-argument form, then default layers stored in
L<C<${^OPEN}>|perlvar/${^OPEN}>
(usually set by the L<open> pragma or the switch C<-CioD>) are ignored.
Those layers will also be ignored if you specify a colon with no name
following it.  In that case the default layer for the operating system
(:raw on Unix, :crlf on Windows) is used.

On some systems (in general, DOS- and Windows-based systems)
L<C<binmode>|/binmode FILEHANDLE, LAYER> is necessary when you're not
working with a text file.  For the sake of portability it is a good idea
always to use it when appropriate, and never to use it when it isn't
appropriate.  Also, people can set their I/O to be by default
UTF8-encoded Unicode, not bytes.

=item Using C<undef> for temporary files

As a special case the three-argument form with a read/write mode and the third
argument being L<C<undef>|/undef EXPR>:

    open(my $tmp, "+>", undef) or die ...

opens a filehandle to a newly created empty anonymous temporary file.
(This happens under any mode, which makes C<< +> >> the only useful and
sensible mode to use.)  You will need to
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE> to do the reading.

=item Opening a filehandle into an in-memory scalar

You can open filehandles directly to Perl scalars instead of a file or
other resource external to the program. To do so, provide a reference to
that scalar as the third argument to C<open>, like so:

 open(my $memory, ">", \$var)
     or die "Can't open memory file: $!";
 print $memory "foo!\n";    # output will appear in $var

To (re)open C<STDOUT> or C<STDERR> as an in-memory file, close it first:

    close STDOUT;
    open(STDOUT, ">", \$variable)
	or die "Can't open STDOUT: $!";

The scalars for in-memory files are treated as octet strings: unless
the file is being opened with truncation the scalar may not contain
any code points over 0xFF.

Opening in-memory files I<can> fail for a variety of reasons.  As with
any other C<open>, check the return value for success.

I<Technical note>: This feature works only when Perl is built with
PerlIO -- the default, except with older (pre-5.16) Perl installations
that were configured to not include it (e.g. via C<Configure
-Uuseperlio>). You can see whether your Perl was built with PerlIO by
running C<perl -V:useperlio>.  If it says C<'define'>, you have PerlIO;
otherwise you don't.

See L<perliol> for detailed info on PerlIO.

=item Opening a filehandle into a command

If MODE is C<|->, then the filename is
interpreted as a command to which output is to be piped, and if MODE
is C<-|>, the filename is interpreted as a command that pipes
output to us.  In the two-argument (and one-argument) form, one should
replace dash (C<->) with the command.
See L<perlipc/"Using open() for IPC"> for more examples of this.
(You are not allowed to L<C<open>|/open FILEHANDLE,MODE,EXPR> to a command
that pipes both in I<and> out, but see L<IPC::Open2>, L<IPC::Open3>, and
L<perlipc/"Bidirectional Communication with Another Process"> for
alternatives.)

 open(my $article_fh, "-|", "caesar <$article")  # decrypt
                                                 # article
     or die "Can't start caesar: $!";

 open(my $article_fh, "caesar <$article |")      # ditto
     or die "Can't start caesar: $!";

 open(my $out_fh, "|-", "sort >Tmp$$")    # $$ is our process id
     or die "Can't start sort: $!";

In the form of pipe opens taking three or more arguments, if LIST is specified
(extra arguments after the command name) then LIST becomes arguments
to the command invoked if the platform supports it.  The meaning of
L<C<open>|/open FILEHANDLE,MODE,EXPR> with more than three arguments for
non-pipe modes is not yet defined, but experimental "layers" may give
extra LIST arguments meaning.

If you open a pipe on the command C<-> (that is, specify either C<|-> or C<-|>
with the one- or two-argument forms of
L<C<open>|/open FILEHANDLE,MODE,EXPR>), an implicit L<C<fork>|/fork> is done,
so L<C<open>|/open FILEHANDLE,MODE,EXPR> returns twice: in the parent process
it returns the pid
of the child process, and in the child process it returns (a defined) C<0>.
Use C<defined($pid)> or C<//> to determine whether the open was successful.

For example, use either

   my $child_pid = open(my $from_kid, "-|")
        // die "Can't fork: $!";

or

   my $child_pid = open(my $to_kid,   "|-")
        // die "Can't fork: $!";

followed by

    if ($child_pid) {
	# am the parent:
	# either write $to_kid or else read $from_kid
	...
       waitpid $child_pid, 0;
    } else {
	# am the child; use STDIN/STDOUT normally
	...
	exit;
    }

The filehandle behaves normally for the parent, but I/O to that
filehandle is piped from/to the STDOUT/STDIN of the child process.
In the child process, the filehandle isn't opened--I/O happens from/to
the new STDOUT/STDIN.  Typically this is used like the normal
piped open when you want to exercise more control over just how the
pipe command gets executed, such as when running setuid and
you don't want to have to scan shell commands for metacharacters.

The following blocks are more or less equivalent:

    open(my $fh, "|tr '[a-z]' '[A-Z]'");
    open(my $fh, "|-", "tr '[a-z]' '[A-Z]'");
    open(my $fh, "|-") || exec 'tr', '[a-z]', '[A-Z]';
    open(my $fh, "|-", "tr", '[a-z]', '[A-Z]');

    open(my $fh, "cat -n '$file'|");
    open(my $fh, "-|", "cat -n '$file'");
    open(my $fh, "-|") || exec "cat", "-n", $file;
    open(my $fh, "-|", "cat", "-n", $file);

The last two examples in each block show the pipe as "list form", which
is not yet supported on all platforms. (If your platform has a real
L<C<fork>|/fork>, such as Linux and macOS, you can use the list form; it
also works on Windows with Perl 5.22 or later.) You would want to use
the list form of the pipe so you can pass literal arguments to the
command without risk of the shell interpreting any shell metacharacters
in them. However, this also bars you from opening pipes to commands that
intentionally contain shell metacharacters, such as:

    open(my $fh, "|cat -n | expand -4 | lpr")
    	|| die "Can't open pipeline to lpr: $!";

See L<perlipc/"Safe Pipe Opens"> for more examples of this.

=item Duping filehandles

You may also, in the Bourne shell tradition, specify an EXPR beginning
with C<< >& >>, in which case the rest of the string is interpreted
as the name of a filehandle (or file descriptor, if numeric) to be
duped (as in L<dup(2)>) and opened.  You may use C<&> after C<< > >>,
C<<< >> >>>, C<< < >>, C<< +> >>, C<<< +>> >>>, and C<< +< >>.
The mode you specify should match the mode of the original filehandle.
(Duping a filehandle does not take into account any existing contents
of IO buffers.)  If you use the three-argument
form, then you can pass either a
number, the name of a filehandle, or the normal "reference to a glob".

Here is a script that saves, redirects, and restores C<STDOUT> and
C<STDERR> using various methods:

    #!/usr/bin/perl
    open(my $oldout, ">&STDOUT")
        or die "Can't dup STDOUT: $!";
    open(OLDERR,     ">&", \*STDERR)
        or die "Can't dup STDERR: $!";

    open(STDOUT, '>', "foo.out")
        or die "Can't redirect STDOUT: $!";
    open(STDERR, ">&STDOUT")
        or die "Can't dup STDOUT: $!";

    select STDERR; $| = 1;  # make unbuffered
    select STDOUT; $| = 1;  # make unbuffered

    print STDOUT "stdout 1\n";  # this works for
    print STDERR "stderr 1\n";  # subprocesses too

    open(STDOUT, ">&", $oldout)
        or die "Can't dup \$oldout: $!";
    open(STDERR, ">&OLDERR")
        or die "Can't dup OLDERR: $!";

    print STDOUT "stdout 2\n";
    print STDERR "stderr 2\n";

If you specify C<< '<&=X' >>, where C<X> is a file descriptor number
or a filehandle, then Perl will do an equivalent of C's L<fdopen(3)> of
that file descriptor (and not call L<dup(2)>); this is more
parsimonious of file descriptors.  For example:

    # open for input, reusing the fileno of $fd
    open(my $fh, "<&=", $fd)

or

    open(my $fh, "<&=$fd")

or

    # open for append, using the fileno of $oldfh
    open(my $fh, ">>&=", $oldfh)

Being parsimonious on filehandles is also useful (besides being
parsimonious) for example when something is dependent on file
descriptors, like for example locking using
L<C<flock>|/flock FILEHANDLE,OPERATION>.  If you do just
C<< open(my $A, ">>&", $B) >>, the filehandle C<$A> will not have the
same file descriptor as C<$B>, and therefore C<flock($A)> will not
C<flock($B)> nor vice versa.  But with C<< open(my $A, ">>&=", $B) >>,
the filehandles will share the same underlying system file descriptor.

Note that under Perls older than 5.8.0, Perl uses the standard C library's'
L<fdopen(3)> to implement the C<=> functionality.  On many Unix systems,
L<fdopen(3)> fails when file descriptors exceed a certain value, typically 255.
For Perls 5.8.0 and later, PerlIO is (most often) the default.

=item Legacy usage

This section describes ways to call C<open> outside of best practices;
you may encounter these uses in older code. Perl does not consider their
use deprecated, exactly, but neither is it recommended in new code, for
the sake of clarity and readability.

=over

=item Specifying mode and filename as a single argument

In the one- and two-argument forms of the call, the mode and filename
should be concatenated (in that order), preferably separated by white
space.  You can--but shouldn't--omit the mode in these forms when that mode
is C<< < >>.  It is safe to use the two-argument form of
L<C<open>|/open FILEHANDLE,MODE,EXPR> if the filename argument is a known literal.

 open(my $dbase, "+<dbase.mine")          # ditto
     or die "Can't open 'dbase.mine' for update: $!";

In the two-argument (and one-argument) form, opening C<< <- >>
or C<-> opens STDIN and opening C<< >- >> opens STDOUT.

New code should favor the three-argument form of C<open> over this older
form. Declaring the mode and the filename as two distinct arguments
avoids any confusion between the two.

=item Calling C<open> with one argument via global variables

As a shortcut, a one-argument call takes the filename from the global
scalar variable of the same name as the filehandle:

    $ARTICLE = 100;
    open(ARTICLE)
        or die "Can't find article $ARTICLE: $!\n";

Here C<$ARTICLE> must be a global (package) scalar variable - not one
declared with L<C<my>|/my VARLIST> or L<C<state>|/state VARLIST>.

=item Assigning a filehandle to a bareword

An older style is to use a bareword as the filehandle, as

    open(FH, "<", "input.txt")
       or die "Can't open < input.txt: $!";

Then you can use C<FH> as the filehandle, in C<< close FH >> and C<<
<FH> >> and so on.  Note that it's a global variable, so this form is
not recommended when dealing with filehandles other than Perl's built-in ones (e.g. STDOUT and STDIN).

=back

=item Other considerations

=over

=item Automatic filehandle closure

The filehandle will be closed when its reference count reaches zero. If
it is a lexically scoped variable declared with L<C<my>|/my VARLIST>,
that usually means the end of the enclosing scope.  However, this
automatic close does not check for errors, so it is better to explicitly
close filehandles, especially those used for writing:

    close($handle)
       || warn "close failed: $!";

=item Automatic pipe flushing

Perl will attempt to flush all files opened for
output before any operation that may do a fork, but this may not be
supported on some platforms (see L<perlport>).  To be safe, you may need
to set L<C<$E<verbar>>|perlvar/$E<verbar>> (C<$AUTOFLUSH> in L<English>)
or call the C<autoflush> method of L<C<IO::Handle>|IO::Handle/METHODS>
on any open handles.

On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor as determined by the value
of L<C<$^F>|perlvar/$^F>.  See L<perlvar/$^F>.

Closing any piped filehandle causes the parent process to wait for the
child to finish, then returns the status value in L<C<$?>|perlvar/$?> and
L<C<${^CHILD_ERROR_NATIVE}>|perlvar/${^CHILD_ERROR_NATIVE}>.

=item Direct versus by-reference assignment of filehandles

If FILEHANDLE -- the first argument in a call to C<open> -- is an
undefined scalar variable (or array or hash element), a new filehandle
is autovivified, meaning that the variable is assigned a reference to a
newly allocated anonymous filehandle.  Otherwise if FILEHANDLE is an
expression, its value is the real filehandle.  (This is considered a
symbolic reference, so C<use strict "refs"> should I<not> be in effect.)

=item Whitespace and special characters in the filename argument

The filename passed to the one- and two-argument forms of
L<C<open>|/open FILEHANDLE,MODE,EXPR> will
have leading and trailing whitespace deleted and normal
redirection characters honored.  This property, known as "magic open",
can often be used to good effect.  A user could specify a filename of
F<"rsh cat file |">, or you could change certain filenames as needed:

    $filename =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;
    open(my $fh, $filename)
        or die "Can't open $filename: $!";

Use the three-argument form to open a file with arbitrary weird characters in it,

    open(my $fh, "<", $file)
    	|| die "Can't open $file: $!";

otherwise it's necessary to protect any leading and trailing whitespace:

    $file =~ s#^(\s)#./$1#;
    open(my $fh, "< $file\0")
    	|| die "Can't open $file: $!";

(this may not work on some bizarre filesystems).  One should
conscientiously choose between the I<magic> and I<three-argument> form
of L<C<open>|/open FILEHANDLE,MODE,EXPR>:

    open(my $in, $ARGV[0]) || die "Can't open $ARGV[0]: $!";

will allow the user to specify an argument of the form C<"rsh cat file |">,
but will not work on a filename that happens to have a trailing space, while

    open(my $in, "<", $ARGV[0])
    	|| die "Can't open $ARGV[0]: $!";

will have exactly the opposite restrictions. (However, some shells
support the syntax C<< perl your_program.pl <( rsh cat file ) >>, which
produces a filename that can be opened normally.)

=item Invoking C-style C<open>

If you want a "real" C L<open(2)>, then you should use the
L<C<sysopen>|/sysopen FILEHANDLE,FILENAME,MODE> function, which involves
no such magic (but uses different filemodes than Perl
L<C<open>|/open FILEHANDLE,MODE,EXPR>, which corresponds to C L<fopen(3)>).
This is another way to protect your filenames from interpretation.  For
example:

    use IO::Handle;
    sysopen(my $fh, $path, O_RDWR|O_CREAT|O_EXCL)
        or die "Can't open $path: $!";
    $fh->autoflush(1);
    print $fh "stuff $$\n";
    seek($fh, 0, 0);
    print "File contains: ", readline($fh);

See L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE> for some details about
mixing reading and writing.

=item Portability issues

See L<perlport/open>.

=back

=back

=back